<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Memorykk</title>
  
  <subtitle>never too late to learn</subtitle>
  <link href="https://memorykk.cn/atom.xml" rel="self"/>
  
  <link href="https://memorykk.cn/"/>
  <updated>2021-09-01T14:18:24.102Z</updated>
  <id>https://memorykk.cn/</id>
  
  <author>
    <name>Memorykk</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis</title>
    <link href="https://memorykk.cn/redis-kuang.html"/>
    <id>https://memorykk.cn/redis-kuang.html</id>
    <published>2021-09-01T14:14:34.000Z</published>
    <updated>2021-09-01T14:18:24.102Z</updated>
    
    <content type="html"><![CDATA[<p>狂神说Redis笔记</p><span id="more"></span><h2 id="一、Nosql概述"><a href="#一、Nosql概述" class="headerlink" title="一、Nosql概述"></a>一、Nosql概述</h2><h3 id="为什么使用Nosql"><a href="#为什么使用Nosql" class="headerlink" title="为什么使用Nosql"></a>为什么使用Nosql</h3><blockquote><p>1、单机Mysql时代</p></blockquote><p><img src="https://img-blog.csdnimg.cn/2020082010365930.png#pic_center" alt="在这里插入图片描述"></p><p>90年代,一个网站的访问量一般不会太大，单个数据库完全够用。随着用户增多，网站出现以下问题</p><ol><li>数据量增加到一定程度，单机数据库就放不下了</li><li>数据的索引（B+ Tree）,一个机器内存也存放不下</li><li>访问量变大后（读写混合），一台服务器承受不住。</li></ol><blockquote><p>2、Memcached(缓存) + Mysql + 垂直拆分（读写分离）</p></blockquote><p>网站80%的情况都是在读，每次都要去查询数据库的话就十分的麻烦！所以说我们希望减轻数据库的压力，我们可以使用缓存来保证效率！</p><p><img src="https://img-blog.csdnimg.cn/20200820103713734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>优化过程经历了以下几个过程：</p><ol><li>优化数据库的数据结构和索引(难度大)</li><li>文件缓存，通过IO流获取比每次都访问数据库效率略高，但是流量爆炸式增长时候，IO流也承受不了</li><li>MemCache,当时最热门的技术，通过在数据库和数据库访问层之间加上一层缓存，第一次访问时查询数据库，将结果保存到缓存，后续的查询先检查缓存，若有直接拿去使用，效率显著提升。</li></ol><blockquote><p>3、分库分表 + 水平拆分 + Mysql集群</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200820103739584.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><blockquote><p>4、如今最近的年代</p></blockquote><p> 如今信息量井喷式增长，各种各样的数据出现（用户定位数据，图片数据等），大数据的背景下关系型数据库（RDBMS）无法满足大量数据要求。Nosql数据库就能轻松解决这些问题。</p><blockquote><p>目前一个基本的互联网项目</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200820103804572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><blockquote><p>为什么要用NoSQL ？</p></blockquote><p>用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式增长！<br>这时候我们就需要使用NoSQL数据库的，Nosql可以很好的处理以上的情况！</p><h3 id="什么是Nosql"><a href="#什么是Nosql" class="headerlink" title="什么是Nosql"></a>什么是Nosql</h3><p><strong>NoSQL = Not Only SQL（不仅仅是SQL）</strong></p><p>Not Only Structured Query Language</p><p>关系型数据库：列+行，同一个表下数据的结构是一样的。</p><p>非关系型数据库：数据存储没有固定的格式，并且可以进行横向扩展。</p><p>NoSQL泛指非关系型数据库，随着web2.0互联网的诞生，传统的关系型数据库很难对付web2.0时代！尤其是超大规模的高并发的社区，暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速，Redis是发展最快的。</p><h3 id="Nosql特点"><a href="#Nosql特点" class="headerlink" title="Nosql特点"></a>Nosql特点</h3><ol><li><p>方便扩展（数据之间没有关系，很好扩展！）</p></li><li><p>大数据量高性能（Redis一秒可以写8万次，读11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高！）</p></li><li><p>数据类型是多样型的！（不需要事先设计数据库，随取随用）</p></li><li><p>传统的 RDBMS 和 NoSQL</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">传统的 RDBMS(关系型数据库)</span><br><span class="line">- 结构化组织</span><br><span class="line">- SQL</span><br><span class="line">- 数据和关系都存在单独的表中 row col</span><br><span class="line">- 操作，数据定义语言</span><br><span class="line">- 严格的一致性</span><br><span class="line">- 基础的事务</span><br><span class="line">- ...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Nosql</span><br><span class="line">- 不仅仅是数据</span><br><span class="line">- 没有固定的查询语言</span><br><span class="line">- 键值对存储，列存储，文档存储，图形数据库（社交关系）</span><br><span class="line">- 最终一致性</span><br><span class="line">- CAP定理和BASE</span><br><span class="line">- 高性能，高可用，高扩展</span><br><span class="line">- ...</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>了解：3V + 3高</p></blockquote><p>大数据时代的3V ：主要是<strong>描述问题</strong>的</p><ol><li>海量Velume</li><li>多样Variety</li><li>实时Velocity</li></ol><p>大数据时代的3高 ： 主要是<strong>对程序的要求</strong></p><ol><li>高并发</li><li>高可扩</li><li>高性能</li></ol><p>真正在公司中的实践：NoSQL + RDBMS 一起使用才是最强的。</p><h3 id="阿里巴巴演进分析"><a href="#阿里巴巴演进分析" class="headerlink" title="阿里巴巴演进分析"></a>阿里巴巴演进分析</h3><p>推荐阅读：阿里云的这群疯子<a href="https://yq.aliyun.com/articles/653511">https://yq.aliyun.com/articles/653511</a></p><p><img src="https://img-blog.csdnimg.cn/20200820103829446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="1"></p><p><img src="https://img-blog.csdnimg.cn/20200820103851613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 商品信息</span></span><br><span class="line">- 一般存放在关系型数据库：Mysql,阿里巴巴使用的Mysql都是经过内部改动的。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 商品描述、评论(文字居多)</span></span><br><span class="line">- 文档型数据库：MongoDB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图片</span></span><br><span class="line">- 分布式文件系统 FastDFS</span><br><span class="line">- 淘宝：TFS</span><br><span class="line">- Google: GFS</span><br><span class="line">- Hadoop: HDFS</span><br><span class="line">- 阿里云: oss</span><br><span class="line"></span><br><span class="line"><span class="comment"># 商品关键字 用于搜索</span></span><br><span class="line">- 搜索引擎：solr,elasticsearch</span><br><span class="line">- 阿里：Isearch 多隆</span><br><span class="line"></span><br><span class="line"><span class="comment"># 商品热门的波段信息</span></span><br><span class="line">- 内存数据库：Redis，Memcache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 商品交易，外部支付接口</span></span><br><span class="line">- 第三方应用</span><br></pre></td></tr></table></figure><h3 id="Nosql的四大分类"><a href="#Nosql的四大分类" class="headerlink" title="Nosql的四大分类"></a>Nosql的四大分类</h3><blockquote><p><strong>KV键值对</strong></p></blockquote><ul><li>新浪：<strong>Redis</strong></li><li>美团：Redis + Tair</li><li>阿里、百度：Redis + Memcache</li></ul><blockquote><p><strong>文档型数据库（bson数据格式）：</strong></p></blockquote><ul><li><strong>MongoDB</strong>(掌握)<ul><li>基于分布式文件存储的数据库。C++编写，用于处理大量文档。</li><li>MongoDB是RDBMS和NoSQL的中间产品。MongoDB是非关系型数据库中功能最丰富的，NoSQL中最像关系型数据库的数据库。</li></ul></li><li>ConthDB</li></ul><blockquote><p><strong>列存储数据库</strong></p></blockquote><ul><li><strong>HBase</strong>(大数据必学)</li><li>分布式文件系统</li></ul><blockquote><p><strong>图关系数据库</strong></p></blockquote><p>用于广告推荐，社交网络</p><ul><li><strong>Neo4j</strong>、InfoGrid</li></ul><table><thead><tr><th><strong>分类</strong></th><th><strong>Examples举例</strong></th><th><strong>典型应用场景</strong></th><th><strong>数据模型</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>键值对（key-value）</strong></td><td>Tokyo Cabinet/Tyrant, Redis, Voldemort, Oracle BDB</td><td>内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。</td><td>Key 指向 Value 的键值对，通常用hash table来实现</td><td>查找速度快</td><td>数据无结构化，通常只被当作字符串或者二进制数据</td></tr><tr><td><strong>列存储数据库</strong></td><td>Cassandra, HBase, Riak</td><td>分布式的文件系统</td><td>以列簇式存储，将同一列数据存在一起</td><td>查找速度快，可扩展性强，更容易进行分布式扩展</td><td>功能相对局限</td></tr><tr><td><strong>文档型数据库</strong></td><td>CouchDB, MongoDb</td><td>Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容）</td><td>Key-Value对应的键值对，Value为结构化数据</td><td>数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构</td><td>查询性能不高，而且缺乏统一的查询语法。</td></tr><tr><td><strong>图形(Graph)数据库</strong></td><td>Neo4J, InfoGrid, Infinite Graph</td><td>社交网络，推荐系统等。专注于构建关系图谱</td><td>图结构</td><td>利用图结构相关算法。比如最短路径寻址，N度关系查找等</td><td>很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群</td></tr></tbody></table><h2 id="二、Redis入门"><a href="#二、Redis入门" class="headerlink" title="二、Redis入门"></a>二、Redis入门</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>Redis是什么？</p></blockquote><p>Redis（Remote Dictionary Server )，即远程字典服务。</p><p>是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、<strong>Key-Value数据库</strong>，并提供多种语言的API。</p><p>与memcached一样，为了保证效率，<strong>数据都是缓存在内存中</strong>。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p><blockquote><p>Redis能该干什么？</p></blockquote><ol><li>内存存储、持久化，内存是断电即失的，所以需要持久化（RDB、AOF）</li><li>高效率、用于高速缓冲</li><li>发布订阅系统</li><li>地图信息分析</li><li>计时器、计数器(eg：浏览量)</li><li>。。。</li></ol><blockquote><p>特性</p></blockquote><ol><li><p>多样的数据类型</p></li><li><p>持久化</p></li><li><p>集群</p></li><li><p>事务</p><p>…</p></li></ol><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>官网：<a href="https://redis.io/">https://redis.io/</a></p><p>推荐使用Linux服务器学习。</p><p>windows版本的Redis已经停更很久了…</p><h3 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h3><p><a href="https://github.com/dmajkic/redis">https://github.com/dmajkic/redis</a></p><ol><li>解压安装包<br><img src="https://img-blog.csdnimg.cn/20200820103922318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li>开启redis-server.exe</li><li>启动redis-cli.exe测试<img src="https://img-blog.csdnimg.cn/20200820103950934.png#pic_center" alt="在这里插入图片描述"></li></ol><h3 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h3><ol><li><p>下载安装包！<code>redis-5.0.8.tar.gz</code></p></li><li><p>解压Redis的安装包！程序一般放在 <code>/opt</code> 目录下</p><p><img src="https://img-blog.csdnimg.cn/20200820104016426.png#pic_center" alt="在这里插入图片描述"></p></li><li><p>基本环境安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install gcc-c++</span><br><span class="line"><span class="comment"># 然后进入redis目录下执行</span></span><br><span class="line">make</span><br><span class="line"><span class="comment"># 然后执行</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://img-blog.csdnimg.cn/20200820104048327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ol><li><p>redis默认安装路径 <code>/usr/local/bin</code><img src="https://img-blog.csdnimg.cn/20200820104140692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>将redis的配置文件复制到 程序安装目录 <code>/usr/local/bin/kconfig</code>下</p><p><img src="https://img-blog.csdnimg.cn/20200820104157817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hxvGQ47d-1597890996509)(狂神说 Redis.assets/image-20200813114000868.png)]"></p></li><li><p>redis默认不是后台启动的，需要修改配置文件！</p><p><img src="https://img-blog.csdnimg.cn/20200820104213706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dDdKTUgd-1597890996510)(狂神说 Redis.assets/image-20200813114019063.png)]"></p></li><li><p>通过制定的配置文件启动redis服务</p><p><img src="https://img-blog.csdnimg.cn/20200820104228556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jOypL57Z-1597890996511)(狂神说 Redis.assets/image-20200813114030597.png)]"></p></li><li><p>使用redis-cli连接指定的端口号测试，Redis的默认端口6379</p><p><img src="https://img-blog.csdnimg.cn/20200820104243223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LnDaISQ4-1597890996512)(狂神说 Redis.assets/image-20200813114045299.png)]"></p></li><li><p>查看redis进程是否开启</p><p><img src="https://img-blog.csdnimg.cn/20200820104300532.png#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9PhN1jC1-1597890996513)(狂神说 Redis.assets/image-20200813114103769.png)]"></p></li><li><p>关闭Redis服务 <code>shutdown</code></p><p><img src="https://img-blog.csdnimg.cn/20200820104314297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Y54EuOYm-1597890996514)(狂神说 Redis.assets/image-20200813114116691.png)]"></p></li><li><p>再次查看进程是否存在</p></li><li><p>后面我们会使用单机多Redis启动集群测试</p></li></ol><h3 id="测试性能"><a href="#测试性能" class="headerlink" title="测试性能"></a>测试性能</h3><p><strong>redis-benchmark：</strong>Redis官方提供的性能测试工具，参数选项如下：</p><p><img src="https://img-blog.csdnimg.cn/20200513214125892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>简单测试：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试：100个并发连接 100000请求</span></span><br><span class="line">redis-benchmark -h localhost -p 6379 -c 100 -n 100000</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200820104343472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-plMshjFg-1597890996515)(狂神说 Redis.assets/image-20200813114143365.png)]"></p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><blockquote><p>redis默认有16个数据库</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200820104357466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-v2S3n3Si-1597890996516)(狂神说 Redis.assets/image-20200813114158322.png)]"></p><p>默认使用的第0个;</p><p>16个数据库为：DB 0~DB 15<br>默认使用DB 0 ，可以使用<code>select n</code>切换到DB n，<code>dbsize</code>可以查看当前数据库的大小，与key数量相关。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get databases <span class="comment"># 命令行查看数据库数量databases</span></span><br><span class="line">1) <span class="string">&quot;databases&quot;</span></span><br><span class="line">2) <span class="string">&quot;16&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; select 8 <span class="comment"># 切换数据库 DB 8</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[8]&gt; dbsize <span class="comment"># 查看数据库大小</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同数据库之间 数据是不能互通的，并且dbsize 是根据库中key的个数。</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name sakura </span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; SELECT 8</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[8]&gt; get name <span class="comment"># db8中并不能获取db0中的键值对。</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379[8]&gt; DBSIZE</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379[8]&gt; SELECT 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;counter:__rand_int__&quot;</span></span><br><span class="line">2) <span class="string">&quot;mylist&quot;</span></span><br><span class="line">3) <span class="string">&quot;name&quot;</span></span><br><span class="line">4) <span class="string">&quot;key:__rand_int__&quot;</span></span><br><span class="line">5) <span class="string">&quot;myset:__rand_int__&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; DBSIZE <span class="comment"># size和key个数相关</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br></pre></td></tr></table></figure><p><code>keys *</code> ：查看当前数据库中所有的key。</p><p><code>flushdb</code>：清空当前数据库中的键值对。</p><p><code>flushall</code>：清空所有数据库的键值对。</p><blockquote><p><strong>Redis是单线程的，Redis是基于内存操作的。</strong></p></blockquote><p>所以Redis的性能瓶颈不是CPU,而是机器内存和网络带宽。</p><p>那么为什么Redis的速度如此快呢，性能这么高呢？QPS达到10W+。</p><p>Redis 选择使用单线程模型处理客户端的请求主要还是因为 CPU 不是 Redis 服务器的瓶颈，所以使用多线程模型带来的性能提升并不能抵消它带来的开发成本和维护成本，系统的性能瓶颈也主要在网络 I/O 操作上；而 Redis 6.0引入多线程操作也是出于性能上的考虑，对于一些大键值对的删除操作，通过多线程非阻塞地释放内存空间也能减少对 Redis 主线程阻塞的时间，提高执行的效率。</p><blockquote><p><strong>Redis为什么单线程还这么快？</strong></p></blockquote><ul><li>误区1：高性能的服务器一定是多线程的？</li><li>误区2：多线程（CPU上下文会切换！）一定比单线程效率高！</li></ul><p>核心：Redis是将所有的数据放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！），对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都是在一个CPU上的，在内存存储数据情况下，单线程就是最佳的方案。</p><h2 id="三、五大数据类型"><a href="#三、五大数据类型" class="headerlink" title="三、五大数据类型"></a>三、五大数据类型</h2><p> Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作<strong>数据库</strong>，<strong>高速缓存</strong>和<strong>消息队列代理</strong>。它支持<a href="https://www.redis.net.cn/tutorial/3508.html">字符串</a>、<a href="https://www.redis.net.cn/tutorial/3509.html">哈希表</a>、<a href="https://www.redis.net.cn/tutorial/3510.html">列表</a>、<a href="https://www.redis.net.cn/tutorial/3511.html">集合</a>、<a href="https://www.redis.net.cn/tutorial/3512.html">有序集合</a>，<a href="https://www.redis.net.cn/tutorial/3508.html">位图</a>，<a href="https://www.redis.net.cn/tutorial/3513.html">hyperloglogs</a>等数据类型。内置复制、<a href="https://www.redis.net.cn/tutorial/3516.html">Lua脚本</a>、LRU收回、<a href="https://www.redis.net.cn/tutorial/3515.html">事务</a>以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动<a href="https://www.redis.net.cn/tutorial/3524.html">分区</a>。</p><h3 id="Redis-key"><a href="#Redis-key" class="headerlink" title="Redis-key"></a>Redis-key</h3><blockquote><p>在redis中无论什么数据类型，在数据库中都是以key-value形式保存，通过进行对Redis-key的操作，来完成对数据库中数据的操作。</p></blockquote><p>下面学习的命令：</p><ul><li><code>exists key</code>：判断键是否存在</li><li><code>del key</code>：删除键值对</li><li><code>move key db</code>：将键值对移动到指定数据库</li><li><code>expire key second</code>：设置键值对的过期时间</li><li><code>type key</code>：查看value的数据类型</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys * <span class="comment"># 查看当前数据库所有key</span></span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name qinjiang <span class="comment"># set key</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 20</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">2) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; move age 1 <span class="comment"># 将键值对移动到指定数据库</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; EXISTS age <span class="comment"># 判断键是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0 <span class="comment"># 不存在</span></span><br><span class="line">127.0.0.1:6379&gt; EXISTS name</span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 存在</span></span><br><span class="line">127.0.0.1:6379&gt; SELECT 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379[1]&gt; del age <span class="comment"># 删除键值对</span></span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 删除个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 20</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; EXPIRE age 15 <span class="comment"># 设置键值对的过期时间</span></span><br><span class="line"></span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 设置成功 开始计数</span></span><br><span class="line">127.0.0.1:6379&gt; ttl age <span class="comment"># 查看key的过期剩余时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 13</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) -2 <span class="comment"># -2 表示key过期，-1表示key未设置过期时间</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; get age <span class="comment"># 过期的key 会被自动delete</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> name <span class="comment"># 查看value的数据类型</span></span><br><span class="line">string</span><br></pre></td></tr></table></figure><p>关于<code>TTL</code>命令</p><p>Redis的key，通过TTL命令返回key的过期时间，一般来说有3种：</p><ol><li>当前key没有设置过期时间，所以会返回-1.</li><li>当前key有设置过期时间，而且key已经过期，所以会返回-2.</li><li>当前key有设置过期时间，且key还没有过期，故会返回key的正常剩余时间.</li></ol><p>关于重命名<code>RENAME</code>和<code>RENAMENX</code></p><ul><li><code>RENAME key newkey</code>修改 key 的名称</li><li><code>RENAMENX key newkey</code>仅当 newkey 不存在时，将 key 改名为 newkey 。</li></ul><p>更多命令学习：<a href="https://www.redis.net.cn/order/">https://www.redis.net.cn/order/</a></p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-wBVZtGVm-1597890996517)(狂神说 Redis.assets/image-20200813114228439.png)]</p><h3 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String(字符串)"></a>String(字符串)</h3><p>普通的set、get直接略过。</p><table><thead><tr><th>命令</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><code>APPEND key value</code></td><td>向指定的key的value后追加字符串</td><td>127.0.0.1:6379&gt; set msg hello OK 127.0.0.1:6379&gt; append msg “ world” (integer) 11 127.0.0.1:6379&gt; get msg “hello world”</td></tr><tr><td><code>DECR/INCR key</code></td><td>将指定key的value数值进行+1/-1(仅对于数字)</td><td>127.0.0.1:6379&gt; set age 20 OK 127.0.0.1:6379&gt; incr age (integer) 21 127.0.0.1:6379&gt; decr age (integer) 20</td></tr><tr><td><code>INCRBY/DECRBY key n</code></td><td>按指定的步长对数值进行加减</td><td>127.0.0.1:6379&gt; INCRBY age 5 (integer) 25 127.0.0.1:6379&gt; DECRBY age 10 (integer) 15</td></tr><tr><td><code>INCRBYFLOAT key n</code></td><td>为数值加上浮点型数值</td><td>127.0.0.1:6379&gt; INCRBYFLOAT age 5.2 “20.2”</td></tr><tr><td><code>STRLEN key</code></td><td>获取key保存值的字符串长度</td><td>127.0.0.1:6379&gt; get msg “hello world” 127.0.0.1:6379&gt; STRLEN msg (integer) 11</td></tr><tr><td><code>GETRANGE key start end</code></td><td>按起止位置获取字符串（闭区间，起止位置都取）</td><td>127.0.0.1:6379&gt; get msg “hello world” 127.0.0.1:6379&gt; GETRANGE msg 3 9 “lo worl”</td></tr><tr><td><code>SETRANGE key offset value</code></td><td>用指定的value 替换key中 offset开始的值</td><td>127.0.0.1:6379&gt; SETRANGE msg 2 hello (integer) 7 127.0.0.1:6379&gt; get msg “tehello”</td></tr><tr><td><code>GETSET key value</code></td><td>将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td><td>127.0.0.1:6379&gt; GETSET msg test “hello world”</td></tr><tr><td><code>SETNX key value</code></td><td>仅当key不存在时进行set</td><td>127.0.0.1:6379&gt; SETNX msg test (integer) 0 127.0.0.1:6379&gt; SETNX name sakura (integer) 1</td></tr><tr><td><code>SETEX key seconds value</code></td><td>set 键值对并设置过期时间</td><td>127.0.0.1:6379&gt; setex name 10 root OK 127.0.0.1:6379&gt; get name (nil)</td></tr><tr><td><code>MSET key1 value1 [key2 value2..]</code></td><td>批量set键值对</td><td>127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 OK</td></tr><tr><td><code>MSETNX key1 value1 [key2 value2..]</code></td><td>==原子性==，批量设置键值对，仅当参数中所有的key都不存在时执行</td><td>127.0.0.1:6379&gt; MSETNX k1 v1 k4 v4 (integer) 0</td></tr><tr><td><code>MGET key1 [key2..]</code></td><td>批量获取多个key保存的值</td><td>127.0.0.1:6379&gt; MGET k1 k2 k3 1) “v1” 2) “v2” 3) “v3”</td></tr><tr><td><code>PSETEX key milliseconds value</code></td><td>和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，</td><td></td></tr><tr><td><code>getset key value</code></td><td>如果不存在值，则返回nil，如果存在值，返回原来的值，并设置新的值,==cas==</td><td></td></tr></tbody></table><p>String类似的使用场景：value除了是字符串还可以是数字，用途举例：</p><ul><li>计数器</li><li>统计多单位的数量：uid:123666：follow 0</li><li>粉丝数</li><li>对象存储缓存</li><li>setnx  分布式锁</li><li>key   -&gt;  user:{id}:{field}</li></ul><h3 id="List-列表"><a href="#List-列表" class="headerlink" title="List(列表)"></a>List(列表)</h3><blockquote><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p><p>一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。</p></blockquote><p>首先我们列表，可以经过规则定义将其变为队列、栈、双端队列等</p><p><img src="https://img-blog.csdnimg.cn/20200820104440398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VPvbIltc-1597890996518)(狂神说 Redis.assets/image-20200813114255459.png)]"></p><p>正如图Redis中List是可以进行双端操作的，所以命令也就分为了LXXX和RLLL两类，有时候L也表示List例如LLEN</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>LPUSH/RPUSH key value1[value2..]</code></td><td>从左边/右边向列表中PUSH值(一个或者多个)。</td></tr><tr><td><code>LRANGE key start end</code></td><td>获取list 起止元素==（索引从左往右 递增）==</td></tr><tr><td><code>LPUSHX/RPUSHX key value</code></td><td>向已存在的列名中push值（一个或者多个）</td></tr><tr><td>`LINSERT key BEFORE</td><td>AFTER pivot value`</td></tr><tr><td><code>LLEN key</code></td><td>查看列表长度</td></tr><tr><td><code>LINDEX key index</code></td><td>通过索引获取列表元素</td></tr><tr><td><code>LSET key index value</code></td><td>通过索引为元素设值</td></tr><tr><td><code>LPOP/RPOP key</code></td><td>从最左边/最右边移除值 并返回</td></tr><tr><td><code>RPOPLPUSH source destination</code></td><td>将列表的尾部(右)最后一个值弹出，并返回，然后加到另一个列表的头部</td></tr><tr><td><code>LTRIM key start end</code></td><td>通过下标截取指定范围内的列表</td></tr><tr><td><code>LREM key count value</code></td><td>List中是允许value重复的 <code>count &gt; 0</code>：从头部开始搜索 然后删除指定的value 至多删除count个 <code>count &lt; 0</code>：从尾部开始搜索… <code>count = 0</code>：删除列表中所有的指定value。</td></tr><tr><td><code>BLPOP/BRPOP key1[key2] timout</code></td><td>移出并获取列表的第一个/最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td><code>BRPOPLPUSH source destination timeout</code></td><td>和<code>RPOPLPUSH</code>功能相同，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---------------------------LPUSH---RPUSH---LRANGE--------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LPUSH mylist k1 <span class="comment"># LPUSH mylist=&gt;&#123;1&#125;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; LPUSH mylist k2 <span class="comment"># LPUSH mylist=&gt;&#123;2,1&#125;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist k3 <span class="comment"># RPUSH mylist=&gt;&#123;2,1,3&#125;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; get mylist <span class="comment"># 普通的get是无法获取list值的</span></span><br><span class="line">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 4 <span class="comment"># LRANGE 获取起止位置范围内的元素</span></span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">3) <span class="string">&quot;k3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 2</span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">3) <span class="string">&quot;k3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 1</span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1 <span class="comment"># 获取全部元素</span></span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">3) <span class="string">&quot;k3&quot;</span></span><br><span class="line"></span><br><span class="line">---------------------------LPUSHX---RPUSHX-----------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LPUSHX list v1 <span class="comment"># list不存在 LPUSHX失败</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; LPUSHX list v1 v2  </span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; LPUSHX mylist k4 k5 <span class="comment"># 向mylist中 左边 PUSH k4 k5</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;k5&quot;</span></span><br><span class="line">2) <span class="string">&quot;k4&quot;</span></span><br><span class="line">3) <span class="string">&quot;k2&quot;</span></span><br><span class="line">4) <span class="string">&quot;k1&quot;</span></span><br><span class="line">5) <span class="string">&quot;k3&quot;</span></span><br><span class="line"></span><br><span class="line">---------------------------LINSERT--LLEN--LINDEX--LSET----------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LINSERT mylist after k2 ins_key1 <span class="comment"># 在k2元素后 插入ins_key1</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;k5&quot;</span></span><br><span class="line">2) <span class="string">&quot;k4&quot;</span></span><br><span class="line">3) <span class="string">&quot;k2&quot;</span></span><br><span class="line">4) <span class="string">&quot;ins_key1&quot;</span></span><br><span class="line">5) <span class="string">&quot;k1&quot;</span></span><br><span class="line">6) <span class="string">&quot;k3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LLEN mylist <span class="comment"># 查看mylist的长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; LINDEX mylist 3 <span class="comment"># 获取下标为3的元素</span></span><br><span class="line"><span class="string">&quot;ins_key1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LINDEX mylist 0</span><br><span class="line"><span class="string">&quot;k5&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LSET mylist 3 k6 <span class="comment"># 将下标3的元素 set值为k6</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;k5&quot;</span></span><br><span class="line">2) <span class="string">&quot;k4&quot;</span></span><br><span class="line">3) <span class="string">&quot;k2&quot;</span></span><br><span class="line">4) <span class="string">&quot;k6&quot;</span></span><br><span class="line">5) <span class="string">&quot;k1&quot;</span></span><br><span class="line">6) <span class="string">&quot;k3&quot;</span></span><br><span class="line"></span><br><span class="line">---------------------------LPOP--RPOP--------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LPOP mylist <span class="comment"># 左侧(头部)弹出</span></span><br><span class="line"><span class="string">&quot;k5&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; RPOP mylist <span class="comment"># 右侧(尾部)弹出</span></span><br><span class="line"><span class="string">&quot;k3&quot;</span></span><br><span class="line"></span><br><span class="line">---------------------------RPOPLPUSH--------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;k4&quot;</span></span><br><span class="line">2) <span class="string">&quot;k2&quot;</span></span><br><span class="line">3) <span class="string">&quot;k6&quot;</span></span><br><span class="line">4) <span class="string">&quot;k1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; RPOPLPUSH mylist newlist <span class="comment"># 将mylist的最后一个值(k1)弹出，加入到newlist的头部</span></span><br><span class="line"><span class="string">&quot;k1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE newlist 0 -1</span><br><span class="line">1) <span class="string">&quot;k1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;k4&quot;</span></span><br><span class="line">2) <span class="string">&quot;k2&quot;</span></span><br><span class="line">3) <span class="string">&quot;k6&quot;</span></span><br><span class="line"></span><br><span class="line">---------------------------LTRIM--------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LTRIM mylist 0 1 <span class="comment"># 截取mylist中的 0~1部分</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;k4&quot;</span></span><br><span class="line">2) <span class="string">&quot;k2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始 mylist: k2,k2,k2,k2,k2,k2,k4,k2,k2,k2,k2</span></span><br><span class="line">---------------------------LREM--------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LREM mylist 3 k2 <span class="comment"># 从头部开始搜索 至多删除3个 k2</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"><span class="comment"># 删除后：mylist: k2,k2,k2,k4,k2,k2,k2,k2</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LREM mylist -2 k2 <span class="comment">#从尾部开始搜索 至多删除2个 k2</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"><span class="comment"># 删除后：mylist: k2,k2,k2,k4,k2,k2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------BLPOP--BRPOP--------------------------</span><br><span class="line"></span><br><span class="line">mylist: k2,k2,k2,k4,k2,k2</span><br><span class="line">newlist: k1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist mylist 30 <span class="comment"># 从newlist中弹出第一个值，mylist作为候选</span></span><br><span class="line">1) <span class="string">&quot;newlist&quot;</span> <span class="comment"># 弹出</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist mylist 30</span><br><span class="line">1) <span class="string">&quot;mylist&quot;</span> <span class="comment"># 由于newlist空了 从mylist中弹出</span></span><br><span class="line">2) <span class="string">&quot;k2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist 30</span><br><span class="line">(30.10s) <span class="comment"># 超时了</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist 30 <span class="comment"># 我们连接另一个客户端向newlist中push了test, 阻塞被解决。</span></span><br><span class="line">1) <span class="string">&quot;newlist&quot;</span></span><br><span class="line">2) <span class="string">&quot;test&quot;</span></span><br><span class="line">(12.54s)</span><br></pre></td></tr></table></figure><blockquote><p>小结</p></blockquote><ul><li>list实际上是一个链表，before Node after , left, right 都可以插入值</li><li><strong>如果key不存在，则创建新的链表</strong></li><li>如果key存在，新增内容</li><li>如果移除了所有值，空链表，也代表不存在</li><li>在两边插入或者改动值，效率最高！修改中间元素，效率相对较低</li></ul><p><strong>应用：</strong></p><p><strong>消息排队！消息队列（Lpush Rpop）,栈（Lpush Lpop）</strong></p><h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合)"></a>Set(集合)</h3><blockquote><p>Redis的Set是<strong>string类型</strong>的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p><p>Redis 中 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p><p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p></blockquote><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>SADD key member1[member2..]</code></td><td>向集合中无序增加一个/多个成员</td></tr><tr><td><code>SCARD key</code></td><td>获取集合的成员数</td></tr><tr><td><code>SMEMBERS key</code></td><td>返回集合中所有的成员</td></tr><tr><td><code>SISMEMBER key member</code></td><td>查询member元素是否是集合的成员,结果是无序的</td></tr><tr><td><code>SRANDMEMBER key [count]</code></td><td>随机返回集合中count个成员，count缺省值为1</td></tr><tr><td><code>SPOP key [count]</code></td><td>随机移除并返回集合中count个成员，count缺省值为1</td></tr><tr><td><code>SMOVE source destination member</code></td><td>将source集合的成员member移动到destination集合</td></tr><tr><td><code>SREM key member1[member2..]</code></td><td>移除集合中一个/多个成员</td></tr><tr><td><code>SDIFF key1[key2..]</code></td><td>返回所有集合的差集 key1- key2 - …</td></tr><tr><td><code>SDIFFSTORE destination key1[key2..]</code></td><td>在SDIFF的基础上，将结果保存到集合中==(覆盖)==。不能保存到其他类型key噢！</td></tr><tr><td><code>SINTER key1 [key2..]</code></td><td>返回所有集合的交集</td></tr><tr><td><code>SINTERSTORE destination key1[key2..]</code></td><td>在SINTER的基础上，存储结果到集合中。覆盖</td></tr><tr><td><code>SUNION key1 [key2..]</code></td><td>返回所有集合的并集</td></tr><tr><td><code>SUNIONSTORE destination key1 [key2..]</code></td><td>在SUNION的基础上，存储结果到及和张。覆盖</td></tr><tr><td><code>SSCAN KEY [MATCH pattern] [COUNT count]</code></td><td>在大量数据环境下，使用此命令遍历集合中元素，每次遍历部分</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---------------SADD--SCARD--SMEMBERS--SISMEMBER--------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SADD myset m1 m2 m3 m4 <span class="comment"># 向myset中增加成员 m1~m4</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; SCARD myset <span class="comment"># 获取集合的成员数目</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; smembers myset <span class="comment"># 获取集合中所有成员</span></span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line">3) <span class="string">&quot;m2&quot;</span></span><br><span class="line">4) <span class="string">&quot;m1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset m5 <span class="comment"># 查询m5是否是myset的成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 0 <span class="comment"># 不是，返回0</span></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset m2</span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 是，返回1</span></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset m3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">---------------------SRANDMEMBER--SPOP----------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset 3 <span class="comment"># 随机返回3个成员</span></span><br><span class="line">1) <span class="string">&quot;m2&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line">3) <span class="string">&quot;m4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset <span class="comment"># 随机返回1个成员</span></span><br><span class="line"><span class="string">&quot;m3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SPOP myset 2 <span class="comment"># 随机移除并返回2个成员</span></span><br><span class="line">1) <span class="string">&quot;m1&quot;</span></span><br><span class="line">2) <span class="string">&quot;m4&quot;</span></span><br><span class="line"><span class="comment"># 将set还原到&#123;m1,m2,m3,m4&#125;</span></span><br><span class="line"></span><br><span class="line">---------------------SMOVE--SREM----------------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SMOVE myset newset m3 <span class="comment"># 将myset中m3成员移动到newset集合</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">2) <span class="string">&quot;m2&quot;</span></span><br><span class="line">3) <span class="string">&quot;m1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS newset</span><br><span class="line">1) <span class="string">&quot;m3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SREM newset m3 <span class="comment"># 从newset中移除m3元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS newset</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面开始是多集合操作,多集合操作中若只有一个参数默认和自身进行运算</span></span><br><span class="line"><span class="comment"># setx=&gt;&#123;m1,m2,m4,m6&#125;, sety=&gt;&#123;m2,m5,m6&#125;, setz=&gt;&#123;m1,m3,m6&#125;</span></span><br><span class="line"></span><br><span class="line">-----------------------------SDIFF------------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SDIFF setx sety setz <span class="comment"># 等价于setx-sety-setz</span></span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SDIFF setx sety <span class="comment"># setx - sety</span></span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">2) <span class="string">&quot;m1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SDIFF sety setx <span class="comment"># sety - setx</span></span><br><span class="line">1) <span class="string">&quot;m5&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------------SINTER---------------------------------------</span><br><span class="line"><span class="comment"># 共同关注（交集）</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SINTER setx sety setz <span class="comment"># 求 setx、sety、setx的交集</span></span><br><span class="line">1) <span class="string">&quot;m6&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SINTER setx sety <span class="comment"># 求setx sety的交集</span></span><br><span class="line">1) <span class="string">&quot;m2&quot;</span></span><br><span class="line">2) <span class="string">&quot;m6&quot;</span></span><br><span class="line"></span><br><span class="line">-------------------------SUNION---------------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SUNION setx sety setz <span class="comment"># setx sety setz的并集</span></span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">2) <span class="string">&quot;m6&quot;</span></span><br><span class="line">3) <span class="string">&quot;m3&quot;</span></span><br><span class="line">4) <span class="string">&quot;m2&quot;</span></span><br><span class="line">5) <span class="string">&quot;m1&quot;</span></span><br><span class="line">6) <span class="string">&quot;m5&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SUNION setx sety <span class="comment"># setx sety 并集</span></span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">2) <span class="string">&quot;m6&quot;</span></span><br><span class="line">3) <span class="string">&quot;m2&quot;</span></span><br><span class="line">4) <span class="string">&quot;m1&quot;</span></span><br><span class="line">5) <span class="string">&quot;m5&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h3><blockquote><p>Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p><p>Set就是一种简化的Hash,只变动key,而value使用默认值填充。可以将一个Hash表作为一个对象进行存储，表中存放对象的信息。</p></blockquote><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>HSET key field value</code></td><td>将哈希表 key 中的字段 field 的值设为 value 。重复设置同一个field会覆盖,返回0</td></tr><tr><td><code>HMSET key field1 value1 [field2 value2..]</code></td><td>同时将多个 field-value (域-值)对设置到哈希表 key 中。</td></tr><tr><td><code>HSETNX key field value</code></td><td>只有在字段 field 不存在时，设置哈希表字段的值。</td></tr><tr><td><code>HEXISTS key field</code></td><td>查看哈希表 key 中，指定的字段是否存在。</td></tr><tr><td><code>HGET key field value</code></td><td>获取存储在哈希表中指定字段的值</td></tr><tr><td><code>HMGET key field1 [field2..]</code></td><td>获取所有给定字段的值</td></tr><tr><td><code>HGETALL key</code></td><td>获取在哈希表key 的所有字段和值</td></tr><tr><td><code>HKEYS key</code></td><td>获取哈希表key中所有的字段</td></tr><tr><td><code>HLEN key</code></td><td>获取哈希表中字段的数量</td></tr><tr><td><code>HVALS key</code></td><td>获取哈希表中所有值</td></tr><tr><td><code>HDEL key field1 [field2..]</code></td><td>删除哈希表key中一个/多个field字段</td></tr><tr><td><code>HINCRBY key field n</code></td><td>为哈希表 key 中的指定字段的整数值加上增量n，并返回增量后结果 一样只适用于整数型字段</td></tr><tr><td><code>HINCRBYFLOAT key field n</code></td><td>为哈希表 key 中的指定字段的浮点数值加上增量 n。</td></tr><tr><td><code>HSCAN key cursor [MATCH pattern] [COUNT count]</code></td><td>迭代哈希表中的键值对。</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">------------------------HSET--HMSET--HSETNX----------------</span><br><span class="line">127.0.0.1:6379&gt; HSET studentx name sakura <span class="comment"># 将studentx哈希表作为一个对象，设置name为sakura</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HSET studentx name gyc <span class="comment"># 重复设置field进行覆盖，并返回0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; HSET studentx age 20 <span class="comment"># 设置studentx的age为20</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HMSET studentx sex 1 tel 15623667886 <span class="comment"># 设置sex为1，tel为15623667886</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; HSETNX studentx name gyc <span class="comment"># HSETNX 设置已存在的field</span></span><br><span class="line">(<span class="built_in">integer</span>) 0 <span class="comment"># 失败</span></span><br><span class="line">127.0.0.1:6379&gt; HSETNX studentx email 12345@qq.com</span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 成功</span></span><br><span class="line"></span><br><span class="line">----------------------HEXISTS--------------------------------</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS studentx name <span class="comment"># name字段在studentx中是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 存在</span></span><br><span class="line">127.0.0.1:6379&gt; HEXISTS studentx addr</span><br><span class="line">(<span class="built_in">integer</span>) 0 <span class="comment"># 不存在</span></span><br><span class="line"></span><br><span class="line">-------------------HGET--HMGET--HGETALL-----------</span><br><span class="line">127.0.0.1:6379&gt; HGET studentx name <span class="comment"># 获取studentx中name字段的value</span></span><br><span class="line"><span class="string">&quot;gyc&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HMGET studentx name age tel <span class="comment"># 获取studentx中name、age、tel字段的value</span></span><br><span class="line">1) <span class="string">&quot;gyc&quot;</span></span><br><span class="line">2) <span class="string">&quot;20&quot;</span></span><br><span class="line">3) <span class="string">&quot;15623667886&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HGETALL studentx <span class="comment"># 获取studentx中所有的field及其value</span></span><br><span class="line"> 1) <span class="string">&quot;name&quot;</span></span><br><span class="line"> 2) <span class="string">&quot;gyc&quot;</span></span><br><span class="line"> 3) <span class="string">&quot;age&quot;</span></span><br><span class="line"> 4) <span class="string">&quot;20&quot;</span></span><br><span class="line"> 5) <span class="string">&quot;sex&quot;</span></span><br><span class="line"> 6) <span class="string">&quot;1&quot;</span></span><br><span class="line"> 7) <span class="string">&quot;tel&quot;</span></span><br><span class="line"> 8) <span class="string">&quot;15623667886&quot;</span></span><br><span class="line"> 9) <span class="string">&quot;email&quot;</span></span><br><span class="line">10) <span class="string">&quot;12345@qq.com&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------HKEYS--HLEN--HVALS--------------</span><br><span class="line">127.0.0.1:6379&gt; HKEYS studentx <span class="comment"># 查看studentx中所有的field</span></span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;age&quot;</span></span><br><span class="line">3) <span class="string">&quot;sex&quot;</span></span><br><span class="line">4) <span class="string">&quot;tel&quot;</span></span><br><span class="line">5) <span class="string">&quot;email&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HLEN studentx <span class="comment"># 查看studentx中的字段数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; HVALS studentx <span class="comment"># 查看studentx中所有的value</span></span><br><span class="line">1) <span class="string">&quot;gyc&quot;</span></span><br><span class="line">2) <span class="string">&quot;20&quot;</span></span><br><span class="line">3) <span class="string">&quot;1&quot;</span></span><br><span class="line">4) <span class="string">&quot;15623667886&quot;</span></span><br><span class="line">5) <span class="string">&quot;12345@qq.com&quot;</span></span><br><span class="line"></span><br><span class="line">-------------------------HDEL--------------------------</span><br><span class="line">127.0.0.1:6379&gt; HDEL studentx sex tel <span class="comment"># 删除studentx 中的sex、tel字段</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; HKEYS studentx</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;age&quot;</span></span><br><span class="line">3) <span class="string">&quot;email&quot;</span></span><br><span class="line"></span><br><span class="line">-------------HINCRBY--HINCRBYFLOAT------------------------</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY studentx age 1 <span class="comment"># studentx的age字段数值+1</span></span><br><span class="line">(<span class="built_in">integer</span>) 21</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY studentx name 1 <span class="comment"># 非整数字型字段不可用</span></span><br><span class="line">(error) ERR <span class="built_in">hash</span> value is not an <span class="built_in">integer</span></span><br><span class="line">127.0.0.1:6379&gt; HINCRBYFLOAT studentx weight 0.6 <span class="comment"># weight字段增加0.6</span></span><br><span class="line"><span class="string">&quot;90.8&quot;</span></span><br></pre></td></tr></table></figure><p> Hash变更的数据user name age，尤其是用户信息之类的，经常变动的信息！<strong>Hash更适合于对象的存储，Sring更加适合字符串存储！</strong></p><h3 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h3><blockquote><p>不同的是每个元素都会关联一个double类型的分数（score）。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>score相同：按字典顺序排序</p><p>有序集合的成员是唯一的,但分数(score)却可以重复。</p></blockquote><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>ZADD key score member1 [score2 member2]</code></td><td>向有序集合添加一个或多个成员，或者更新已存在成员的分数</td></tr><tr><td><code>ZCARD key</code></td><td>获取有序集合的成员数</td></tr><tr><td><code>ZCOUNT key min max</code></td><td>计算在有序集合中指定区间score的成员数</td></tr><tr><td><code>ZINCRBY key n member</code></td><td>有序集合中对指定成员的分数加上增量 n</td></tr><tr><td><code>ZSCORE key member</code></td><td>返回有序集中，成员的分数值</td></tr><tr><td><code>ZRANK key member</code></td><td>返回有序集合中指定成员的索引</td></tr><tr><td><code>ZRANGE key start end</code></td><td>通过索引区间返回有序集合成指定区间内的成员</td></tr><tr><td><code>ZRANGEBYLEX key min max</code></td><td>通过字典区间返回有序集合的成员</td></tr><tr><td><code>ZRANGEBYSCORE key min max</code></td><td>通过分数返回有序集合指定区间内的成员==-inf 和 +inf分别表示最小最大值，只支持开区间()==</td></tr><tr><td><code>ZLEXCOUNT key min max</code></td><td>在有序集合中计算指定字典区间内成员数量</td></tr><tr><td><code>ZREM key member1 [member2..]</code></td><td>移除有序集合中一个/多个成员</td></tr><tr><td><code>ZREMRANGEBYLEX key min max</code></td><td>移除有序集合中给定的字典区间的所有成员</td></tr><tr><td><code>ZREMRANGEBYRANK key start stop</code></td><td>移除有序集合中给定的排名区间的所有成员</td></tr><tr><td><code>ZREMRANGEBYSCORE key min max</code></td><td>移除有序集合中给定的分数区间的所有成员</td></tr><tr><td><code>ZREVRANGE key start end</code></td><td>返回有序集中指定区间内的成员，通过索引，分数从高到底</td></tr><tr><td><code>ZREVRANGEBYSCORRE key max min</code></td><td>返回有序集中指定分数区间内的成员，分数从高到低排序</td></tr><tr><td><code>ZREVRANGEBYLEX key max min</code></td><td>返回有序集中指定字典区间内的成员，按字典顺序倒序</td></tr><tr><td><code>ZREVRANK key member</code></td><td>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td></tr><tr><td><code>ZINTERSTORE destination numkeys key1 [key2 ..]</code></td><td>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中，numkeys：表示参与运算的集合数，将score相加作为结果的score</td></tr><tr><td><code>ZUNIONSTORE destination numkeys key1 [key2..]</code></td><td>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</td></tr><tr><td><code>ZSCAN key cursor [MATCH pattern\] [COUNT count]</code></td><td>迭代有序集合中的元素（包括元素成员和元素分值）</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-------------------ZADD--ZCARD--ZCOUNT--------------</span><br><span class="line">127.0.0.1:6379&gt; ZADD myzset 1 m1 2 m2 3 m3 <span class="comment"># 向有序集合myzset中添加成员m1 score=1 以及成员m2 score=2..</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZCARD myzset <span class="comment"># 获取有序集合的成员数</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT myzset 0 1 <span class="comment"># 获取score在 [0,1]区间的成员数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT myzset 0 2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">----------------ZINCRBY--ZSCORE--------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZINCRBY myzset 5 m2 <span class="comment"># 将成员m2的score +5</span></span><br><span class="line"><span class="string">&quot;7&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZSCORE myzset m1 <span class="comment"># 获取成员m1的score</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZSCORE myzset m2</span><br><span class="line"><span class="string">&quot;7&quot;</span></span><br><span class="line"></span><br><span class="line">--------------ZRANK--ZRANGE-----------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZRANK myzset m1 <span class="comment"># 获取成员m1的索引，索引按照score排序，score相同索引值按字典顺序顺序增加</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; ZRANK myzset m2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myzset 0 1 <span class="comment"># 获取索引在 0~1的成员</span></span><br><span class="line">1) <span class="string">&quot;m1&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myzset 0 -1 <span class="comment"># 获取全部成员</span></span><br><span class="line">1) <span class="string">&quot;m1&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line">3) <span class="string">&quot;m2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#testset=&gt;&#123;abc,add,amaze,apple,back,java,redis&#125; score均为0</span></span><br><span class="line">------------------ZRANGEBYLEX---------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset - + <span class="comment"># 返回所有成员</span></span><br><span class="line">1) <span class="string">&quot;abc&quot;</span></span><br><span class="line">2) <span class="string">&quot;add&quot;</span></span><br><span class="line">3) <span class="string">&quot;amaze&quot;</span></span><br><span class="line">4) <span class="string">&quot;apple&quot;</span></span><br><span class="line">5) <span class="string">&quot;back&quot;</span></span><br><span class="line">6) <span class="string">&quot;java&quot;</span></span><br><span class="line">7) <span class="string">&quot;redis&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset - + LIMIT 0 3 <span class="comment"># 分页 按索引显示查询结果的 0,1,2条记录</span></span><br><span class="line">1) <span class="string">&quot;abc&quot;</span></span><br><span class="line">2) <span class="string">&quot;add&quot;</span></span><br><span class="line">3) <span class="string">&quot;amaze&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset - + LIMIT 3 3 <span class="comment"># 显示 3,4,5条记录</span></span><br><span class="line">1) <span class="string">&quot;apple&quot;</span></span><br><span class="line">2) <span class="string">&quot;back&quot;</span></span><br><span class="line">3) <span class="string">&quot;java&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset (- [apple <span class="comment"># 显示 (-,apple] 区间内的成员</span></span><br><span class="line">1) <span class="string">&quot;abc&quot;</span></span><br><span class="line">2) <span class="string">&quot;add&quot;</span></span><br><span class="line">3) <span class="string">&quot;amaze&quot;</span></span><br><span class="line">4) <span class="string">&quot;apple&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset [apple [java <span class="comment"># 显示 [apple,java]字典区间的成员</span></span><br><span class="line">1) <span class="string">&quot;apple&quot;</span></span><br><span class="line">2) <span class="string">&quot;back&quot;</span></span><br><span class="line">3) <span class="string">&quot;java&quot;</span></span><br><span class="line"></span><br><span class="line">-----------------------ZRANGEBYSCORE---------------------</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE myzset 1 10 <span class="comment"># 返回score在 [1,10]之间的的成员</span></span><br><span class="line">1) <span class="string">&quot;m1&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line">3) <span class="string">&quot;m2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE myzset 1 5</span><br><span class="line">1) <span class="string">&quot;m1&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line"></span><br><span class="line">--------------------ZLEXCOUNT-----------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZLEXCOUNT testset - +</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; ZLEXCOUNT testset [apple [java</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">------------------ZREM--ZREMRANGEBYLEX--ZREMRANGBYRANK--ZREMRANGEBYSCORE--------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZREM testset abc <span class="comment"># 移除成员abc</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYLEX testset [apple [java <span class="comment"># 移除字典区间[apple,java]中的所有成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYRANK testset 0 1 <span class="comment"># 移除排名0~1的所有成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYSCORE myzset 0 3 <span class="comment"># 移除score在 [0,3]的成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># testset=&gt; &#123;abc,add,apple,amaze,back,java,redis&#125; score均为0</span></span><br><span class="line"><span class="comment"># myzset=&gt; &#123;(m1,1),(m2,2),(m3,3),(m4,4),(m7,7),(m9,9)&#125;</span></span><br><span class="line">----------------ZREVRANGE--ZREVRANGEBYSCORE--ZREVRANGEBYLEX-----------</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE myzset 0 3 <span class="comment"># 按score递减排序，然后按索引，返回结果的 0~3</span></span><br><span class="line">1) <span class="string">&quot;m9&quot;</span></span><br><span class="line">2) <span class="string">&quot;m7&quot;</span></span><br><span class="line">3) <span class="string">&quot;m4&quot;</span></span><br><span class="line">4) <span class="string">&quot;m3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE myzset 2 4 <span class="comment"># 返回排序结果的 索引的2~4</span></span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line">3) <span class="string">&quot;m2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGEBYSCORE myzset 6 2 <span class="comment"># 按score递减顺序 返回集合中分数在[2,6]之间的成员</span></span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line">3) <span class="string">&quot;m2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGEBYLEX testset [java (add <span class="comment"># 按字典倒序 返回集合中(add,java]字典区间的成员</span></span><br><span class="line">1) <span class="string">&quot;java&quot;</span></span><br><span class="line">2) <span class="string">&quot;back&quot;</span></span><br><span class="line">3) <span class="string">&quot;apple&quot;</span></span><br><span class="line">4) <span class="string">&quot;amaze&quot;</span></span><br><span class="line"></span><br><span class="line">-------------------------ZREVRANK------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANK myzset m7 <span class="comment"># 按score递减顺序，返回成员m7索引</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANK myzset m2</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># mathscore=&gt;&#123;(xm,90),(xh,95),(xg,87)&#125; 小明、小红、小刚的数学成绩</span></span><br><span class="line"><span class="comment"># enscore=&gt;&#123;(xm,70),(xh,93),(xg,90)&#125; 小明、小红、小刚的英语成绩</span></span><br><span class="line">-------------------ZINTERSTORE--ZUNIONSTORE-----------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZINTERSTORE sumscore 2 mathscore enscore <span class="comment"># 将mathscore enscore进行合并 结果存放到sumscore</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE sumscore 0 -1 withscores <span class="comment"># 合并后的score是之前集合中所有score的和</span></span><br><span class="line">1) <span class="string">&quot;xm&quot;</span></span><br><span class="line">2) <span class="string">&quot;160&quot;</span></span><br><span class="line">3) <span class="string">&quot;xg&quot;</span></span><br><span class="line">4) <span class="string">&quot;177&quot;</span></span><br><span class="line">5) <span class="string">&quot;xh&quot;</span></span><br><span class="line">6) <span class="string">&quot;188&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ZUNIONSTORE lowestscore 2 mathscore enscore AGGREGATE MIN <span class="comment"># 取两个集合的成员score最小值作为结果的</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE lowestscore 0 -1 withscores</span><br><span class="line">1) <span class="string">&quot;xm&quot;</span></span><br><span class="line">2) <span class="string">&quot;70&quot;</span></span><br><span class="line">3) <span class="string">&quot;xg&quot;</span></span><br><span class="line">4) <span class="string">&quot;87&quot;</span></span><br><span class="line">5) <span class="string">&quot;xh&quot;</span></span><br><span class="line">6) <span class="string">&quot;93&quot;</span></span><br></pre></td></tr></table></figure><p>应用案例：</p><ul><li>set排序 存储班级成绩表 工资表排序！</li><li>普通消息，1.重要消息 2.带权重进行判断</li><li>排行榜应用实现，取Top N测试</li></ul><h2 id="四、三种特殊数据类型"><a href="#四、三种特殊数据类型" class="headerlink" title="四、三种特殊数据类型"></a>四、三种特殊数据类型</h2><h3 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial(地理位置)"></a>Geospatial(地理位置)</h3><blockquote><p>使用经纬度定位地理坐标并用一个<strong>有序集合zset保存</strong>，所以zset命令也可以使用</p></blockquote><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>geoadd key longitud(经度) latitude(纬度) member [..]</code></td><td>将具体经纬度的坐标存入一个有序集合</td></tr><tr><td><code>geopos key member [member..]</code></td><td>获取集合中的一个/多个成员坐标</td></tr><tr><td><code>geodist key member1 member2 [unit]</code></td><td>返回两个给定位置之间的距离。默认以米作为单位。</td></tr><tr><td>`georadius key longitude latitude radius m</td><td>km</td></tr><tr><td><code>GEORADIUSBYMEMBER key member radius...</code></td><td>功能与GEORADIUS相同，只是中心位置不是具体的经纬度，而是使用结合中已有的成员作为中心点。</td></tr><tr><td><code>geohash key member1 [member2..]</code></td><td>返回一个或多个位置元素的Geohash表示。使用Geohash位置52点整数编码。</td></tr></tbody></table><p><strong>有效经纬度</strong></p><blockquote><ul><li>有效的经度从-180度到180度。</li><li>有效的纬度从-85.05112878度到85.05112878度。</li></ul></blockquote><p>指定单位的参数 <strong>unit</strong> 必须是以下单位的其中一个：</p><ul><li><strong>m</strong> 表示单位为米。</li><li><strong>km</strong> 表示单位为千米。</li><li><strong>mi</strong> 表示单位为英里。</li><li><strong>ft</strong> 表示单位为英尺。</li></ul><p><strong>关于GEORADIUS的参数</strong></p><blockquote><p>通过<code>georadius</code>就可以完成 <strong>附近的人</strong>功能</p><p>withcoord:带上坐标</p><p>withdist:带上距离，单位与半径单位相同</p><p>COUNT n : 只显示前n个(按距离递增排序)</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">----------------georadius---------------------127.0.0.1:6379&gt; GEORADIUS china:city 120 30 500 km withcoord withdist <span class="comment"># 查询经纬度(120,30)坐标500km半径内的成员1) 1) &quot;hangzhou&quot;   2) &quot;29.4151&quot;   3) 1) &quot;120.20000249147415&quot;      2) &quot;30.199999888333501&quot;2) 1) &quot;shanghai&quot;   2) &quot;205.3611&quot;   3) 1) &quot;121.40000134706497&quot;      2) &quot;31.400000253193539&quot;     ------------geohash---------------------------127.0.0.1:6379&gt; geohash china:city yichang shanghai # 获取成员经纬坐标的geohash表示1) &quot;wmrjwbr5250&quot;2) &quot;wtw6ds0y300&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Hyperloglog-基数统计"><a href="#Hyperloglog-基数统计" class="headerlink" title="Hyperloglog(基数统计)"></a>Hyperloglog(基数统计)</h3><blockquote><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p><p>花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。</p><p>因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><p>其底层使用string数据类型</p></blockquote><p><strong>什么是基数？</strong></p><blockquote><p>数据集中不重复的元素的个数。</p></blockquote><p><strong>应用场景：</strong></p><p>网页的访问量（UV）：一个用户多次访问，也只能算作一个人。</p><blockquote><p>传统实现，存储用户的id,然后每次进行比较。当用户变多之后这种方式及其浪费空间，而我们的目的只是<strong>计数</strong>，Hyperloglog就能帮助我们利用最小的空间完成。</p></blockquote><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>PFADD key element1 [elememt2..]</code></td><td>添加指定元素到 HyperLogLog 中</td></tr><tr><td><code>PFCOUNT key [key]</code></td><td>返回给定 HyperLogLog 的基数估算值。</td></tr><tr><td><code>PFMERGE destkey sourcekey [sourcekey..]</code></td><td>将多个 HyperLogLog 合并为一个 HyperLogLog</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">----------PFADD--PFCOUNT---------------------127.0.0.1:6379&gt; PFADD myelemx a b c d e f g h i j k <span class="comment"># 添加元素(integer) 1127.0.0.1:6379&gt; type myelemx # hyperloglog底层使用Stringstring127.0.0.1:6379&gt; PFCOUNT myelemx # 估算myelemx的基数(integer) 11127.0.0.1:6379&gt; PFADD myelemy i j k z m c b v p q s(integer) 1127.0.0.1:6379&gt; PFCOUNT myelemy(integer) 11----------------PFMERGE-----------------------127.0.0.1:6379&gt; PFMERGE myelemz myelemx myelemy # 合并myelemx和myelemy 成为myelemzOK127.0.0.1:6379&gt; PFCOUNT myelemz # 估算基数(integer) 17</span></span><br></pre></td></tr></table></figure><p>如果==允许容错==，那么一定可以使用Hyperloglog !</p><p>如果不允许容错，就使用set或者自己的数据类型即可 ！</p><h3 id="BitMaps-位图"><a href="#BitMaps-位图" class="headerlink" title="BitMaps(位图)"></a>BitMaps(位图)</h3><blockquote><p>使用位存储，信息状态只有 0 和 1</p><p>Bitmap是一串连续的2进制数字（0或1），每一位所在的位置为偏移(offset)，在bitmap上可执行AND,OR,XOR,NOT以及其它位操作。</p></blockquote><p><strong>应用场景</strong></p><p>签到统计、状态统计</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>setbit key offset value</code></td><td>为指定key的offset位设置值</td></tr><tr><td><code>getbit key offset</code></td><td>获取offset位的值</td></tr><tr><td><code>bitcount key [start end]</code></td><td>统计字符串被设置为1的bit数，也可以指定统计范围按字节</td></tr><tr><td><code>bitop operration destkey key[key..]</code></td><td>对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</td></tr><tr><td><code>BITPOS key bit [start] [end]</code></td><td>返回字符串里面第一个被设置为1或者0的bit位。start和end只能按字节,不能按位</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">------------setbit--getbit--------------127.0.0.1:6379&gt; setbit sign 0 1 <span class="comment"># 设置sign的第0位为 1 (integer) 0127.0.0.1:6379&gt; setbit sign 2 1 # 设置sign的第2位为 1  不设置默认 是0(integer) 0127.0.0.1:6379&gt; setbit sign 3 1(integer) 0127.0.0.1:6379&gt; setbit sign 5 1(integer) 0127.0.0.1:6379&gt; type signstring127.0.0.1:6379&gt; getbit sign 2 # 获取第2位的数值(integer) 1127.0.0.1:6379&gt; getbit sign 3(integer) 1127.0.0.1:6379&gt; getbit sign 4 # 未设置默认是0(integer) 0-----------bitcount----------------------------127.0.0.1:6379&gt; BITCOUNT sign # 统计sign中为1的位数(integer) 4</span></span><br></pre></td></tr></table></figure><p><strong>bitmaps的底层</strong></p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9PlszjhS-1597890996519)(D:\我\MyBlog\狂神说 Redis.assets\image-20200803234336175.png)]</p><p>这样设置以后你能get到的值是：<strong>\xA2\x80</strong>，所以bitmaps是一串从左到右的二进制串</p><h2 id="五、事务"><a href="#五、事务" class="headerlink" title="五、事务"></a>五、事务</h2><p>==Redis的单条命令是保证原子性的，但是redis事务不能保证原子性==</p><blockquote><p>Redis事务本质：一组命令的集合。</p><p>—————– 队列 set set set 执行 ——————-</p><p>事务中每条命令都会被序列化，执行过程中按顺序执行，不允许其他命令进行干扰。</p><ul><li>一次性：一次性执行</li><li>顺序性：队列一次执行</li><li>排他性：不允许被干扰</li></ul><hr><ol><li>Redis事务没有隔离级别的概念</li><li>Redis单条命令是保证原子性的，但是事务不保证原子性！</li></ol></blockquote><h3 id="Redis事务操作过程"><a href="#Redis事务操作过程" class="headerlink" title="Redis事务操作过程"></a>Redis事务操作过程</h3><ul><li>开启事务（<code>multi</code>）</li><li>命令入队</li><li>执行事务（<code>exec</code>）</li></ul><p>==所以事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成。==</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi <span class="comment"># 开启事务OK127.0.0.1:6379&gt; set k1 v1 # 命令入队QUEUED127.0.0.1:6379&gt; set k2 v2 # ..QUEUED127.0.0.1:6379&gt; get k1QUEUED127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; keys *QUEUED127.0.0.1:6379&gt; exec # 事务执行1) OK2) OK3) &quot;v1&quot;4) OK5) 1) &quot;k3&quot;   2) &quot;k2&quot;   3) &quot;k1&quot;</span></span><br></pre></td></tr></table></figure><p><strong>取消事务(<code>discurd</code>)</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1QUEUED127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2QUEUED127.0.0.1:6379&gt; DISCARD <span class="comment"># 放弃事务OK127.0.0.1:6379&gt; EXEC (error) ERR EXEC without MULTI # 当前未开启事务127.0.0.1:6379&gt; get k1 # 被放弃事务中命令并未执行(nil)</span></span><br></pre></td></tr></table></figure><h3 id="事务错误"><a href="#事务错误" class="headerlink" title="事务错误"></a>事务错误</h3><blockquote><p>代码语法错误（编译时异常）所有的命令都不执行</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1QUEUED127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2QUEUED127.0.0.1:6379&gt; error k1 <span class="comment"># 这是一条语法错误命令(error) ERR unknown command `error`, with args beginning with: `k1`, # 会报错但是不影响后续命令入队 127.0.0.1:6379&gt; get k2QUEUED127.0.0.1:6379&gt; EXEC(error) EXECABORT Transaction discarded because of previous errors. # 执行报错127.0.0.1:6379&gt; get k1 (nil) # 其他命令并没有被执行</span></span><br></pre></td></tr></table></figure><blockquote><p>代码逻辑错误 (运行时异常) **其他命令可以正常执行 ** &gt;&gt;&gt; 所以不保证事务原子性</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1QUEUED127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2QUEUED127.0.0.1:6379&gt; INCR k1 <span class="comment"># 这条命令逻辑错误（对字符串进行增量）QUEUED127.0.0.1:6379&gt; get k2QUEUED127.0.0.1:6379&gt; exec1) OK2) OK3) (error) ERR value is not an integer or out of range # 运行时报错4) &quot;v2&quot; # 其他命令正常执行# 虽然中间有一条命令报错了，但是后面的指令依旧正常执行成功了。# 所以说Redis单条指令保证原子性，但是Redis事务不能保证原子性。</span></span><br></pre></td></tr></table></figure><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p><strong>悲观锁：</strong></p><ul><li>很悲观，认为什么时候都会出现问题，无论做什么都会加锁</li></ul><p><strong>乐观锁：</strong></p><ul><li>很乐观，认为什么时候都不会出现问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据</li><li>获取version</li><li>更新的时候比较version</li></ul><p>使用<code>watch key</code>监控指定数据，相当于乐观锁加锁。</p><blockquote><p>正常执行</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 100 <span class="comment"># 设置余额:100OK127.0.0.1:6379&gt; set use 0 # 支出使用:0OK127.0.0.1:6379&gt; watch money # 监视money (上锁)OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; DECRBY money 20QUEUED127.0.0.1:6379&gt; INCRBY use 20QUEUED127.0.0.1:6379&gt; exec # 监视值没有被中途修改，事务正常执行1) (integer) 802) (integer) 20</span></span><br></pre></td></tr></table></figure><blockquote><p>测试多线程修改值，使用watch可以当做redis的乐观锁操作（==相当于getversion==，）</p><p>提交事务时比对之前watch时get到的值，发现和现在不同，就执行失败，相当于加锁。</p></blockquote><p>我们启动另外一个客户端模拟插队线程。</p><p>线程1：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch money <span class="comment"># money上锁OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; DECRBY money 20QUEUED127.0.0.1:6379&gt; INCRBY use 20QUEUED127.0.0.1:6379&gt; # 此时事务并没有执行</span></span><br></pre></td></tr></table></figure><p>模拟线程插队，线程2：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INCRBY money 500 <span class="comment"># 修改了线程一中监视的money(integer) 60012</span></span><br></pre></td></tr></table></figure><p>回到线程1，执行事务：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EXEC <span class="comment"># 执行之前，另一个线程修改了我们的值，这个时候就会导致事务执行失败(nil) # 没有结果，说明事务执行失败127.0.0.1:6379&gt; get money # 线程2 修改生效&quot;600&quot;127.0.0.1:6379&gt; get use # 线程1事务执行失败，数值没有被修改&quot;0&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>失败了怎么办呢？解锁获取最新值，然后再加锁进行事务。</p><p><code>unwatch</code>进行解锁。</p></blockquote><p><img src="/images/redis-kuang/image-20210831113434480.png" alt="image-20210831113434480"></p><p>注意：每次提交执行exec后都会自动释放锁，不管是否成功</p><h2 id="六、Jedis"><a href="#六、Jedis" class="headerlink" title="六、Jedis"></a>六、Jedis</h2><p>使用Java来操作Redis，Jedis是Redis官方推荐使用的Java连接redis的客户端。</p><ol><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入jredis的包--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!--fastjson--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.70<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编码测试</p><ul><li><p>连接数据库</p><ol><li><p>修改redis的配置文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/<span class="built_in">local</span>/bin/myconfig/redis.conf1</span><br></pre></td></tr></table></figure><ol><li><p>将只绑定本地注释</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-4IRUFJ95-1597890996520)(狂神说 Redis.assets/image-20200813161921480.png)]</p></li><li><p>保护模式改为 no</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oKjIVapw-1597890996521)(狂神说 Redis.assets/image-20200813161939847.png)]</p></li><li><p>允许后台运行</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-c2IMvpZL-1597890996522)(狂神说 Redis.assets/image-20200813161954567.png)]</p></li></ol></li></ol></li></ul></li><li><p>开放端口6379</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=6379/tcp --permanet1</span><br></pre></td></tr></table></figure><p>重启防火墙服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart firewalld.service1</span><br></pre></td></tr></table></figure><ol><li><p>阿里云服务器控制台配置安全组</p></li><li><p>重启redis-server</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@AlibabaECS bin]<span class="comment"># redis-server myconfig/redis.conf 1</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><ul><li><p>操作命令</p><p><strong>TestPing.java</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPing</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.xx.xxx&quot;</span>, <span class="number">6379</span>);        String response = jedis.ping();        System.out.println(response); <span class="comment">// PONG    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>断开连接</p></li></ul><ol><li><p><strong>事务</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTX</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;39.99.xxx.xx&quot;</span>, <span class="number">6379</span>);        JSONObject jsonObject = <span class="keyword">new</span> JSONObject();        jsonObject.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);        jsonObject.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;kuangshen&quot;</span>);        <span class="comment">// 开启事务        Transaction multi = jedis.multi();        String result = jsonObject.toJSONString();        // jedis.watch(result)        try &#123;            multi.set(&quot;user1&quot;, result);            multi.set(&quot;user2&quot;, result);            // 执行事务            multi.exec();        &#125;catch (Exception e)&#123;            // 放弃事务            multi.discard();        &#125; finally &#123;            // 关闭连接            System.out.println(jedis.get(&quot;user1&quot;));            System.out.println(jedis.get(&quot;user2&quot;));            jedis.close();        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="七、SpringBoot整合"><a href="#七、SpringBoot整合" class="headerlink" title="七、SpringBoot整合"></a>七、SpringBoot整合</h2><ol><li>导入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>springboot 2.x后 ，原来使用的 Jedis 被 lettuce 替换。</p><blockquote><p>jedis：采用的直连，多个线程操作的话，是不安全的。如果要避免不安全，使用jedis pool连接池！更像BIO模式</p><p>lettuce：采用netty，实例可以在多个线程中共享，不存在线程不安全的情况！可以减少线程数据了，更像NIO模式</p></blockquote><p>我们在学习SpringBoot自动配置的原理时，整合一个组件并进行配置一定会有一个自动配置类xxxAutoConfiguration,并且在spring.factories中也一定能找到这个类的完全限定名。Redis也不例外。</p><p><img src="https://img-blog.csdnimg.cn/20200513214531573.png" alt="在这里插入图片描述"></p><p>那么就一定还存在一个RedisProperties类</p><p><img src="https://img-blog.csdnimg.cn/20200513214554661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>之前我们说SpringBoot2.x后默认使用Lettuce来替换Jedis，现在我们就能来验证了。</p><p>先看Jedis:</p><p><img src="https://img-blog.csdnimg.cn/20200513214607475.png" alt="在这里插入图片描述"></p><p>@ConditionalOnClass注解中有两个类是默认不存在的，所以Jedis是无法生效的</p><p>然后再看Lettuce：</p><p><img src="https://img-blog.csdnimg.cn/20200513214618179.png" alt="在这里插入图片描述"></p><p>完美生效。</p><p>现在我们回到RedisAutoConfiguratio</p><p><img src="https://img-blog.csdnimg.cn/2020051321462777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="img"></p><p>只有两个简单的Bean</p><ul><li><strong>RedisTemplate</strong></li><li><strong>StringRedisTemplate</strong></li></ul><p>当看到xxTemplate时可以对比RestTemplat、SqlSessionTemplate,通过使用这些Template来间接操作组件。那么这俩也不会例外。分别用于操作Redis和Redis中的String数据类型。</p><p>在RedisTemplate上也有一个条件注解，说明我们是可以对其进行定制化的</p><p>说完这些，我们需要知道如何编写配置文件然后连接Redis，就需要阅读RedisProperties</p><p><img src="https://img-blog.csdnimg.cn/20200513214638238.png" alt="在这里插入图片描述"></p><p>这是一些基本的配置属性。</p><p><img src="https://img-blog.csdnimg.cn/20200513214649380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>还有一些连接池相关的配置。注意使用时一定使用Lettuce的连接池。</p><p><img src="https://img-blog.csdnimg.cn/20200513214700372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li><p>编写配置文件</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置redisspring.redis.host=39.99.xxx.xxspring.redis.port=6379</span></span><br></pre></td></tr></table></figure></li><li><p>使用RedisTemplate</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTestclass</span> Redis02SpringbootApplicationTests &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> RedisTemplate redisTemplate;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;        <span class="comment">// redisTemplate 操作不同的数据类型，api和我们的指令是一样的        // opsForValue 操作字符串 类似String        // opsForList 操作List 类似List        // opsForHah        // 除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务和基本的CRUD        // 获取连接对象        //RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();        //connection.flushDb();        //connection.flushAll();        redisTemplate.opsForValue().set(&quot;mykey&quot;,&quot;kuangshen&quot;);        System.out.println(redisTemplate.opsForValue().get(&quot;mykey&quot;));    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>测试结果</p><p><strong>此时我们回到Redis查看数据时候，惊奇发现全是乱码，可是程序中可以正常输出：</strong></p><p><img src="https://img-blog.csdnimg.cn/20200513214734520.png" alt="在这里插入图片描述"></p><p> 这时候就关系到存储对象的序列化问题，在网络中传输的对象也是一样需要序列化，否者就全是乱码。</p><p>我们转到看那个默认的RedisTemplate内部什么样子：</p><p><img src="https://img-blog.csdnimg.cn/20200513214746506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在最开始就能看到几个关于序列化的参数。</p><p>默认的序列化器是采用JDK序列化器</p><p><img src="https://img-blog.csdnimg.cn/20200513214757247.png" alt="在这里插入图片描述"></p><p>而默认的RedisTemplate中的所有序列化器都是使用这个序列化器：</p><p><img src="https://img-blog.csdnimg.cn/20200513214809494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>后续我们定制RedisTemplate就可以对其进行修改。</p><p><code>RedisSerializer</code>提供了多种序列化方案：</p><ul><li><p>直接调用RedisSerializer的静态方法来返回序列化器，然后set</p><p><img src="https://img-blog.csdnimg.cn/20200513214818682.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>自己new 相应的实现类，然后set</p><p><img src="https://img-blog.csdnimg.cn/20200513214827233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul></li><li><p><strong>定制RedisTemplate的模板：</strong></p><p>我们创建一个Bean加入容器，就会触发RedisTemplate上的条件注解使默认的RedisTemplate失效。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configurationpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;   <span class="meta">@Bean</span>    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;        <span class="comment">// 将template 泛型设置为 &lt;String, Object&gt;        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate();        // 连接工厂，不必修改        template.setConnectionFactory(redisConnectionFactory);        /*         * 序列化设置         */        // key、hash的key 采用 String序列化方式        template.setKeySerializer(RedisSerializer.string());        template.setHashKeySerializer(RedisSerializer.string());        // value、hash的value 采用 Jackson 序列化方式        template.setValueSerializer(RedisSerializer.json());        template.setHashValueSerializer(RedisSerializer.json());        template.afterPropertiesSet();                return template;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>这样一来，只要实体类进行了序列化，我们存什么都不会有乱码的担忧了。</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oc8kJP08-1597890996523)(狂神说 Redis.assets/image-20200817175638086.png)]</p></li></ol><h2 id="八、自定义Redis工具类"><a href="#八、自定义Redis工具类" class="headerlink" title="八、自定义Redis工具类"></a>八、自定义Redis工具类</h2><p>使用RedisTemplate需要频繁调用<code>.opForxxx</code>然后才能进行对应的操作，这样使用起来代码效率低下，工作中一般不会这样使用，而是将这些常用的公共API抽取出来封装成为一个工具类，然后直接使用工具类来间接操作Redis,不但效率高并且易用。</p><p>工具类参考博客：</p><p><a href="https://www.cnblogs.com/zeng1994/p/03303c805731afc9aa9c60dbbd32a323.html">https://www.cnblogs.com/zeng1994/p/03303c805731afc9aa9c60dbbd32a323.html</a></p><p><a href="https://www.cnblogs.com/zhzhlong/p/11434284.html">https://www.cnblogs.com/zhzhlong/p/11434284.html</a></p><h2 id="九、Redis-conf"><a href="#九、Redis-conf" class="headerlink" title="九、Redis.conf"></a>九、Redis.conf</h2><blockquote><p>容量单位不区分大小写，G和GB有区别</p></blockquote><p><img src="https://img-blog.csdnimg.cn/2020051321485460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="img"></p><blockquote><p>可以使用 include 组合多个配置问题</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200513214902552.png" alt="在这里插入图片描述"></p><blockquote><p>网络配置</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200513214912813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>日志输出级别</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200513214923678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="img"></p><blockquote><p>日志输出文件</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200513214933713.png" alt="在这里插入图片描述"></p><blockquote><p>持久化规则</p></blockquote><p>由于Redis是基于内存的数据库，需要将数据由内存持久化到文件中</p><p>持久化方式：</p><ul><li>RDB</li><li>AOF</li></ul><p><img src="https://img-blog.csdnimg.cn/20200513214944964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>RDB文件相关</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200513214955679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200513215006207.png" alt="在这里插入图片描述"></p><blockquote><p>主从复制</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200513215016371.png" alt="在这里插入图片描述"></p><blockquote><p>Security模块中进行密码设置</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200513215026143.png" alt="在这里插入图片描述"></p><blockquote><p>客户端连接相关</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">maxclients 10000  最大客户端数量</span><br><span class="line">maxmemory &lt;bytes&gt; 最大内存限制</span><br><span class="line">maxmemory-policy noeviction <span class="comment"># 内存达到限制值的处理策略</span></span><br></pre></td></tr></table></figure><p>redis 中的<strong>默认</strong>的过期策略是 <strong>volatile-lru</strong> 。</p><p><strong>设置方式</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">config <span class="built_in">set</span> maxmemory-policy volatile-lru </span><br><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="maxmemory-policy-六种方式"><a href="#maxmemory-policy-六种方式" class="headerlink" title="maxmemory-policy 六种方式"></a><strong>maxmemory-policy 六种方式</strong></h4><p><strong>1、volatile-lru：</strong>只对设置了过期时间的key进行LRU（默认值）</p><p><strong>2、allkeys-lru ：</strong> 删除lru算法的key</p><p><strong>3、volatile-random：</strong>随机删除即将过期key</p><p><strong>4、allkeys-random：</strong>随机删除</p><p><strong>5、volatile-ttl ：</strong> 删除即将过期的</p><p><strong>6、noeviction ：</strong> 永不过期，返回错误</p><blockquote><p>AOF相关部分</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200513215037918.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200513215047999.png" alt="在这里插入图片描述"></p><h2 id="十、持久化—RDB"><a href="#十、持久化—RDB" class="headerlink" title="十、持久化—RDB"></a>十、持久化—RDB</h2><p>RDB：Redis Databases</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-C0mm1D4A-1597890996524)(狂神说 Redis.assets/image-20200818122236614.png)]</p><h3 id="什么是RDB"><a href="#什么是RDB" class="headerlink" title="什么是RDB"></a>什么是RDB</h3><hr><p>在指定时间间隔后，将内存中的数据集快照写入数据库 ；在恢复时候，直接读取快照文件，进行数据的恢复 ；</p><p><img src="https://img-blog.csdnimg.cn/20200513215126515.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。文件名可以在配置文件中进行自定义。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><hr><p>在进行 <strong><code>RDB</code></strong> 的时候，**<code>redis</code>** 的主线程是不会做 <strong><code>io</code></strong> 操作的，主线程会 <strong><code>fork</code></strong> 一个子线程来完成该操作；</p><ol><li>Redis 调用forks。同时拥有父进程和子进程。</li><li>子进程将数据集写入到一个临时 RDB 文件中。</li><li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li></ol><p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求。)</p><p><img src="https://img-blog.csdnimg.cn/20200513215141519.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h3><hr><ol><li>save的规则满足的情况下，会自动触发rdb原则</li><li>执行flushall命令，也会触发我们的rdb原则</li><li>退出redis，也会自动产生rdb文件</li></ol><h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><p>使用 <code>save</code> 命令，会立刻对当前内存中的数据进行持久化 ,但是会阻塞，也就是不接受其他操作了；</p><blockquote><p>由于 <code>save</code> 命令是同步命令，会占用Redis的主进程。若Redis数据非常多时，<code>save</code>命令执行速度会非常慢，阻塞所有客户端的请求。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200513215150892.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="flushall命令"><a href="#flushall命令" class="headerlink" title="flushall命令"></a>flushall命令</h4><p><code>flushall</code> 命令也   会触发持久化 ；</p><h4 id="触发持久化规则"><a href="#触发持久化规则" class="headerlink" title="触发持久化规则"></a>触发持久化规则</h4><p>满足配置条件中的触发条件 ；</p><blockquote><p>可以通过配置文件对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动进行数据集保存操作。</p><p><img src="https://img-blog.csdnimg.cn/20200513215205970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200513215220858.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="bgsave"><a href="#bgsave" class="headerlink" title="bgsave"></a>bgsave</h4><p><code>bgsave</code> 是异步进行，进行持久化的时候，<code>redis</code> 还可以将继续响应客户端请求 ；</p><p><img src="https://img-blog.csdnimg.cn/2020051321523151.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>bgsave和save对比</strong></p><table><thead><tr><th>命令</th><th>save</th><th>bgsave</th></tr></thead><tbody><tr><td>IO类型</td><td>==同步==</td><td>==异步==</td></tr><tr><td>阻塞？</td><td>是</td><td>是（阻塞发生在fock()，通常非常快）</td></tr><tr><td>复杂度</td><td>O(n)</td><td>O(n)</td></tr><tr><td>优点</td><td>不会消耗额外的内存</td><td>不阻塞客户端命令</td></tr><tr><td>缺点</td><td>阻塞客户端命令</td><td>需要fock子进程，消耗内存</td></tr></tbody></table><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ol><li>适合大规模的数据恢复</li><li>对数据的完整性要求不高</li></ol><p><strong>缺点：</strong></p><ol><li>需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了。</li><li>fork进程的时候，会占用一定的内容空间。</li></ol><h2 id="十一、持久化AOF"><a href="#十一、持久化AOF" class="headerlink" title="十一、持久化AOF"></a>十一、持久化AOF</h2><p><strong>Append Only File</strong></p><p>将我们所有的命令都记录下来，history，恢复的时候就把这个文件全部再执行一遍</p><p><img src="/images/redis-kuang/image-20210831213900233.png" alt="image-20210831213900233"></p><blockquote><p>以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p></blockquote><h3 id="什么是AOF"><a href="#什么是AOF" class="headerlink" title="什么是AOF"></a>什么是AOF</h3><p> <img src="https://img2020.cnblogs.com/blog/2000608/202004/2000608-20200421153007546-585324670.png" alt="img"></p><p>快照功能（RDB）并不是非常耐久（durable)： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、以及未保存到快照中的那些数据。 从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。</p><p>如果要使用AOF，需要修改配置文件：</p><p><img src="https://img-blog.csdnimg.cn/20200513215247113.png" alt="在这里插入图片描述"></p><p><code>appendonly no yes</code>则表示启用AOF</p><p>默认是不开启的，我们需要手动配置，然后重启redis，就可以生效了！</p><p>如果这个aof文件有错位，这时候redis是启动不起来的，我需要修改这个aof文件</p><p>redis给我们提供了一个工具<code>redis-check-aof --fix</code></p><blockquote><p>优点和缺点</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">appendonly yes  <span class="comment"># 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分的情况下，rdb完全够用appendfilename &quot;appendonly.aof&quot;# 判断是否需要将 AOF 缓存区中的内容写入和同步到 AOF 文件中# appendfsync always # 每次修改都会sync 消耗性能appendfsync everysec # 每秒执行一次 sync 可能会丢失这一秒的数据# appendfsync no # 不执行 sync ,这时候操作系统自己同步数据，速度最快,Redis 在每一个事件循环都要将 AOF 缓冲区中的所有内容写入到 AOF 文件。而 AOF 文件的同步由操作系统控制。这种模式下速度最快，但是同步的时间间隔较长，出现故障时可能会丢失较多数据。 </span></span><br></pre></td></tr></table></figure><p><strong><img src="https://img2020.cnblogs.com/blog/2000608/202004/2000608-20200421154006686-2034814519.png" alt="img">优点</strong></p><ol><li>每一次修改都会同步，文件的完整性会更加好</li><li>没秒同步一次，可能会丢失一秒的数据</li><li>从不同步，效率最高</li></ol><p><strong>缺点</strong></p><ol><li>相对于数据文件来说，aof远远大于rdb，修复速度比rdb慢！</li><li>Aof运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化</li></ol><h2 id="redis的重写-Rewrite-机制"><a href="#redis的重写-Rewrite-机制" class="headerlink" title="redis的重写(Rewrite)机制"></a><strong>redis的重写(Rewrite)机制</strong></h2><h4 id="4-1重写机制介绍"><a href="#4-1重写机制介绍" class="headerlink" title="4.1重写机制介绍"></a><strong>4.1重写机制介绍</strong></h4><p>   AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了<strong>重写机制,</strong> 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof</p><h4 id="4-2重写的原理"><a href="#4-2重写的原理" class="headerlink" title="4.2重写的原理"></a><strong>4.2重写的原理</strong></h4><p>  <strong>AOF文件持续增长而过大时，</strong>会fork出一条新进程来将文件重写**(也是先写临时文件最后再rename)，<strong>遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写</strong>了一个新的aof文件，这点和快照有点类似**</p><h4 id="4-3重写的三种触发机制"><a href="#4-3重写的三种触发机制" class="headerlink" title="4.3重写的三种触发机制"></a><strong>4.3重写的三种触发机制</strong></h4><pre><code> 1.**手动调用 bgrewriteaof 命令**，如果当前有正在运行的 rewrite 子进程，则本次rewrite 会推迟执行，否则，直接触发一次 rewrite。 2.**通过配置指令手动开启 AOF 功能**，如果没有 RDB 子进程的情况下，会触发一次 rewrite，**将当前数据库中的数据写入 rewrite 文件。** 3.在 Redis 定时器中，如果有需要退出执行的 rewrite 并且没有正在运行的 RDB 或者 rewrite 子进程时，触发一次或者 AOF 文件大小已经到达配置的 rewrite 条件也会自动触发一次。4.**Redis会记录上次重写时的AOF大小**，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M是也会触发</code></pre><h2 id="十二、RDB和AOP选择"><a href="#十二、RDB和AOP选择" class="headerlink" title="十二、RDB和AOP选择"></a>十二、RDB和AOP选择</h2><h3 id="RDB-和-AOF-对比"><a href="#RDB-和-AOF-对比" class="headerlink" title="RDB 和 AOF 对比"></a>RDB 和 AOF 对比</h3><table><thead><tr><th></th><th>RDB</th><th><strong>AOF</strong></th></tr></thead><tbody><tr><td>启动优先级</td><td>低</td><td>高</td></tr><tr><td>体积</td><td>小</td><td>大 -&gt; 重写</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>丢数据</td><td>根据策略决定</td></tr><tr><td></td><td></td><td>更加完整，持续的IO</td></tr></tbody></table><h3 id="如何选择使用哪种持久化方式？"><a href="#如何选择使用哪种持久化方式？" class="headerlink" title="如何选择使用哪种持久化方式？"></a>如何选择使用哪种持久化方式？</h3><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</p><p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p><p>有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。</p><h2 id="十三、Redis发布与订阅"><a href="#十三、Redis发布与订阅" class="headerlink" title="十三、Redis发布与订阅"></a>十三、Redis发布与订阅</h2><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p><p><img src="/images/redis-kuang/image-20210831220653321.png" alt="image-20210831220653321"></p><p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p><p><img src="https://img-blog.csdnimg.cn/20200513215523258.png" alt="在这里插入图片描述"></p><p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客 户端：</p><p><img src="https://img-blog.csdnimg.cn/2020051321553483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>PSUBSCRIBE pattern [pattern..]</code></td><td>订阅一个或多个符合给定模式的频道。</td></tr><tr><td><code>PUNSUBSCRIBE pattern [pattern..]</code></td><td>退订一个或多个符合给定模式的频道。</td></tr><tr><td><code>PUBSUB subcommand [argument[argument]]</code></td><td>查看订阅与发布系统状态。</td></tr><tr><td>==<code>PUBLISH channel message</code>==</td><td>向指定频道发布消息</td></tr><tr><td>==<code>SUBSCRIBE channel [channel..]</code>==</td><td>订阅给定的一个或多个频道。</td></tr><tr><td><code>SUBSCRIBE channel [channel..]</code></td><td>退订一个或多个频道</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">------------订阅端----------------------127.0.0.1:6379&gt; SUBSCRIBE sakura <span class="comment"># 订阅sakura频道Reading messages... (press Ctrl-C to quit) # 等待接收消息1) &quot;subscribe&quot; # 订阅成功的消息2) &quot;sakura&quot;3) (integer) 11) &quot;message&quot; # 接收到来自sakura频道的消息 &quot;hello world&quot;2) &quot;sakura&quot;3) &quot;hello world&quot;1) &quot;message&quot; # 接收到来自sakura频道的消息 &quot;hello i am sakura&quot;2) &quot;sakura&quot;3) &quot;hello i am sakura&quot;--------------消息发布端-------------------127.0.0.1:6379&gt; PUBLISH sakura &quot;hello world&quot; # 发布消息到sakura频道(integer) 1127.0.0.1:6379&gt; PUBLISH sakura &quot;hello i am sakura&quot; # 发布消息(integer) 1-----------------查看活跃的频道------------127.0.0.1:6379&gt; PUBSUB channels1) &quot;sakura&quot;</span></span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>每个 Redis 服务器进程都维持着一个表示服务器状态的 redis.h/redisServer 结构， 结构的 pubsub_channels 属性是一个==字典==， 这个字典就用于保存订阅频道的信息，其中，字典的键为正在被订阅的频道， 而字典的值则是一个==链表==， 链表中保存了所有订阅这个频道的客户端。</p><p><img src="https://img-blog.csdnimg.cn/2020051321554964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>客户端订阅，就被链接到对应频道的链表的尾部，退订则就是将客户端节点从链表中移除。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>如果一个客户端订阅了频道，但自己读取消息的速度却不够快的话，那么==不断积压的消息==会使redis输出缓冲区的体积变得越来越大，这可能使得redis本身的速度变慢，甚至直接崩溃。</li><li>这和数据传输可靠性有关，如果在==订阅方断线==，那么他将会丢失所有在断线期间发布者发布的消息。</li></ol><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol><li>消息订阅：公众号订阅，微博关注等等（起始更多是使用消息队列来进行实现）</li><li>多人在线聊天室。</li></ol><p>稍微复杂的场景，我们就会使用消息中间件MQ处理。</p><h2 id="十四、Redis主从复制"><a href="#十四、Redis主从复制" class="headerlink" title="十四、Redis主从复制"></a>十四、Redis主从复制</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p> 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader）,后者称为从节点（Slave/Follower）， 数据的复制是单向的！只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。</p><p>默认情况下，每台Redis服务器都是主节点，一个主节点可以有0个或者多个从节点，但每个从节点只能由一个主节点。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。</li><li>故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式</li><li>负载均衡：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量。</li><li>高可用基石：主从复制还是哨兵和集群能够实施的基础。</li></ol><h3 id="为什么使用集群"><a href="#为什么使用集群" class="headerlink" title="为什么使用集群"></a>为什么使用集群</h3><ol><li>单台服务器难以负载大量的请求</li><li>单台服务器故障率高，系统崩坏概率大</li><li>单台服务器内存容量有限。</li></ol><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>我们在讲解配置文件的时候，注意到有一个<code>replication</code>模块 (见Redis.conf中第8条)</p><p>查看当前库的信息：<code>info replication</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication<span class="comment"># Replicationrole:master # 角色connected_slaves:0 # 从机数量master_replid:3b54deef5b7b7b7f7dd8acefa23be48879b4fcffmaster_replid2:0000000000000000000000000000000000000000master_repl_offset:0second_repl_offset:-1repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0</span></span><br></pre></td></tr></table></figure><p>既然需要启动多个服务，就需要多个配置文件。每个配置文件对应修改以下信息：</p><ul><li>端口号</li><li>pid文件名</li><li>日志文件名</li><li>rdb文件名</li></ul><p>启动单机多服务集群：</p><p><img src="https://img-blog.csdnimg.cn/20200513215610163.png" alt="在这里插入图片描述"></p><h3 id="一主二从配置"><a href="#一主二从配置" class="headerlink" title="一主二从配置"></a>一主二从配置</h3><p>==默认情况下，每台Redis服务器都是主节点；==我们一般情况下只用配置从机就好了！</p><p>认老大！一主（79）二从（80，81）</p><p>使用<code>SLAVEOF host port</code>就可以为从机配置主机了。</p><p><img src="https://img-blog.csdnimg.cn/20200513215637483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>然后主机上也能看到从机的状态：</p><p><img src="https://img-blog.csdnimg.cn/20200513215645778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>我们这里是使用命令搭建，是暂时的，==真实开发中应该在从机的配置文件中进行配置，==这样的话是永久的。</p><p><img src="https://img-blog.csdnimg.cn/20200513215654634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3><ol><li><p>从机只能读，不能写，主机可读可写但是多用于写。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6381&gt; <span class="built_in">set</span> name sakura <span class="comment"># 从机6381写入失败(error) READONLY You can&#x27;t write against a read only replica.127.0.0.1:6380&gt; set name sakura # 从机6380写入失败(error) READONLY You can&#x27;t write against a read only replica.127.0.0.1:6379&gt; set name sakuraOK127.0.0.1:6379&gt; get name&quot;sakura&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>当==主机断电宕机==后，默认情况下从机的角色不会发生变化 ，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状。</p></li><li><p>当==从机断电宕机==后，若不是使用配置文件配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据。这里就要提到一个同步原理。</p></li></ol><p><img src="/images/redis-kuang/image-20210901084036049.png" alt="image-20210901084036049"></p><ol><li><p>第二条中提到，默认情况下，主机故障后，不会出现新的主机，有两种方式可以产生新的主机：</p><ul><li>从机手动执行命令<code>slaveof no one</code>,这样执行以后从机会独立出来成为一个主机</li><li>使用哨兵模式（自动选举）</li></ul></li></ol><blockquote><p>如果没有老大了，这个时候能不能选择出来一个老大呢？手动！</p></blockquote><p>如果主机断开了连接，我们可以使用<code>SLAVEOF no one</code>让自己变成主机！其他的节点就可以手动连接到最新的主节点（手动）！如果这个时候老大修复了，那么久重新连接！</p><h2 id="十五、哨兵模式"><a href="#十五、哨兵模式" class="headerlink" title="十五、哨兵模式"></a>十五、哨兵模式</h2><p>更多信息参考博客：<a href="https://www.jianshu.com/p/06ab9daf921d">https://www.jianshu.com/p/06ab9daf921d</a></p><p><strong>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。</strong>这不是一种推荐的方式，更多时候，我们优先考虑<strong>哨兵模式</strong>。</p><p>单机单个哨兵</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-2ENYVAPp-1597890996527)(狂神说 Redis.assets/image-20200818233231154.png)]</p><p>哨兵的作用：</p><ul><li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li><li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过<strong>发布订阅模式</strong>通知其他的从服务器，修改配置文件，让它们切换主机。</li></ul><p>多哨兵模式</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ga1RyfVc-1597890996528)(狂神说 Redis.assets/image-20200818233316478.png)]</p><p>哨兵的核心配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure><ul><li>数字1表示 ：当一个哨兵主观认为主机断开，就可以客观认为主机故障，然后开始选举新的主机。</li></ul><blockquote><p>测试</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-sentinel xxx&#x2F;sentinel.conf</span><br></pre></td></tr></table></figure><p>成功启动哨兵模式</p><p><img src="https://img-blog.csdnimg.cn/20200513215752444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>此时哨兵监视着我们的主机6379，当我们断开主机后：</p><p><img src="https://img-blog.csdnimg.cn/20200513215806972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>哨兵模式优缺点</p></blockquote><p><strong>优点：</strong></p><ol><li>哨兵集群，基于主从复制模式，所有主从复制的优点，它都有</li><li>主从可以切换，故障可以转移，系统的可用性更好</li><li>哨兵模式是主从模式的升级，手动到自动，更加健壮</li></ol><p><strong>缺点：</strong></p><ol><li>Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦</li><li>实现哨兵模式的配置其实是很麻烦的，里面有很多配置项</li></ol><blockquote><p>哨兵模式的全部配置</p></blockquote><p>完整的哨兵模式配置文件 sentinel.conf</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Example sentinel.conf # 哨兵sentinel实例运行的端口 默认26379port 26379 # 哨兵sentinel的工作目录dir /tmp # 哨兵sentinel监控的redis主节点的 ip port # master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。# quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了# sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;sentinel monitor mymaster 127.0.0.1 6379 1 # 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码# 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码# sentinel auth-pass &lt;master-name&gt; &lt;password&gt;sentinel auth-pass mymaster MySUPER--secret-0123passw0rd  # 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒# sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;sentinel down-after-milliseconds mymaster 30000 # 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。# sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;sentinel parallel-syncs mymaster 1   # 故障转移的超时时间 failover-timeout 可以用在以下这些方面： #1. 同一个sentinel对同一个master两次failover之间的间隔时间。#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。#3.当想要取消一个正在进行的failover所需要的时间。  #4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了# 默认三分钟# sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;sentinel failover-timeout mymaster 180000 # SCRIPTS EXECUTION #配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。#对于脚本的运行结果有以下规则：#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。 #通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，#这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，#一个是事件的类型，#一个是事件的描述。#如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。#通知脚本# sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;  sentinel notification-script mymaster /var/redis/notify.sh # 客户端重新配置主节点参数脚本# 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。# 以下参数将会在调用脚本时传给脚本:# &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;# 目前&lt;state&gt;总是“failover”,# &lt;role&gt;是“leader”或者“observer”中的一个。 # 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的# 这个脚本应该是通用的，能被多次调用，不是针对性的。# sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span></span><br></pre></td></tr></table></figure><h2 id="十六、缓存穿透与雪崩"><a href="#十六、缓存穿透与雪崩" class="headerlink" title="十六、缓存穿透与雪崩"></a>十六、缓存穿透与雪崩</h2><h3 id="缓存穿透（查不到）"><a href="#缓存穿透（查不到）" class="headerlink" title="缓存穿透（查不到）"></a>缓存穿透（查不到）</h3><blockquote><p>概念</p></blockquote><p>在默认情况下，用户请求数据时，会先在缓存(Redis)中查找，若没找到即缓存未命中，再在数据库中进行查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景）缓存都没有命中的话，就会全部转移到数据库上，造成数据库极大的压力，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击。</p><blockquote><p>解决方案</p></blockquote><p><strong>布隆过滤器</strong></p><p>对所有可能查询的参数以Hash的形式存储，以便快速确定是否存在这个值，在控制层先进行拦截校验，校验不通过直接打回，减轻了存储系统的压力。</p><p><img src="https://img-blog.csdnimg.cn/20200513215824722.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>缓存空对象</strong></p><p>一次请求若在缓存和数据库中都没找到，就在缓存中方一个空对象用于处理后续这个请求。</p><p><img src="https://img-blog.csdnimg.cn/20200513215836317.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p> 这样做有一个缺陷：存储空对象也需要空间，大量的空对象会耗费一定的空间，存储效率并不高。解决这个缺陷的方式就是设置较短过期时间</p><p>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</p><h3 id="缓存击穿（量太大，缓存过期）"><a href="#缓存击穿（量太大，缓存过期）" class="headerlink" title="缓存击穿（量太大，缓存过期）"></a>缓存击穿（量太大，缓存过期）</h3><blockquote><p>概念</p></blockquote><p> 相较于缓存穿透，缓存击穿的目的性更强，一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。</p><p> 比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。</p><blockquote><p>解决方案</p></blockquote><ol><li><p><strong>设置热点数据永不过期</strong></p><p>这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间。</p></li><li><p><strong>加互斥锁(分布式锁)</strong></p><p>在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。</p></li></ol><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><blockquote><p>概念</p></blockquote><p>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p><p><img src="https://img-blog.csdnimg.cn/20200513215850428.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>解决方案</p></blockquote><ul><li><p>redis高可用</p><p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群</p></li><li><p>限流降级</p><p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p></li><li><p>数据预热</p><p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;狂神说Redis笔记&lt;/p&gt;</summary>
    
    
    
    <category term="Study" scheme="https://memorykk.cn/categories/Study/"/>
    
    
    <category term="Redis" scheme="https://memorykk.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://memorykk.cn/Mysql-index.html"/>
    <id>https://memorykk.cn/Mysql-index.html</id>
    <published>2021-08-27T02:23:12.000Z</published>
    <updated>2021-08-27T02:21:14.253Z</updated>
    
    <content type="html"><![CDATA[<p>Mysql索引+事务</p><span id="more"></span><p>索引是帮助MySQL高效获取数据的排好序的数据结构，将无序的数据编程有序的查询。</p><ul><li>二叉树：单链</li><li>红黑树：二叉平衡树，提高一倍。旋转成本，树的高度可能会很高，效率很差</li><li>Hash表：</li><li>B-Tree：改进红黑树，使高度尽可能小，节点横向扩展，一个存储更多的节点 。</li></ul><p>索引数据分布在叶子、非叶子中，索引不重复，索引从左至右递增。</p><p><img src="/images/Mysql_index/image-20210825202125656.png" alt="image-20210825202125656"></p><ul><li>B+Tree：叶子节点指针连接，非叶子节点不存储数据，叶子节点包含所有索引，非叶子节点包含一部分索引，冗余索引（只需要冗余主键），数据放在叶子节点。</li></ul><p>双向链表便于大于、小于的索引查找</p><p><img src="/images/Mysql_index/image-20210825202004251.png" alt="image-20210825202004251"></p><p>树的高度越小越好，一个节点上存储更多索引（16KB），所以从磁盘一次加载的数据多，二分查找速度快</p><p>B+树非叶子节点不存储数据，也就能放更多的索引，存储量大，B树节点有数据就不行。所以决定树的高度：非叶子节点中能放的索引数量。</p><p>三层即可存储2000w+索引，在mysql启动时将上层索引加载到内存中，索引取数据只需要大约一次IO。</p><p><img src="/images/Mysql_index/image-20210825203138095.png" alt="image-20210825203138095"></p><p>.frm 表结构</p><p>.MYD 表数据</p><p>.MYI 表索引</p><p>myisam查询过程：条件是否是索引，是则遍历myiB+树，根据地址找到myd磁盘地址。</p><p>.frm 表结构</p><p>.ibd 数据+索引，表数据也是按照B+组织</p><p>innodb推荐建立主键：自增主键：</p><ul><li>聚集索引：叶节点包含了完整的数据记录，数据和索引聚集在一起，innodb主键索引。</li></ul><p>innodb非主键索引（回表、二次）：叶子节点存储主键值：一致性和节省存储空间。</p><ul><li>非聚集索引：索引和数据分开存储。（myisam）效率不如聚集，回表：二次索引（拿到索引再去磁盘遍历索引）</li></ul><p><img src="/images/Mysql_index/image-20210825204526349.png" alt="image-20210825204526349"></p><p>必须要建主键？Mysql会使用主键构建B+树，没有主键Mysql会找一个不重复的列来构建，找不到就生成一个隐藏列rowid来构建，所以节省空间。</p><p>为什么不能用UUID？UUID非整型非自增，比较大小效率慢，所以推荐整型。B+范围查找只需两次，非自增只向后插，不用分页，分裂次数少，维护B+结构成本小，推荐自增。</p><p>索引就是目录，用空间换时间，B+的节点就是16KB的页，查找就是遍历页上的有序数据，一个页上有多个节点，但是页越来越长，形成链表效率会降低，所以构建目录的目录，即树。</p><p>mysql运行时间长之后，缓存加载到内存越来越大，</p><ul><li>Hash索引：</li></ul><p>一次计算。不支持范围查询，hash冲突问题</p><ul><li>联合索引：</li></ul><p>多个字段，按先后顺序，谁先排好序就以谁的排序为准，后面的忽略。</p><p><img src="/images/Mysql_index/image-20210825211720812.png" alt="image-20210825211720812"></p><p>建立联合索引需要重新构建B+树，所以会和主键索引构建的B+树大量冗余数据，资源浪费，所以可以使联合索引树叶子节点不存储数据，只存储主键，然后回表，是个折中的办法。</p><p><img src="/images/Mysql_index/image-20210826090232766.png" alt="image-20210826090232766"></p><p>主键索引：</p><p><img src="/images/Mysql_index/image-20210826094000399.png" alt="image-20210826094000399"></p><p>select * from t where b&gt;1;(bcd联合索引)</p><p><strong>选择索引：</strong>利用联合索引可以找到数据，但是查找的是*全部数据，叶子节点只有bcd三列数据，所以需要7次回表查出全部数据，全表扫描走主键只需要四次，更快，所以实际执行的是全表扫描，非联合索引。</p><ul><li><p>如果是select b,c,d,a；那么也能走联合索引，因为想要的四个字段都在一棵树上，叶子是主键a</p></li><li><p>select b;联合索引的叶子能够找出满足要求的数据，就不用走全表扫描。</p></li><li><p>同样地，如果联合索引回表次数&lt;全表扫描加载页次数，也不用走全扫描。</p></li><li><p>select b from t;没有where条件也能走联合索引，主键索引和联合索引都能找到所需数据，并且如果二者的页数相等，但是因为联合索引叶子节点存储主键，主键索引叶子存储数据，所以联合索引的一页比主键索引的一页存储的数据更多，虽然不完整，只有bcd，但是查询我们只要b就够了，所以不走主键。</p></li><li><p>select * from t order by b,c,d;走bcd不用排序但需要回表八次，全表扫描需要四次，需要排序。因为只有8条数据，排序很快，所以走的是全表扫描。如果select b不需要回表，走的是联合索引。</p></li></ul><p>最左前缀法则：查询从最左前列开始并且二不能跳过中间。也就是联合索引触发必须从包含第一个列的条件开始。</p><p>原理：比如age=30，如果不考虑name是否有序而使用age索引的前提是前面的name相同，那么就应该理解为同一列的节点的age是有序的，但是不是有序的，需要全表扫描（从左向右逐个检查）。判断索引是否会用到的原则，当前列是否有序。</p><p>Mysql中类型不匹配时，字符转数字，数字型字符会自动类型转成数字，非数字型字符会转成0，即：</p><p>select ‘a’=0;  true</p><p>select ‘b12’=0;  true</p><p>select ‘1’=0; false </p><p>隐式的类型转换可能会导致索引失效。</p><p>Mysql5.8之前仅支持升序索引，5.7支持语法层面的降序，但是索引组织仍然是升序的。</p><p><strong>B树和B+树的区别</strong></p><p>B树每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为null。</p><p><img src="/images/Mysql_index/20170920132504569-1630027523648.png" alt="20170920132504569"></p><p>B+树只有叶子节点存储data，叶子节点包含了这棵树的所有键值，叶子节点不存储指针。</p><p><img src="/images/Mysql_index/20170920132523536.png" alt="20170920132523536"></p><p>MySql索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指<br>针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。  </p><p><img src="/images/Mysql_index/image-20210827092732211.png" alt="image-20210827092732211"></p><p>原因有很多，最主要的是这棵树矮胖，呵呵。一般来说，索引很大，往往以索引文件的形式存储的磁盘上，索引查找时产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的时间复杂度。树高度越小，I/O次数越少。 </p><p>那为什么是B+树而不是B树呢，因为它内节点不存储data，这样一个节点就可以存储更多的key。</p><p><strong>索引类型对数据库的性能影响</strong></p><p><img src="/images/Mysql_index/image-20210826161730787.png" alt="image-20210826161730787"></p><p>普通可重复，唯一不可重复，唯一可以有null，可以有多个，主键不能有null，且只能有一个。全文索引like关键字。</p><p><strong>聚簇 非聚簇</strong></p><p><img src="/images/Mysql_index/image-20210826163500181.png"></p><p><img src="/images/Mysql_index/image-20210826163536434.png" alt="image-20210826163536434"></p><p>innodb仅叶子节点将索引数据放在一起。</p><p>表中除了主键索引的其他索引都是辅助索引，其叶子节点存储地十主键，类非聚簇索引，但存储的不是行地址，而是主键，所以非聚簇索引都是辅助索引。</p><p><strong>索引数据结构的优劣势</strong></p><p><img src="/images/Mysql_index/image-20210826164046114.png" alt="image-20210826164046114"></p><p><img src="/images/Mysql_index/image-20210826164125546.png" alt="image-20210826164125546"></p><p><img src="/images/Mysql_index/image-20210826164153227.png" alt="image-20210826164153227"></p><p><strong>索引的设计原则</strong></p><p><img src="/images/Mysql_index/image-20210826164315221-1629967396390.png" alt="image-20210826164315221"></p><ul><li>适合索引的是where</li><li>使用前缀段短索引</li><li>不能在更新频繁、数据区分度小、重复度高、数据量小的列建索引</li></ul><p><strong>Mysql锁的类型</strong></p><p><img src="/images/Mysql_index/image-20210826164836207.png" alt="image-20210826164836207"></p><p><img src="/images/Mysql_index/image-20210826165201233.png" alt="image-20210826165201233"></p><p><img src="/images/Mysql_index/image-20210826165417928.png" alt="image-20210826165417928"></p><p><img src="/images/Mysql_index/image-20210826170133849.png" alt="image-20210826170133849"></p><p>1 4 5 7，间隙锁锁住234，临建锁锁住1234.</p><p>行锁页锁会出现死锁。</p><p>临建锁next key = 记录锁record + 间隙锁gap，三者都属于行锁。</p><p>意向锁提高了加锁效率。</p><p>innodb默认采用行锁，myisam默认采用表锁。</p><p><strong>Mysql执行计划</strong></p><ul><li><p>id：select的序号，顺序增长，越大优先级越高；</p></li><li><p>select_type：</p><ul><li>simple：简单查询，不包含子查询和union；</li><li>primary：复杂查询中最外层的select；</li><li>subquery：select中的子查询；</li><li>derived：from中的子查询。</li></ul></li><li><p>table：正在访问哪个表</p><ul><li>from有子查询时，drivenN，N代表id=N的查询</li><li>有union时，union1,2，表示参与union的id</li></ul></li><li><p>type：关联类型或访问类型，即MySQL决定<strong>如何查找表中的行</strong>，查找数据行记录的大概范围。<br>依次从最优到最差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL<br>一般来说，得保证查询达到range级别，最好达到ref  </p><ul><li>NULL：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表  </li><li>const：<strong>通过索引一次命中；</strong></li><li>system：表中只有一行记录；</li><li>eq_ref：primary key 或 unique key 索引的所有部分被连接使用 ，最多<strong>只会返回一条</strong>符合条件的记录。<strong>唯一性索引扫描</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> film_actor <span class="keyword">left</span> <span class="keyword">join</span> film <span class="keyword">on</span> film_actor.film_id <span class="operator">=</span> film.id;</span><br></pre></td></tr></table></figure><ul><li>ref：相比 eq_ref，<strong>非唯一性索引扫描</strong>，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。  <strong>和eq_ref都需要回表</strong></li><li>range：<strong>范围扫描</strong>，通常出现在 in(), between ,&gt; ,&lt;, &gt;= 等操作中。使用一个索引来检索给定范围的行。  </li><li>index：<strong>扫描全索引就能拿到结果</strong>，一般是扫描某个二级索引，这种扫描不会从索引树根节点开始快速查找，而是直接对二级索引的叶子节点遍历和扫描，速度还是比较慢的，这种查询一般为使用覆盖索引，二级索引一般比较小，所以这种通常比ALL快一些  </li><li>ALL：即全表扫描，扫描你的聚簇索引的所有叶子节点。通常情况下这需要增加索引来进行优化了  </li></ul></li><li><p>key：显示mysql<strong>实际采用哪个索引</strong>来优化对该表的访问。<br>如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用<br>force index、ignore index ；</p></li><li><p>possible_keys：显示查询<strong>可能使用哪些索引</strong>来查找。<br>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。<br>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果  。</p></li><li><p>key_len：mysql在<strong>索引里使用的字节数</strong>，通过这个值可以算出具体使用了索引中的哪些列，特别是联合索引。  </p><p>索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引  </p></li><li><p>ref：在key列记录的索引中，表查找值所<strong>用到的列或常量</strong>，常见的有：const（等值查询），字段名（例：film.id）  </p></li><li><p>rows：mysql估计要读取并检测的行数，越少越好，注意这个不是结果集里的行数  </p></li><li><p>filtered：读取rows行，返回x行，x/rows 返回百分比</p></li><li><p>Extra：额外信息</p><ul><li>Using index：使用<strong>覆盖</strong>索引 ，性能高</li></ul><p>覆盖索引定义：mysql执行计划explain结果里的key有使用索引，如果select后面查询的字段都可以从这个索引的树中获取，这种情况一般可以说是用到了覆盖索引，extra里一般都有using index；覆盖索引一般针对的是辅助索引，整个查询结果只通过辅助索引就能拿到结果，不需要通过辅助索引树找到主键，再通过主键去主键索引树里获取其它字段值。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> film_id <span class="keyword">from</span> film_actor <span class="keyword">where</span> film_id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>Using where：使用 where 语句来处理结果，并且查询的列<strong>未被索引覆盖</strong>  </li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> actor <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>Using index condition：查询的列<strong>不完全</strong>被索引覆盖，where条件中是一个前导列的范围；</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> film_actor <span class="keyword">where</span> film_id <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>Using temporary：排序、分组时等，mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化  </li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="keyword">distinct</span> name <span class="keyword">from</span> film;</span><br></pre></td></tr></table></figure><ul><li><p>Using filesort：将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一般也是要考虑使用索引来优化的  </p></li><li><p>Select tables optimized away：使用某些聚合函数（比如 max、min）来访问存在索引的某个字段是  </p></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="built_in">min</span>(id) <span class="keyword">from</span> film;</span><br></pre></td></tr></table></figure></li></ul><p><strong>事务的基本特性和隔离级别</strong></p><p>原子性、一致性、隔离性、持久性。</p><p><img src="/images/Mysql_index/image-20210826205502058.png" alt="image-20210826205502058"></p><p>一致性：事务之前id唯一，不能操作之后不唯一了。</p><p><img src="/images/Mysql_index/image-20210826205907242.png" alt="image-20210826205907242"></p><p>readview只针对查询操作，如果在此期间其他事务插入了新数据，就会导致之幻读。配合间隙锁解决。</p><p><img src="/images/Mysql_index/image-20210826210528829.png" alt="image-20210826210528829"></p><p><strong>Mysql主从同步原理</strong></p><p><img src="/images/Mysql_index/image-20210826211212487.png" alt="image-20210826211212487"></p><p><img src="/images/Mysql_index/image-20210826211235973.png" alt="image-20210826211235973"></p><p><img src="/images/Mysql_index/image-20210827101814389.png" alt="image-20210827101814389"></p><p><strong>MyISAM和InnoDB的区别</strong></p><p><img src="/images/Mysql_index/image-20210826211329868.png" alt="image-20210826211329868"></p><p>MYISAM适合查询，InnoDB适合写。</p><hr><p>客户端 - server（连接器 - 查询缓存 - 分析器 - 优化器 - 执行器） - 存储引擎（查询结果，返回结果集） </p><p>Buffer Pool 128MB：查找的结果从磁盘复制到BufferPool，先从pool查，修改先改pool，离散的页数组：</p><ul><li><p>free list：记录空闲的页，便于插入</p></li><li><p>flush list：记录脏页，便于后台线程寻找</p></li><li><p>lru list：pool占满时，最近最久未使用的页被淘汰，头部是新的，尾部是旧的</p></li></ul><p>对于全表扫描，大量数据会将pool换掉。Innodb将lru分为热点区5/8，冷数据区3/8，优先淘汰冷数据区，两次访问到数据的间隔&gt;1s，表示一个正常的频率，转移冷数据-&gt;热数据，全表扫描时间隔小于1s，就不会发生冷替换热的情况。</p><hr><p>脏页刷新丢失：</p><p>1、修改pool产生脏页</p><p>2、生成逻辑redo log（mysql内存中脏页持久化到磁盘需要，挂掉之后重新执行redo恢复） -&gt; log buffer</p><p>3、redo log 持久化（当事务提交时）</p><p>4、bin log 持久化</p><p>5、undo log </p><p>6、修改成功</p><p>redo(log file0,log file1)file满检查点：将log file持久化到磁盘。logfile太小持久化频繁，太大恢复启动慢。</p><p><strong>持久化机制：</strong>不持久化、立即持久、立即刷新到OS缓存而不立即持久化</p><p><img src="/images/Mysql_index/image-20210826145638599.png" alt="image-20210826145638599"></p><p>执行事务生成bin log</p><table><thead><tr><th>redo</th><th>bin log</th></tr></thead><tbody><tr><td>innodb</td><td>mysql级别</td></tr><tr><td>物理的、记录一页的某个位置的数据修改，速度快</td><td>逻辑的sql语句，慢。用于主从复制</td></tr></tbody></table><p>undo log：反向日志，记录修改之前的数据，回滚使用，实现事物的隔离级别。</p><p><strong>double write buffer</strong>（OS中）</p><p>innodb数据页16KB，OS页4KB分四次写入。解决问题：如果中途挂了，就不清楚是写入了还是没写入，即没有原子性，所以出现双写缓存。</p><p>innodb写入双写缓存即认为成功，并产生redo log，成功之后log失效</p><p>刷新一次先写入双写缓存，再写入表空间两部完成。如果第一步挂了 ，这时候可以使用redo log恢复，如果第二部挂了，可以重新从双写缓存拿到完整的数据重新写。</p><p><strong>Change Buffer</strong></p><p>插入缓冲区：写操作更新数据页、索引页，数据页由日志优化，change优化索引页。</p><p>储存在buffer pool（索引页+数据页）中，占25%。存储修改的信息（update语句），修改时数据页被更新，但索引页不更新，暂时存在change buffer中，等到下次查询走索引调用的时候将磁盘中的索引调到pool中，再和change中对应的update整合，拿到正确的索引页，即延迟更新机制，使update效率变高了。</p><p><strong>可重复读</strong></p><p>开启两个事务，a先读取，b修改此值，a再次读取，结果仍为之前的旧值。</p><p>undo实现：每个事务通过链表readview记录和它同时存在的活跃的事务，以及它们的undo log，在第二次查询时，按照记录的undolog，判断生成的事务是否在readview里，若在则执行undolog，这样就可以还原之前的值，然后输出。</p><p><img src="/images/Mysql_index/image-20210826155926540.png" alt="image-20210826155926540"></p><p>可重复读在第一次读时生成readview，后面使用同一个readview；读已提交在别的事务提交之后发生更新，判断undo链发现不在readview里，就直接取最新值。也就是说，在别的事务提交之后，查找的数据还不是最新的，而是事务启动时候的，读取已提交却可以拿到最新数据，所以可重复读相对更严。</p><p>隔离级别越来越严，越难读到最新值，效率也就越低。 </p><p><img src="/images/Mysql_index/image-20210826161145756.png" alt="image-20210826161145756"></p><p><strong>视图</strong></p><p>视图（View）是一种虚拟存在的表。视图并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。通俗的讲，视图就是一条SELECT语句执行后返回的结果集。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。<br>视图相对于普通的表的优势主要包括以下几项。</p><ul><li>简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。</li><li>安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。</li><li>数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。  </li></ul><p><strong>存储过程</strong></p><p>存储过程和函数是 事先经过编译并存储在数据库中的一段 <strong>SQL 语句的集合</strong>，调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</p><ul><li><p>函数 ： 是一个有返回值的过程 ；</p></li><li><p>过程 ： 是一个没有返回值的函数 ；  </p></li></ul><p><strong>触发器</strong></p><p>触发器是与表有关的数据库对象，指在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。  </p><p><strong>MySQL体系结构</strong></p><p><img src="/images/Mysql_index/image-20210827093733982.png" alt="image-20210827093733982"></p><p>整个MySQL Server由以下组成<br>Connection Pool : 连接池组件<br>Management Services &amp; Utilities : 管理服务和工具组件<br>SQL Interface : SQL接口组件<br>Parser : 查询分析器组件<br>Optimizer : 优化器组件<br>Caches &amp; Buffers : 缓冲池组件<br>Pluggable Storage Engines : 存储引擎<br>File System : 文件系统  </p><p>连接层、服务层、引擎层、存储层。</p><p>MySQL提供了插件式的存储引擎架构，存储引擎是基于表的，而不是基于库的。</p><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th><th>MEMORY</th><th>MERGE</th><th>NDB</th></tr></thead><tbody><tr><td>存储限制</td><td>64TB</td><td>有</td><td>有</td><td>没有</td><td>有</td></tr><tr><td>事务安全</td><td>==支持==</td><td></td><td></td><td></td><td></td></tr><tr><td>锁机制</td><td>==行锁(适合高并发)==</td><td>==表锁==</td><td>表锁</td><td>表锁</td><td>行锁</td></tr><tr><td>B树索引</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>哈希索引</td><td></td><td></td><td>支持</td><td></td><td></td></tr><tr><td>全文索引</td><td>支持(5.6版本之后)</td><td>支持</td><td></td><td></td><td></td></tr><tr><td>集群索引</td><td>支持</td><td></td><td></td><td></td><td></td></tr><tr><td>数据索引</td><td>支持</td><td></td><td>支持</td><td></td><td>支持</td></tr><tr><td>索引缓存</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>数据可压缩</td><td></td><td>支持</td><td></td><td></td><td></td></tr><tr><td>空间使用</td><td>高</td><td>低</td><td>N/A</td><td>低</td><td>低</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中等</td><td>低</td><td>高</td></tr><tr><td>批量插入速度</td><td>低</td><td>高</td><td>高</td><td>高</td><td>高</td></tr><tr><td>支持外键</td><td>==支持==</td><td></td><td></td><td></td><td></td></tr></tbody></table><p><strong>外键</strong></p><ul><li><p>MySQL支持外键的存储引擎只有InnoDB ， 在创建外键的时候， 要求父表必须有对应的索引 ， 子表在创建外键的时候， 也会自动的创建对应的索引。</p></li><li><p>MyISAM 不支持事务、也不支持外键，其优势是访问的速度快，对事务的完整性没有要求或者以SELECT、INSERT为主的应用基本上都可以使用这个引擎来创建表 。</p></li></ul><p><strong>存储方式</strong>    </p><ul><li>InnoDB 存储表和索引有以下两种方式 ： </li></ul><p>①. 使用共享表空间存储， 这种方式创建的表的表结构保存在.frm文件中， 数据和索引保存在 innodb_data_home_dir 和 innodb_data_file_path定义的表空间中，可以是多个文件。</p><p>MyISAM 不支持事务、也不支持外键，其优势是访问的速度快，对事务的完整性没有要求或者以SELECT、INSERT为主的应用基本上都可以使用这个引擎来创建表 。</p><p>②. 使用多表空间存储， 这种方式创建的表的表结构仍然存在 .frm 文件中，但是每个表的数据和索引单独保存在 .ibd 中。</p><p>MyISAM 不支持事务、也不支持外键，其优势是访问的速度快，对事务的完整性没有要求或者以SELECT、INSERT为主的应用基本上都可以使用这个引擎来创建表 。</p><ul><li><p>每个MyISAM在磁盘上存储成3个文件，其文件名都和表名相同，但拓展名分别是 ： </p><p>.frm (存储表定义)；</p><p>.MYD(MYData , 存储数据)；</p><p>.MYI(MYIndex , 存储索引)；</p></li></ul><p><strong>选择</strong></p><ul><li>InnoDB : 是Mysql的默认存储引擎，用于事务处理应用程序，支持外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询意外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。InnoDB存储引擎除了有效的降低由于删除和更新导致的锁定， 还可以确保事务的完整提交和回滚，对于类似于计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB是最合适的选择。</li><li>MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</li></ul><p><strong>避免索引失效</strong></p><p>1).  全值匹配 ，对索引中所有列都指定具体值。</p><p>改情况下，索引生效，执行效率高。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;北京市&#x27;</span>\G;</span><br></pre></td></tr></table></figure><p>2). 最左前缀法则</p><p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。</p><p>匹配最左前缀法则，走索引：</p><p>违法最左前缀法则 ， 索引失效：</p><p>如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效： </p><p>3). 范围查询右边的列，不能使用索引 。 </p><p><img src="/images/Mysql_index/image-20210827095442175.png" alt="image-20210827095442175"></p><p>根据前面的两个字段name ， status 查询是走索引的， 但是最后一个条件address 没有用到索引。</p><p>4). 不要在索引列上进行运算操作， 索引将失效。 </p><p>5). 字符串不加单引号，造成索引失效。 </p><p><img src="/images/Mysql_index/image-20210827095508302.png" alt="image-20210827095508302"></p><p>由于，在查询是，没有对字符串加单引号，MySQL的查询优化器，会自动的进行类型转换，造成索引失效。</p><p>6). 尽量使用覆盖索引，避免select *</p><p>尽量使用覆盖索引（只访问索引的查询（索引列完全包含查询列）），减少select * 。 </p><p>如果查询列，超出索引列，也会降低性能。 </p><p>7). 用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</p><p>示例，name字段是索引列 ， 而createtime不是索引列，中间是or进行连接是不走索引的 ： </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;黑马程序员&#x27;</span> <span class="keyword">or</span> createtime <span class="operator">=</span> <span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>\G;</span><br></pre></td></tr></table></figure><p><img src="/images/Mysql_index/image-20210827095641389.png" alt="image-20210827095641389"></p><p>8).  以%开头的Like模糊查询，索引失效。</p><p>解决：不使用select *，使用覆盖索引select</p><p>9). 如果MySQL评估使用索引比全表更慢，则不使用索引。</p><p>10). is  NULL ， is NOT NULL  <font color='red'>有时</font>索引失效。  </p><p>11). in 走索引， not in 索引失效。</p><p>12). 单列索引和复合索引。</p><p>尽量使用复合索引，而少使用单列索引 。</p><p><strong>SQL优化</strong></p><ul><li><p>大量插入</p><ul><li>按照主键插入</li><li>关闭唯一校验</li></ul><p>导入数据前执行 SET UNIQUE_CHECKS=0，关闭唯一性校验，在导入结束后执行SET UNIQUE_CHECKS=1， </p><ul><li>手动提交事务  </li></ul><p>导入前执行 SET AUTOCOMMIT=0，关闭自动提交，导入结束后再执行 SET AUTOCOMMIT=1，打开自动提交</p></li><li><p>insert语句</p><ul><li>尽量使用一条语句包含多个值插入</li><li>开一个事务插入</li><li>有序插入</li></ul></li><li><p>分页</p><p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是 limit 2000000,10  ，此时需要MySQL排序前2000010 记录，仅仅返回2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。</p><ul><li><p>先查主键，在根据主键查全部记录</p><p><img src="/images/Mysql_index/image-20210827100841455.png" alt="image-20210827100841455"></p></li><li><p>适用于主键自增的表，可以把Limit 查询转换成某个位置的查询 。  </p><p><img src="/images/Mysql_index/image-20210827100919667.png" alt="image-20210827100919667"></p></li></ul></li><li><p>使用SQL提示</p><ul><li>USE INDEX：提供希望MySQL去参考的索引列表，就可以让MySQL不再考虑其他可用的索引。</li><li>IGNORE INDEX：忽略一个或者多个索引</li><li>FORCE INDEX：强制MySQL使用一个特定的索引</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Mysql索引+事务&lt;/p&gt;</summary>
    
    
    
    <category term="Study" scheme="https://memorykk.cn/categories/Study/"/>
    
    
    <category term="MySQL" scheme="https://memorykk.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL_黑马</title>
    <link href="https://memorykk.cn/Mysql-hm.html"/>
    <id>https://memorykk.cn/Mysql-hm.html</id>
    <published>2021-08-26T13:23:12.000Z</published>
    <updated>2021-08-26T14:06:58.674Z</updated>
    
    <content type="html"><![CDATA[<p>Mysql黑马程序员</p><span id="more"></span><h1 id="Mysql高级-day01"><a href="#Mysql高级-day01" class="headerlink" title="Mysql高级-day01"></a>Mysql高级-day01</h1><h3 id="MySQL高级课程简介"><a href="#MySQL高级课程简介" class="headerlink" title="MySQL高级课程简介"></a>MySQL高级课程简介</h3><table><thead><tr><th align="center">序号</th><th>Day01</th><th>Day02</th><th>Day03</th><th>Day04</th></tr></thead><tbody><tr><td align="center">1</td><td>Linux系统安装MySQL</td><td>体系结构</td><td>应用优化</td><td>MySQL 常用工具</td></tr><tr><td align="center">2</td><td>索引</td><td>存储引擎</td><td>查询缓存优化</td><td>MySQL 日志</td></tr><tr><td align="center">3</td><td>视图</td><td>优化SQL步骤</td><td>内存管理及优化</td><td>MySQL 主从复制</td></tr><tr><td align="center">4</td><td>存储过程和函数</td><td>索引使用</td><td>MySQL锁问题</td><td>综合案例</td></tr><tr><td align="center">5</td><td>触发器</td><td>SQL优化</td><td>常用SQL技巧</td><td></td></tr></tbody></table><h3 id="1-Linux-系统安装MySQL"><a href="#1-Linux-系统安装MySQL" class="headerlink" title="1. Linux 系统安装MySQL"></a>1. Linux 系统安装MySQL</h3><h4 id="1-1-下载Linux-安装包"><a href="#1-1-下载Linux-安装包" class="headerlink" title="1.1 下载Linux 安装包"></a>1.1 下载Linux 安装包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;dev.mysql.com&#x2F;downloads&#x2F;mysql&#x2F;5.7.html#downloads</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/1/1555661091565.png" alt="1555661091565"> </p><h4 id="1-2-安装MySQL"><a href="#1-2-安装MySQL" class="headerlink" title="1.2 安装MySQL"></a>1.2 安装MySQL</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1). 卸载 centos 中预安装的 mysql</span><br><span class="line"></span><br><span class="line">rpm -qa | grep -i mysql</span><br><span class="line"></span><br><span class="line">rpm -e mysql-libs-5.1.71-1.el6.x86_64 --nodeps</span><br><span class="line"></span><br><span class="line">2). 上传 mysql 的安装包</span><br><span class="line"></span><br><span class="line">alt + p -------&gt; put  E:&#x2F;test&#x2F;MySQL-5.6.22-1.el6.i686.rpm-bundle.tar</span><br><span class="line"></span><br><span class="line">3). 解压 mysql 的安装包 </span><br><span class="line"></span><br><span class="line">mkdir mysql</span><br><span class="line"></span><br><span class="line">tar -xvf MySQL-5.6.22-1.el6.i686.rpm-bundle.tar -C &#x2F;root&#x2F;mysql</span><br><span class="line"></span><br><span class="line">4). 安装依赖包 </span><br><span class="line"></span><br><span class="line">yum -y install libaio.so.1 libgcc_s.so.1 libstdc++.so.6 libncurses.so.5 --setopt&#x3D;protected_multilib&#x3D;false</span><br><span class="line"></span><br><span class="line">yum  update libstdc++-4.4.7-4.el6.x86_64</span><br><span class="line"></span><br><span class="line">5). 安装 mysql-client</span><br><span class="line"></span><br><span class="line">rpm -ivh MySQL-client-5.6.22-1.el6.i686.rpm</span><br><span class="line"></span><br><span class="line">6). 安装 mysql-server</span><br><span class="line"></span><br><span class="line">rpm -ivh MySQL-server-5.6.22-1.el6.i686.rpm</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-3-启动-MySQL-服务"><a href="#1-3-启动-MySQL-服务" class="headerlink" title="1.3 启动 MySQL 服务"></a>1.3 启动 MySQL 服务</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">service mysql <span class="keyword">start</span></span><br><span class="line"></span><br><span class="line">service mysql stop</span><br><span class="line"></span><br><span class="line">service mysql status</span><br><span class="line"></span><br><span class="line">service mysql restart</span><br></pre></td></tr></table></figure><h4 id="1-4-登录MySQL"><a href="#1-4-登录MySQL" class="headerlink" title="1.4 登录MySQL"></a>1.4 登录MySQL</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql 安装完成之后, 会自动生成一个随机的密码, 并且保存在一个密码文件中 : &#x2F;root&#x2F;.mysql_secret</span><br><span class="line"></span><br><span class="line">mysql -u root -p </span><br><span class="line"></span><br><span class="line">登录之后, 修改密码 :</span><br><span class="line"></span><br><span class="line">set password &#x3D; password(&#39;itcast&#39;);</span><br><span class="line"></span><br><span class="line">授权远程访问 : </span><br><span class="line"></span><br><span class="line">grant all privileges on *.* to &#39;root&#39; @&#39;%&#39; identified by &#39;itcast&#39;;</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a>2. 索引</h3><h4 id="2-1-索引概述"><a href="#2-1-索引概述" class="headerlink" title="2.1 索引概述"></a>2.1 索引概述</h4><p>MySQL官方对索引的定义为：索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。如下面的==示意图==所示 : </p><p><img src="/images/MySQL_hm/1/1555902055367.png" alt="1555902055367"> </p><p>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找快速获取到相应数据。</p><p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。索引是数据库中用来提高性能的最常用的工具。</p><h4 id="2-2-索引优势劣势"><a href="#2-2-索引优势劣势" class="headerlink" title="2.2 索引优势劣势"></a>2.2 索引优势劣势</h4><p>优势</p><p>1） 类似于书籍的目录索引，提高数据检索的效率，降低数据库的IO成本。</p><p>2） 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。</p><p>劣势</p><p>1） 实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也是要占用空间的。</p><p>2） 虽然索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。</p><h4 id="2-3-索引结构"><a href="#2-3-索引结构" class="headerlink" title="2.3 索引结构"></a>2.3 索引结构</h4><p>索引是在MySQL的存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型的。MySQL目前提供了以下4种索引：</p><ul><li>BTREE 索引 ： 最常见的索引类型，大部分索引都支持 B 树索引。</li><li>HASH 索引：只有Memory引擎支持 ， 使用场景简单 。</li><li>R-tree 索引（空间索引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，不做特别介绍。</li><li>Full-text （全文索引） ：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从Mysql5.6版本开始支持全文索引。</li></ul><center><b>MyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持</b></center><table><thead><tr><th>索引</th><th>InnoDB引擎</th><th>MyISAM引擎</th><th>Memory引擎</th></tr></thead><tbody><tr><td>BTREE索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>HASH 索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-tree 索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本之后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><p>我们平常所说的索引，如果没有特别指明，都是指B+树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引、复合索引、前缀索引、唯一索引默认都是使用 B+tree 索引，统称为 索引。</p><h5 id="2-3-1-BTREE-结构"><a href="#2-3-1-BTREE-结构" class="headerlink" title="2.3.1 BTREE 结构"></a>2.3.1 BTREE 结构</h5><p>BTree又叫多路平衡搜索树，一颗m叉的BTree特性如下：</p><ul><li>树中每个节点最多包含m个孩子。</li><li>除根节点与叶子节点外，每个节点至少有[ceil(m/2)]个孩子。</li><li>若根节点不是叶子节点，则至少有两个孩子。</li><li>所有的叶子节点都在同一层。</li><li>每个非叶子节点由n个key与n+1个指针组成，其中[ceil(m/2)-1] &lt;= n &lt;= m-1 </li></ul><p>以5叉BTree为例，key的数量：公式推导[ceil(m/2)-1] &lt;= n &lt;= m-1。所以 2 &lt;= n &lt;=4 。当n&gt;4时，中间节点分裂到父节点，两边节点分裂。</p><p>插入 C N G A H E K Q M F W L T Z D P R X Y S 数据为例。</p><p>演变过程如下：</p><p>1). 插入前4个字母 C N G A </p><p><img src="/images/MySQL_hm/1/1555944126588.png" alt="1555944126588"> </p><p>2). 插入H，n&gt;4，中间元素G字母向上分裂到新的节点</p><p><img src="/images/MySQL_hm/1/1555944549825.png" alt="1555944549825"> </p><p>3). 插入E，K，Q不需要分裂</p><p><img src="/images/MySQL_hm/1/1555944596893.png" alt="1555944596893"> </p><p>4). 插入M，中间元素M字母向上分裂到父节点G</p><p><img src="/images/MySQL_hm/1/1555944652560.png" alt="1555944652560"> </p><p>5). 插入F，W，L，T不需要分裂</p><p><img src="/images/MySQL_hm/1/1555944686928.png" alt="1555944686928"> </p><p>6). 插入Z，中间元素T向上分裂到父节点中 </p><p><img src="/images/MySQL_hm/1/1555944713486.png" alt="1555944713486"> </p><p>7). 插入D，中间元素D向上分裂到父节点中。然后插入P，R，X，Y不需要分裂</p><p><img src="/images/MySQL_hm/1/1555944749984.png" alt="1555944749984"> </p><p>8). 最后插入S，NPQR节点n&gt;5，中间节点Q向上分裂，但分裂后父节点DGMT的n&gt;5，中间节点M向上分裂</p><p><img src="/images/MySQL_hm/1/1555944848294.png" alt="1555944848294"> </p><p>到此，该BTREE树就已经构建完成了， BTREE树 和 二叉树 相比， 查询数据的效率更高， 因为对于相同的数据量来说，BTREE的层级结构比二叉树小，因此搜索速度快。</p><h5 id="2-3-3-B-TREE-结构"><a href="#2-3-3-B-TREE-结构" class="headerlink" title="2.3.3 B+TREE 结构"></a>2.3.3 B+TREE 结构</h5><p>B+Tree为BTree的变种，B+Tree与BTree的区别为：</p><p>1). n叉B+Tree最多含有n个key，而BTree最多含有n-1个key。</p><p>2). B+Tree的叶子节点保存所有的key信息，依key大小顺序排列。</p><p>3). 所有的非叶子节点都可以看作是key的索引部分。</p><p><img src="/images/MySQL_hm/1/00001.jpg" alt="1555906287178"> </p><p>由于B+Tree只有叶子节点保存key信息，查询任何key都要从root走到叶子。所以B+Tree的查询效率更加稳定。</p><h5 id="2-3-3-MySQL中的B-Tree"><a href="#2-3-3-MySQL中的B-Tree" class="headerlink" title="2.3.3 MySQL中的B+Tree"></a>2.3.3 MySQL中的B+Tree</h5><p>MySql索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。</p><p>MySQL中的 B+Tree 索引结构示意图: </p><p><img src="/images/MySQL_hm/1/1555906287178.png" alt="1555906287178">  </p><h4 id="2-4-索引分类"><a href="#2-4-索引分类" class="headerlink" title="2.4 索引分类"></a>2.4 索引分类</h4><p>1） 单值索引 ：即一个索引只包含单个列，一个表可以有多个单列索引</p><p>2） 唯一索引 ：索引列的值必须唯一，但允许有空值</p><p>3） 复合索引 ：即一个索引包含多个列</p><h4 id="2-5-索引语法"><a href="#2-5-索引语法" class="headerlink" title="2.5 索引语法"></a>2.5 索引语法</h4><p>索引在创建表的时候，可以同时创建， 也可以随时增加新的索引。</p><p>准备环境:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database demo_01 <span class="keyword">default</span> charset<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line">use demo_01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `city` (</span><br><span class="line">  `city_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `city_name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `country_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`city_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `country` (</span><br><span class="line">  `country_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `country_name` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`country_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `city` (`city_id`, `city_name`, `country_id`) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;西安&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `city` (`city_id`, `city_name`, `country_id`) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;NewYork&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `city` (`city_id`, `city_name`, `country_id`) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;北京&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `city` (`city_id`, `city_name`, `country_id`) <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;上海&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `country` (`country_id`, `country_name`) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;China&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `country` (`country_id`, `country_name`) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;America&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `country` (`country_id`, `country_name`) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;Japan&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `country` (`country_id`, `country_name`) <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;UK&#x27;</span>);</span><br></pre></td></tr></table></figure><h5 id="2-5-1-创建索引"><a href="#2-5-1-创建索引" class="headerlink" title="2.5.1 创建索引"></a>2.5.1 创建索引</h5><p>语法 ：     </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span><span class="operator">|</span>FULLTEXT<span class="operator">|</span>SPATIAL]  INDEX index_name </span><br><span class="line">[<span class="keyword">USING</span>  index_type]</span><br><span class="line"><span class="keyword">ON</span> tbl_name(index_col_name,...)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">index_col_name : column_name[(length)][<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><p>示例 ： 为city表中的city_name字段创建索引 ；</p><p><img src="/images/MySQL_hm/1/1551438009843.png" alt="1551438009843">    ​      </p><p>​    </p><h5 id="2-5-2-查看索引"><a href="#2-5-2-查看索引" class="headerlink" title="2.5.2 查看索引"></a>2.5.2 查看索引</h5><p>语法： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show index  from  table_name;</span><br></pre></td></tr></table></figure><p>示例：查看city表中的索引信息；</p><p><img src="/images/MySQL_hm/1/1551440511890.png" alt="1551440511890"> </p><p><img src="/images/MySQL_hm/1/1551440544483.png" alt="1551440544483">      </p><h5 id="2-5-3-删除索引"><a href="#2-5-3-删除索引" class="headerlink" title="2.5.3 删除索引"></a>2.5.3 删除索引</h5><p>语法 ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP  INDEX  index_name  ON  tbl_name;</span><br></pre></td></tr></table></figure><p>示例 ： 想要删除city表上的索引idx_city_name，可以操作如下：</p><p><img src="/images/MySQL_hm/1/1551438238293.png" alt="1551438238293">      </p><h5 id="2-5-4-ALTER命令"><a href="#2-5-4-ALTER命令" class="headerlink" title="2.5.4 ALTER命令"></a>2.5.4 ALTER命令</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1). alter  table  tb_name  add  primary  key(column_list); 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL2). alter  table  tb_name  add  unique index_name(column_list);这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）3). alter  table  tb_name  add  index index_name(column_list);添加普通索引， 索引值可以出现多次。4). alter  table  tb_name  add  fulltext  index_name(column_list);该语句指定了索引为FULLTEXT， 用于全文索引</span><br></pre></td></tr></table></figure><h4 id="2-6-索引设计原则"><a href="#2-6-索引设计原则" class="headerlink" title="2.6 索引设计原则"></a>2.6 索引设计原则</h4><p>​    索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。</p><ul><li><p>对查询频次较高，且数据量比较大的表建立索引。</p></li><li><p>索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。</p></li><li><p>使用唯一索引，区分度越高，使用索引的效率越高。</p></li><li><p>索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。</p></li><li><p>使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I/O效率。</p></li><li><p>利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建复合索引:CREATE INDEX idx_name_email_status ON tb_seller(NAME,email,STATUS);就相当于对name 创建索引 ;对name , email 创建了索引 ;对name , email, status 创建了索引 ;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-视图"><a href="#3-视图" class="headerlink" title="3. 视图"></a>3. 视图</h3><h4 id="3-1-视图概述"><a href="#3-1-视图概述" class="headerlink" title="3.1 视图概述"></a>3.1 视图概述</h4><p>​    视图（View）是一种虚拟存在的表。视图并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。通俗的讲，视图就是一条SELECT语句执行后返回的结果集。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p><p>视图相对于普通的表的优势主要包括以下几项。</p><ul><li>简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。</li><li>安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。</li><li>数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。</li></ul><h4 id="3-2-创建或者修改视图"><a href="#3-2-创建或者修改视图" class="headerlink" title="3.2 创建或者修改视图"></a>3.2 创建或者修改视图</h4><p>创建视图的语法为：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">CREATE [OR REPLACE] [ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]VIEW view_name [(column_list)]AS select_statement[WITH [CASCADED | LOCAL] CHECK OPTION]</span><br></pre></td></tr></table></figure><p>修改视图的语法为：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">ALTER [ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]VIEW view_name [(column_list)]AS select_statement[WITH [CASCADED | LOCAL] CHECK OPTION]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选项 : WITH [CASCADED | LOCAL] CHECK OPTION 决定了是否允许更新数据使记录不再满足视图的条件。LOCAL ： 只要满足本视图的条件就可以更新。CASCADED ： 必须满足所有针对该视图的所有视图的条件才可以更新。 默认值.</span><br></pre></td></tr></table></figure><p>示例 , 创建city_country_view视图 , 执行如下SQL : </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> city_country_view <span class="keyword">as</span> <span class="keyword">select</span> t.<span class="operator">*</span>,c.country_name <span class="keyword">from</span> country c , city t <span class="keyword">where</span> c.country_id <span class="operator">=</span> t.country_id;</span><br></pre></td></tr></table></figure><p>查询视图 : </p><p><img src="/images/MySQL_hm/1/1551503428635.png" alt="1551503428635">     </p><h4 id="3-3-查看视图"><a href="#3-3-查看视图" class="headerlink" title="3.3 查看视图"></a>3.3 查看视图</h4><p>​    从 MySQL 5.1 版本开始，使用 SHOW TABLES 命令的时候不仅显示表的名字，同时也会显示视图的名字，而不存在单独显示视图的 SHOW VIEWS 命令。</p><p><img src="/images/MySQL_hm/1/1551537565159.png" alt="1551537565159">     </p><p>同样，在使用 SHOW TABLE STATUS 命令的时候，不但可以显示表的信息，同时也可以显示视图的信息。    </p><p><img src="/images/MySQL_hm/1/1551537646323.png" alt="1551537646323"> </p><p>如果需要查询某个视图的定义，可以使用 SHOW CREATE VIEW 命令进行查看 ： </p><p><img src="/images/MySQL_hm/1/1551588962944.png" alt="1551588962944">  </p><h4 id="3-4-删除视图"><a href="#3-4-删除视图" class="headerlink" title="3.4 删除视图"></a>3.4 删除视图</h4><p>语法 : </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> [IF <span class="keyword">EXISTS</span>] view_name [, view_name] ...[RESTRICT <span class="operator">|</span> CASCADE]</span><br></pre></td></tr></table></figure><p>示例 , 删除视图city_country_view :</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP VIEW city_country_view ;</span><br></pre></td></tr></table></figure><h3 id="4-存储过程和函数"><a href="#4-存储过程和函数" class="headerlink" title="4. 存储过程和函数"></a>4. 存储过程和函数</h3><h4 id="4-1-存储过程和函数概述"><a href="#4-1-存储过程和函数概述" class="headerlink" title="4.1 存储过程和函数概述"></a>4.1 存储过程和函数概述</h4><p>​    存储过程和函数是  事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。    </p><p>​    存储过程和函数的区别在于函数必须有返回值，而存储过程没有。</p><p>​    函数 ： 是一个有返回值的过程 ；</p><p>​    过程 ： 是一个没有返回值的函数 ；</p><h4 id="4-2-创建存储过程"><a href="#4-2-创建存储过程" class="headerlink" title="4.2 创建存储过程"></a>4.2 创建存储过程</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> procedure_name ([proc_parameter[,...]])<span class="keyword">begin</span><span class="comment">-- SQL语句end ;</span></span><br></pre></td></tr></table></figure><p>示例 ：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter $<span class="keyword">create</span> <span class="keyword">procedure</span> pro_test1()<span class="keyword">begin</span><span class="keyword">select</span> <span class="string">&#x27;Hello Mysql&#x27;</span> ;<span class="keyword">end</span>$delimiter ;</span><br></pre></td></tr></table></figure><p><strong><font color="red">知识小贴士</font></strong></p><p>DELIMITER</p><p>​    该关键字用来声明SQL语句的分隔符 , 告诉 MySQL 解释器，该段命令是否已经结束了，mysql是否可以执行了。默认情况下，delimiter是分号;。在命令行客户端中，如果有一行命令以分号结束，那么回车后，mysql将会执行该命令。</p><h4 id="4-3-调用存储过程"><a href="#4-3-调用存储过程" class="headerlink" title="4.3 调用存储过程"></a>4.3 调用存储过程</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> procedure_name() ;</span><br></pre></td></tr></table></figure><h4 id="4-4-查看存储过程"><a href="#4-4-查看存储过程" class="headerlink" title="4.4 查看存储过程"></a>4.4 查看存储过程</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询db_name数据库中的所有的存储过程select name from mysql.proc where db=&#x27;db_name&#x27;;-- 查询存储过程的状态信息show procedure status;-- 查询某个存储过程的定义show create procedure test.pro_test1 \G;</span></span><br></pre></td></tr></table></figure><h4 id="4-5-删除存储过程"><a href="#4-5-删除存储过程" class="headerlink" title="4.5 删除存储过程"></a>4.5 删除存储过程</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span>  [IF <span class="keyword">EXISTS</span>] sp_name ；</span><br></pre></td></tr></table></figure><h4 id="4-6-语法"><a href="#4-6-语法" class="headerlink" title="4.6 语法"></a>4.6 语法</h4><p>存储过程是可以编程的，意味着可以使用变量，表达式，控制结构 ， 来完成比较复杂的功能。</p><h5 id="4-6-1-变量"><a href="#4-6-1-变量" class="headerlink" title="4.6.1 变量"></a>4.6.1 变量</h5><ul><li><p>DECLARE</p><p>通过 DECLARE 可以定义一个局部变量，该变量的作用范围只能在 BEGIN…END 块中。</p></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> var_name[,...] type [<span class="keyword">DEFAULT</span> <span class="keyword">value</span>]</span><br></pre></td></tr></table></figure><p>示例 : </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter $ <span class="keyword">create</span> <span class="keyword">procedure</span> pro_test2()  <span class="keyword">begin</span>  <span class="keyword">declare</span> num <span class="type">int</span> <span class="keyword">default</span> <span class="number">5</span>; <span class="keyword">select</span> num<span class="operator">+</span> <span class="number">10</span>;  <span class="keyword">end</span>$ delimiter ; </span><br></pre></td></tr></table></figure><ul><li>SET</li></ul><p>直接赋值使用 SET，可以赋常量或者赋表达式，具体语法如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET var_name &#x3D; expr [, var_name &#x3D; expr] ...</span><br></pre></td></tr></table></figure><p>示例 : </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $    <span class="keyword">CREATE</span>  <span class="keyword">PROCEDURE</span> pro_test3()  <span class="keyword">BEGIN</span>  <span class="keyword">DECLARE</span> NAME <span class="type">VARCHAR</span>(<span class="number">20</span>);  <span class="keyword">SET</span> NAME <span class="operator">=</span> <span class="string">&#x27;MYSQL&#x27;</span>;  <span class="keyword">SELECT</span> NAME ;  <span class="keyword">END</span>$    DELIMITER ;</span><br></pre></td></tr></table></figure><p>也可以通过select … into 方式进行赋值操作 :</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $<span class="keyword">CREATE</span>  <span class="keyword">PROCEDURE</span> pro_test5()<span class="keyword">BEGIN</span><span class="keyword">declare</span>  countnum <span class="type">int</span>;<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> countnum <span class="keyword">from</span> city;<span class="keyword">select</span> countnum;<span class="keyword">END</span>$DELIMITER ;</span><br></pre></td></tr></table></figure><h5 id="4-6-2-if条件判断"><a href="#4-6-2-if条件判断" class="headerlink" title="4.6.2 if条件判断"></a>4.6.2 if条件判断</h5><p>语法结构 : </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">if search_condition <span class="keyword">then</span> statement_list[elseif search_condition <span class="keyword">then</span> statement_list] ...[<span class="keyword">else</span> statement_list]<span class="keyword">end</span> if;</span><br></pre></td></tr></table></figure><p>需求： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根据定义的身高变量，判定当前身高的所属的身材类型 180 及以上 ----------&gt; 身材高挑170 - 180  ---------&gt; 标准身材170 以下  ----------&gt; 一般身材</span><br></pre></td></tr></table></figure><p>示例 : </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter $<span class="keyword">create</span> <span class="keyword">procedure</span> pro_test6()<span class="keyword">begin</span>  <span class="keyword">declare</span>  height  <span class="type">int</span>  <span class="keyword">default</span>  <span class="number">175</span>;   <span class="keyword">declare</span>  description  <span class="type">varchar</span>(<span class="number">50</span>);    if  height <span class="operator">&gt;=</span> <span class="number">180</span>  <span class="keyword">then</span>    <span class="keyword">set</span> description <span class="operator">=</span> <span class="string">&#x27;身材高挑&#x27;</span>;  elseif height <span class="operator">&gt;=</span> <span class="number">170</span> <span class="keyword">and</span> height <span class="operator">&lt;</span> <span class="number">180</span>  <span class="keyword">then</span>    <span class="keyword">set</span> description <span class="operator">=</span> <span class="string">&#x27;标准身材&#x27;</span>;  <span class="keyword">else</span>    <span class="keyword">set</span> description <span class="operator">=</span> <span class="string">&#x27;一般身材&#x27;</span>;  <span class="keyword">end</span> if;    <span class="keyword">select</span> description ;<span class="keyword">end</span>$delimiter ;</span><br></pre></td></tr></table></figure><p>调用结果为 : </p><p><img src="/images/MySQL_hm/1/1552057035580.png" alt="1552057035580"> </p><h5 id="4-6-3-传递参数"><a href="#4-6-3-传递参数" class="headerlink" title="4.6.3 传递参数"></a>4.6.3 传递参数</h5><p>语法格式 : </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure procedure_name([in&#x2F;out&#x2F;inout] 参数名   参数类型)...IN :   该参数可以作为输入，也就是需要调用方传入值 , 默认OUT:   该参数作为输出，也就是该参数可以作为返回值INOUT: 既可以作为输入参数，也可以作为输出参数</span><br></pre></td></tr></table></figure><p><strong>IN - 输入</strong></p><p>需求 :</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根据定义的身高变量，判定当前身高的所属的身材类型 </span><br></pre></td></tr></table></figure><p>示例  : </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter $<span class="keyword">create</span> <span class="keyword">procedure</span> pro_test5(<span class="keyword">in</span> height <span class="type">int</span>)<span class="keyword">begin</span>    <span class="keyword">declare</span> description <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>;  if height <span class="operator">&gt;=</span> <span class="number">180</span> <span class="keyword">then</span>    <span class="keyword">set</span> description<span class="operator">=</span><span class="string">&#x27;身材高挑&#x27;</span>;  elseif height <span class="operator">&gt;=</span> <span class="number">170</span> <span class="keyword">and</span> height <span class="operator">&lt;</span> <span class="number">180</span> <span class="keyword">then</span>    <span class="keyword">set</span> description<span class="operator">=</span><span class="string">&#x27;标准身材&#x27;</span>;  <span class="keyword">else</span>    <span class="keyword">set</span> description<span class="operator">=</span><span class="string">&#x27;一般身材&#x27;</span>;  <span class="keyword">end</span> if;  <span class="keyword">select</span> concat(<span class="string">&#x27;身高 &#x27;</span>, height , <span class="string">&#x27;对应的身材类型为:&#x27;</span>,description);<span class="keyword">end</span>$delimiter ;</span><br></pre></td></tr></table></figure><p><strong>OUT-输出</strong></p><p> 需求 :</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根据传入的身高变量，获取当前身高的所属的身材类型  </span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_test5(<span class="keyword">in</span> height <span class="type">int</span> , <span class="keyword">out</span> description <span class="type">varchar</span>(<span class="number">100</span>))<span class="keyword">begin</span>  if height <span class="operator">&gt;=</span> <span class="number">180</span> <span class="keyword">then</span>    <span class="keyword">set</span> description<span class="operator">=</span><span class="string">&#x27;身材高挑&#x27;</span>;  elseif height <span class="operator">&gt;=</span> <span class="number">170</span> <span class="keyword">and</span> height <span class="operator">&lt;</span> <span class="number">180</span> <span class="keyword">then</span>    <span class="keyword">set</span> description<span class="operator">=</span><span class="string">&#x27;标准身材&#x27;</span>;  <span class="keyword">else</span>    <span class="keyword">set</span> description<span class="operator">=</span><span class="string">&#x27;一般身材&#x27;</span>;  <span class="keyword">end</span> if;<span class="keyword">end</span>$</span><br></pre></td></tr></table></figure><p>调用:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call pro_test5(168, @description)$select @description$</span><br></pre></td></tr></table></figure><p><font color='red'><strong>小知识</strong> </font></p><p>@description :  这种变量要在变量名称前面加上“@”符号，叫做用户会话变量，代表整个会话过程他都是有作用的，这个类似于全局变量一样。</p><p>@@global.sort_buffer_size : 这种在变量前加上 “@@” 符号, 叫做 系统变量 </p><h5 id="4-6-4-case结构"><a href="#4-6-4-case结构" class="headerlink" title="4.6.4 case结构"></a>4.6.4 case结构</h5><p>语法结构 : </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">方式一 : <span class="keyword">CASE</span> case_value  <span class="keyword">WHEN</span> when_value <span class="keyword">THEN</span> statement_list    [<span class="keyword">WHEN</span> when_value <span class="keyword">THEN</span> statement_list] ...    [<span class="keyword">ELSE</span> statement_list]  <span class="keyword">END</span> <span class="keyword">CASE</span>;方式二 : <span class="keyword">CASE</span>  <span class="keyword">WHEN</span> search_condition <span class="keyword">THEN</span> statement_list    [<span class="keyword">WHEN</span> search_condition <span class="keyword">THEN</span> statement_list] ...    [<span class="keyword">ELSE</span> statement_list]  <span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br></pre></td></tr></table></figure><p>需求:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个月份, 然后计算出所在的季度</span><br></pre></td></tr></table></figure><p>示例  :</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter $<span class="keyword">create</span> <span class="keyword">procedure</span> pro_test9(<span class="keyword">month</span> <span class="type">int</span>)<span class="keyword">begin</span>  <span class="keyword">declare</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">20</span>);  <span class="keyword">case</span>     <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span><span class="number">3</span> <span class="keyword">then</span>       <span class="keyword">set</span> <span class="keyword">result</span> <span class="operator">=</span> <span class="string">&#x27;第一季度&#x27;</span>;    <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">4</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span><span class="number">6</span> <span class="keyword">then</span>       <span class="keyword">set</span> <span class="keyword">result</span> <span class="operator">=</span> <span class="string">&#x27;第二季度&#x27;</span>;    <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">7</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span><span class="number">9</span> <span class="keyword">then</span>       <span class="keyword">set</span> <span class="keyword">result</span> <span class="operator">=</span> <span class="string">&#x27;第三季度&#x27;</span>;    <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">10</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span><span class="number">12</span> <span class="keyword">then</span>       <span class="keyword">set</span> <span class="keyword">result</span> <span class="operator">=</span> <span class="string">&#x27;第四季度&#x27;</span>;  <span class="keyword">end</span> <span class="keyword">case</span>;    <span class="keyword">select</span> concat(<span class="string">&#x27;您输入的月份为 :&#x27;</span>, <span class="keyword">month</span> , <span class="string">&#x27; , 该月份为 : &#x27;</span> , <span class="keyword">result</span>) <span class="keyword">as</span> content ;  <span class="keyword">end</span>$delimiter ;</span><br></pre></td></tr></table></figure><h5 id="4-6-5-while循环"><a href="#4-6-5-while循环" class="headerlink" title="4.6.5 while循环"></a>4.6.5 while循环</h5><p>语法结构: </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">while search_condition dostatement_list<span class="keyword">end</span> while;</span><br></pre></td></tr></table></figure><p>需求:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">计算从1加到n的值</span><br></pre></td></tr></table></figure><p>示例  : </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter $<span class="keyword">create</span> <span class="keyword">procedure</span> pro_test8(n <span class="type">int</span>)<span class="keyword">begin</span>  <span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;  <span class="keyword">declare</span> num <span class="type">int</span> <span class="keyword">default</span> <span class="number">1</span>;  while num<span class="operator">&lt;=</span>n do    <span class="keyword">set</span> total <span class="operator">=</span> total <span class="operator">+</span> num;<span class="keyword">set</span> num <span class="operator">=</span> num <span class="operator">+</span> <span class="number">1</span>;  <span class="keyword">end</span> while;  <span class="keyword">select</span> total;<span class="keyword">end</span>$delimiter ;</span><br></pre></td></tr></table></figure><h5 id="4-6-6-repeat结构"><a href="#4-6-6-repeat结构" class="headerlink" title="4.6.6 repeat结构"></a>4.6.6 repeat结构</h5><p>有条件的循环控制语句, 当满足条件的时候退出循环 。while 是满足条件才执行，repeat 是满足条件就退出循环。</p><p>语法结构 : </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">REPEAT  statement_list  UNTIL search_conditionEND REPEAT;</span><br></pre></td></tr></table></figure><p>需求: </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">计算从1加到n的值</span><br></pre></td></tr></table></figure><p>示例  : </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter $<span class="keyword">create</span> <span class="keyword">procedure</span> pro_test10(n <span class="type">int</span>)<span class="keyword">begin</span>  <span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;    repeat     <span class="keyword">set</span> total <span class="operator">=</span> total <span class="operator">+</span> n;    <span class="keyword">set</span> n <span class="operator">=</span> n <span class="operator">-</span> <span class="number">1</span>;    until n<span class="operator">=</span><span class="number">0</span>    <span class="keyword">end</span> repeat;    <span class="keyword">select</span> total ;  <span class="keyword">end</span>$delimiter ;</span><br></pre></td></tr></table></figure><h5 id="4-6-7-loop语句"><a href="#4-6-7-loop语句" class="headerlink" title="4.6.7 loop语句"></a>4.6.7 loop语句</h5><p>LOOP 实现简单的循环，退出循环的条件需要使用其他的语句定义，通常可以使用 LEAVE 语句实现，具体语法如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[begin_label:] LOOP  statement_listEND LOOP [end_label]</span><br></pre></td></tr></table></figure><p>如果不在 statement_list 中增加退出循环的语句，那么 LOOP 语句可以用来实现简单的死循环。</p><h5 id="4-6-8-leave语句"><a href="#4-6-8-leave语句" class="headerlink" title="4.6.8 leave语句"></a>4.6.8 leave语句</h5><p>用来从标注的流程构造中退出，通常和 BEGIN … END 或者循环一起使用。下面是一个使用 LOOP 和 LEAVE 的简单例子 , 退出循环：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter $<span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> pro_test11(n <span class="type">int</span>)<span class="keyword">BEGIN</span>  <span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;    ins: LOOP        IF n <span class="operator">&lt;=</span> <span class="number">0</span> <span class="keyword">then</span>      leave ins;    <span class="keyword">END</span> IF;        <span class="keyword">set</span> total <span class="operator">=</span> total <span class="operator">+</span> n;    <span class="keyword">set</span> n <span class="operator">=</span> n <span class="operator">-</span> <span class="number">1</span>;    <span class="keyword">END</span> LOOP ins;    <span class="keyword">select</span> total;<span class="keyword">END</span>$delimiter ;</span><br></pre></td></tr></table></figure><h5 id="4-6-9-游标-光标"><a href="#4-6-9-游标-光标" class="headerlink" title="4.6.9 游标/光标"></a>4.6.9 游标/光标</h5><p>游标是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用光标对结果集进行循环的处理。光标的使用包括光标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。</p><p>声明光标：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> select_statement ;</span><br></pre></td></tr></table></figure><p>OPEN 光标：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">OPEN</span> cursor_name ;</span><br></pre></td></tr></table></figure><p>FETCH 光标：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FETCH</span> cursor_name <span class="keyword">INTO</span> var_name [, var_name] ...</span><br></pre></td></tr></table></figure><p>CLOSE 光标：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CLOSE</span> cursor_name ;</span><br></pre></td></tr></table></figure><p>示例 : </p><p>初始化脚本:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(  id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment ,  name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;姓名&#x27;</span>,  age <span class="type">int</span>(<span class="number">11</span>) comment <span class="string">&#x27;年龄&#x27;</span>,  salary <span class="type">int</span>(<span class="number">11</span>) comment <span class="string">&#x27;薪水&#x27;</span>,  <span class="keyword">primary</span> key(`id`))engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8 ;<span class="keyword">insert</span> <span class="keyword">into</span> emp(id,name,age,salary) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;金毛狮王&#x27;</span>,<span class="number">55</span>,<span class="number">3800</span>),(<span class="keyword">null</span>,<span class="string">&#x27;白眉鹰王&#x27;</span>,<span class="number">60</span>,<span class="number">4000</span>),(<span class="keyword">null</span>,<span class="string">&#x27;青翼蝠王&#x27;</span>,<span class="number">38</span>,<span class="number">2800</span>),(<span class="keyword">null</span>,<span class="string">&#x27;紫衫龙王&#x27;</span>,<span class="number">42</span>,<span class="number">1800</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询emp表中数据, 并逐行获取进行展示create procedure pro_test11()begin  declare e_id int(11);  declare e_name varchar(50);  declare e_age int(11);  declare e_salary int(11);  declare emp_result cursor for select * from emp;    open emp_result;    fetch emp_result into e_id,e_name,e_age,e_salary;  select concat(&#x27;id=&#x27;,e_id , &#x27;, name=&#x27;,e_name, &#x27;, age=&#x27;, e_age, &#x27;, 薪资为: &#x27;,e_salary);    fetch emp_result into e_id,e_name,e_age,e_salary;  select concat(&#x27;id=&#x27;,e_id , &#x27;, name=&#x27;,e_name, &#x27;, age=&#x27;, e_age, &#x27;, 薪资为: &#x27;,e_salary);    fetch emp_result into e_id,e_name,e_age,e_salary;  select concat(&#x27;id=&#x27;,e_id , &#x27;, name=&#x27;,e_name, &#x27;, age=&#x27;, e_age, &#x27;, 薪资为: &#x27;,e_salary);    fetch emp_result into e_id,e_name,e_age,e_salary;  select concat(&#x27;id=&#x27;,e_id , &#x27;, name=&#x27;,e_name, &#x27;, age=&#x27;, e_age, &#x27;, 薪资为: &#x27;,e_salary);    fetch emp_result into e_id,e_name,e_age,e_salary;  select concat(&#x27;id=&#x27;,e_id , &#x27;, name=&#x27;,e_name, &#x27;, age=&#x27;, e_age, &#x27;, 薪资为: &#x27;,e_salary);    close emp_result;end$</span></span><br></pre></td></tr></table></figure><p>通过循环结构 , 获取游标中的数据 : </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $<span class="keyword">create</span> <span class="keyword">procedure</span> pro_test12()<span class="keyword">begin</span>  <span class="keyword">DECLARE</span> id <span class="type">int</span>(<span class="number">11</span>);  <span class="keyword">DECLARE</span> name <span class="type">varchar</span>(<span class="number">50</span>);  <span class="keyword">DECLARE</span> age <span class="type">int</span>(<span class="number">11</span>);  <span class="keyword">DECLARE</span> salary <span class="type">int</span>(<span class="number">11</span>);  <span class="keyword">DECLARE</span> has_data <span class="type">int</span> <span class="keyword">default</span> <span class="number">1</span>;    <span class="keyword">DECLARE</span> emp_result <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;  <span class="keyword">DECLARE</span> EXIT HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">set</span> has_data <span class="operator">=</span> <span class="number">0</span>;    <span class="keyword">open</span> emp_result;    repeat    <span class="keyword">fetch</span> emp_result <span class="keyword">into</span> id , name , age , salary;    <span class="keyword">select</span> concat(<span class="string">&#x27;id为&#x27;</span>,id, <span class="string">&#x27;, name 为&#x27;</span> ,name , <span class="string">&#x27;, age为 &#x27;</span> ,age , <span class="string">&#x27;, 薪水为: &#x27;</span>, salary);    until has_data <span class="operator">=</span> <span class="number">0</span>  <span class="keyword">end</span> repeat;    <span class="keyword">close</span> emp_result;<span class="keyword">end</span>$DELIMITER ; </span><br></pre></td></tr></table></figure><h4 id="4-7-存储函数"><a href="#4-7-存储函数" class="headerlink" title="4.7 存储函数"></a>4.7 存储函数</h4><p>语法结构:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE FUNCTION function_name([param type ... ]) RETURNS type BEGIN...END;</span><br></pre></td></tr></table></figure><p>案例 : </p><p>定义一个存储过程, 请求满足条件的总记录数 ;</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter $<span class="keyword">create</span> <span class="keyword">function</span> count_city(countryId <span class="type">int</span>)<span class="keyword">returns</span> intbegin  <span class="keyword">declare</span> cnum <span class="type">int</span> ;    <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> cnum <span class="keyword">from</span> city <span class="keyword">where</span> country_id <span class="operator">=</span> countryId;    <span class="keyword">return</span> cnum;<span class="keyword">end</span>$delimiter ;</span><br></pre></td></tr></table></figure><p>调用: </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select count_city(1);select count_city(2);</span><br></pre></td></tr></table></figure><h3 id="5-触发器"><a href="#5-触发器" class="headerlink" title="5. 触发器"></a>5. 触发器</h3><h4 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h4><p>触发器是与表有关的数据库对象，指在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。</p><p>使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p><table><thead><tr><th>触发器类型</th><th>NEW 和 OLD的使用</th></tr></thead><tbody><tr><td>INSERT 型触发器</td><td>NEW 表示将要或者已经新增的数据</td></tr><tr><td>UPDATE 型触发器</td><td>OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据</td></tr><tr><td>DELETE 型触发器</td><td>OLD 表示将要或者已经删除的数据</td></tr></tbody></table><h4 id="5-2-创建触发器"><a href="#5-2-创建触发器" class="headerlink" title="5.2 创建触发器"></a>5.2 创建触发器</h4><p>语法结构 : </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> trigger_name before<span class="operator">/</span>after <span class="keyword">insert</span><span class="operator">/</span>update<span class="operator">/</span>deleteon tbl_name [ <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> ]  <span class="comment">-- 行级触发器begintrigger_stmt ;end;</span></span><br></pre></td></tr></table></figure><p>示例 </p><p>需求</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过触发器记录 emp 表的数据变更日志 , 包含增加, 修改 , 删除 ;</span><br></pre></td></tr></table></figure><p>首先创建一张日志表 : </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp_logs(  id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,  operation <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;操作类型, insert/update/delete&#x27;</span>,  operate_time datetime <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;操作时间&#x27;</span>,  operate_id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;操作表的ID&#x27;</span>,  operate_params <span class="type">varchar</span>(<span class="number">500</span>) comment <span class="string">&#x27;操作参数&#x27;</span>,  <span class="keyword">primary</span> key(`id`))engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>创建 insert 型触发器，完成插入数据时的日志记录 : </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $<span class="keyword">create</span> <span class="keyword">trigger</span> emp_logs_insert_triggerafter <span class="keyword">insert</span> <span class="keyword">on</span> emp <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> <span class="keyword">begin</span>  <span class="keyword">insert</span> <span class="keyword">into</span> emp_logs (id,operation,operate_time,operate_id,operate_params) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;insert&#x27;</span>,now(),new.id,concat(<span class="string">&#x27;插入后(id:&#x27;</span>,new.id,<span class="string">&#x27;, name:&#x27;</span>,new.name,<span class="string">&#x27;, age:&#x27;</span>,new.age,<span class="string">&#x27;, salary:&#x27;</span>,new.salary,<span class="string">&#x27;)&#x27;</span>));<span class="keyword">end</span> $DELIMITER ;</span><br></pre></td></tr></table></figure><p>创建 update 型触发器，完成更新数据时的日志记录 : </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $<span class="keyword">create</span> <span class="keyword">trigger</span> emp_logs_update_triggerafter update <span class="keyword">on</span> emp <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> <span class="keyword">begin</span>  <span class="keyword">insert</span> <span class="keyword">into</span> emp_logs (id,operation,operate_time,operate_id,operate_params) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;update&#x27;</span>,now(),new.id,concat(<span class="string">&#x27;修改前(id:&#x27;</span>,old.id,<span class="string">&#x27;, name:&#x27;</span>,old.name,<span class="string">&#x27;, age:&#x27;</span>,old.age,<span class="string">&#x27;, salary:&#x27;</span>,old.salary,<span class="string">&#x27;) , 修改后(id&#x27;</span>,new.id, <span class="string">&#x27;name:&#x27;</span>,new.name,<span class="string">&#x27;, age:&#x27;</span>,new.age,<span class="string">&#x27;, salary:&#x27;</span>,new.salary,<span class="string">&#x27;)&#x27;</span>));                                                                      <span class="keyword">end</span> $DELIMITER ;</span><br></pre></td></tr></table></figure><p>创建delete 行的触发器 , 完成删除数据时的日志记录 : </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $<span class="keyword">create</span> <span class="keyword">trigger</span> emp_logs_delete_triggerafter <span class="keyword">delete</span> <span class="keyword">on</span> emp <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> <span class="keyword">begin</span>  <span class="keyword">insert</span> <span class="keyword">into</span> emp_logs (id,operation,operate_time,operate_id,operate_params) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;delete&#x27;</span>,now(),old.id,concat(<span class="string">&#x27;删除前(id:&#x27;</span>,old.id,<span class="string">&#x27;, name:&#x27;</span>,old.name,<span class="string">&#x27;, age:&#x27;</span>,old.age,<span class="string">&#x27;, salary:&#x27;</span>,old.salary,<span class="string">&#x27;)&#x27;</span>));                                                                      <span class="keyword">end</span> $DELIMITER ;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(id,name,age,salary) <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="string">&#x27;光明左使&#x27;</span>,<span class="number">30</span>,<span class="number">3500</span>);<span class="keyword">insert</span> <span class="keyword">into</span> emp(id,name,age,salary) <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="string">&#x27;光明右使&#x27;</span>,<span class="number">33</span>,<span class="number">3200</span>);update emp <span class="keyword">set</span> age <span class="operator">=</span> <span class="number">39</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span>;<span class="keyword">delete</span> <span class="keyword">from</span> emp <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h4 id="5-3-删除触发器"><a href="#5-3-删除触发器" class="headerlink" title="5.3 删除触发器"></a>5.3 删除触发器</h4><p>语法结构 : </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop trigger [schema_name.]trigger_name</span><br></pre></td></tr></table></figure><p>如果没有指定 schema_name，默认为当前数据库 。</p><h4 id="5-4-查看触发器"><a href="#5-4-查看触发器" class="headerlink" title="5.4 查看触发器"></a>5.4 查看触发器</h4><p>可以通过执行 SHOW TRIGGERS 命令查看触发器的状态、语法等信息。</p><p>语法结构 ： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show triggers ；</span><br></pre></td></tr></table></figure><h1 id="Mysql高级-day02"><a href="#Mysql高级-day02" class="headerlink" title="Mysql高级-day02"></a>Mysql高级-day02</h1><h3 id="1-Mysql的体系结构概览"><a href="#1-Mysql的体系结构概览" class="headerlink" title="1. Mysql的体系结构概览"></a>1. Mysql的体系结构概览</h3><p><img src="/images/MySQL_hm/2/000001.jpg" alt="171214401286615"> </p><p>整个MySQL Server由以下组成</p><ul><li>Connection Pool : 连接池组件</li><li>Management Services &amp; Utilities : 管理服务和工具组件</li><li>SQL Interface : SQL接口组件</li><li>Parser : 查询分析器组件</li><li>Optimizer : 优化器组件</li><li>Caches &amp; Buffers : 缓冲池组件</li><li>Pluggable Storage Engines : 存储引擎</li><li>File System : 文件系统</li></ul><p>1） 连接层</p><p>最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于 TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p><p>2） 服务层</p><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p><p>3） 引擎层</p><p>存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。</p><p>4）存储层</p><p>数据存储层， 主要是将数据存储在文件系统之上，并完成与存储引擎的交互。</p><p>和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p><h3 id="2-存储引擎"><a href="#2-存储引擎" class="headerlink" title="2. 存储引擎"></a>2. 存储引擎</h3><h4 id="2-1-存储引擎概述"><a href="#2-1-存储引擎概述" class="headerlink" title="2.1 存储引擎概述"></a>2.1 存储引擎概述</h4><p>​    和大多数的数据库不同, MySQL中有一个存储引擎的概念, 针对不同的存储需求可以选择最优的存储引擎。</p><p>​    存储引擎就是存储数据，建立索引，更新查询数据等等技术的实现方式 。存储引擎是基于表的，而不是基于库的。所以存储引擎也可被称为表类型。</p><p>​    Oracle，SqlServer等数据库只有一种存储引擎。MySQL提供了插件式的存储引擎架构。所以MySQL存在多种存储引擎，可以根据需要使用相应引擎，或者编写存储引擎。</p><p>​    MySQL5.0支持的存储引擎包含 ： InnoDB 、MyISAM 、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED等，其中InnoDB和BDB提供事务安全表，其他存储引擎是非事务安全表。</p><p>可以通过指定 show engines ， 来查询当前数据库支持的存储引擎 ： </p><p><img src="/images/MySQL_hm/2/1551186043529.png" alt="1551186043529"> </p><p>创建新表时如果不指定存储引擎，那么系统就会使用默认的存储引擎，MySQL5.5之前的默认存储引擎是MyISAM，5.5之后就改为了InnoDB。</p><p>查看Mysql数据库默认的存储引擎 ， 指令 ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;%storage_engine%&#39; ； </span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/2/1556086372754.png" alt="1556086372754">       </p><h4 id="2-2-各种存储引擎特性"><a href="#2-2-各种存储引擎特性" class="headerlink" title="2.2 各种存储引擎特性"></a>2.2 各种存储引擎特性</h4><p>下面重点介绍几种常用的存储引擎， 并对比各个存储引擎之间的区别， 如下表所示 ： </p><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th><th>MEMORY</th><th>MERGE</th><th>NDB</th></tr></thead><tbody><tr><td>存储限制</td><td>64TB</td><td>有</td><td>有</td><td>没有</td><td>有</td></tr><tr><td>事务安全</td><td>==支持==</td><td></td><td></td><td></td><td></td></tr><tr><td>锁机制</td><td>==行锁(适合高并发)==</td><td>==表锁==</td><td>表锁</td><td>表锁</td><td>行锁</td></tr><tr><td>B树索引</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>哈希索引</td><td></td><td></td><td>支持</td><td></td><td></td></tr><tr><td>全文索引</td><td>支持(5.6版本之后)</td><td>支持</td><td></td><td></td><td></td></tr><tr><td>集群索引</td><td>支持</td><td></td><td></td><td></td><td></td></tr><tr><td>数据索引</td><td>支持</td><td></td><td>支持</td><td></td><td>支持</td></tr><tr><td>索引缓存</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>数据可压缩</td><td></td><td>支持</td><td></td><td></td><td></td></tr><tr><td>空间使用</td><td>高</td><td>低</td><td>N/A</td><td>低</td><td>低</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中等</td><td>低</td><td>高</td></tr><tr><td>批量插入速度</td><td>低</td><td>高</td><td>高</td><td>高</td><td>高</td></tr><tr><td>支持外键</td><td>==支持==</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>下面我们将重点介绍最长使用的两种存储引擎： InnoDB、MyISAM ， 另外两种 MEMORY、MERGE ， 了解即可。</p><h5 id="2-2-1-InnoDB"><a href="#2-2-1-InnoDB" class="headerlink" title="2.2.1 InnoDB"></a>2.2.1 InnoDB</h5><p>​    InnoDB存储引擎是Mysql的默认存储引擎。InnoDB存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保留数据和索引。</p><p>InnoDB存储引擎不同于其他存储引擎的特点 ： </p><p><strong>事务控制</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table goods_innodb(</span><br><span class="line">id int NOT NULL AUTO_INCREMENT,</span><br><span class="line">name varchar(20) NOT NULL,</span><br><span class="line">    primary key(id)</span><br><span class="line">)ENGINE&#x3D;innodb DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start transaction;</span><br><span class="line"></span><br><span class="line">insert into goods_innodb(id,name)values(null,&#39;Meta20&#39;);</span><br><span class="line"></span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/2/1556075130115.png" alt="1556075130115"> </p><p>测试，发现在InnoDB中是存在事务的 ；</p><p><strong>外键约束</strong></p><p>​    MySQL支持外键的存储引擎只有InnoDB ， 在创建外键的时候， 要求父表必须有对应的索引 ， 子表在创建外键的时候， 也会自动的创建对应的索引。</p><p>​    下面两张表中 ， country_innodb是父表 ， country_id为主键索引，city_innodb表是子表，country_id字段为外键，对应于country_innodb表的主键country_id 。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> country_innodb(</span><br><span class="line">country_id <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    country_name <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(country_id)</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> city_innodb(</span><br><span class="line">city_id <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    city_name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    country_id <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(city_id),</span><br><span class="line">    key idx_fk_country_id(country_id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> `fk_city_country` <span class="keyword">FOREIGN</span> KEY(country_id) <span class="keyword">REFERENCES</span> country_innodb(country_id) <span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT <span class="keyword">ON</span> UPDATE CASCADE</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> country_innodb <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;China&#x27;</span>),(<span class="keyword">null</span>,<span class="string">&#x27;America&#x27;</span>),(<span class="keyword">null</span>,<span class="string">&#x27;Japan&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> city_innodb <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Xian&#x27;</span>,<span class="number">1</span>),(<span class="keyword">null</span>,<span class="string">&#x27;NewYork&#x27;</span>,<span class="number">2</span>),(<span class="keyword">null</span>,<span class="string">&#x27;BeiJing&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在创建索引时， 可以指定在删除、更新父表时，对子表进行的相应操作，包括 RESTRICT、CASCADE、SET NULL 和 NO ACTION。</p><p>RESTRICT和NO ACTION相同， 是指限制在子表有关联记录的情况下， 父表不能更新；</p><p>CASCADE表示父表在更新或者删除时，更新或者删除子表对应的记录；</p><p>SET NULL 则表示父表在更新或者删除的时候，子表的对应字段被SET NULL 。</p><p>针对上面创建的两个表， 子表的外键指定是ON DELETE RESTRICT ON UPDATE CASCADE 方式的， 那么在主表删除记录的时候， 如果子表有对应记录， 则不允许删除， 主表在更新记录的时候， 如果子表有对应记录， 则子表对应更新 。</p><p>表中数据如下图所示 ： </p><p><img src="/images/MySQL_hm/2/1556087540767.png" alt="1556087540767"> </p><p>外键信息可以使用如下两种方式查看 ： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show create table city_innodb ;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/2/1556087611295.png" alt="1556087611295">     </p><p>删除country_id为1 的country数据： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from country_innodb where country_id &#x3D; 1;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/2/1556087719145.png" alt="1556087719145"> </p><p>更新主表country表的字段 country_id : </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update country_innodb set country_id &#x3D; 100 where country_id &#x3D; 1;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/2/1556087759615.png" alt="1556087759615">  </p><p>更新后， 子表的数据信息为 ： </p><p><img src="/images/MySQL_hm/2/1556087793738.png" alt="1556087793738">  </p><p><strong>存储方式</strong>    </p><p>InnoDB 存储表和索引有以下两种方式 ： </p><p>①. 使用共享表空间存储， 这种方式创建的表的表结构保存在.frm文件中， 数据和索引保存在 innodb_data_home_dir 和 innodb_data_file_path定义的表空间中，可以是多个文件。</p><p>②. 使用多表空间存储， 这种方式创建的表的表结构仍然存在 .frm 文件中，但是每个表的数据和索引单独保存在 .ibd 中。</p><p><img src="/images/MySQL_hm/2/1556075336630.png" alt="1556075336630"> </p><h5 id="2-2-2-MyISAM"><a href="#2-2-2-MyISAM" class="headerlink" title="2.2.2 MyISAM"></a>2.2.2 MyISAM</h5><p>​    MyISAM 不支持事务、也不支持外键，其优势是访问的速度快，对事务的完整性没有要求或者以SELECT、INSERT为主的应用基本上都可以使用这个引擎来创建表 。有以下两个比较重要的特点： </p><p><strong>不支持事务</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> goods_myisam(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(id)</span><br><span class="line">)ENGINE<span class="operator">=</span>myisam <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p><img src="E:/教学资料/课程营销/Mysql高级/课程资料/day-02/文档/images/MySQL_hm/2/1551347590309.png" alt="1551347590309"> </p><p>通过测试，我们发现，在MyISAM存储引擎中，是没有事务控制的 ；</p><p><strong>文件存储方式</strong></p><p>每个MyISAM在磁盘上存储成3个文件，其文件名都和表名相同，但拓展名分别是 ： </p><p>.frm (存储表定义)；</p><p>.MYD(MYData , 存储数据)；</p><p>.MYI(MYIndex , 存储索引)；</p><p><img src="/images/MySQL_hm/2/1556075073836.png" alt="1556075073836"> </p><h5 id="2-2-3-MEMORY"><a href="#2-2-3-MEMORY" class="headerlink" title="2.2.3 MEMORY"></a>2.2.3 MEMORY</h5><p>​    Memory存储引擎将表的数据存放在内存中。每个MEMORY表实际对应一个磁盘文件，格式是.frm ，该文件中只存储表的结构，而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。MEMORY 类型的表访问非常地快，因为他的数据是存放在内存中的，并且默认使用HASH索引 ， 但是服务一旦关闭，表中的数据就会丢失。</p><h5 id="2-2-4-MERGE"><a href="#2-2-4-MERGE" class="headerlink" title="2.2.4 MERGE"></a>2.2.4 MERGE</h5><p>​    MERGE存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，MERGE表本身并没有存储数据，对MERGE类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行的。</p><p>​    对于MERGE类型表的插入操作，是通过INSERT_METHOD子句定义插入的表，可以有3个不同的值，使用FIRST 或 LAST 值使得插入操作被相应地作用在第一或者最后一个表上，不定义这个子句或者定义为NO，表示不能对这个MERGE表执行插入操作。</p><p>​    可以对MERGE表进行DROP操作，但是这个操作只是删除MERGE表的定义，对内部的表是没有任何影响的。</p><p><img src="/images/MySQL_hm/2/1556076359503.png" alt="1556076359503"> </p><p>下面是一个创建和使用MERGE表的示例 ： </p><p>1）. 创建3个测试表 order_1990, order_1991, order_all , 其中order_all是前两个表的MERGE表 ： </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> order_1990(order_id <span class="type">int</span> ,order_money <span class="keyword">double</span>(<span class="number">10</span>,<span class="number">2</span>),order_address <span class="type">varchar</span>(<span class="number">50</span>),<span class="keyword">primary</span> key (order_id))engine <span class="operator">=</span> myisam <span class="keyword">default</span> charset<span class="operator">=</span>utf8;<span class="keyword">create</span> <span class="keyword">table</span> order_1991(order_id <span class="type">int</span> ,order_money <span class="keyword">double</span>(<span class="number">10</span>,<span class="number">2</span>),order_address <span class="type">varchar</span>(<span class="number">50</span>),<span class="keyword">primary</span> key (order_id))engine <span class="operator">=</span> myisam <span class="keyword">default</span> charset<span class="operator">=</span>utf8;<span class="keyword">create</span> <span class="keyword">table</span> order_all(order_id <span class="type">int</span> ,order_money <span class="keyword">double</span>(<span class="number">10</span>,<span class="number">2</span>),order_address <span class="type">varchar</span>(<span class="number">50</span>),<span class="keyword">primary</span> key (order_id))engine <span class="operator">=</span> <span class="keyword">merge</span> <span class="keyword">union</span> <span class="operator">=</span> (order_1990,order_1991) INSERT_METHOD<span class="operator">=</span><span class="keyword">LAST</span> <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>2）. 分别向两张表中插入记录 </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> order_1990 <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">100.0</span>,<span class="string">&#x27;北京&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> order_1990 <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">100.0</span>,<span class="string">&#x27;上海&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> order_1991 <span class="keyword">values</span>(<span class="number">10</span>,<span class="number">200.0</span>,<span class="string">&#x27;北京&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> order_1991 <span class="keyword">values</span>(<span class="number">11</span>,<span class="number">200.0</span>,<span class="string">&#x27;上海&#x27;</span>);</span><br></pre></td></tr></table></figure><p>3）. 查询3张表中的数据。</p><p>order_1990中的数据 ： </p><p><img src="/images/MySQL_hm/2/1551408083254.png" alt="1551408083254"> </p><p>order_1991中的数据 ： </p><p><img src="/images/MySQL_hm/2/1551408133323.png" alt="1551408133323">  </p><p>order_all中的数据 ：</p><p><img src="/images/MySQL_hm/2/1551408216185.png" alt="1551408216185"> </p><p>​     </p><p>4）. 往order_all中插入一条记录 ，由于在MERGE表定义时，INSERT_METHOD 选择的是LAST，那么插入的数据会想最后一张表中插入。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> order_all <span class="keyword">values</span>(<span class="number">100</span>,<span class="number">10000.0</span>,<span class="string">&#x27;西安&#x27;</span>)；</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/2/1551408519889.png" alt="1551408519889">          </p><h4 id="2-3-存储引擎的选择"><a href="#2-3-存储引擎的选择" class="headerlink" title="2.3 存储引擎的选择"></a>2.3 存储引擎的选择</h4><p>​    在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。以下是几种常用的存储引擎的使用环境。</p><ul><li>InnoDB : 是Mysql的默认存储引擎，用于事务处理应用程序，支持外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询意外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。InnoDB存储引擎除了有效的降低由于删除和更新导致的锁定， 还可以确保事务的完整提交和回滚，对于类似于计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB是最合适的选择。</li><li>MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</li><li>MEMORY：将所有数据保存在RAM中，在需要快速定位记录和其他类似数据环境下，可以提供几块的访问。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。MEMORY表通常用于更新不太频繁的小表，用以快速得到访问结果。</li><li>MERGE：用于将一系列等同的MyISAM表以逻辑方式组合在一起，并作为一个对象引用他们。MERGE表的优点在于可以突破对单个MyISAM表的大小限制，并且通过将不同的表分布在多个磁盘上，可以有效的改善MERGE表的访问效率。这对于存储诸如数据仓储等VLDB环境十分合适。</li></ul><h3 id="3-优化SQL步骤"><a href="#3-优化SQL步骤" class="headerlink" title="3. 优化SQL步骤"></a>3. 优化SQL步骤</h3><p>在应用的的开发过程中，由于初期数据量小，开发人员写 SQL 语句时更重视功能上的实现，但是当应用系统正式上线后，随着生产数据量的急剧增长，很多 SQL 语句开始逐渐显露出性能问题，对生产的影响也越来越大，此时这些有问题的 SQL 语句就成为整个系统性能的瓶颈，因此我们必须要对它们进行优化，本章将详细介绍在 MySQL 中优化 SQL 语句的方法。</p><p>当面对一个有 SQL 性能问题的数据库时，我们应该从何处入手来进行系统的分析，使得能够尽快定位问题 SQL 并尽快解决问题。</p><h4 id="3-1-查看SQL执行频率"><a href="#3-1-查看SQL执行频率" class="headerlink" title="3.1 查看SQL执行频率"></a>3.1 查看SQL执行频率</h4><p>MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。show [session|global] status 可以根据需要加上参数“session”或者“global”来显示 session 级（当前连接）的计结果和 global 级（自数据库上次启动至今）的统计结果。如果不写，默认使用参数是“session”。</p><p>下面的命令显示了当前 session 中所有统计参数的值：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show status like &#39;Com_______&#39;;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/2/1552487172501.png" alt="1552487172501">  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show status like &#39;Innodb_rows_%&#39;;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/2/1552487245859.png" alt="1552487245859"></p><p>Com_xxx 表示每个 xxx 语句执行的次数，我们通常比较关心的是以下几个统计参数。</p><table><thead><tr><th align="left">参数</th><th>含义</th></tr></thead><tbody><tr><td align="left">Com_select</td><td>执行 select 操作的次数，一次查询只累加 1。</td></tr><tr><td align="left">Com_insert</td><td>执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次。</td></tr><tr><td align="left">Com_update</td><td>执行 UPDATE 操作的次数。</td></tr><tr><td align="left">Com_delete</td><td>执行 DELETE 操作的次数。</td></tr><tr><td align="left">Innodb_rows_read</td><td>select 查询返回的行数。</td></tr><tr><td align="left">Innodb_rows_inserted</td><td>执行 INSERT 操作插入的行数。</td></tr><tr><td align="left">Innodb_rows_updated</td><td>执行 UPDATE 操作更新的行数。</td></tr><tr><td align="left">Innodb_rows_deleted</td><td>执行 DELETE 操作删除的行数。</td></tr><tr><td align="left">Connections</td><td>试图连接 MySQL 服务器的次数。</td></tr><tr><td align="left">Uptime</td><td>服务器工作时间。</td></tr><tr><td align="left">Slow_queries</td><td>慢查询的次数。</td></tr></tbody></table><p>Com_***      :  这些参数对于所有存储引擎的表操作都会进行累计。</p><p>Innodb_*** :  这几个参数只是针对InnoDB 存储引擎的，累加的算法也略有不同。</p><h4 id="3-2-定位低效率执行SQL"><a href="#3-2-定位低效率执行SQL" class="headerlink" title="3.2 定位低效率执行SQL"></a>3.2 定位低效率执行SQL</h4><p>可以通过以下两种方式定位执行效率较低的 SQL 语句。</p><ul><li>慢查询日志 : 通过慢查询日志定位那些执行效率较低的 SQL 语句，用–log-slow-queries[=file_name]选项启动时，mysqld 写一个包含所有执行时间超过 long_query_time 秒的 SQL 语句的日志文件。具体可以查看本书第 26 章中日志管理的相关部分。</li><li>show processlist  : 慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用show processlist命令查看当前MySQL在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。</li></ul><p><img src="/images/MySQL_hm/2/1556098544349.png" alt="1556098544349"> </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1） id列，用户登录mysql时，系统分配的&quot;connection_id&quot;，可以使用函数connection_id()查看2） user列，显示当前用户。如果不是root，这个命令就只显示用户权限范围的sql语句3） host列，显示这个语句是从哪个ip的哪个端口上发的，可以用来跟踪出现问题语句的用户4） db列，显示这个进程目前连接的是哪个数据库5） command列，显示当前连接的执行的命令，一般取值为休眠（sleep），查询（query），连接（connect）等6） time列，显示这个状态持续的时间，单位是秒7） state列，显示使用当前连接的sql语句的状态，很重要的列。state描述的是语句执行中的某一个状态。一个sql语句，以查询为例，可能需要经过copying to tmp table、sorting result、sending data等状态才可以完成8） info列，显示这个sql语句，是判断问题语句的一个重要依据</span><br></pre></td></tr></table></figure><h4 id="3-3-explain分析执行计划"><a href="#3-3-explain分析执行计划" class="headerlink" title="3.3 explain分析执行计划"></a>3.3 explain分析执行计划</h4><p>通过以上步骤查询到效率低的 SQL 语句后，可以通过 EXPLAIN或者 DESC命令获取 MySQL如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p><p>查询SQL语句的执行计划 ： </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain  <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_item <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/2/1552487489859.png" alt="1552487489859"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain  <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_item <span class="keyword">where</span> title <span class="operator">=</span> <span class="string">&#x27;阿尔卡特 (OT-979) 冰川白 联通3G手机3&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/2/1552487526919.png" alt="1552487526919">  </p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。</td></tr><tr><td>select_type</td><td>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个 SELECT）等</td></tr><tr><td>table</td><td>输出结果集的表</td></tr><tr><td>type</td><td>表示表的连接类型，性能由好到差的连接类型为( system  —&gt;  const  —–&gt;  eq_ref  ——&gt;  ref  ——-&gt;  ref_or_null—-&gt;  index_merge  —&gt;  index_subquery  —–&gt;  range  —–&gt;  index  ——&gt; all )</td></tr><tr><td>possible_keys</td><td>表示查询时，可能使用的索引</td></tr><tr><td>key</td><td>表示实际使用的索引</td></tr><tr><td>key_len</td><td>索引字段的长度</td></tr><tr><td>rows</td><td>扫描行的数量</td></tr><tr><td>extra</td><td>执行情况的说明和描述</td></tr></tbody></table><h5 id="3-3-1-环境准备"><a href="#3-3-1-环境准备" class="headerlink" title="3.3.1 环境准备"></a>3.3.1 环境准备</h5><p><img src="/images/MySQL_hm/2/1556122799330.png" alt="1556122799330"> </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_role` (  `id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  `role_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,  `role_code` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,  `description` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,  <span class="keyword">PRIMARY</span> KEY (`id`),  <span class="keyword">UNIQUE</span> KEY `unique_role_name` (`role_name`)) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_user` (  `id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  `username` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  `password` <span class="type">varchar</span>(<span class="number">96</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  `name` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  <span class="keyword">PRIMARY</span> KEY (`id`),  <span class="keyword">UNIQUE</span> KEY `unique_user_username` (`username`)) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `user_role` (  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> auto_increment ,  `user_id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,  `role_id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,  <span class="keyword">PRIMARY</span> KEY (`id`),  KEY `fk_ur_user_id` (`user_id`),  KEY `fk_ur_role_id` (`role_id`),  <span class="keyword">CONSTRAINT</span> `fk_ur_role_id` <span class="keyword">FOREIGN</span> KEY (`role_id`) <span class="keyword">REFERENCES</span> `t_role` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> ACTION <span class="keyword">ON</span> UPDATE <span class="keyword">NO</span> ACTION,  <span class="keyword">CONSTRAINT</span> `fk_ur_user_id` <span class="keyword">FOREIGN</span> KEY (`user_id`) <span class="keyword">REFERENCES</span> `t_user` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> ACTION <span class="keyword">ON</span> UPDATE <span class="keyword">NO</span> ACTION) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;<span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;super&#x27;</span>,<span class="string">&#x27;$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#x27;</span>,<span class="string">&#x27;超级管理员&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#x27;</span>,<span class="string">&#x27;系统管理员&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;itcast&#x27;</span>,<span class="string">&#x27;$2a$10$8qmaHgUFUAmPR5pOuWhYWOr291WJYjHelUlYn07k5ELF8ZCrW0Cui&#x27;</span>,<span class="string">&#x27;test02&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;stu1&#x27;</span>,<span class="string">&#x27;$2a$10$pLtt2KDAFpwTWLjNsmTEi.oU1yOZyIn9XkziK/y/spH5rftCpUMZa&#x27;</span>,<span class="string">&#x27;学生1&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;stu2&#x27;</span>,<span class="string">&#x27;$2a$10$nxPKkYSez7uz2YQYUnwhR.z57km3yqKn3Hr/p1FR6ZKgc18u.Tvqm&#x27;</span>,<span class="string">&#x27;学生2&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;t1&#x27;</span>,<span class="string">&#x27;$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#x27;</span>,<span class="string">&#x27;老师1&#x27;</span>);<span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="keyword">VALUES</span>(<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;学生&#x27;</span>,<span class="string">&#x27;student&#x27;</span>,<span class="string">&#x27;学生&#x27;</span>);<span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="keyword">VALUES</span>(<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;老师&#x27;</span>,<span class="string">&#x27;teacher&#x27;</span>,<span class="string">&#x27;老师&#x27;</span>);<span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="keyword">VALUES</span>(<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;教学管理员&#x27;</span>,<span class="string">&#x27;teachmanager&#x27;</span>,<span class="string">&#x27;教学管理员&#x27;</span>);<span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="keyword">VALUES</span>(<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;管理员&#x27;</span>,<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;管理员&#x27;</span>);<span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="keyword">VALUES</span>(<span class="string">&#x27;10&#x27;</span>,<span class="string">&#x27;超级管理员&#x27;</span>,<span class="string">&#x27;super&#x27;</span>,<span class="string">&#x27;超级管理员&#x27;</span>);<span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_role(id,user_id,role_id) <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;5&#x27;</span>),(<span class="keyword">NULL</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;7&#x27;</span>),(<span class="keyword">NULL</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;8&#x27;</span>),(<span class="keyword">NULL</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;9&#x27;</span>),(<span class="keyword">NULL</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;8&#x27;</span>),(<span class="keyword">NULL</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;10&#x27;</span>) ;</span><br></pre></td></tr></table></figure><h5 id="3-3-2-explain-之-id"><a href="#3-3-2-explain-之-id" class="headerlink" title="3.3.2 explain 之 id"></a>3.3.2 explain 之 id</h5><p>id 字段是 select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。id 情况有三种 ： </p><p>1） id 相同表示加载表的顺序是从上到下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from t_role r, t_user u, user_role ur where r.id &#x3D; ur.role_id and u.id &#x3D; ur.user_id ;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/2/1556102471304.png" alt="1556102471304"></p><p>2） id 不同id值越大，优先级越高，越先被执行。 </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_role <span class="keyword">WHERE</span> id <span class="operator">=</span> (<span class="keyword">SELECT</span> role_id <span class="keyword">FROM</span> user_role <span class="keyword">WHERE</span> user_id <span class="operator">=</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;stu1&#x27;</span>))</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/2/1556103009534.png" alt="1556103009534"> </p><p>3） id 有相同，也有不同，同时存在。id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_role r , (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_role ur <span class="keyword">WHERE</span> ur.`user_id` <span class="operator">=</span> <span class="string">&#x27;2&#x27;</span>) a <span class="keyword">WHERE</span> r.id <span class="operator">=</span> a.role_id ; </span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/2/1556103294182.png" alt="1556103294182"> </p><h5 id="3-3-3-explain-之-select-type"><a href="#3-3-3-explain-之-select-type" class="headerlink" title="3.3.3 explain 之 select_type"></a>3.3.3 explain 之 select_type</h5><p> 表示 SELECT 的类型，常见的取值，如下表所示：</p><table><thead><tr><th>select_type</th><th>含义</th></tr></thead><tbody><tr><td>SIMPLE</td><td>简单的select查询，查询中不包含子查询或者UNION</td></tr><tr><td>PRIMARY</td><td>查询中若包含任何复杂的子查询，最外层查询标记为该标识</td></tr><tr><td>SUBQUERY</td><td>在SELECT 或 WHERE 列表中包含了子查询</td></tr><tr><td>DERIVED</td><td>在FROM 列表中包含的子查询，被标记为 DERIVED（衍生） MYSQL会递归执行这些子查询，把结果放在临时表中</td></tr><tr><td>UNION</td><td>若第二个SELECT出现在UNION之后，则标记为UNION ； 若UNION包含在FROM子句的子查询中，外层SELECT将被标记为 ： DERIVED</td></tr><tr><td>UNION RESULT</td><td>从UNION表获取结果的SELECT</td></tr></tbody></table><h5 id="3-3-4-explain-之-table"><a href="#3-3-4-explain-之-table" class="headerlink" title="3.3.4 explain 之 table"></a>3.3.4 explain 之 table</h5><p>展示这一行的数据是关于哪一张表的 </p><h5 id="3-3-5-explain-之-type"><a href="#3-3-5-explain-之-type" class="headerlink" title="3.3.5 explain 之 type"></a>3.3.5 explain 之 type</h5><p>type 显示的是访问类型，是较为重要的一个指标，可取值为： </p><table><thead><tr><th>type</th><th>含义</th></tr></thead><tbody><tr><td>NULL</td><td>MySQL不访问任何表，索引，直接返回结果</td></tr><tr><td>system</td><td>表只有一行记录(等于系统表)，这是const类型的特例，一般不会出现</td></tr><tr><td>const</td><td>表示通过索引一次就找到了，const 用于比较primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL 就能将该查询转换为一个常亮。const于将 “主键” 或 “唯一” 索引的所有部分与常量值进行比较</td></tr><tr><td>eq_ref</td><td>类似ref，区别在于使用的是唯一索引，使用主键的关联查询，关联查询出的记录只有一条。常见于主键或唯一索引扫描</td></tr><tr><td>ref</td><td>非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，返回所有匹配某个单独值的所有行（多个）</td></tr><tr><td>range</td><td>只检索给定返回的行，使用一个索引来选择行。 where 之后出现 between ， &lt; , &gt; , in 等操作。</td></tr><tr><td>index</td><td>index 与 ALL的区别为  index 类型只是遍历了索引树， 通常比ALL 快， ALL 是遍历数据文件。</td></tr><tr><td>all</td><td>将遍历全表以找到匹配的行</td></tr></tbody></table><p>结果值从最好到最坏以此是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NULL &gt; system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALLsystem &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</span><br></pre></td></tr></table></figure><p>==一般来说， 我们需要保证查询至少达到 range 级别， 最好达到ref 。==</p><h5 id="3-3-6-explain-之-key"><a href="#3-3-6-explain-之-key" class="headerlink" title="3.3.6 explain 之  key"></a>3.3.6 explain 之  key</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">possible_keys : 显示可能应用在这张表的索引， 一个或多个。 key ： 实际使用的索引， 如果为NULL， 则没有使用索引。key_len : 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。</span><br></pre></td></tr></table></figure><h5 id="3-3-7-explain-之-rows"><a href="#3-3-7-explain-之-rows" class="headerlink" title="3.3.7 explain 之 rows"></a>3.3.7 explain 之 rows</h5><p>扫描行的数量。</p><h5 id="3-3-8-explain-之-extra"><a href="#3-3-8-explain-之-extra" class="headerlink" title="3.3.8 explain 之 extra"></a>3.3.8 explain 之 extra</h5><p>其他的额外的执行计划信息，在该列展示 。</p><table><thead><tr><th>extra</th><th>含义</th></tr></thead><tbody><tr><td>using  filesort</td><td>说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取， 称为 “文件排序”, 效率低。</td></tr><tr><td>using  temporary</td><td>使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于 order by 和 group by； 效率低</td></tr><tr><td>using  index</td><td>表示相应的select操作使用了覆盖索引， 避免访问表的数据行， 效率不错。</td></tr></tbody></table><h4 id="3-4-show-profile分析SQL"><a href="#3-4-show-profile分析SQL" class="headerlink" title="3.4 show profile分析SQL"></a>3.4 show profile分析SQL</h4><p>Mysql从5.0.37版本开始增加了对 show profiles 和 show profile 语句的支持。show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。</p><p>通过 have_profiling 参数，能够看到当前MySQL是否支持profile：</p><p><img src="/images/MySQL_hm/2/1552488401999.png" alt="1552488401999"> </p><p>默认profiling是关闭的，可以通过set语句在Session级别开启profiling：</p><p><img src="/images/MySQL_hm/2/1552488372405.png" alt="1552488372405"> </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling<span class="operator">=</span><span class="number">1</span>; <span class="operator">/</span><span class="operator">/</span>开启profiling 开关；</span><br></pre></td></tr></table></figure><p>通过profile，我们能够更清楚地了解SQL执行的过程。</p><p>首先，我们可以执行一系列的操作，如下图所示：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;use db01;<span class="keyword">show</span> tables;<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_item <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">5</span>;<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_item;</span><br></pre></td></tr></table></figure><p>执行完上述命令之后，再执行show profiles 指令， 来查看SQL语句执行的耗时：</p><p><img src="/images/MySQL_hm/2/1552489017940.png" alt="1552489017940">  </p><p>通过show  profile for  query  query_id 语句可以查看到该SQL执行过程中每个线程的状态和消耗的时间：</p><p><img src="/images/MySQL_hm/2/1552489053763.png" alt="1552489053763"> </p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">TIP ：Sending data 状态表示MySQL线程开始访问数据行并把结果返回给客户端，而不仅仅是返回个客户端。由于在Sending data状态下，MySQL线程往往需要做大量的磁盘读取操作，所以经常是整各查询中耗时最长的状态。</span><br></pre></td></tr></table></figure><p>在获取到最消耗时间的线程状态后，MySQL支持进一步选择all、cpu、block io 、context switch、page faults等明细类型类查看MySQL在使用什么资源上耗费了过高的时间。例如，选择查看CPU的耗费时间  ：</p><p><img src="/images/MySQL_hm/2/1552489671119.png" alt="1552489671119"> </p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>Status</td><td>sql 语句执行的状态</td></tr><tr><td>Duration</td><td>sql 执行过程中每一个步骤的耗时</td></tr><tr><td>CPU_user</td><td>当前用户占有的cpu</td></tr><tr><td>CPU_system</td><td>系统占有的cpu</td></tr></tbody></table><h4 id="3-5-trace分析优化器执行计划"><a href="#3-5-trace分析优化器执行计划" class="headerlink" title="3.5 trace分析优化器执行计划"></a>3.5 trace分析优化器执行计划</h4><p>MySQL5.6提供了对SQL的跟踪trace, 通过trace文件能够进一步了解为什么优化器选择A计划, 而不是选择B计划。</p><p>打开trace ， 设置格式为 JSON，并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span>&quot;enabled=on&quot;,end_markers_in_json<span class="operator">=</span><span class="keyword">on</span>;<span class="keyword">set</span> optimizer_trace_max_mem_size<span class="operator">=</span><span class="number">1000000</span>;</span><br></pre></td></tr></table></figure><p>执行SQL语句 ：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_item <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>最后， 检查information_schema.optimizer_trace就可以知道MySQL是如何执行SQL的 ：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="code"><pre><span class="line">*************************** 1. row ***************************QUERY: select * from tb_item where id &lt; 4TRACE: &#123;  &quot;steps&quot;: [    &#123;      &quot;join_preparation&quot;: &#123;        &quot;select#&quot;: 1,        &quot;steps&quot;: [          &#123;            &quot;expanded_query&quot;: &quot;/* select#1 */ select `tb_item`.`id` AS `id`,`tb_item`.`title` AS `title`,`tb_item`.`price` AS `price`,`tb_item`.`num` AS `num`,`tb_item`.`categoryid` AS `categoryid`,`tb_item`.`status` AS `status`,`tb_item`.`sellerid` AS `sellerid`,`tb_item`.`createtime` AS `createtime`,`tb_item`.`updatetime` AS `updatetime` from `tb_item` where (`tb_item`.`id` &lt; 4)&quot;          &#125;        ] /* steps */      &#125; /* join_preparation */    &#125;,    &#123;      &quot;join_optimization&quot;: &#123;        &quot;select#&quot;: 1,        &quot;steps&quot;: [          &#123;            &quot;condition_processing&quot;: &#123;              &quot;condition&quot;: &quot;WHERE&quot;,              &quot;original_condition&quot;: &quot;(`tb_item`.`id` &lt; 4)&quot;,              &quot;steps&quot;: [                &#123;                  &quot;transformation&quot;: &quot;equality_propagation&quot;,                  &quot;resulting_condition&quot;: &quot;(`tb_item`.`id` &lt; 4)&quot;                &#125;,                &#123;                  &quot;transformation&quot;: &quot;constant_propagation&quot;,                  &quot;resulting_condition&quot;: &quot;(`tb_item`.`id` &lt; 4)&quot;                &#125;,                &#123;                  &quot;transformation&quot;: &quot;trivial_condition_removal&quot;,                  &quot;resulting_condition&quot;: &quot;(`tb_item`.`id` &lt; 4)&quot;                &#125;              ] /* steps */            &#125; /* condition_processing */          &#125;,          &#123;            &quot;table_dependencies&quot;: [              &#123;                &quot;table&quot;: &quot;`tb_item`&quot;,                &quot;row_may_be_null&quot;: false,                &quot;map_bit&quot;: 0,                &quot;depends_on_map_bits&quot;: [                ] /* depends_on_map_bits */              &#125;            ] /* table_dependencies */          &#125;,          &#123;            &quot;ref_optimizer_key_uses&quot;: [            ] /* ref_optimizer_key_uses */          &#125;,          &#123;            &quot;rows_estimation&quot;: [              &#123;                &quot;table&quot;: &quot;`tb_item`&quot;,                &quot;range_analysis&quot;: &#123;                  &quot;table_scan&quot;: &#123;                    &quot;rows&quot;: 9816098,                    &quot;cost&quot;: 2.04e6                  &#125; /* table_scan */,                  &quot;potential_range_indices&quot;: [                    &#123;                      &quot;index&quot;: &quot;PRIMARY&quot;,                      &quot;usable&quot;: true,                      &quot;key_parts&quot;: [                        &quot;id&quot;                      ] /* key_parts */                    &#125;                  ] /* potential_range_indices */,                  &quot;setup_range_conditions&quot;: [                  ] /* setup_range_conditions */,                  &quot;group_index_range&quot;: &#123;                    &quot;chosen&quot;: false,                    &quot;cause&quot;: &quot;not_group_by_or_distinct&quot;                  &#125; /* group_index_range */,                  &quot;analyzing_range_alternatives&quot;: &#123;                    &quot;range_scan_alternatives&quot;: [                      &#123;                        &quot;index&quot;: &quot;PRIMARY&quot;,                        &quot;ranges&quot;: [                          &quot;id &lt; 4&quot;                        ] /* ranges */,                        &quot;index_dives_for_eq_ranges&quot;: true,                        &quot;rowid_ordered&quot;: true,                        &quot;using_mrr&quot;: false,                        &quot;index_only&quot;: false,                        &quot;rows&quot;: 3,                        &quot;cost&quot;: 1.6154,                        &quot;chosen&quot;: true                      &#125;                    ] /* range_scan_alternatives */,                    &quot;analyzing_roworder_intersect&quot;: &#123;                      &quot;usable&quot;: false,                      &quot;cause&quot;: &quot;too_few_roworder_scans&quot;                    &#125; /* analyzing_roworder_intersect */                  &#125; /* analyzing_range_alternatives */,                  &quot;chosen_range_access_summary&quot;: &#123;                    &quot;range_access_plan&quot;: &#123;                      &quot;type&quot;: &quot;range_scan&quot;,                      &quot;index&quot;: &quot;PRIMARY&quot;,                      &quot;rows&quot;: 3,                      &quot;ranges&quot;: [                        &quot;id &lt; 4&quot;                      ] /* ranges */                    &#125; /* range_access_plan */,                    &quot;rows_for_plan&quot;: 3,                    &quot;cost_for_plan&quot;: 1.6154,                    &quot;chosen&quot;: true                  &#125; /* chosen_range_access_summary */                &#125; /* range_analysis */              &#125;            ] /* rows_estimation */          &#125;,          &#123;            &quot;considered_execution_plans&quot;: [              &#123;                &quot;plan_prefix&quot;: [                ] /* plan_prefix */,                &quot;table&quot;: &quot;`tb_item`&quot;,                &quot;best_access_path&quot;: &#123;                  &quot;considered_access_paths&quot;: [                    &#123;                      &quot;access_type&quot;: &quot;range&quot;,                      &quot;rows&quot;: 3,                      &quot;cost&quot;: 2.2154,                      &quot;chosen&quot;: true                    &#125;                  ] /* considered_access_paths */                &#125; /* best_access_path */,                &quot;cost_for_plan&quot;: 2.2154,                &quot;rows_for_plan&quot;: 3,                &quot;chosen&quot;: true              &#125;            ] /* considered_execution_plans */          &#125;,          &#123;            &quot;attaching_conditions_to_tables&quot;: &#123;              &quot;original_condition&quot;: &quot;(`tb_item`.`id` &lt; 4)&quot;,              &quot;attached_conditions_computation&quot;: [              ] /* attached_conditions_computation */,              &quot;attached_conditions_summary&quot;: [                &#123;                  &quot;table&quot;: &quot;`tb_item`&quot;,                  &quot;attached&quot;: &quot;(`tb_item`.`id` &lt; 4)&quot;                &#125;              ] /* attached_conditions_summary */            &#125; /* attaching_conditions_to_tables */          &#125;,          &#123;            &quot;refine_plan&quot;: [              &#123;                &quot;table&quot;: &quot;`tb_item`&quot;,                &quot;access_type&quot;: &quot;range&quot;              &#125;            ] /* refine_plan */          &#125;        ] /* steps */      &#125; /* join_optimization */    &#125;,    &#123;      &quot;join_execution&quot;: &#123;        &quot;select#&quot;: 1,        &quot;steps&quot;: [        ] /* steps */      &#125; /* join_execution */    &#125;  ] /* steps */&#125;</span><br></pre></td></tr></table></figure><h3 id="4-索引的使用"><a href="#4-索引的使用" class="headerlink" title="4. 索引的使用"></a>4. 索引的使用</h3><p>索引是数据库优化最常用也是最重要的手段之一, 通过索引通常可以帮助用户解决大多数的MySQL的性能优化问题。</p><h4 id="4-1-验证索引提升查询效率"><a href="#4-1-验证索引提升查询效率" class="headerlink" title="4.1 验证索引提升查询效率"></a>4.1 验证索引提升查询效率</h4><p>在我们准备的表结构tb_item 中， 一共存储了 300 万记录；</p><p>A. 根据ID查询 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tb_item where id &#x3D; 1999\G;</span><br></pre></td></tr></table></figure><p><img src="E:/教学资料/课程营销/Mysql高级/课程资料/day-02/文档/images/MySQL_hm/2/1553261992653.png" alt="1553261992653"> </p><p>查询速度很快， 接近0s ， 主要的原因是因为id为主键， 有索引；</p><p><img src="E:/教学资料/课程营销/Mysql高级/课程资料/day-02/文档/images/MySQL_hm/2/1553262044466.png" alt="1553262044466"> </p><p>2). 根据 title 进行精确查询</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_item <span class="keyword">where</span> title <span class="operator">=</span> <span class="string">&#x27;iphoneX 移动3G 32G941&#x27;</span>\G; </span><br></pre></td></tr></table></figure><p><img src="E:/教学资料/课程营销/Mysql高级/课程资料/day-02/文档/images/MySQL_hm/2/1553262215900.png" alt="1553262215900"> </p><p>查看SQL语句的执行计划 ： </p><p><img src="E:/教学资料/课程营销/Mysql高级/课程资料/day-02/文档/images/MySQL_hm/2/1553262469785.png" alt="1553262469785"> </p><p>处理方案 ， 针对title字段， 创建索引 ： </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_item_title <span class="keyword">on</span> tb_item(title);</span><br></pre></td></tr></table></figure><p><img src="E:/教学资料/课程营销/Mysql高级/课程资料/day-02/文档/images/MySQL_hm/2/1553263229523.png" alt="1553263229523"> </p><p>索引创建完成之后，再次进行查询 ： </p><p><img src="E:/教学资料/课程营销/Mysql高级/课程资料/day-02/文档/images/MySQL_hm/2/1553263302706.png" alt="1553263302706"> </p><p>通过explain ， 查看执行计划，执行SQL时使用了刚才创建的索引 </p><p><img src="E:/教学资料/课程营销/Mysql高级/课程资料/day-02/文档/images/MySQL_hm/2/1553263355262.png" alt="1553263355262"> </p><h4 id="4-2-索引的使用"><a href="#4-2-索引的使用" class="headerlink" title="4.2 索引的使用"></a>4.2 索引的使用</h4><h5 id="4-2-1-准备环境"><a href="#4-2-1-准备环境" class="headerlink" title="4.2.1 准备环境"></a>4.2.1 准备环境</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `tb_seller` (`sellerid` <span class="type">varchar</span> (<span class="number">100</span>),`name` <span class="type">varchar</span> (<span class="number">100</span>),`nickname` <span class="type">varchar</span> (<span class="number">50</span>),`password` <span class="type">varchar</span> (<span class="number">60</span>),`status` <span class="type">varchar</span> (<span class="number">1</span>),`address` <span class="type">varchar</span> (<span class="number">100</span>),`createtime` datetime,    <span class="keyword">primary</span> key(`sellerid`))engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8mb4; <span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;alibaba&#x27;</span>,<span class="string">&#x27;阿里巴巴&#x27;</span>,<span class="string">&#x27;阿里小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;baidu&#x27;</span>,<span class="string">&#x27;百度科技有限公司&#x27;</span>,<span class="string">&#x27;百度小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;huawei&#x27;</span>,<span class="string">&#x27;华为科技有限公司&#x27;</span>,<span class="string">&#x27;华为小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;itcast&#x27;</span>,<span class="string">&#x27;传智播客教育科技有限公司&#x27;</span>,<span class="string">&#x27;传智播客&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;itheima&#x27;</span>,<span class="string">&#x27;黑马程序员&#x27;</span>,<span class="string">&#x27;黑马程序员&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;luoji&#x27;</span>,<span class="string">&#x27;罗技科技有限公司&#x27;</span>,<span class="string">&#x27;罗技小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;oppo&#x27;</span>,<span class="string">&#x27;OPPO科技有限公司&#x27;</span>,<span class="string">&#x27;OPPO官方旗舰店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;ourpalm&#x27;</span>,<span class="string">&#x27;掌趣科技股份有限公司&#x27;</span>,<span class="string">&#x27;掌趣小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;qiandu&#x27;</span>,<span class="string">&#x27;千度科技&#x27;</span>,<span class="string">&#x27;千度小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;sina&#x27;</span>,<span class="string">&#x27;新浪科技有限公司&#x27;</span>,<span class="string">&#x27;新浪官方旗舰店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;xiaomi&#x27;</span>,<span class="string">&#x27;小米科技&#x27;</span>,<span class="string">&#x27;小米官方旗舰店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;西安市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;yijia&#x27;</span>,<span class="string">&#x27;宜家家居&#x27;</span>,<span class="string">&#x27;宜家家居旗舰店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);<span class="keyword">create</span> index idx_seller_name_sta_addr <span class="keyword">on</span> tb_seller(name,status,address);</span><br></pre></td></tr></table></figure><h5 id="4-2-2-避免索引失效"><a href="#4-2-2-避免索引失效" class="headerlink" title="4.2.2 避免索引失效"></a>4.2.2 避免索引失效</h5><p>1).  全值匹配 ，对索引中所有列都指定具体值。</p><p>改情况下，索引生效，执行效率高。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;北京市&#x27;</span>\G;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/2/1556170997921.png" alt="1556170997921"> </p><p>2). 最左前缀法则</p><p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。</p><p>匹配最左前缀法则，走索引：</p><p><img src="/images/MySQL_hm/2/1556171348995.png" alt="1556171348995">  </p><p>违法最左前缀法则 ， 索引失效：</p><p><img src="/images/MySQL_hm/2/1556171428140.png" alt="1556171428140"> </p><p>如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效：</p><p><img src="/images/MySQL_hm/2/1556171662203.png" alt="1556171662203"> </p><p>3). 范围查询右边的列，不能使用索引 。</p><p><img src="/images/MySQL_hm/2/1556172256791.png" alt="1556172256791"> </p><p>根据前面的两个字段name ， status 查询是走索引的， 但是最后一个条件address 没有用到索引。</p><p>4). 不要在索引列上进行运算操作， 索引将失效。</p><p><img src="/images/MySQL_hm/2/1556172813715.png" alt="1556172813715"> </p><p>5). 字符串不加单引号，造成索引失效。</p><p><img src="/images/MySQL_hm/2/1556172967493.png" alt="1556172967493"> </p><p>由于，在查询是，没有对字符串加单引号，MySQL的查询优化器，会自动的进行类型转换，造成索引失效。</p><p>6). 尽量使用覆盖索引，避免select *</p><p>尽量使用覆盖索引（只访问索引的查询（索引列完全包含查询列）），减少select * 。</p><p><img src="/images/MySQL_hm/2/1556173928299.png" alt="1556173928299"> </p><p>如果查询列，超出索引列，也会降低性能。</p><p><img src="/images/MySQL_hm/2/1556173986068.png" alt="1556173986068"> </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TIP :     using index ：使用覆盖索引的时候就会出现    using where：在查找使用索引的情况下，需要回表去查询所需的数据    using index condition：查找使用了索引，但是需要回表查询数据    using index ; using where：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据</span><br></pre></td></tr></table></figure><p>7). 用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</p><p>示例，name字段是索引列 ， 而createtime不是索引列，中间是or进行连接是不走索引的 ： </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;黑马程序员&#x27;</span> <span class="keyword">or</span> createtime <span class="operator">=</span> <span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>\G;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/2/1556174994440.png" alt="1556174994440"> </p><p>8).  以%开头的Like模糊查询，索引失效。</p><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p><p><img src="/images/MySQL_hm/2/1556175114369.png" alt="1556175114369"> </p><p>解决方案 ： </p><p>通过覆盖索引来解决 </p><p><img src="/images/MySQL_hm/2/1556247686483.png" alt="1556247686483"> </p><p>9). 如果MySQL评估使用索引比全表更慢，则不使用索引。</p><p><img src="/images/MySQL_hm/2/1556175445210.png" alt="1556175445210"> </p><p>10). is  NULL ， is NOT NULL  <font color='red'>有时</font>索引失效。</p><p><img src="/images/MySQL_hm/2/1556180634889.png" alt="1556180634889">  </p><p>11). in 走索引， not in 索引失效。</p><p><img src="/images/MySQL_hm/2/1556249602732.png" alt="1556249602732">  </p><p>12). 单列索引和复合索引。</p><p>尽量使用复合索引，而少使用单列索引 。</p><p>创建复合索引 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create index idx_name_sta_address on tb_seller(name, status, address);就相当于创建了三个索引 ： namename + statusname + status + address</span><br></pre></td></tr></table></figure><p>创建单列索引 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create index idx_seller_name on tb_seller(name);create index idx_seller_status on tb_seller(status);create index idx_seller_address on tb_seller(address);</span><br></pre></td></tr></table></figure><p>数据库会选择一个最优的索引（辨识度最高索引）来使用，并不会使用全部索引 。</p><h4 id="4-3-查看索引使用情况"><a href="#4-3-查看索引使用情况" class="headerlink" title="4.3 查看索引使用情况"></a>4.3 查看索引使用情况</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Handler_read%&#x27;</span>;<span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Handler_read%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/2/1552885364563.png" alt="1552885364563"> </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Handler_read_first：索引中第一条被读的次数。如果较高，表示服务器正执行大量全索引扫描（这个值越低越好）。Handler_read_key：如果索引正在工作，这个值代表一个行被索引值读的次数，如果值越低，表示索引得到的性能改善不高，因为索引不经常使用（这个值越高越好）。Handler_read_next ：按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加。Handler_read_prev：按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY ... DESC。Handler_read_rnd ：根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。这个值较高，意味着运行效率低，应该建立索引来补救。Handler_read_rnd_next：在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。</span><br></pre></td></tr></table></figure><h3 id="5-SQL优化"><a href="#5-SQL优化" class="headerlink" title="5. SQL优化"></a>5. SQL优化</h3><h4 id="5-1-大批量插入数据"><a href="#5-1-大批量插入数据" class="headerlink" title="5.1 大批量插入数据"></a>5.1 大批量插入数据</h4><p>环境准备 ： </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_user_2` (  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,  `username` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  `password` <span class="type">varchar</span>(<span class="number">96</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  `name` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  `birthday` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,  `sex` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,  `email` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,  `phone` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,  `qq` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,  `status` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户状态&#x27;</span>,  `create_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  `update_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,  <span class="keyword">PRIMARY</span> KEY (`id`),  <span class="keyword">UNIQUE</span> KEY `unique_user_username` (`username`)) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ;</span><br></pre></td></tr></table></figure><p>当使用load 命令导入数据的时候，适当的设置可以提高导入的效率。</p><p><img src="/images/MySQL_hm/2/1556269346488.png" alt="1556269346488"> </p><p>对于 InnoDB 类型的表，有以下几种方式可以提高导入的效率：</p><p>1） 主键顺序插入</p><p>因为InnoDB类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。如果InnoDB表没有主键，那么系统会自动默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这点，来提高导入数据的效率。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">脚本文件介绍 :sql1.log  ----&gt; 主键有序sql2.log  ----&gt; 主键无序</span><br></pre></td></tr></table></figure><p>插入ID顺序排列数据：</p><p><img src="/images/MySQL_hm/2/1555771750567.png" alt="1555771750567"></p><p>插入ID无序排列数据：</p><p><img src="/images/MySQL_hm/2/1555771959734.png" alt="1555771959734"> </p><p>2） 关闭唯一性校验</p><p>在导入数据前执行 SET UNIQUE_CHECKS=0，关闭唯一性校验，在导入结束后执行SET UNIQUE_CHECKS=1，恢复唯一性校验，可以提高导入的效率。</p><p><img src="/images/MySQL_hm/2/1555772132736.png" alt="1555772132736"> </p><p>3） 手动提交事务</p><p>如果应用使用自动提交的方式，建议在导入前执行 SET AUTOCOMMIT=0，关闭自动提交，导入结束后再执行 SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率。</p><p><img src="/images/MySQL_hm/2/1555772351208.png" alt="1555772351208"></p><h4 id="5-2-优化insert语句"><a href="#5-2-优化insert语句" class="headerlink" title="5.2 优化insert语句"></a>5.2 优化insert语句</h4><p>当进行数据的insert操作的时候，可以考虑采用以下几种优化方案。</p><ul><li><p>如果需要同时对一张表插入很多行数据时，应该尽量使用多个值表的insert语句，这种方式将大大的缩减客户端与数据库之间的连接、关闭等消耗。使得效率比分开执行的单个insert语句快。</p><p>示例， 原始方式为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br></pre></td></tr></table></figure><p>优化后的方案为 ： </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>)，(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>在事务中进行数据插入。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;<span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);<span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></li><li><p>数据有序插入</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;Tim&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;Rose&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>);</span><br></pre></td></tr></table></figure><p>优化后</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;Tim&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;Rose&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-3-优化order-by语句"><a href="#5-3-优化order-by语句" class="headerlink" title="5.3 优化order by语句"></a>5.3 优化order by语句</h4><h5 id="5-3-1-环境准备"><a href="#5-3-1-环境准备" class="headerlink" title="5.3.1 环境准备"></a>5.3.1 环境准备</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `emp` (  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,  `name` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  `age` <span class="type">int</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  `salary` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,  <span class="keyword">PRIMARY</span> KEY (`id`)) ENGINE<span class="operator">=</span>InnoDB  <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;<span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;25&#x27;</span>,<span class="string">&#x27;2300&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;Jerry&#x27;</span>,<span class="string">&#x27;30&#x27;</span>,<span class="string">&#x27;3500&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;Luci&#x27;</span>,<span class="string">&#x27;25&#x27;</span>,<span class="string">&#x27;2800&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;Jay&#x27;</span>,<span class="string">&#x27;36&#x27;</span>,<span class="string">&#x27;3500&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;Tom2&#x27;</span>,<span class="string">&#x27;21&#x27;</span>,<span class="string">&#x27;2200&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;Jerry2&#x27;</span>,<span class="string">&#x27;31&#x27;</span>,<span class="string">&#x27;3300&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;Luci2&#x27;</span>,<span class="string">&#x27;26&#x27;</span>,<span class="string">&#x27;2700&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;Jay2&#x27;</span>,<span class="string">&#x27;33&#x27;</span>,<span class="string">&#x27;3500&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;Tom3&#x27;</span>,<span class="string">&#x27;23&#x27;</span>,<span class="string">&#x27;2400&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;10&#x27;</span>,<span class="string">&#x27;Jerry3&#x27;</span>,<span class="string">&#x27;32&#x27;</span>,<span class="string">&#x27;3100&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;11&#x27;</span>,<span class="string">&#x27;Luci3&#x27;</span>,<span class="string">&#x27;26&#x27;</span>,<span class="string">&#x27;2900&#x27;</span>);<span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;12&#x27;</span>,<span class="string">&#x27;Jay3&#x27;</span>,<span class="string">&#x27;37&#x27;</span>,<span class="string">&#x27;4500&#x27;</span>);<span class="keyword">create</span> index idx_emp_age_salary <span class="keyword">on</span> emp(age,salary);</span><br></pre></td></tr></table></figure><h5 id="5-3-2-两种排序方式"><a href="#5-3-2-两种排序方式" class="headerlink" title="5.3.2 两种排序方式"></a>5.3.2 两种排序方式</h5><p>1). 第一种是通过对返回数据进行排序，也就是通常说的 filesort 排序，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</p><p><img src="/images/MySQL_hm/2/1556335817763.png" alt="1556335817763"> </p><p>2). 第二种通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。</p><p><img src="/images/MySQL_hm/2/1556335866539.png" alt="1556335866539"> </p><p>多字段排序</p><p><img src="/images/MySQL_hm/2/1556336352061.png" alt="1556336352061"> </p><p>了解了MySQL的排序方式，优化目标就清晰了：尽量减少额外的排序，通过索引直接返回有序数据。where 条件和Order by 使用相同的索引，并且Order By 的顺序和索引顺序相同， 并且Order  by 的字段都是升序，或者都是降序。否则肯定需要额外的操作，这样就会出现FileSort。</p><h5 id="5-3-3-Filesort-的优化"><a href="#5-3-3-Filesort-的优化" class="headerlink" title="5.3.3 Filesort 的优化"></a>5.3.3 Filesort 的优化</h5><p>通过创建合适的索引，能够减少 Filesort 的出现，但是在某些情况下，条件限制不能让Filesort消失，那就需要加快 Filesort的排序操作。对于Filesort ， MySQL 有两种排序算法：</p><p>1） 两次扫描算法 ：MySQL4.1 之前，使用该方式排序。首先根据条件取出排序字段和行指针信息，然后在排序区 sort buffer 中排序，如果sort buffer不够，则在临时表 temporary table 中存储排序结果。完成排序之后，再根据行指针回表读取记录，该操作可能会导致大量随机I/O操作。</p><p>2）一次扫描算法：一次性取出满足条件的所有字段，然后在排序区 sort  buffer 中排序后直接输出结果集。排序时内存开销较大，但是排序效率比两次扫描算法要高。</p><p>MySQL 通过比较系统变量 max_length_for_sort_data 的大小和Query语句取出的字段总大小， 来判定是否那种排序算法，如果max_length_for_sort_data 更大，那么使用第二种优化之后的算法；否则使用第一种。</p><p>可以适当提高 sort_buffer_size  和 max_length_for_sort_data  系统变量，来增大排序区的大小，提高排序的效率。</p><p><img src="/images/MySQL_hm/2/1556338367593.png" alt="1556338367593"> </p><h4 id="5-4-优化group-by-语句"><a href="#5-4-优化group-by-语句" class="headerlink" title="5.4 优化group by 语句"></a>5.4 优化group by 语句</h4><p>由于GROUP BY 实际上也同样会进行排序操作，而且与ORDER BY 相比，GROUP BY 主要只是多了排序之后的分组操作。当然，如果在分组的时候还使用了其他的一些聚合函数，那么还需要一些聚合函数的计算。所以，在GROUP BY 的实现过程中，与 ORDER BY 一样也可以利用到索引。</p><p>如果查询包含 group by 但是用户想要避免排序结果的消耗， 则可以执行order by null 禁止排序。如下 ：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> index idx_emp_age_salary <span class="keyword">on</span> emp;explain <span class="keyword">select</span> age,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> age;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/2/1556339573979.png" alt="1556339573979">  </p><p>优化后</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> age,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> age <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/2/1556339633161.png" alt="1556339633161">  </p><p>从上面的例子可以看出，第一个SQL语句需要进行”filesort”，而第二个SQL由于order  by  null 不需要进行 “filesort”， 而上文提过Filesort往往非常耗费时间。</p><p>创建索引 ：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_emp_age_salary <span class="keyword">on</span> emp(age,salary)；</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/2/1556339688158.png" alt="1556339688158"> </p><h4 id="5-5-优化嵌套查询"><a href="#5-5-优化嵌套查询" class="headerlink" title="5.5 优化嵌套查询"></a>5.5 优化嵌套查询</h4><p>Mysql4.1版本之后，开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询是可以被更高效的连接（JOIN）替代。</p><p>示例 ，查找有角色的所有的用户信息 : </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="keyword">select</span> user_id <span class="keyword">from</span> user_role );</span><br></pre></td></tr></table></figure><p>执行计划为 : </p><p><img src="/images/MySQL_hm/2/1556359399199.png" alt="1556359399199">   </p><p>优化后 :</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user u , user_role ur <span class="keyword">where</span> u.id <span class="operator">=</span> ur.user_id;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/2/1556359482142.png" alt="1556359482142">   </p><p>连接(Join)查询之所以更有效率一些 ，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上需要两个步骤的查询工作。</p><h4 id="5-6-优化OR条件"><a href="#5-6-优化OR条件" class="headerlink" title="5.6 优化OR条件"></a>5.6 优化OR条件</h4><p>对于包含OR的查询子句，如果要利用索引，则OR之间的每个条件列都必须用到索引 ， 而且不能使用到复合索引； 如果没有索引，则应该考虑增加索引。</p><p>获取 emp 表中的所有的索引 ： </p><p><img src="/images/MySQL_hm/2/1556354464657.png" alt="1556354464657">  </p><p>示例 ： </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/2/1556354887509.png" alt="1556354887509"></p><p><img src="/images/MySQL_hm/2/1556354920964.png" alt="1556354920964">  </p><p>建议使用 union 替换 or ： </p><p><img src="/images/MySQL_hm/2/1556355027728.png" alt="1556355027728"> </p><p>我们来比较下重要指标，发现主要差别是 type 和 ref 这两项</p><p>type 显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null  &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</span><br></pre></td></tr></table></figure><p>UNION 语句的 type 值为 ref，OR 语句的 type 值为 range，可以看到这是一个很明显的差距</p><p>UNION 语句的 ref 值为 const，OR 语句的 type 值为 null，const 表示是常量值引用，非常快</p><p>这两项的差距就说明了 UNION 要优于 OR 。</p><h4 id="5-7-优化分页查询"><a href="#5-7-优化分页查询" class="headerlink" title="5.7 优化分页查询"></a>5.7 优化分页查询</h4><p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是 limit 2000000,10  ，此时需要MySQL排序前2000010 记录，仅仅返回2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。</p><p><img src="/images/MySQL_hm/2/1556361314783.png" alt="1556361314783"> </p><h5 id="5-7-1-优化思路一"><a href="#5-7-1-优化思路一" class="headerlink" title="5.7.1 优化思路一"></a>5.7.1 优化思路一</h5><p>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</p><p><img src="/images/MySQL_hm/2/1556416102800.png" alt="1556416102800"> </p><h5 id="5-7-2-优化思路二"><a href="#5-7-2-优化思路二" class="headerlink" title="5.7.2 优化思路二"></a>5.7.2 优化思路二</h5><p>该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询 。</p><p><img src="/images/MySQL_hm/2/1556363928151.png" alt="1556363928151"> </p><h4 id="5-8-使用SQL提示"><a href="#5-8-使用SQL提示" class="headerlink" title="5.8 使用SQL提示"></a>5.8 使用SQL提示</h4><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><h5 id="5-8-1-USE-INDEX"><a href="#5-8-1-USE-INDEX" class="headerlink" title="5.8.1 USE INDEX"></a>5.8.1 USE INDEX</h5><p>在查询语句中表名的后面，添加 use index 来提供希望MySQL去参考的索引列表，就可以让MySQL不再考虑其他可用的索引。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create index idx_seller_name on tb_seller(name);</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/2/1556370971576.png" alt="1556370971576"> </p><h5 id="5-8-2-IGNORE-INDEX"><a href="#5-8-2-IGNORE-INDEX" class="headerlink" title="5.8.2 IGNORE INDEX"></a>5.8.2 IGNORE INDEX</h5><p>如果用户只是单纯的想让MySQL忽略一个或者多个索引，则可以使用 ignore index 作为 hint 。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from tb_seller ignore index(idx_seller_name) where name &#x3D; &#39;小米科技&#39;;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/2/1556371004594.png" alt="1556371004594"> </p><h5 id="5-8-3-FORCE-INDEX"><a href="#5-8-3-FORCE-INDEX" class="headerlink" title="5.8.3 FORCE INDEX"></a>5.8.3 FORCE INDEX</h5><p>为强制MySQL使用一个特定的索引，可在查询中使用 force index 作为hint 。 </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_seller_address <span class="keyword">on</span> tb_seller(address);</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/2/1556371355788.png" alt="1556371355788"> </p><h1 id="Mysql高级-day03"><a href="#Mysql高级-day03" class="headerlink" title="Mysql高级-day03"></a>Mysql高级-day03</h1><h3 id="1-应用优化"><a href="#1-应用优化" class="headerlink" title="1. 应用优化"></a>1. 应用优化</h3><p>前面章节，我们介绍了很多数据库的优化措施。但是在实际生产环境中，由于数据库本身的性能局限，就必须要对前台的应用进行一些优化，来降低数据库的访问压力。</p><h4 id="1-1-使用连接池"><a href="#1-1-使用连接池" class="headerlink" title="1.1 使用连接池"></a>1.1 使用连接池</h4><p>对于访问数据库来说，建立连接的代价是比较昂贵的，因为我们频繁的创建关闭连接，是比较耗费资源的，我们有必要建立 数据库连接池，以提高访问的性能。</p><h4 id="1-2-减少对MySQL的访问"><a href="#1-2-减少对MySQL的访问" class="headerlink" title="1.2 减少对MySQL的访问"></a>1.2 减少对MySQL的访问</h4><h5 id="1-2-1-避免对数据进行重复检索"><a href="#1-2-1-避免对数据进行重复检索" class="headerlink" title="1.2.1 避免对数据进行重复检索"></a>1.2.1 避免对数据进行重复检索</h5><p>在编写应用代码时，需要能够理清对数据库的访问逻辑。能够一次连接就获取到结果的，就不用两次连接，这样可以大大减少对数据库无用的重复请求。</p><p>比如 ，需要获取书籍的id 和name字段 ， 则查询如下： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id , name from tb_book;</span><br></pre></td></tr></table></figure><p>之后，在业务逻辑中有需要获取到书籍状态信息， 则查询如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id , status from tb_book;</span><br></pre></td></tr></table></figure><p>这样，就需要向数据库提交两次请求，数据库就要做两次查询操作。其实完全可以用一条SQL语句得到想要的结果。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id, name , status from tb_book;</span><br></pre></td></tr></table></figure><h5 id="1-2-2-增加cache层"><a href="#1-2-2-增加cache层" class="headerlink" title="1.2.2 增加cache层"></a>1.2.2 增加cache层</h5><p>在应用中，我们可以在应用中增加 缓存 层来达到减轻数据库负担的目的。缓存层有很多种，也有很多实现方式，只要能达到降低数据库的负担又能满足应用需求就可以。</p><p>因此可以部分数据从数据库中抽取出来放到应用端以文本方式存储， 或者使用框架(Mybatis, Hibernate)提供的一级缓存/二级缓存，或者使用redis数据库来缓存数据 。</p><h4 id="1-3-负载均衡"><a href="#1-3-负载均衡" class="headerlink" title="1.3 负载均衡"></a>1.3 负载均衡</h4><p>负载均衡是应用中使用非常普遍的一种优化方法，它的机制就是利用某种均衡算法，将固定的负载量分布到不同的服务器上， 以此来降低单台服务器的负载，达到优化的效果。</p><h5 id="1-3-1-利用MySQL复制分流查询"><a href="#1-3-1-利用MySQL复制分流查询" class="headerlink" title="1.3.1 利用MySQL复制分流查询"></a>1.3.1 利用MySQL复制分流查询</h5><p>通过MySQL的主从复制，实现读写分离，使增删改操作走主节点，查询操作走从节点，从而可以降低单台服务器的读写压力。</p><p><img src="/images/MySQL_hm/3/1.jpg" alt="1"> </p><h5 id="1-3-2-采用分布式数据库架构"><a href="#1-3-2-采用分布式数据库架构" class="headerlink" title="1.3.2 采用分布式数据库架构"></a>1.3.2 采用分布式数据库架构</h5><p>分布式数据库架构适合大数据量、负载高的情况，它有良好的拓展性和高可用性。通过在多台服务器之间分布数据，可以实现在多台服务器之间的负载均衡，提高访问效率。</p><h3 id="2-Mysql中查询缓存优化"><a href="#2-Mysql中查询缓存优化" class="headerlink" title="2. Mysql中查询缓存优化"></a>2. Mysql中查询缓存优化</h3><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><p>开启Mysql的查询缓存，当执行完全相同的SQL语句的时候，服务器就会直接从缓存中读取结果，当数据被修改，之前的缓存会失效，修改比较频繁的表不适合做查询缓存。</p><h4 id="2-2-操作流程"><a href="#2-2-操作流程" class="headerlink" title="2.2 操作流程"></a>2.2 操作流程</h4><p> <img src="/images/MySQL_hm/3/20180919131632347.png" alt="20180919131632347"> </p><ol><li>客户端发送一条查询给服务器；</li><li>服务器先会检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段；</li><li>服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划；</li><li>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询；</li><li>将结果返回给客户端。</li></ol><h4 id="2-3-查询缓存配置"><a href="#2-3-查询缓存配置" class="headerlink" title="2.3 查询缓存配置"></a>2.3 查询缓存配置</h4><ol><li><p>查看当前的MySQL数据库是否支持查询缓存：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;have_query_cache&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/3/1555249929012.png" alt="1555249929012"> </p></li><li><p>查看当前MySQL是否开启了查询缓存 ：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;query_cache_type&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/3/1555250015377.png" alt="1555250015377"> </p></li><li><p>查看查询缓存的占用大小 ：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;query_cache_size&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/3/1555250142451.png" alt="1555250142451">      </p></li><li><p>查看查询缓存的状态变量：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Qcache%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/3/1555250443958.png" alt="1555250443958"> </p><p>各个变量的含义如下：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>Qcache_free_blocks</td><td>查询缓存中的可用内存块数</td></tr><tr><td>Qcache_free_memory</td><td>查询缓存的可用内存量</td></tr><tr><td>Qcache_hits</td><td>查询缓存命中数</td></tr><tr><td>Qcache_inserts</td><td>添加到查询缓存的查询数</td></tr><tr><td>Qcache_lowmen_prunes</td><td>由于内存不足而从查询缓存中删除的查询数</td></tr><tr><td>Qcache_not_cached</td><td>非缓存查询的数量（由于 query_cache_type 设置而无法缓存或未缓存）</td></tr><tr><td>Qcache_queries_in_cache</td><td>查询缓存中注册的查询数</td></tr><tr><td>Qcache_total_blocks</td><td>查询缓存中的块总数</td></tr></tbody></table></li></ol><h4 id="2-4-开启查询缓存"><a href="#2-4-开启查询缓存" class="headerlink" title="2.4 开启查询缓存"></a>2.4 开启查询缓存</h4><p>MySQL的查询缓存默认是关闭的，需要手动配置参数 query_cache_type ， 来开启查询缓存。query_cache_type 该参数的可取值有三个 ：</p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>OFF 或 0</td><td>查询缓存功能关闭</td></tr><tr><td>ON 或 1</td><td>查询缓存功能打开，SELECT的结果符合缓存条件即会缓存，否则，不予缓存，显式指定 SQL_NO_CACHE，不予缓存</td></tr><tr><td>DEMAND 或 2</td><td>查询缓存功能按需进行，显式指定 SQL_CACHE 的SELECT语句才会缓存；其它均不予缓存</td></tr></tbody></table><p>在 /usr/my.cnf 配置中，增加以下配置 ： </p><p><img src="/images/MySQL_hm/3/1555251383805.png" alt="1555251383805">         </p><p>配置完毕之后，重启服务既可生效 ；</p><p>然后就可以在命令行执行SQL语句进行验证 ，执行一条比较耗时的SQL语句，然后再多执行几次，查看后面几次的执行时间；获取通过查看查询缓存的缓存命中数，来判定是否走查询缓存。</p><h4 id="2-5-查询缓存SELECT选项"><a href="#2-5-查询缓存SELECT选项" class="headerlink" title="2.5 查询缓存SELECT选项"></a>2.5 查询缓存SELECT选项</h4><p>可以在SELECT语句中指定两个与查询缓存相关的选项 ：</p><p>SQL_CACHE : 如果查询结果是可缓存的，并且 query_cache_type 系统变量的值为ON或 DEMAND ，则缓存查询结果 。</p><p>SQL_NO_CACHE : 服务器不使用查询缓存。它既不检查查询缓存，也不检查结果是否已缓存，也不缓存查询结果。</p><p>例子：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SQL_CACHE id, name <span class="keyword">FROM</span> customer;</span><br><span class="line"><span class="keyword">SELECT</span> SQL_NO_CACHE id, name <span class="keyword">FROM</span> customer;</span><br></pre></td></tr></table></figure><p>​    </p><h4 id="2-6-查询缓存失效的情况"><a href="#2-6-查询缓存失效的情况" class="headerlink" title="2.6 查询缓存失效的情况"></a>2.6 查询缓存失效的情况</h4><p>1） SQL 语句不一致的情况， 要想命中查询缓存，查询的SQL语句必须一致。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SQL1 : <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_item;</span><br><span class="line">SQL2 : <span class="keyword">Select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_item;</span><br></pre></td></tr></table></figure><p>2） 当查询语句中有一些不确定的时，则不会缓存。如 ： now() , current_date() , curdate() , curtime() , rand() , uuid() , user() , database() 。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SQL1 : <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_item <span class="keyword">where</span> updatetime <span class="operator">&lt;</span> now() limit <span class="number">1</span>;</span><br><span class="line">SQL2 : <span class="keyword">select</span> <span class="keyword">user</span>();</span><br><span class="line">SQL3 : <span class="keyword">select</span> database();</span><br></pre></td></tr></table></figure><p>3） 不使用任何表查询语句。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure><p>4）  查询 mysql， information_schema或  performance_schema 数据库中的表时，不会走查询缓存。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.engines;</span><br></pre></td></tr></table></figure><p>5） 在存储的函数，触发器或事件的主体内执行的查询。</p><p>6） 如果表更改，则使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除。这包括使用<code>MERGE</code>映射到已更改表的表的查询。一个表可以被许多类型的语句，如被改变 INSERT， UPDATE， DELETE， TRUNCATE TABLE， ALTER TABLE， DROP TABLE，或 DROP DATABASE 。</p><h3 id="3-Mysql内存管理及优化"><a href="#3-Mysql内存管理及优化" class="headerlink" title="3. Mysql内存管理及优化"></a>3. Mysql内存管理及优化</h3><h4 id="3-1-内存优化原则"><a href="#3-1-内存优化原则" class="headerlink" title="3.1 内存优化原则"></a>3.1 内存优化原则</h4><p>1） 将尽量多的内存分配给MySQL做缓存，但要给操作系统和其他程序预留足够内存。</p><p>2） MyISAM 存储引擎的数据文件读取依赖于操作系统自身的IO缓存，因此，如果有MyISAM表，就要预留更多的内存给操作系统做IO缓存。</p><p>3） 排序区、连接区等缓存是分配给每个数据库会话（session）专用的，其默认值的设置要根据最大连接数合理分配，如果设置太大，不但浪费资源，而且在并发连接较高时会导致物理内存耗尽。</p><h4 id="3-2-MyISAM-内存优化"><a href="#3-2-MyISAM-内存优化" class="headerlink" title="3.2 MyISAM 内存优化"></a>3.2 MyISAM 内存优化</h4><p>myisam存储引擎使用 key_buffer 缓存索引块，加速myisam索引的读写速度。对于myisam表的数据块，mysql没有特别的缓存机制，完全依赖于操作系统的IO缓存。</p><h5 id="key-buffer-size"><a href="#key-buffer-size" class="headerlink" title="key_buffer_size"></a>key_buffer_size</h5><p>key_buffer_size决定MyISAM索引块缓存区的大小，直接影响到MyISAM表的存取效率。可以在MySQL参数文件中设置key_buffer_size的值，对于一般MyISAM数据库，建议至少将1/4可用内存分配给key_buffer_size。</p><p>在/usr/my.cnf 中做如下配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key_buffer_size&#x3D;512M</span><br></pre></td></tr></table></figure><h5 id="read-buffer-size"><a href="#read-buffer-size" class="headerlink" title="read_buffer_size"></a>read_buffer_size</h5><p>如果需要经常顺序扫描myisam表，可以通过增大read_buffer_size的值来改善性能。但需要注意的是read_buffer_size是每个session独占的，如果默认值设置太大，就会造成内存浪费。</p><h5 id="read-rnd-buffer-size"><a href="#read-rnd-buffer-size" class="headerlink" title="read_rnd_buffer_size"></a>read_rnd_buffer_size</h5><p>对于需要做排序的myisam表的查询，如带有order by子句的sql，适当增加 read_rnd_buffer_size 的值，可以改善此类的sql性能。但需要注意的是 read_rnd_buffer_size 是每个session独占的，如果默认值设置太大，就会造成内存浪费。</p><h4 id="3-3-InnoDB-内存优化"><a href="#3-3-InnoDB-内存优化" class="headerlink" title="3.3 InnoDB 内存优化"></a>3.3 InnoDB 内存优化</h4><p>innodb用一块内存区做IO缓存池，该缓存池不仅用来缓存innodb的索引块，而且也用来缓存innodb的数据块。</p><h5 id="innodb-buffer-pool-size"><a href="#innodb-buffer-pool-size" class="headerlink" title="innodb_buffer_pool_size"></a>innodb_buffer_pool_size</h5><p>该变量决定了 innodb 存储引擎表数据和索引数据的最大缓存区大小。在保证操作系统及其他程序有足够内存可用的情况下，innodb_buffer_pool_size 的值越大，缓存命中率越高，访问InnoDB表需要的磁盘I/O 就越少，性能也就越高。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">innodb_buffer_pool_size&#x3D;512M</span><br></pre></td></tr></table></figure><h5 id="innodb-log-buffer-size"><a href="#innodb-log-buffer-size" class="headerlink" title="innodb_log_buffer_size"></a>innodb_log_buffer_size</h5><p>决定了innodb重做日志缓存的大小，对于可能产生大量更新记录的大事务，增加innodb_log_buffer_size的大小，可以避免innodb在事务提交前就执行不必要的日志写入磁盘操作。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">innodb_log_buffer_size&#x3D;10M</span><br></pre></td></tr></table></figure><h3 id="4-Mysql并发参数调整"><a href="#4-Mysql并发参数调整" class="headerlink" title="4. Mysql并发参数调整"></a>4. Mysql并发参数调整</h3><p>从实现上来说，MySQL Server 是多线程结构，包括后台线程和客户服务线程。多线程可以有效利用服务器资源，提高数据库的并发性能。在Mysql中，控制并发连接和线程的主要参数包括 max_connections、back_log、thread_cache_size、table_open_cahce。</p><h4 id="4-1-max-connections"><a href="#4-1-max-connections" class="headerlink" title="4.1 max_connections"></a>4.1 max_connections</h4><p>采用max_connections 控制允许连接到MySQL数据库的最大数量，默认值是 151。如果状态变量 connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。</p><p>Mysql 最大可支持的连接数，取决于很多因素，包括给定操作系统平台的线程库的质量、内存大小、每个连接的负荷、CPU的处理速度，期望的响应时间等。在Linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。</p><h4 id="4-2-back-log"><a href="#4-2-back-log" class="headerlink" title="4.2 back_log"></a>4.2 back_log</h4><p>back_log 参数控制MySQL监听TCP端口时设置的积压请求栈大小。如果MySql的连接数达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默认值为 50 ， 之后的版本默认为 50 + （max_connections / 5）， 但最大不超过900。</p><p>如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。</p><h4 id="4-3-table-open-cache"><a href="#4-3-table-open-cache" class="headerlink" title="4.3 table_open_cache"></a>4.3 table_open_cache</h4><p>该参数用来控制所有SQL语句执行线程可打开表缓存的数量， 而在执行SQL语句时，每一个SQL执行线程至少要打开 1 个表缓存。该参数的值应该根据设置的最大连接数 max_connections 以及每个连接执行关联查询中涉及的表的最大数量来设定 ：</p><p>​    max_connections x N ；</p><h4 id="4-4-thread-cache-size"><a href="#4-4-thread-cache-size" class="headerlink" title="4.4 thread_cache_size"></a>4.4 thread_cache_size</h4><p>为了加快连接数据库的速度，MySQL 会缓存一定数量的客户服务线程以备重用，通过参数 thread_cache_size 可控制 MySQL 缓存客户服务线程的数量。</p><h4 id="4-5-innodb-lock-wait-timeout"><a href="#4-5-innodb-lock-wait-timeout" class="headerlink" title="4.5 innodb_lock_wait_timeout"></a>4.5 innodb_lock_wait_timeout</h4><p>该参数是用来设置InnoDB 事务等待行锁的时间，默认值是50ms ， 可以根据需要进行动态设置。对于需要快速反馈的业务系统来说，可以将行锁的等待时间调小，以避免事务长时间挂起； 对于后台运行的批量处理程序来说， 可以将行锁的等待时间调大， 以避免发生大的回滚操作。</p><h3 id="5-Mysql锁问题"><a href="#5-Mysql锁问题" class="headerlink" title="5. Mysql锁问题"></a>5. Mysql锁问题</h3><h4 id="5-1-锁概述"><a href="#5-1-锁概述" class="headerlink" title="5.1 锁概述"></a>5.1 锁概述</h4><p>锁是计算机协调多个进程或线程并发访问某一资源的机制（避免争抢）。</p><p>在数据库中，除传统的计算资源（如 CPU、RAM、I/O 等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><h4 id="5-2-锁分类"><a href="#5-2-锁分类" class="headerlink" title="5.2 锁分类"></a>5.2 锁分类</h4><p>从对数据操作的粒度分 ： </p><p>1） 表锁：操作时，会锁定整个表。</p><p>2） 行锁：操作时，会锁定当前操作行。</p><p>从对数据操作的类型分：</p><p>1） 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。</p><p>2） 写锁（排它锁）：当前操作没有完成之前，它会阻断其他写锁和读锁。</p><h4 id="5-3-Mysql-锁"><a href="#5-3-Mysql-锁" class="headerlink" title="5.3 Mysql 锁"></a>5.3 Mysql 锁</h4><p>相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。下表中罗列出了各存储引擎对锁的支持情况：<br>| 存储引擎 | 表级锁 | 行级锁 | 页面锁 |<br>| ——– | —— | —— | —— |<br>| MyISAM   | 支持   | 不支持 | 不支持 |<br>| InnoDB   | 支持   | 支持   | 不支持 |<br>| MEMORY   | 支持   | 不支持 | 不支持 |<br>| BDB      | 支持   | 不支持 | 支持   |</p><p>MySQL这3种锁的特性可大致归纳如下 ：</p><table><thead><tr><th>锁类型</th><th>特点</th></tr></thead><tbody><tr><td>表级锁</td><td>偏向MyISAM 存储引擎，开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</td></tr><tr><td>行级锁</td><td>偏向InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</td></tr><tr><td>页面锁</td><td>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</td></tr></tbody></table><p>从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适！仅从锁的角度来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web 应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并查询的应用，如一些在线事务处理（OLTP）系统。</p><h4 id="5-2-MyISAM-表锁"><a href="#5-2-MyISAM-表锁" class="headerlink" title="5.2 MyISAM 表锁"></a>5.2 MyISAM 表锁</h4><p>MyISAM 存储引擎只支持表锁，这也是MySQL开始几个版本中唯一支持的锁类型。</p><h5 id="5-2-1-如何加表锁"><a href="#5-2-1-如何加表锁" class="headerlink" title="5.2.1 如何加表锁"></a>5.2.1 如何加表锁</h5><p>MyISAM 在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁。</p><p>显示加表锁语法：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">加读锁 ： lock <span class="keyword">table</span> table_name read;</span><br><span class="line"></span><br><span class="line">加写锁 ： lock <span class="keyword">table</span> table_name write；</span><br></pre></td></tr></table></figure><h5 id="5-2-2-读锁案例"><a href="#5-2-2-读锁案例" class="headerlink" title="5.2.2 读锁案例"></a>5.2.2 读锁案例</h5><p>准备环境</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database demo_03 <span class="keyword">default</span> charset<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line">use demo_03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_book` (</span><br><span class="line">  `id` <span class="type">INT</span>(<span class="number">11</span>) auto_increment,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `publish_time` <span class="type">DATE</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `status` <span class="type">CHAR</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>myisam <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_book (id, name, publish_time, status) <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;java编程思想&#x27;</span>,<span class="string">&#x27;2088-08-01&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_book (id, name, publish_time, status) <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;solr编程思想&#x27;</span>,<span class="string">&#x27;2088-08-08&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_user` (</span><br><span class="line">  `id` <span class="type">INT</span>(<span class="number">11</span>) auto_increment,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>myisam <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_user (id, name) <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;令狐冲&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_user (id, name) <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;田伯光&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端 一 ：</p><p>1）获得tb_book 表的读锁 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lock table tb_book read;</span><br></pre></td></tr></table></figure><p>2） 执行查询操作</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tb_book;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/3/1553906896564.png" alt="1553906896564"> </p><p>可以正常执行 ， 查询出数据。</p><p>客户端 二 ：</p><p>3） 执行查询操作</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tb_book;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/3/1553907044500.png" alt="1553907044500"> </p><p>客户端 一 ：</p><p>4）查询未锁定的表</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name from tb_seller;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/3/1553908913515.png" alt="1553908913515"> </p><p>客户端 二 ：</p><p>5）查询未锁定的表</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name from tb_seller;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/3/1553908973840.png" alt="1553908973840"> </p><p>可以正常查询出未锁定的表；</p><p>客户端 一 ：</p><p>6） 执行插入操作 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into tb_book values(null,&#39;Mysql高级&#39;,&#39;2088-01-01&#39;,&#39;1&#39;);</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/3/1553907198462.png" alt="1553907198462"> </p><p>执行插入， 直接报错 ， 由于当前tb_book 获得的是 读锁， 不能执行更新操作。</p><p>客户端 二 ：</p><p>7） 执行插入操作 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into tb_book values(null,&#39;Mysql高级&#39;,&#39;2088-01-01&#39;,&#39;1&#39;);</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/3/1553907403957.png" alt="1553907403957"> </p><p>当在客户端一中释放锁指令 unlock tables  后 ， 客户端二中的 inesrt 语句 ， 立即执行 ；</p><h5 id="5-2-3-写锁案例"><a href="#5-2-3-写锁案例" class="headerlink" title="5.2.3 写锁案例"></a>5.2.3 写锁案例</h5><p>客户端 一 :</p><p>1）获得tb_book 表的写锁 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lock table tb_book write ;</span><br></pre></td></tr></table></figure><p>2）执行查询操作</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tb_book ;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/3/1553907849829.png" alt="1553907849829"> </p><p>查询操作执行成功；</p><p>3）执行更新操作</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update tb_book set name &#x3D; &#39;java编程思想（第二版）&#39; where id &#x3D; 1;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/3/1553907875221.png" alt="1553907875221"> </p><p>更新操作执行成功 ；</p><p>客户端 二 :</p><p>4）执行查询操作</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tb_book ;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/3/1553908019755.png" alt="1553908019755"> </p><p>当在客户端一中释放锁指令 unlock tables  后 ， 客户端二中的 select 语句 ， 立即执行 ；</p><p><img src="/images/MySQL_hm/3/1553908131373.png" alt="1553908131373"> </p><h5 id="5-2-4-结论"><a href="#5-2-4-结论" class="headerlink" title="5.2.4 结论"></a>5.2.4 结论</h5><p>锁模式的相互兼容性如表中所示：</p><p><img src="../../../../../../%E6%95%99%E5%AD%A6%E8%B5%84%E6%96%99/%E8%AF%BE%E7%A8%8B%E8%90%A5%E9%94%80/Mysql%E9%AB%98%E7%BA%A7/%E8%AF%BE%E7%A8%8B%E8%B5%84%E6%96%99/day-03/%E6%96%87%E6%A1%A3//images/MySQL_hm/3/1553905621992.png" alt="1553905621992"> </p><p>由上表可见： </p><p>​    1） 对MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；</p><p>​    2） 对MyISAM 表的写操作，则会阻塞其他用户对同一表的读和写操作；</p><p>​    简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁，则既会阻塞读，又会阻塞写。</p><p>此外，MyISAM 的读写锁调度是写优先，这也是MyISAM不适合做写为主的表的存储引擎的原因。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。</p><h5 id="5-2-5-查看锁的争用情况"><a href="#5-2-5-查看锁的争用情况" class="headerlink" title="5.2.5 查看锁的争用情况"></a>5.2.5 查看锁的争用情况</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show open tables；</span><br></pre></td></tr></table></figure><p><img src="../../../../../../%E6%95%99%E5%AD%A6%E8%B5%84%E6%96%99/%E8%AF%BE%E7%A8%8B%E8%90%A5%E9%94%80/Mysql%E9%AB%98%E7%BA%A7/%E8%AF%BE%E7%A8%8B%E8%B5%84%E6%96%99/day-03/%E6%96%87%E6%A1%A3//images/MySQL_hm/3/1556443073322.png" alt="1556443073322"> </p><p>In_user : 表当前被查询使用的次数。如果该数为零，则表是打开的，但是当前没有被使用。</p><p>Name_locked：表名称是否被锁定。名称锁定用于取消表或对表进行重命名等操作。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show status like &#39;Table_locks%&#39;;</span><br></pre></td></tr></table></figure><p><img src="../../../../../../%E6%95%99%E5%AD%A6%E8%B5%84%E6%96%99/%E8%AF%BE%E7%A8%8B%E8%90%A5%E9%94%80/Mysql%E9%AB%98%E7%BA%A7/%E8%AF%BE%E7%A8%8B%E8%B5%84%E6%96%99/day-03/%E6%96%87%E6%A1%A3//images/MySQL_hm/3/1556443170082.png" alt="1556443170082"> </p><p>Table_locks_immediate ： 指的是能够立即获得表级锁的次数，每立即获取锁，值加1。</p><p>Table_locks_waited ： 指的是不能立即获取表级锁而需要等待的次数，每等待一次，该值加1，此值高说明存在着较为严重的表级锁争用情况。</p><h4 id="5-3-InnoDB-行锁"><a href="#5-3-InnoDB-行锁" class="headerlink" title="5.3 InnoDB 行锁"></a>5.3 InnoDB 行锁</h4><h5 id="5-3-1-行锁介绍"><a href="#5-3-1-行锁介绍" class="headerlink" title="5.3.1 行锁介绍"></a>5.3.1 行锁介绍</h5><p>行锁特点 ：偏向InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</p><p>InnoDB 与 MyISAM 的最大不同有两点：一是支持事务；二是 采用了行级锁。</p><h5 id="5-3-2-背景知识"><a href="#5-3-2-背景知识" class="headerlink" title="5.3.2 背景知识"></a>5.3.2 背景知识</h5><p><strong>事务及其ACID属性</strong></p><p>事务是由一组SQL语句组成的逻辑处理单元。</p><p>事务具有以下4个特性，简称为事务ACID属性。</p><table><thead><tr><th>ACID属性</th><th>含义</th></tr></thead><tbody><tr><td>原子性（Atomicity）</td><td>事务是一个原子操作单元，其对数据的修改，要么全部成功，要么全部失败。</td></tr><tr><td>一致性（Consistent）</td><td>在事务开始和完成时，数据都必须保持一致状态。</td></tr><tr><td>隔离性（Isolation）</td><td>数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的 “独立” 环境下运行。</td></tr><tr><td>持久性（Durable）</td><td>事务完成之后，对于数据的修改是永久的。</td></tr></tbody></table><p><strong>并发事务处理带来的问题</strong></p><table><thead><tr><th>问题</th><th>含义</th></tr></thead><tbody><tr><td>丢失更新（Lost Update）</td><td>当两个或多个事务选择同一行，最初的事务修改的值，会被后面的事务修改的值覆盖。</td></tr><tr><td>脏读（Dirty Reads）</td><td>当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</td></tr><tr><td>不可重复读（Non-Repeatable Reads）</td><td>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现和以前读出的数据不一致。</td></tr><tr><td>幻读（Phantom Reads）</td><td>一个事务按照相同的查询条件重新读取以前查询过的数据，却发现其他事务插入了满足其查询条件的新数据。</td></tr></tbody></table><p><strong>事务隔离级别</strong></p><p>为了解决上述提到的事务并发问题，数据库提供一定的事务隔离机制来解决这个问题。数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使用事务在一定程度上“串行化” 进行，这显然与“并发” 是矛盾的。 </p><p>数据库的隔离级别有4个，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏写、脏读、不可重复读、幻读这几类问题。</p><table><thead><tr><th>隔离级别</th><th>丢失更新</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>×</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable read（默认）</td><td>×</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>备注 ： √  代表可能出现 ， × 代表不会出现 。</p><p>Mysql 的数据库的默认隔离级别为 Repeatable read ， 查看方式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;tx_isolation&#39;;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/3/1554331600009.png" alt="1554331600009">  </p><h5 id="5-3-3-InnoDB-的行锁模式"><a href="#5-3-3-InnoDB-的行锁模式" class="headerlink" title="5.3.3 InnoDB 的行锁模式"></a>5.3.3 InnoDB 的行锁模式</h5><p>InnoDB  实现了以下两种类型的行锁。</p><ul><li>共享锁（S）：又称为读锁，简称S锁，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</li><li>排他锁（X）：又称为写锁，简称X锁，排他锁就是不能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。</li></ul><p>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；</p><p>对于普通SELECT语句，InnoDB不会加任何锁；</p><p>可以通过以下语句显示给记录集加共享锁或排他锁 。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE</span><br><span class="line"></span><br><span class="line">排他锁（X) ：SELECT * FROM table_name WHERE ... FOR UPDATE</span><br></pre></td></tr></table></figure><h5 id="5-3-4-案例准备工作"><a href="#5-3-4-案例准备工作" class="headerlink" title="5.3.4 案例准备工作"></a>5.3.4 案例准备工作</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_innodb_lock(</span><br><span class="line">id <span class="type">int</span>(<span class="number">11</span>),</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">16</span>),</span><br><span class="line">sex <span class="type">varchar</span>(<span class="number">1</span>)</span><br><span class="line">)engine <span class="operator">=</span> innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;100&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;400&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;500&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">6</span>,<span class="string">&#x27;600&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">&#x27;700&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">8</span>,<span class="string">&#x27;800&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">9</span>,<span class="string">&#x27;900&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;200&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> index idx_test_innodb_lock_id <span class="keyword">on</span> test_innodb_lock(id);</span><br><span class="line"><span class="keyword">create</span> index idx_test_innodb_lock_name <span class="keyword">on</span> test_innodb_lock(name);</span><br></pre></td></tr></table></figure><h5 id="5-3-5-行锁基本演示"><a href="#5-3-5-行锁基本演示" class="headerlink" title="5.3.5 行锁基本演示"></a>5.3.5 行锁基本演示</h5><table><thead><tr><th>Session-1</th><th>Session-2</th></tr></thead><tbody><tr><td><img src="/images/MySQL_hm/3/1554354615030.png" alt="1554354615030">      关闭自动提交功能</td><td><img src="/images/MySQL_hm/3/1554354601867.png" alt="1554354601867">  关闭自动提交功能</td></tr><tr><td><img src="/images/MySQL_hm/3/1554354713628.png" alt="1554354713628"> 可以正常的查询出全部的数据</td><td><img src="/images/MySQL_hm/3/1554354717336.png" alt="1554354717336"> 可以正常的查询出全部的数据</td></tr><tr><td><img src="/images/MySQL_hm/3/1554354830589.png" alt="1554354830589">查询id 为3的数据 ；</td><td><img src="/images/MySQL_hm/3/1554354832708.png" alt="1554354832708">获取id为3的数据 ；</td></tr><tr><td><img src="/images/MySQL_hm/3/1554382789984.png" alt="1554382789984"> 更新id为3的数据，但是不提交；</td><td><img src="/images/MySQL_hm/3/1554382905352.png" alt="1554382905352"> 更新id为3 的数据， 出于等待状态</td></tr><tr><td><img src="/images/MySQL_hm/3/1554382977653.png" alt="1554382977653"> 通过commit， 提交事务</td><td><img src="/images/MySQL_hm/3/1554383044542.png" alt="1554383044542"> 解除阻塞，更新正常进行</td></tr><tr><td>以上， 操作的都是同一行的数据，接下来，演示不同行的数据 ：</td><td></td></tr><tr><td><img src="/images/MySQL_hm/3/1554385220580.png" alt="1554385220580"> 更新id为3数据，正常的获取到行锁 ， 执行更新 ；</td><td><img src="/images/MySQL_hm/3/1554385236768.png" alt="1554385236768"> 由于与Session-1 操作不是同一行，获取当前行锁，执行更新；</td></tr></tbody></table><h5 id="5-3-6-无索引行锁升级为表锁"><a href="#5-3-6-无索引行锁升级为表锁" class="headerlink" title="5.3.6 无索引行锁升级为表锁"></a>5.3.6 无索引行锁升级为表锁</h5><p>如果不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，实际效果跟表锁一样。</p><p>查看当前表的索引 ： show  index  from test_innodb_lock ;</p><p><img src="/images/MySQL_hm/3/1554385956215.png" alt="1554385956215"> </p><table><thead><tr><th>Session-1</th><th>Session-2</th></tr></thead><tbody><tr><td>关闭事务的自动提交<img src="/images/MySQL_hm/3/1554386287454.png" alt="1554386287454"></td><td>关闭事务的自动提交<img src="/images/MySQL_hm/3/1554386312524.png" alt="1554386312524"></td></tr><tr><td>执行更新语句 ：<img src="/images/MySQL_hm/3/1554386654793.png" alt="1554386654793"></td><td>执行更新语句， 但处于阻塞状态：<img src="/images/MySQL_hm/3/1554386685610.png" alt="1554386685610"></td></tr><tr><td>提交事务：<img src="/images/MySQL_hm/3/1554386721653.png" alt="1554386721653"></td><td>解除阻塞，执行更新成功 ：<img src="/images/MySQL_hm/3/1554386750004.png" alt="1554386750004"></td></tr><tr><td></td><td>执行提交操作 ：<img src="/images/MySQL_hm/3/1554386804807.png" alt="1554386804807"></td></tr></tbody></table><p>由于 执行更新时 ， name字段本来为varchar类型， 我们是作为数组类型使用，存在类型转换，索引失效，最终行锁变为表锁 ；</p><h5 id="5-3-7-间隙锁危害"><a href="#5-3-7-间隙锁危害" class="headerlink" title="5.3.7 间隙锁危害"></a>5.3.7 间隙锁危害</h5><p>当我们用范围条件，而不是使用相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据进行加锁； 对于键值在条件范围内但并不存在的记录，叫做 “间隙（GAP）” ， InnoDB也会对这个 “间隙” 加锁，这种锁机制就是所谓的 间隙锁（Next-Key锁） 。</p><p>示例 ： </p><table><thead><tr><th>Session-1</th><th>Session-2</th></tr></thead><tbody><tr><td>关闭事务自动提交 <img src="/images/MySQL_hm/3/1554387987130.png" alt="1554387987130"></td><td>关闭事务自动提交<img src="/images/MySQL_hm/3/1554387994533.png" alt="1554387994533"></td></tr><tr><td>根据id范围更新数据<img src="/images/MySQL_hm/3/1554388492478.png" alt="1554388492478"></td><td></td></tr><tr><td></td><td>插入id为2的记录， 出于阻塞状态<img src="/images/MySQL_hm/3/1554388515936.png" alt="1554388515936"></td></tr><tr><td>提交事务 ；<img src="/images/MySQL_hm/3/1554388149305.png" alt="1554388149305"></td><td></td></tr><tr><td></td><td>解除阻塞 ， 执行插入操作 ：<img src="/images/MySQL_hm/3/1554388548562.png" alt="1554388548562"></td></tr><tr><td></td><td>提交事务 ：</td></tr></tbody></table><h5 id="5-3-8-InnoDB-行锁争用情况"><a href="#5-3-8-InnoDB-行锁争用情况" class="headerlink" title="5.3.8 InnoDB 行锁争用情况"></a>5.3.8 InnoDB 行锁争用情况</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span>  status <span class="keyword">like</span> <span class="string">&#x27;innodb_row_lock%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/3/1556455943670.png" alt="1556455943670"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Innodb_row_lock_current_waits: 当前正在等待锁定的数量</span><br><span class="line"></span><br><span class="line">Innodb_row_lock_time: 从系统启动到现在锁定总时间长度</span><br><span class="line"></span><br><span class="line">Innodb_row_lock_time_avg:每次等待所花平均时长</span><br><span class="line"></span><br><span class="line">Innodb_row_lock_time_max:从系统启动到现在等待最长的一次所花的时间</span><br><span class="line"></span><br><span class="line">Innodb_row_lock_waits: 系统启动后到现在总共等待的次数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当等待的次数很高，而且每次等待的时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="5-3-9-总结"><a href="#5-3-9-总结" class="headerlink" title="5.3.9 总结"></a>5.3.9 总结</h5><p>InnoDB存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面带来了性能损耗可能比表锁会更高一些，但是在整体并发处理能力方面要远远由于MyISAM的表锁的。当系统并发量较高的时候，InnoDB的整体性能和MyISAM相比就会有比较明显的优势。</p><p>但是，InnoDB的行级锁同样也有其脆弱的一面，当我们使用不当的时候，可能会让InnoDB的整体性能表现不仅不能比MyISAM高，甚至可能会更差。</p><p>优化建议：</p><ul><li>尽可能让所有数据检索都能通过索引来完成，避免无索引行锁升级为表锁。</li><li>合理设计索引，尽量缩小锁的范围</li><li>尽可能减少索引条件，及索引范围，避免间隙锁</li><li>尽量控制事务大小，减少锁定资源量和时间长度</li><li>尽可使用低级别事务隔离（但是需要业务层面满足需求）</li></ul><h3 id="6-常用SQL技巧"><a href="#6-常用SQL技巧" class="headerlink" title="6. 常用SQL技巧"></a>6. 常用SQL技巧</h3><h4 id="6-1-SQL执行顺序"><a href="#6-1-SQL执行顺序" class="headerlink" title="6.1 SQL执行顺序"></a>6.1 SQL执行顺序</h4><p>编写顺序</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> list<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"><span class="operator">&lt;</span>left_table<span class="operator">&gt;</span> <span class="operator">&lt;</span>join_type<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">JOIN</span></span><br><span class="line"><span class="operator">&lt;</span>right_table<span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>join_condition<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="operator">&lt;</span>where_condition<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line"><span class="operator">&lt;</span>group_by_list<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="operator">&lt;</span>having_condition<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line"><span class="operator">&lt;</span>order_by_condition<span class="operator">&gt;</span></span><br><span class="line">LIMIT</span><br><span class="line"><span class="operator">&lt;</span>limit_params<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>执行顺序</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span><span class="operator">&lt;</span>left_table<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>join_condition<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span>join_type<span class="operator">&gt;</span><span class="keyword">JOIN</span><span class="operator">&lt;</span>right_table<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span><span class="operator">&lt;</span>where_condition<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>group_by_list<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">HAVING</span><span class="operator">&lt;</span>having_condition<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span><span class="operator">&lt;</span><span class="keyword">select</span> list<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span><span class="operator">&lt;</span>order_by_condition<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line">LIMIT<span class="operator">&lt;</span>limit_params<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h4 id="6-2-正则表达式使用"><a href="#6-2-正则表达式使用" class="headerlink" title="6.2 正则表达式使用"></a>6.2 正则表达式使用</h4><p>正则表达式（Regular Expression）是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>^</td><td>在字符串开始处进行匹配</td></tr><tr><td>$</td><td>在字符串末尾处进行匹配</td></tr><tr><td>.</td><td>匹配任意单个字符, 包括换行符</td></tr><tr><td>[…]</td><td>匹配出括号内的任意字符</td></tr><tr><td>[^…]</td><td>匹配不出括号内的任意字符</td></tr><tr><td>a*</td><td>匹配零个或者多个a(包括空串)</td></tr><tr><td>a+</td><td>匹配一个或者多个a(不包括空串)</td></tr><tr><td>a?</td><td>匹配零个或者一个a</td></tr><tr><td>a1|a2</td><td>匹配a1或a2</td></tr><tr><td>a(m)</td><td>匹配m个a</td></tr><tr><td>a(m,)</td><td>至少匹配m个a</td></tr><tr><td>a(m,n)</td><td>匹配m个a 到 n个a</td></tr><tr><td>a(,n)</td><td>匹配0到n个a</td></tr><tr><td>(…)</td><td>将模式元素组成单一元素</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from emp where name regexp &#39;^T&#39;;</span><br><span class="line"></span><br><span class="line">select * from emp where name regexp &#39;2$&#39;;</span><br><span class="line"></span><br><span class="line">select * from emp where name regexp &#39;[uvw]&#39;;</span><br></pre></td></tr></table></figure><h4 id="6-3-MySQL-常用函数"><a href="#6-3-MySQL-常用函数" class="headerlink" title="6.3 MySQL 常用函数"></a>6.3 MySQL 常用函数</h4><p>数字函数</p><table><thead><tr><th>函数名称</th><th>作 用</th></tr></thead><tbody><tr><td>ABS</td><td>求绝对值</td></tr><tr><td>SQRT</td><td>求二次方根</td></tr><tr><td>MOD</td><td>求余数</td></tr><tr><td>CEIL 和 CEILING</td><td>两个函数功能相同，都是返回不小于参数的最小整数，即向上取整</td></tr><tr><td>FLOOR</td><td>向下取整，返回值转化为一个BIGINT</td></tr><tr><td>RAND</td><td>生成一个0~1之间的随机数，传入整数参数是，用来产生重复序列</td></tr><tr><td>ROUND</td><td>对所传参数进行四舍五入</td></tr><tr><td>SIGN</td><td>返回参数的符号</td></tr><tr><td>POW 和 POWER</td><td>两个函数的功能相同，都是所传参数的次方的结果值</td></tr><tr><td>SIN</td><td>求正弦值</td></tr><tr><td>ASIN</td><td>求反正弦值，与函数 SIN 互为反函数</td></tr><tr><td>COS</td><td>求余弦值</td></tr><tr><td>ACOS</td><td>求反余弦值，与函数 COS 互为反函数</td></tr><tr><td>TAN</td><td>求正切值</td></tr><tr><td>ATAN</td><td>求反正切值，与函数 TAN 互为反函数</td></tr><tr><td>COT</td><td>求余切值</td></tr></tbody></table><p>字符串函数</p><table><thead><tr><th>函数名称</th><th>作 用</th></tr></thead><tbody><tr><td>LENGTH</td><td>计算字符串长度函数，返回字符串的字节长度</td></tr><tr><td>CONCAT</td><td>合并字符串函数，返回结果为连接参数产生的字符串，参数可以使一个或多个</td></tr><tr><td>INSERT</td><td>替换字符串函数</td></tr><tr><td>LOWER</td><td>将字符串中的字母转换为小写</td></tr><tr><td>UPPER</td><td>将字符串中的字母转换为大写</td></tr><tr><td>LEFT</td><td>从左侧字截取符串，返回字符串左边的若干个字符</td></tr><tr><td>RIGHT</td><td>从右侧字截取符串，返回字符串右边的若干个字符</td></tr><tr><td>TRIM</td><td>删除字符串左右两侧的空格</td></tr><tr><td>REPLACE</td><td>字符串替换函数，返回替换后的新字符串</td></tr><tr><td>SUBSTRING</td><td>截取字符串，返回从指定位置开始的指定长度的字符换</td></tr><tr><td>REVERSE</td><td>字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串</td></tr></tbody></table><p>日期函数</p><table><thead><tr><th>函数名称</th><th>作 用</th></tr></thead><tbody><tr><td>CURDATE 和 CURRENT_DATE</td><td>两个函数作用相同，返回当前系统的日期值</td></tr><tr><td>CURTIME 和 CURRENT_TIME</td><td>两个函数作用相同，返回当前系统的时间值</td></tr><tr><td>NOW 和  SYSDATE</td><td>两个函数作用相同，返回当前系统的日期和时间值</td></tr><tr><td>MONTH</td><td>获取指定日期中的月份</td></tr><tr><td>MONTHNAME</td><td>获取指定日期中的月份英文名称</td></tr><tr><td>DAYNAME</td><td>获取指定曰期对应的星期几的英文名称</td></tr><tr><td>DAYOFWEEK</td><td>获取指定日期对应的一周的索引位置值</td></tr><tr><td>WEEK</td><td>获取指定日期是一年中的第几周，返回值的范围是否为 0〜52 或 1〜53</td></tr><tr><td>DAYOFYEAR</td><td>获取指定曰期是一年中的第几天，返回值范围是1~366</td></tr><tr><td>DAYOFMONTH</td><td>获取指定日期是一个月中是第几天，返回值范围是1~31</td></tr><tr><td>YEAR</td><td>获取年份，返回值范围是 1970〜2069</td></tr><tr><td>TIME_TO_SEC</td><td>将时间参数转换为秒数</td></tr><tr><td>SEC_TO_TIME</td><td>将秒数转换为时间，与TIME_TO_SEC 互为反函数</td></tr><tr><td>DATE_ADD 和 ADDDATE</td><td>两个函数功能相同，都是向日期添加指定的时间间隔</td></tr><tr><td>DATE_SUB 和 SUBDATE</td><td>两个函数功能相同，都是向日期减去指定的时间间隔</td></tr><tr><td>ADDTIME</td><td>时间加法运算，在原始时间上添加指定的时间</td></tr><tr><td>SUBTIME</td><td>时间减法运算，在原始时间上减去指定的时间</td></tr><tr><td>DATEDIFF</td><td>获取两个日期之间间隔，返回参数 1 减去参数 2 的值</td></tr><tr><td>DATE_FORMAT</td><td>格式化指定的日期，根据参数返回指定格式的值</td></tr><tr><td>WEEKDAY</td><td>获取指定日期在一周内的对应的工作日索引</td></tr></tbody></table><p>聚合函数</p><table><thead><tr><th>函数名称</th><th>作用</th></tr></thead><tbody><tr><td>MAX</td><td>查询指定列的最大值</td></tr><tr><td>MIN</td><td>查询指定列的最小值</td></tr><tr><td>COUNT</td><td>统计查询结果的行数</td></tr><tr><td>SUM</td><td>求和，返回指定列的总和</td></tr><tr><td>AVG</td><td>求平均值，返回指定列数据的平均值</td></tr></tbody></table><h1 id="Mysql高级-day04"><a href="#Mysql高级-day04" class="headerlink" title="Mysql高级-day04"></a>Mysql高级-day04</h1><h3 id="1-MySql中常用工具"><a href="#1-MySql中常用工具" class="headerlink" title="1. MySql中常用工具"></a>1. MySql中常用工具</h3><h4 id="1-1-mysql"><a href="#1-1-mysql" class="headerlink" title="1.1 mysql"></a>1.1 mysql</h4><p>该mysql不是指mysql服务，而是指mysql的客户端工具。</p><p>语法 ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql [options] [database]</span><br></pre></td></tr></table></figure><h5 id="1-1-1-连接选项"><a href="#1-1-1-连接选项" class="headerlink" title="1.1.1 连接选项"></a>1.1.1 连接选项</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参数 ： </span><br><span class="line">-u, --user&#x3D;name指定用户名</span><br><span class="line">-p, --password[&#x3D;name]指定密码</span><br><span class="line">-h, --host&#x3D;name指定服务器IP或域名</span><br><span class="line">-P, --port&#x3D;#指定连接端口</span><br><span class="line"></span><br><span class="line">示例 ：</span><br><span class="line">mysql -h 127.0.0.1 -P 3306 -u root -p</span><br><span class="line"></span><br><span class="line">mysql -h127.0.0.1 -P3306 -uroot -p2143</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="1-1-2-执行选项"><a href="#1-1-2-执行选项" class="headerlink" title="1.1.2 执行选项"></a>1.1.2 执行选项</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-e, --execute&#x3D;name执行SQL语句并退出</span><br></pre></td></tr></table></figure><p>此选项可以在Mysql客户端执行SQL语句，而不用连接到MySQL数据库再执行，对于一些批处理脚本，这种方式尤其方便。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">mysql -uroot -p2143 db01 -e &quot;select * from tb_book&quot;;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/4/1555325632715.png" alt="1555325632715"> </p><h4 id="1-2-mysqladmin"><a href="#1-2-mysqladmin" class="headerlink" title="1.2 mysqladmin"></a>1.2 mysqladmin</h4><p>mysqladmin 是一个执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等。</p><p>可以通过 ： mysqladmin –help  指令查看帮助文档</p><p><img src="/images/MySQL_hm/4/1555326108697.png" alt="1555326108697"> </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 ：</span><br><span class="line">mysqladmin -uroot -p2143 create &#39;test01&#39;;  </span><br><span class="line">mysqladmin -uroot -p2143 drop &#39;test01&#39;;</span><br><span class="line">mysqladmin -uroot -p2143 version;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-3-mysqlbinlog"><a href="#1-3-mysqlbinlog" class="headerlink" title="1.3 mysqlbinlog"></a>1.3 mysqlbinlog</h4><p>由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会使用到mysqlbinlog 日志管理工具。</p><p>语法 ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqlbinlog [options]  log-files1 log-files2 ...</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line"></span><br><span class="line">-d, --database&#x3D;name : 指定数据库名称，只列出指定的数据库相关操作。</span><br><span class="line"></span><br><span class="line">-o, --offset&#x3D;# : 忽略掉日志中的前n行命令。</span><br><span class="line"></span><br><span class="line">-r,--result-file&#x3D;name : 将输出的文本格式日志输出到指定文件。</span><br><span class="line"></span><br><span class="line">-s, --short-form : 显示简单格式， 省略掉一些信息。</span><br><span class="line"></span><br><span class="line">--start-datatime&#x3D;date1  --stop-datetime&#x3D;date2 : 指定日期间隔内的所有日志。</span><br><span class="line"></span><br><span class="line">--start-position&#x3D;pos1 --stop-position&#x3D;pos2 : 指定位置间隔内的所有日志。</span><br></pre></td></tr></table></figure><h4 id="1-4-mysqldump"><a href="#1-4-mysqldump" class="headerlink" title="1.4 mysqldump"></a>1.4 mysqldump</h4><p>mysqldump 客户端工具用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句。</p><p>语法 ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump [options] db_name [tables]</span><br><span class="line"></span><br><span class="line">mysqldump [options] --database&#x2F;-B db1 [db2 db3...]</span><br><span class="line"></span><br><span class="line">mysqldump [options] --all-databases&#x2F;-A</span><br></pre></td></tr></table></figure><h5 id="1-4-1-连接选项"><a href="#1-4-1-连接选项" class="headerlink" title="1.4.1 连接选项"></a>1.4.1 连接选项</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参数 ： </span><br><span class="line">-u, --user&#x3D;name指定用户名</span><br><span class="line">-p, --password[&#x3D;name]指定密码</span><br><span class="line">-h, --host&#x3D;name指定服务器IP或域名</span><br><span class="line">-P, --port&#x3D;#指定连接端口</span><br></pre></td></tr></table></figure><h5 id="1-4-2-输出内容选项"><a href="#1-4-2-输出内容选项" class="headerlink" title="1.4.2 输出内容选项"></a>1.4.2 输出内容选项</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参数：</span><br><span class="line">--add-drop-database在每个数据库创建语句前加上 Drop database 语句</span><br><span class="line">--add-drop-table在每个表创建语句前加上 Drop table 语句 , 默认开启 ; 不开启 (--skip-add-drop-table)</span><br><span class="line"></span><br><span class="line">-n, --no-create-db不包含数据库的创建语句</span><br><span class="line">-t, --no-create-info不包含数据表的创建语句</span><br><span class="line">-d --no-data不包含数据</span><br><span class="line"></span><br><span class="line"> -T, --tab&#x3D;name自动生成两个文件：一个.sql文件，创建表结构的语句；</span><br><span class="line"> 一个.txt文件，数据文件，相当于select into outfile  </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 ： </span><br><span class="line">mysqldump -uroot -p2143 db01 tb_book --add-drop-database --add-drop-table &gt; a</span><br><span class="line"></span><br><span class="line">mysqldump -uroot -p2143 -T &#x2F;tmp test city</span><br></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-imagess\1555501806693.png" alt="1555501806693"> </p><h4 id="1-5-mysqlimport-source"><a href="#1-5-mysqlimport-source" class="headerlink" title="1.5 mysqlimport/source"></a>1.5 mysqlimport/source</h4><p>mysqlimport 是客户端数据导入工具，用来导入mysqldump 加 -T 参数后导出的文本文件。</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqlimport [options]  db_name  textfile1  [textfile2...]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqlimport -uroot -p2143 test &#x2F;tmp&#x2F;city.txt</span><br></pre></td></tr></table></figure><p>如果需要导入sql文件,可以使用mysql中的source 指令 : </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;root&#x2F;tb_book.sql</span><br></pre></td></tr></table></figure><h4 id="1-6-mysqlshow"><a href="#1-6-mysqlshow" class="headerlink" title="1.6 mysqlshow"></a>1.6 mysqlshow</h4><p>mysqlshow 客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引。</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqlshow [options] [db_name [table_name [col_name]]]</span><br></pre></td></tr></table></figure><p>参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--count显示数据库及表的统计信息（数据库，表 均可以不指定）-i显示指定数据库或者指定表的状态信息</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询每个数据库的表的数量及表中记录的数量mysqlshow -uroot -p2143 --count#查询test库中每个表中的字段书，及行数mysqlshow -uroot -p2143 test --count#查询test库中book表的详细情况mysqlshow -uroot -p2143 test book --count</span><br></pre></td></tr></table></figure><h3 id="2-Mysql-日志"><a href="#2-Mysql-日志" class="headerlink" title="2. Mysql 日志"></a>2. Mysql 日志</h3><p>在任何一种数据库中，都会有各种各样的日志，记录着数据库工作的方方面面，以帮助数据库管理员追踪数据库曾经发生过的各种事件。MySQL 也不例外，在 MySQL 中，有 4 种不同的日志，分别是错误日志、二进制日志（BINLOG 日志）、查询日志和慢查询日志，这些日志记录着数据库在不同方面的踪迹。</p><h4 id="2-1-错误日志"><a href="#2-1-错误日志" class="headerlink" title="2.1 错误日志"></a>2.1 错误日志</h4><p>错误日志是 MySQL 中最重要的日志之一，它记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，可以首先查看此日志。</p><p>该日志是默认开启的 ， 默认存放目录为 mysql 的数据目录（var/lib/mysql）, 默认的日志文件名为  hostname.err（hostname是主机名）。</p><p>查看日志位置指令 ： </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_error%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/4/1553993244446.png" alt="1553993244446"> </p><p>查看日志内容 ： </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -f /var/lib/mysql/xaxh-server.err</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/4/1553993537874.png" alt="1553993537874"> </p><h4 id="2-2-二进制日志"><a href="#2-2-二进制日志" class="headerlink" title="2.2 二进制日志"></a>2.2 二进制日志</h4><h5 id="2-2-1概述"><a href="#2-2-1概述" class="headerlink" title="2.2.1概述"></a>2.2.1概述</h5><p>二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但是不包括数据查询语句。此日志对于灾难时的数据恢复起着极其重要的作用，MySQL的主从复制， 就是通过该binlog实现的。</p><p>二进制日志，默认情况下是没有开启的，需要到MySQL的配置文件中开启，并配置MySQL日志的格式。 </p><p>配置文件位置 : /usr/my.cnf</p><p>日志存放位置 : 配置时，给定了文件名但是没有指定路径，日志默认写入Mysql的数据目录。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#配置开启binlog日志， 日志的文件前缀为 mysqlbin -----&gt; 生成的文件名如 : mysqlbin.000001,mysqlbin.000002</span><br><span class="line">log_bin&#x3D;mysqlbin</span><br><span class="line"></span><br><span class="line">#配置二进制日志的格式</span><br><span class="line">binlog_format&#x3D;STATEMENT</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-2-2-日志格式"><a href="#2-2-2-日志格式" class="headerlink" title="2.2.2 日志格式"></a>2.2.2 日志格式</h5><p><strong>STATEMENT</strong></p><p>该日志格式在日志文件中记录的都是SQL语句（statement），每一条对数据进行修改的SQL都会记录在日志文件中，通过Mysql提供的mysqlbinlog工具，可以清晰的查看到每条语句的文本。主从复制的时候，从库（slave）会将日志解析为原文本，并在从库重新执行一次。</p><p><strong>ROW</strong></p><p>该日志格式在日志文件中记录的是每一行的数据变更，而不是记录SQL语句。比如，执行SQL语句 ： update tb_book set status=’1’ , 如果是STATEMENT 日志格式，在日志中会记录一行SQL文件； 如果是ROW，由于是对全表进行更新，也就是每一行记录都会发生变更，ROW 格式的日志中会记录每一行的数据变更。</p><p><strong>MIXED</strong></p><p>这是目前MySQL默认的日志格式，即混合了STATEMENT 和 ROW两种格式。默认情况下采用STATEMENT，但是在一些特殊情况下采用ROW来进行记录。MIXED 格式能尽量利用两种模式的优点，而避开他们的缺点。</p><h5 id="2-2-3-日志读取"><a href="#2-2-3-日志读取" class="headerlink" title="2.2.3 日志读取"></a>2.2.3 日志读取</h5><p>由于日志以二进制方式存储，不能直接读取，需要用mysqlbinlog工具来查看，语法如下 ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqlbinlog log-file；</span><br></pre></td></tr></table></figure><p><strong>查看STATEMENT格式日志</strong> </p><p>执行插入语句 ：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_book <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Lucene&#x27;</span>,<span class="string">&#x27;2088-05-01&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure><p> 查看日志文件 ：</p><p><img src="/images/MySQL_hm/4/1554079717375.png" alt="1554079717375"> </p><p>mysqlbin.index : 该文件是日志索引文件 ， 记录日志的文件名；</p><p>mysqlbing.000001 ：日志文件</p><p>查看日志内容 ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqlbinlog mysqlbing.000001；</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/4/1554080016778.png" alt="1554080016778"> </p><p><strong>查看ROW格式日志</strong></p><p>配置 :</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#配置开启binlog日志， 日志的文件前缀为 mysqlbin -----&gt; 生成的文件名如 : mysqlbin.000001,mysqlbin.000002</span><br><span class="line">log_bin&#x3D;mysqlbin</span><br><span class="line"></span><br><span class="line">#配置二进制日志的格式</span><br><span class="line">binlog_format&#x3D;ROW</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>插入数据 :</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_book <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;SpringCloud实战&#x27;</span>,<span class="string">&#x27;2088-05-05&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure><p>如果日志格式是 ROW , 直接查看数据 , 是查看不懂的 ; 可以在mysqlbinlog 后面加上参数 -vv  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqlbinlog <span class="operator">-</span>vv mysqlbin<span class="number">.000002</span> </span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/4/1554095452022.png" alt="1554095452022"> </p><h5 id="2-2-4-日志删除"><a href="#2-2-4-日志删除" class="headerlink" title="2.2.4 日志删除"></a>2.2.4 日志删除</h5><p>对于比较繁忙的系统，由于每天生成日志量大 ，这些日志如果长时间不清楚，将会占用大量的磁盘空间。下面我们将会讲解几种删除日志的常见方法 ：</p><p><strong>方式一</strong> </p><p>通过 Reset Master 指令删除全部 binlog 日志，删除之后，日志编号，将从 xxxx.000001重新开始 。</p><p>查询之前 ，先查询下日志文件 ： </p><p><img src="/images/MySQL_hm/4/1554118609489.png" alt="1554118609489">   </p><p>执行删除日志指令： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Reset Master</span><br></pre></td></tr></table></figure><p>执行之后， 查看日志文件 ：</p><p><img src="/images/MySQL_hm/4/1554118675264.png" alt="1554118675264"> </p><p><strong>方式二</strong></p><p>执行指令 <code> purge  master logs to &#39;mysqlbin.******&#39;</code> ，该命令将删除  <code> ******</code> 编号之前的所有日志。 </p><p><strong>方式三</strong></p><p>执行指令 <code> purge master logs before &#39;yyyy-mm-dd hh24:mi:ss&#39;</code> ，该命令将删除日志为 “yyyy-mm-dd hh24:mi:ss” 之前产生的所有日志 。</p><p><strong>方式四</strong></p><p>设置参数 –expire_logs_days=# ，此参数的含义是设置日志的过期天数， 过了指定的天数后日志将会被自动删除，这样将有利于减少DBA 管理日志的工作量。</p><p>配置如下 ： </p><p><img src="/images/MySQL_hm/4/1554125506938.png" alt="1554125506938"> </p><h4 id="2-3-查询日志"><a href="#2-3-查询日志" class="headerlink" title="2.3 查询日志"></a>2.3 查询日志</h4><p>查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。</p><p>默认情况下， 查询日志是未开启的。如果需要开启查询日志，可以设置以下配置 ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#该选项用来开启查询日志 ， 可选值 ： 0 或者 1 ； 0 代表关闭， 1 代表开启 </span><br><span class="line">general_log&#x3D;1</span><br><span class="line"></span><br><span class="line">#设置日志的文件名 ， 如果没有指定， 默认的文件名为 host_name.log </span><br><span class="line">general_log_file&#x3D;file_name</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 mysql 的配置文件 /usr/my.cnf 中配置如下内容 ： </p><p><img src="/images/MySQL_hm/4/1554128184632.png" alt="1554128184632"> </p><p>配置完毕之后，在数据库执行以下操作 ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tb_book;</span><br><span class="line">select * from tb_book where id &#x3D; 1;</span><br><span class="line">update tb_book set name &#x3D; &#39;lucene入门指南&#39; where id &#x3D; 5;</span><br><span class="line">select * from tb_book where id &lt; 8;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行完毕之后， 再次来查询日志文件 ： </p><p><img src="/images/MySQL_hm/4/1554128089851.png" alt="1554128089851"> </p><h4 id="2-4-慢查询日志"><a href="#2-4-慢查询日志" class="headerlink" title="2.4 慢查询日志"></a>2.4 慢查询日志</h4><p>慢查询日志记录了所有执行时间超过参数 long_query_time 设置值并且扫描记录数不小于 min_examined_row_limit 的所有的SQL语句的日志。long_query_time 默认为 10 秒，最小为 0， 精度可以到微秒。</p><h5 id="2-4-1-文件位置和格式"><a href="#2-4-1-文件位置和格式" class="headerlink" title="2.4.1 文件位置和格式"></a>2.4.1 文件位置和格式</h5><p>慢查询日志默认是关闭的 。可以通过两个参数来控制慢查询日志 ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 该参数用来控制慢查询日志是否开启， 可取值： 1 和 0 ， 1 代表开启， 0 代表关闭slow_query_log&#x3D;1 # 该参数用来指定慢查询日志的文件名slow_query_log_file&#x3D;slow_query.log# 该选项用来配置查询的时间限制， 超过这个时间将认为值慢查询， 将需要进行日志记录， 默认10slong_query_time&#x3D;10</span><br></pre></td></tr></table></figure><h5 id="2-4-2-日志的读取"><a href="#2-4-2-日志的读取" class="headerlink" title="2.4.2 日志的读取"></a>2.4.2 日志的读取</h5><p>和错误日志、查询日志一样，慢查询日志记录的格式也是纯文本，可以被直接读取。</p><p>1） 查询long_query_time 的值。</p><p><img src="/images/MySQL_hm/4/1554130333472.png" alt="1554130333472"> </p><p>2） 执行查询操作</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id, title,price,num ,status <span class="keyword">from</span> tb_item <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/4/1554130448709.png" alt="1554130448709"></p><p>由于该语句执行时间很短，为0s ， 所以不会记录在慢查询日志中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tb_item where title like &#39;%阿尔卡特 (OT-927) 炭黑 联通3G手机 双卡双待165454%&#39; ;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/4/1554130532577.png" alt="1554130532577"> </p><p>该SQL语句 ， 执行时长为 26.77s ，超过10s ， 所以会记录在慢查询日志文件中。</p><p>3） 查看慢查询日志文件</p><p>直接通过cat 指令查询该日志文件 ： </p><p><img src="/images/MySQL_hm/4/1554130669360.png" alt="1554130669360"> </p><p>如果慢查询日志内容很多， 直接查看文件，比较麻烦， 这个时候可以借助于mysql自带的 mysqldumpslow 工具， 来对慢查询日志进行分类汇总。 </p><p><img src="/images/MySQL_hm/4/1554130856485.png" alt="1554130856485"> </p><h3 id="3-Mysql复制"><a href="#3-Mysql复制" class="headerlink" title="3. Mysql复制"></a>3. Mysql复制</h3><h4 id="3-1-复制概述"><a href="#3-1-复制概述" class="headerlink" title="3.1 复制概述"></a>3.1 复制概述</h4><p>复制是指将主数据库的DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。</p><p>MySQL支持一台主库同时向多台从库进行复制， 从库同时也可以作为其他从服务器的主库，实现链状复制。</p><h4 id="3-2-复制原理"><a href="#3-2-复制原理" class="headerlink" title="3.2 复制原理"></a>3.2 复制原理</h4><p>MySQL 的主从复制原理如下。</p><p><img src="/images/MySQL_hm/4/1.jpg" alt="1554423698190"> </p><p>从上层来看，复制分成三步：</p><ul><li><p>Master 主库在事务提交时，会把数据变更作为时间 Events 记录在二进制日志文件 Binlog 中。</p></li><li><p>主库推送二进制日志文件 Binlog 中的日志事件到从库的中继日志 Relay Log 。</p></li><li><p>slave重做中继日志中的事件，将改变反映它自己的数据。</p></li></ul><h4 id="3-3-复制优势"><a href="#3-3-复制优势" class="headerlink" title="3.3 复制优势"></a>3.3 复制优势</h4><p>MySQL 复制的有点主要包含以下三个方面：</p><ul><li><p>主库出现问题，可以快速切换到从库提供服务。</p></li><li><p>可以在从库上执行查询操作，从主库中更新，实现读写分离，降低主库的访问压力。</p></li><li><p>可以在从库中执行备份，以避免备份期间影响主库的服务。</p></li></ul><h4 id="3-4-搭建步骤"><a href="#3-4-搭建步骤" class="headerlink" title="3.4 搭建步骤"></a>3.4 搭建步骤</h4><h5 id="3-4-1-master"><a href="#3-4-1-master" class="headerlink" title="3.4.1 master"></a>3.4.1 master</h5><p>1） 在master 的配置文件（/usr/my.cnf）中，配置如下内容：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#mysql 服务ID,保证整个集群环境中唯一</span></span><br><span class="line"><span class="meta">server-id</span>=<span class="string">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql binlog 日志的存储路径和文件名</span></span><br><span class="line"><span class="meta">log-bin</span>=<span class="string">/var/lib/mysql/mysqlbin</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#错误日志,默认已经开启</span></span><br><span class="line"><span class="comment">#log-err</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql的安装目录</span></span><br><span class="line"><span class="comment">#basedir</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql的临时目录</span></span><br><span class="line"><span class="comment">#tmpdir</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql的数据存放目录</span></span><br><span class="line"><span class="comment">#datadir</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#是否只读,1 代表只读, 0 代表读写</span></span><br><span class="line"><span class="meta">read-only</span>=<span class="string">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#忽略的数据, 指不需要同步的数据库</span></span><br><span class="line"><span class="meta">binlog-ignore-db</span>=<span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定同步的数据库</span></span><br><span class="line"><span class="comment">#binlog-do-db=db01</span></span><br></pre></td></tr></table></figure><p>2） 执行完毕之后，需要重启Mysql：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">service mysql restart ；</span><br></pre></td></tr></table></figure><p>3） 创建同步数据的账户，并且进行授权操作：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> replication slave <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;itcast&#x27;</span>@<span class="string">&#x27;192.168.192.131&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;itcast&#x27;</span>;</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>4） 查看master状态：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> master status;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/4/1554477759735.png" alt="1554477759735"> </p><p>字段含义：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">File : 从哪个日志文件开始推送日志文件 Position ： 从哪个位置开始推送日志Binlog_Ignore_DB : 指定不需要同步的数据库</span><br></pre></td></tr></table></figure><h5 id="3-4-2-slave"><a href="#3-4-2-slave" class="headerlink" title="3.4.2 slave"></a>3.4.2 slave</h5><p>1） 在 slave 端配置文件中，配置如下内容：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#mysql服务端ID,唯一</span></span><br><span class="line"><span class="meta">server-id</span>=<span class="string">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定binlog日志</span></span><br><span class="line"><span class="meta">log-bin</span>=<span class="string">/var/lib/mysql/mysqlbin</span></span><br></pre></td></tr></table></figure><p>2）  执行完毕之后，需要重启Mysql：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service mysql restart；</span><br></pre></td></tr></table></figure><p>3） 执行如下指令 ：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">change master <span class="keyword">to</span> master_host<span class="operator">=</span> <span class="string">&#x27;192.168.192.130&#x27;</span>, master_user<span class="operator">=</span><span class="string">&#x27;itcast&#x27;</span>, master_password<span class="operator">=</span><span class="string">&#x27;itcast&#x27;</span>, master_log_file<span class="operator">=</span><span class="string">&#x27;mysqlbin.000001&#x27;</span>, master_log_pos<span class="operator">=</span><span class="number">413</span>;</span><br></pre></td></tr></table></figure><p>指定当前从库对应的主库的IP地址，用户名，密码，从哪个日志文件开始的那个位置开始同步推送日志。</p><p>4） 开启同步操作</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start slave;</span><br><span class="line"></span><br><span class="line">show slave status;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/4/1554479387365.png" alt="1554479387365"> </p><p>5） 停止同步操作</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stop slave;</span><br></pre></td></tr></table></figure><h5 id="3-4-3-验证同步操作"><a href="#3-4-3-验证同步操作" class="headerlink" title="3.4.3 验证同步操作"></a>3.4.3 验证同步操作</h5><p>1） 在主库中创建数据库，创建表，并插入数据 ：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database db01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">user</span> db01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">sex <span class="type">varchar</span>(<span class="number">1</span>),</span><br><span class="line"><span class="keyword">primary</span> key (id)</span><br><span class="line">)engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(id,name,sex) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(id,name,sex) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Trigger&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(id,name,sex) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Dawn&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br></pre></td></tr></table></figure><p>2） 在从库中查询数据，进行验证 ：</p><p>在从库中，可以查看到刚才创建的数据库：</p><p><img src="/images/MySQL_hm/4/1554544658640.png" alt="1554544658640"> </p><p>在该数据库中，查询user表中的数据：</p><p><img src="/images/MySQL_hm/4/1554544679538.png" alt="1554544679538"> </p><h3 id="4-综合案例"><a href="#4-综合案例" class="headerlink" title="4. 综合案例"></a>4. 综合案例</h3><h4 id="4-1-需求分析"><a href="#4-1-需求分析" class="headerlink" title="4.1 需求分析"></a>4.1 需求分析</h4><p>在业务系统中，需要记录当前业务系统的访问日志，该访问日志包含：操作人，操作时间，访问类，访问方法，请求参数，请求结果，请求结果类型，请求时长 等信息。记录详细的系统访问日志，主要便于对系统中的用户请求进行追踪，并且在系统 的管理后台可以查看到用户的访问记录。</p><p>记录系统中的日志信息，可以通过Spring 框架的AOP来实现。具体的请求处理流程，如下：</p><p><img src="/images/MySQL_hm/4/1555075760661.png" alt="1555075760661"> </p><h4 id="4-2-搭建案例环境"><a href="#4-2-搭建案例环境" class="headerlink" title="4.2 搭建案例环境"></a>4.2 搭建案例环境</h4><h5 id="4-2-1-数据库表"><a href="#4-2-1-数据库表" class="headerlink" title="4.2.1 数据库表"></a>4.2.1 数据库表</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE mysql_demo <span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 ；</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `brand` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;品牌名称&#x27;</span>,</span><br><span class="line">  `first_char` <span class="type">varchar</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;品牌首字母&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `item` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;商品id&#x27;</span>,</span><br><span class="line">  `title` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品标题&#x27;</span>,</span><br><span class="line">  `price` <span class="keyword">double</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品价格，单位为：元&#x27;</span>,</span><br><span class="line">  `num` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;库存数量&#x27;</span>,</span><br><span class="line">  `categoryid` <span class="type">bigint</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;所属类目，叶子类目&#x27;</span>,</span><br><span class="line">  `status` <span class="type">varchar</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品状态，1-正常，2-下架，3-删除&#x27;</span>,</span><br><span class="line">  `sellerid` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商家ID&#x27;</span>,</span><br><span class="line">  `createtime` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `updatetime` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;商品表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">96</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `birthday` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `sex` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `email` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `phone` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `qq` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `operation_log` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;ID&#x27;</span>,</span><br><span class="line">  `operate_class` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;操作类&#x27;</span>,</span><br><span class="line">  `operate_method` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;操作方法&#x27;</span>,</span><br><span class="line">  `return_class` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;返回值类型&#x27;</span>,</span><br><span class="line">  `operate_user` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;操作用户&#x27;</span>,</span><br><span class="line">  `operate_time` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;操作时间&#x27;</span>,</span><br><span class="line">  `param_and_value` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;请求参数名及参数值&#x27;</span>,</span><br><span class="line">  `cost_time` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;执行方法耗时, 单位 ms&#x27;</span>,</span><br><span class="line">  `return_value` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;返回值&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB  <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="4-2-2-pom-xml"><a href="#4-2-2-pom-xml" class="headerlink" title="4.2.2 pom.xml"></a>4.2.2 pom.xml</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span>1.6.6<span class="tag">&lt;/<span class="name">slf4j.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">log4j.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mybatis.version</span>&gt;</span>3.4.5<span class="tag">&lt;/<span class="name">mybatis.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> <span class="comment">&lt;!-- spring --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-orm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">uriEncoding</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">uriEncoding</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="4-2-3-web-xml"><a href="#4-2-3-web-xml" class="headerlink" title="4.2.3 web.xml"></a>4.2.3 web.xml</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">version</span>=<span class="string">&quot;2.5&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 解决post乱码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定加载的配置文件 ，通过参数contextConfigLocation加载--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>log-datalist.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="4-2-4-db-properties"><a href="#4-2-4-db-properties" class="headerlink" title="4.2.4 db.properties"></a>4.2.4 db.properties</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://192.168.142.128:3306/mysql_demo</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">itcast</span></span><br></pre></td></tr></table></figure><h5 id="4-2-5-applicationContext-xml"><a href="#4-2-5-applicationContext-xml" class="headerlink" title="4.2.5 applicationContext.xml"></a>4.2.5 applicationContext.xml</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 加载配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:db.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置 spring 创建容器时要扫描的包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.itcast&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">context:exclude-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置 MyBatis 的 Session 工厂 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cn.itcast.pojo&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置 Mapper 扫描器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cn.itcast.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务的注解驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="4-2-6-springmvc-xml"><a href="#4-2-6-springmvc-xml" class="headerlink" title="4.2.6 springmvc.xml"></a>4.2.6 springmvc.xml</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.itcast.controller&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="4-2-7-导入基础工程"><a href="#4-2-7-导入基础工程" class="headerlink" title="4.2.7 导入基础工程"></a>4.2.7 导入基础工程</h5><p><img src="/images/MySQL_hm/4/1555076434270.png" alt="1555076434270"> </p><h4 id="4-3-通过AOP记录操作日志"><a href="#4-3-通过AOP记录操作日志" class="headerlink" title="4.3 通过AOP记录操作日志"></a>4.3 通过AOP记录操作日志</h4><h5 id="4-3-1-自定义注解"><a href="#4-3-1-自定义注解" class="headerlink" title="4.3.1 自定义注解"></a>4.3.1 自定义注解</h5><p>通过自定义注解，来标示方法需不需要进行记录日志，如果该方法在访问时需要记录日志，则在该方法上标示该注解既可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> OperateLog &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-3-2-定义通知类"><a href="#4-3-2-定义通知类" class="headerlink" title="4.3.2 定义通知类"></a>4.3.2 定义通知类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperateAdvice</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Logger log = Logger.getLogger(OperateAdvice.class);</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> OperationLogService operationLogService;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   <span class="meta">@Around(&quot;execution(* cn.itcast.controller.*.*(..)) &amp;&amp; @annotation(operateLog)&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">insertLogAround</span><span class="params">(ProceedingJoinPoint pjp , OperateLog operateLog)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot; ************************ 记录日志 [start]  ****************************** &quot;</span>);</span><br><span class="line">      </span><br><span class="line">      OperationLog op = <span class="keyword">new</span> OperationLog();</span><br><span class="line">      </span><br><span class="line">      DateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">      op.setOperateTime(sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">      op.setOperateUser(DataUtils.getRandStr(<span class="number">8</span>));</span><br><span class="line">      </span><br><span class="line">      op.setOperateClass(pjp.getTarget().getClass().getName());</span><br><span class="line">      op.setOperateMethod(pjp.getSignature().getName());</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//获取方法调用时传递的参数</span></span><br><span class="line">      Object[] args = pjp.getArgs();</span><br><span class="line">      op.setParamAndValue(Arrays.toString(args));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> start_time = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//放行</span></span><br><span class="line">      Object object = pjp.proceed();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> end_time = System.currentTimeMillis();</span><br><span class="line">      op.setCostTime(end_time - start_time);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(object != <span class="keyword">null</span>)&#123;</span><br><span class="line">         op.setReturnClass(object.getClass().getName());</span><br><span class="line">         op.setReturnValue(object.toString());</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         op.setReturnClass(<span class="string">&quot;java.lang.Object&quot;</span>);</span><br><span class="line">         op.setParamAndValue(<span class="string">&quot;void&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      log.error(JsonUtils.obj2JsonString(op));</span><br><span class="line"></span><br><span class="line">      operationLogService.insert(op);</span><br><span class="line">      </span><br><span class="line">      System.out.println(<span class="string">&quot; ************************** 记录日志 [end]  *************************** &quot;</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> object;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-3-3-方法上加注解"><a href="#4-3-3-方法上加注解" class="headerlink" title="4.3.3 方法上加注解"></a>4.3.3 方法上加注解</h5><p>在需要记录日志的方法上加上注解@OperateLog。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@OperateLog</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/insert&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">insert</span><span class="params">(<span class="meta">@RequestBody</span> Brand brand)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        brandService.insert(brand);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">true</span>,<span class="string">&quot;操作成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">false</span>,<span class="string">&quot;操作失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-日志查询后端代码实现"><a href="#4-4-日志查询后端代码实现" class="headerlink" title="4.4 日志查询后端代码实现"></a>4.4 日志查询后端代码实现</h4><h5 id="4-4-1-Mapper接口"><a href="#4-4-1-Mapper接口" class="headerlink" title="4.4.1 Mapper接口"></a>4.4.1 Mapper接口</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OperationLogMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(OperationLog operationLog)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;OperationLog&gt; <span class="title">selectListByCondition</span><span class="params">(Map dataMap)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">countByCondition</span><span class="params">(Map dataMap)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-4-2-Mapper-xml-映射配置文件"><a href="#4-4-2-Mapper-xml-映射配置文件" class="headerlink" title="4.4.2 Mapper.xml 映射配置文件"></a>4.4.2 Mapper.xml 映射配置文件</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;cn.itcast.mapper.OperationLogMapper&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;operationLog&quot;</span>&gt;</span></span><br><span class="line">        INSERT INTO operation_log(id,return_value,return_class,operate_user,operate_time,param_and_value,</span><br><span class="line">        operate_class,operate_method,cost_time)</span><br><span class="line">      VALUES(NULL,#&#123;returnValue&#125;,#&#123;returnClass&#125;,#&#123;operateUser&#125;,#&#123;operateTime&#125;,#&#123;paramAndValue&#125;,</span><br><span class="line">        #&#123;operateClass&#125;,#&#123;operateMethod&#125;,#&#123;costTime&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectListByCondition&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;operationLog&quot;</span>&gt;</span></span><br><span class="line">      select</span><br><span class="line">        id ,</span><br><span class="line">        operate_class as operateClass ,</span><br><span class="line">        operate_method as operateMethod,</span><br><span class="line">        return_class as returnClass,</span><br><span class="line">        operate_user as operateUser,</span><br><span class="line">        operate_time as operateTime,</span><br><span class="line">        param_and_value as paramAndValue,</span><br><span class="line">        cost_time as costTime,</span><br><span class="line">        return_value as returnValue</span><br><span class="line">      from operation_log</span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;oplog_where&quot;</span>/&gt;</span></span><br><span class="line">      limit #&#123;start&#125;,#&#123;size&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;countByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;long&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        select count(*) from operation_log</span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;oplog_where&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;oplog_where&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;operateClass != null and operateClass != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">                and operate_class = #&#123;operateClass&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;operateMethod != null and operateMethod != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">                and operate_method = #&#123;operateMethod&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;returnClass != null and returnClass != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">                and return_class = #&#123;returnClass&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;costTime != null&quot;</span>&gt;</span></span><br><span class="line">                and cost_time =  #&#123;costTime&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="4-4-3-Service"><a href="#4-4-3-Service" class="headerlink" title="4.4.3 Service"></a>4.4.3 Service</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationLogService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private static Logger logger = Logger.getLogger(OperationLogService.class);</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OperationLogMapper operationLogMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(OperationLog operationLog)</span></span>&#123;</span><br><span class="line">        operationLogMapper.insert(operationLog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据条件查询</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PageResult <span class="title">selectListByCondition</span><span class="params">(Map dataMap, Integer pageNum , Integer pageSize)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(paramMap ==<span class="keyword">null</span>)&#123;</span><br><span class="line">            paramMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        &#125;</span><br><span class="line">        paramMap.put(<span class="string">&quot;start&quot;</span> , (pageNum-<span class="number">1</span>)*rows);</span><br><span class="line">        paramMap.put(<span class="string">&quot;rows&quot;</span>,rows);</span><br><span class="line"></span><br><span class="line">        Object costTime = paramMap.get(<span class="string">&quot;costTime&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(costTime != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(costTime.toString()))&#123;</span><br><span class="line">                paramMap.put(<span class="string">&quot;costTime&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                paramMap.put(<span class="string">&quot;costTime&quot;</span>,<span class="keyword">new</span> Long(paramMap.get(<span class="string">&quot;costTime&quot;</span>).toString()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(dataMap);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> countStart = System.currentTimeMillis();</span><br><span class="line">        Long count = operationLogMapper.countByCondition(dataMap);</span><br><span class="line">        <span class="keyword">long</span> countEnd = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Count Cost Time : &quot;</span> + (countEnd-countStart)+<span class="string">&quot; ms&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;OperationLog&gt; list = operationLogMapper.selectListByCondition(dataMap);</span><br><span class="line">        <span class="keyword">long</span> queryEnd = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Query Cost Time : &quot;</span> + (queryEnd-countEnd)+<span class="string">&quot; ms&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PageResult(count,list);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-4-4-Controller"><a href="#4-4-4-Controller" class="headerlink" title="4.4.4 Controller"></a>4.4.4 Controller</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/operationLog&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationLogController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OperationLogService operationLogService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/findList&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PageResult <span class="title">findList</span><span class="params">(<span class="meta">@RequestBody</span> Map dataMap, Integer pageNum , Integer pageSize)</span></span>&#123;</span><br><span class="line">        PageResult page = operationLogService.selectListByCondition(dataMap, pageNum, pageSize);</span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-日志查询前端代码实现"><a href="#4-5-日志查询前端代码实现" class="headerlink" title="4.5 日志查询前端代码实现"></a>4.5 日志查询前端代码实现</h4><p>前端代码使用 BootStrap + AdminLTE 进行布局， 使用Vuejs 进行视图层展示。</p><h5 id="4-5-1-js"><a href="#4-5-1-js" class="headerlink" title="4.5.1 js"></a>4.5.1 js</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">       el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">       data: &#123;</span><br><span class="line">           dataList:[],</span><br><span class="line">           searchEntity:&#123;</span><br><span class="line"><span class="javascript">               operateClass:<span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">               operateMethod:<span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">               returnClass:<span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">               costTime:<span class="string">&#x27;&#x27;</span></span></span><br><span class="line">           &#125;,</span><br><span class="line"></span><br><span class="line"><span class="javascript">           page: <span class="number">1</span>,  <span class="comment">//显示的是哪一页</span></span></span><br><span class="line"><span class="javascript">           pageSize: <span class="number">10</span>, <span class="comment">//每一页显示的数据条数</span></span></span><br><span class="line"><span class="javascript">           total: <span class="number">150</span>, <span class="comment">//记录总数</span></span></span><br><span class="line"><span class="javascript">           maxPage:<span class="number">8</span>  <span class="comment">//最大页数</span></span></span><br><span class="line">       &#125;,</span><br><span class="line">       methods: &#123;</span><br><span class="line"><span class="javascript">           pageHandler: <span class="function"><span class="keyword">function</span> (<span class="params">page</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">               <span class="built_in">this</span>.page = page;</span></span><br><span class="line"><span class="javascript">               <span class="built_in">this</span>.search();</span></span><br><span class="line">           &#125;,</span><br><span class="line"></span><br><span class="line"><span class="javascript">           search: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">               <span class="keyword">var</span> _this = <span class="built_in">this</span>;</span></span><br><span class="line"><span class="javascript">               <span class="built_in">this</span>.showLoading();</span></span><br><span class="line"><span class="javascript">               axios.post(<span class="string">&#x27;/operationLog/findList.do?pageNum=&#x27;</span> + _this.page + <span class="string">&quot;&amp;pageSize=&quot;</span> + _this.pageSize, _this.searchEntity).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span></span><br><span class="line">                   if (response) &#123;</span><br><span class="line">                       _this.dataList = response.data.dataList;</span><br><span class="line">                       _this.total = response.data.total;</span><br><span class="line">                       _this.hideLoading();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;)</span><br><span class="line">           &#125;,</span><br><span class="line"></span><br><span class="line"><span class="javascript">           showLoading: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">               $(<span class="string">&#x27;#loadingModal&#x27;</span>).modal(&#123;<span class="attr">backdrop</span>: <span class="string">&#x27;static&#x27;</span>, <span class="attr">keyboard</span>: <span class="literal">false</span>&#125;);</span></span><br><span class="line">           &#125;,</span><br><span class="line"></span><br><span class="line"><span class="javascript">           hideLoading: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">               $(<span class="string">&#x27;#loadingModal&#x27;</span>).modal(<span class="string">&#x27;hide&#x27;</span>);</span></span><br><span class="line">           &#125;,</span><br><span class="line">       &#125;,</span><br><span class="line"></span><br><span class="line"><span class="javascript">       created:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">           <span class="built_in">this</span>.pageHandler(<span class="number">1</span>);</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="4-5-2-列表数据展示"><a href="#4-5-2-列表数据展示" class="headerlink" title="4.5.2 列表数据展示"></a>4.5.2 列表数据展示</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">v-for</span>=<span class="string">&quot;item in dataList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.id&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.operateClass&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.operateMethod&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.returnClass&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.returnValue&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.operateUser&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.operateTime&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.costTime&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;text-center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn bg-olive btn-xs&quot;</span>&gt;</span>详情<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn bg-olive btn-xs&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4.5.3 分页插件</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span> <span class="attr">id</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">zpagenav</span> <span class="attr">v-bind:page</span>=<span class="string">&quot;page&quot;</span> <span class="attr">v-bind:page-size</span>=<span class="string">&quot;pageSize&quot;</span> <span class="attr">v-bind:total</span>=<span class="string">&quot;total&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">v-bind:max-page</span>=<span class="string">&quot;maxPage&quot;</span>  <span class="attr">v-on:pagehandler</span>=<span class="string">&quot;pageHandler&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">zpagenav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-6-联调测试"><a href="#4-6-联调测试" class="headerlink" title="4.6 联调测试"></a>4.6 联调测试</h4><p>可以通过postman来访问业务系统，再查看数据库中的日志信息，验证能不能将用户的访问日志记录下来。</p><p><img src="/images/MySQL_hm/4/1555077276426.png" alt="1555077276426"> </p><h4 id="4-7-分析性能问题"><a href="#4-7-分析性能问题" class="headerlink" title="4.7 分析性能问题"></a>4.7 分析性能问题</h4><p>系统中用户访问日志的数据量，随着时间的推移，这张表的数据量会越来越大，因此我们需要根据业务需求，来对日志查询模块的性能进行优化。</p><p>1） 分页查询优化</p><p>由于在进行日志查询时，是进行分页查询，那也就意味着，在查看时，至少需要查询两次：</p><p>A. 查询符合条件的总记录数。–&gt; count 操作</p><p>B. 查询符合条件的列表数据。–&gt; 分页查询 limit 操作</p><p>通常来说，count() 都需要扫描大量的行（意味着需要访问大量的数据）才能获得精确的结果，因此是很难对该SQL进行优化操作的。如果需要对count进行优化，可以采用另外一种思路，可以增加汇总表，或者redis缓存来专门记录该表对应的记录数，这样的话，就可以很轻松的实现汇总数据的查询，而且效率很高，但是这种统计并不能保证百分之百的准确 。对于数据库的操作，“快速、精确、实现简单”，三者永远只能满足其二，必须舍掉其中一个。</p><p>2） 条件查询优化</p><p>针对于条件查询,需要对查询条件,及排序字段建立索引。</p><p>3） 读写分离</p><p>通过主从复制集群，来完成读写分离，使写操作走主节点， 而读操作，走从节点。</p><p>4） MySQL服务器优化</p><p>5） 应用优化</p><h4 id="4-8-性能优化-分页"><a href="#4-8-性能优化-分页" class="headerlink" title="4.8 性能优化 - 分页"></a>4.8 性能优化 - 分页</h4><h5 id="4-8-1-优化count"><a href="#4-8-1-优化count" class="headerlink" title="4.8.1 优化count"></a>4.8.1 优化count</h5><p>创建一张表用来记录日志表的总数据量：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> log_counter(</span><br><span class="line">logcount <span class="type">bigint</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">)engine <span class="operator">=</span> innodb <span class="keyword">default</span> CHARSET <span class="operator">=</span> utf8;</span><br></pre></td></tr></table></figure><p>在每次插入数据之后，更新该表 ：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateLogCounter&quot;</span> &gt;</span></span><br><span class="line">    update log_counter set logcount = logcount + 1</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在进行分页查询时, 获取总记录数，从该表中查询既可。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;countLogFromCounter&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;long&quot;</span>&gt;</span>    select logcount from log_counter limit 1<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="4-8-2-优化-limit"><a href="#4-8-2-优化-limit" class="headerlink" title="4.8.2 优化 limit"></a>4.8.2 优化 limit</h5><p>在进行分页时，一般通过创建覆盖索引，能够比较好的提高性能。一个非常常见，而又非常头疼的分页场景就是 “limit 1000000,10” ，此时MySQL需要搜索出前1000010 条记录后，仅仅需要返回第 1000001 到 1000010 条记录，前1000000 记录会被抛弃，查询代价非常大。 </p><p><img src="/images/MySQL_hm/4/1555081714638.png" alt="1555081714638"> </p><p>当点击比较靠后的页码时，就会出现这个问题，查询效率非常慢。</p><p>优化SQL：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> operation_log limit <span class="number">3000000</span> , <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>将上述SQL优化为 : </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> operation_log t , (<span class="keyword">select</span> id <span class="keyword">from</span> operation_log <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">3000000</span>,<span class="number">10</span>) b <span class="keyword">where</span> t.id <span class="operator">=</span> b.id ;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectListByCondition&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;operationLog&quot;</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    id ,</span><br><span class="line">    operate_class as operateClass ,</span><br><span class="line">    operate_method as operateMethod,</span><br><span class="line">    return_class as returnClass,</span><br><span class="line">    operate_user as operateUser,</span><br><span class="line">    operate_time as operateTime,</span><br><span class="line">    param_and_value as paramAndValue,</span><br><span class="line">    cost_time as costTime,</span><br><span class="line">    return_value as returnValue</span><br><span class="line">  from operation_log t,</span><br><span class="line">    </span><br><span class="line">  (select id from operation_log </span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;oplog_where&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">  order by id limit #&#123;start&#125;,#&#123;rows&#125;) b  where t.id = b.id  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-9-性能优化-索引"><a href="#4-9-性能优化-索引" class="headerlink" title="4.9 性能优化 - 索引"></a>4.9 性能优化 - 索引</h4><p><img src="/images/MySQL_hm/4/1555152703824.png" alt="1555152703824"></p><p>当根据操作人进行查询时， 查询的效率很低，耗时比较长。原因就是因为在创建数据库表结构时，并没有针对于 操作人 字段建立索引。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_user_method_return_cost <span class="keyword">ON</span> operation_log(operate_user,operate_method,return_class,cost_time);</span><br></pre></td></tr></table></figure><p>同上 ， 为了查询效率高，我们也需要对 操作方法、返回值类型、操作耗时 等字段进行创建索引，以提高查询效率。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_optlog_method_return_cost <span class="keyword">ON</span> operation_log(operate_method,return_class,cost_time);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_optlog_return_cost <span class="keyword">ON</span> operation_log(return_class,cost_time);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_optlog_cost <span class="keyword">ON</span> operation_log(cost_time);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-10-性能优化-排序"><a href="#4-10-性能优化-排序" class="headerlink" title="4.10 性能优化 - 排序"></a>4.10 性能优化 - 排序</h4><p>在查询数据时，如果业务需求中需要我们对结果内容进行了排序处理 , 这个时候,我们还需要对排序的字段建立适当的索引, 来提高排序的效率 。</p><h4 id="4-11-性能优化-读写分离"><a href="#4-11-性能优化-读写分离" class="headerlink" title="4.11 性能优化 - 读写分离"></a>4.11 性能优化 - 读写分离</h4><h5 id="4-11-1-概述"><a href="#4-11-1-概述" class="headerlink" title="4.11.1 概述"></a>4.11.1 概述</h5><p>在Mysql主从复制的基础上，可以使用读写分离来降低单台Mysql节点的压力，从而来提高访问效率，读写分离的架构如下：</p><p><img src="/images/MySQL_hm/4/1555235426739.png" alt="1555235426739"> </p><p>对于读写分离的实现，可以通过Spring AOP 来进行动态的切换数据源，进行操作 ：</p><h5 id="4-11-2-实现方式"><a href="#4-11-2-实现方式" class="headerlink" title="4.11.2 实现方式"></a>4.11.2 实现方式</h5><p>db.properties</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">jdbc.write.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.write.url</span>=<span class="string">jdbc:mysql://192.168.142.128:3306/mysql_demo</span></span><br><span class="line"><span class="meta">jdbc.write.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.write.password</span>=<span class="string">itcast</span></span><br><span class="line"></span><br><span class="line"><span class="meta">jdbc.read.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.read.url</span>=<span class="string">jdbc:mysql://192.168.142.129:3306/mysql_demo</span></span><br><span class="line"><span class="meta">jdbc.read.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.read.password</span>=<span class="string">itcast</span></span><br></pre></td></tr></table></figure><p>applicationContext-datasource.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据源 - Read --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;readDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>  <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.read.driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.read.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.read.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.read.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据源 - Write --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;writeDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>  <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>  <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.write.driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.write.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.write.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.write.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置动态分配的读写 数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.itcast.aop.datasource.ChooseDataSource&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetDataSources&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span> <span class="attr">key-type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value-type</span>=<span class="string">&quot;javax.sql.DataSource&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;write&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;writeDataSource&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;read&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;readDataSource&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultTargetDataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;writeDataSource&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;methodType&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span> <span class="attr">key-type</span>=<span class="string">&quot;java.lang.String&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;read&quot;</span> <span class="attr">value</span>=<span class="string">&quot;,get,select,count,list,query,find&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;write&quot;</span> <span class="attr">value</span>=<span class="string">&quot;,add,create,update,delete,remove,insert&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ChooseDataSource</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChooseDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractRoutingDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; METHOD_TYPE_MAP = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现父类中的抽象方法，获取数据源名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceHandler.getDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置方法名前缀对应的数据源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMethodType</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            List&lt;String&gt; v = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            String[] types = map.get(key).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (String type : types) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!StringUtils.isEmpty(type)) &#123;</span><br><span class="line">                    v.add(type);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            METHOD_TYPE_MAP.put(key, v);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;METHOD_TYPE_MAP : &quot;</span>+METHOD_TYPE_MAP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DataSourceHandler</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据源名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; holder = <span class="keyword">new</span> ThreadLocal&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在项目启动的时候将配置的读、写数据源加到holder中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putDataSource</span><span class="params">(String datasource)</span> </span>&#123;</span><br><span class="line">        holder.set(datasource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从holer中获取数据源字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DataSourceAspect</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(-9999)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置前置通知,使用在方法aspect()上注册的切入点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* cn.itcast.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="meta">@Order(-9999)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint point)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String className = point.getTarget().getClass().getName();</span><br><span class="line">        String method = point.getSignature().getName();</span><br><span class="line">        logger.info(className + <span class="string">&quot;.&quot;</span> + method + <span class="string">&quot;(&quot;</span> + Arrays.asList(point.getArgs())+ <span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (String key : ChooseDataSource.METHOD_TYPE_MAP.keySet()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String type : ChooseDataSource.METHOD_TYPE_MAP.get(key)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (method.startsWith(type)) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;key : &quot;</span> + key);</span><br><span class="line">                        DataSourceHandler.putDataSource(key);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 @Order(-9999) 注解来控制事务管理器, 与该通知类的加载顺序 , 需要让通知类 , 先加载 , 来判定使用哪个数据源 .</p><h5 id="4-11-3-验证"><a href="#4-11-3-验证" class="headerlink" title="4.11.3 验证"></a>4.11.3 验证</h5><p>在主库和从库中，执行如下SQL语句，来查看是否读的时候， 从从库中读取 ； 写入操作的时候，是否写入到主库。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Innodb_rows_%&#x27;</span> ;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL_hm/4/1555235982584.png" alt="1555235982584"> </p><h5 id="4-11-4-原理"><a href="#4-11-4-原理" class="headerlink" title="4.11.4 原理"></a>4.11.4 原理</h5><p><img src="/images/MySQL_hm/4/aop-datasource.png" alt="1555235982584"></p><h4 id="4-12-性能优化-应用优化"><a href="#4-12-性能优化-应用优化" class="headerlink" title="4.12 性能优化 - 应用优化"></a>4.12 性能优化 - 应用优化</h4><h5 id="4-12-1-缓存"><a href="#4-12-1-缓存" class="headerlink" title="4.12.1 缓存"></a>4.12.1 缓存</h5><p>可以在业务系统中使用redis来做缓存，缓存一些基础性的数据，来降低关系型数据库的压力，提高访问效率。</p><h5 id="4-12-2-全文检索"><a href="#4-12-2-全文检索" class="headerlink" title="4.12.2 全文检索"></a>4.12.2 全文检索</h5><p>如果业务系统中的数据量比较大（达到千万级别），这个时候，如果再对数据库进行查询，特别是进行分页查询，速度将变得很慢（因为在分页时首先需要count求合计数），为了提高访问效率，这个时候，可以考虑加入Solr 或者 ElasticSearch全文检索服务，来提高访问效率。</p><h5 id="4-13-3-非关系数据库"><a href="#4-13-3-非关系数据库" class="headerlink" title="4.13.3 非关系数据库"></a>4.13.3 非关系数据库</h5><p>也可以考虑将非核心（重要）数据，存在 MongoDB 中，这样可以提高插入以及查询的效率。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Mysql黑马程序员&lt;/p&gt;</summary>
    
    
    
    <category term="Study" scheme="https://memorykk.cn/categories/Study/"/>
    
    
    <category term="MySQL" scheme="https://memorykk.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis</title>
    <link href="https://memorykk.cn/Mybatis.html"/>
    <id>https://memorykk.cn/Mybatis.html</id>
    <published>2021-08-19T06:23:35.000Z</published>
    <updated>2021-08-21T03:57:17.321Z</updated>
    
    <content type="html"><![CDATA[<p>MyBatis 是一个半自动化的<strong>ORM框架</strong> </p><span id="more"></span><ul><li><p><a href="#01-mybatis%E4%B8%8Ehibernate%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C">0.1. <strong>MyBatis与Hibernate有哪些不同？</strong></a></p></li><li><p><a href="#02-%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2like">0.2. <strong>模糊查询like</strong></a></p></li><li><p><a href="#03-%E5%BC%95%E5%85%A5%E8%B5%84%E6%BA%90%E6%96%B9%E5%BC%8F">0.3. <strong>引入资源方式</strong></a></p></li><li><p><a href="#04-namespace">0.4. namespace</a></p></li><li><p><a href="#05-dao%E6%8E%A5%E5%8F%A3%E5%92%8Cxml%E6%96%87%E4%BB%B6%E9%87%8C%E7%9A%84sql%E6%98%AF%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E5%85%B3%E7%B3%BB%E7%9A%84">0.5. Dao接口和XML文件里的SQL是如何建立关系的？</a></p><ul><li><a href="#051-%E4%B8%80%E8%A7%A3%E6%9E%90xml">0.5.1. 一、解析XML</a><ul><li><a href="#0511-%E5%88%9B%E5%BB%BAsqlsource">0.5.1.1. 、创建SqlSource</a></li><li><a href="#0512-%E5%88%9B%E5%BB%BAmappedstatement">0.5.1.2. 、创建MappedStatement</a></li></ul></li><li><a href="#052-%E4%BA%8Cdao%E6%8E%A5%E5%8F%A3%E4%BB%A3%E7%90%86">0.5.2. 二、Dao接口代理</a></li><li><a href="#053-%E4%B8%89%E6%89%A7%E8%A1%8C">0.5.3. 三、执行</a></li></ul></li><li><p><a href="#06-%E4%BD%9C%E7%94%A8%E5%9F%9F">0.6. <strong>作用域</strong></a></p></li><li><p><a href="#07-%E5%B1%9E%E6%80%A7%E5%90%8D%E5%92%8C%E5%AD%97%E6%AE%B5%E5%90%8D%E4%B8%8D%E4%B8%80%E8%87%B4">0.7. 属性名和字段名不一致</a></p></li><li><p><a href="#08-resultmap">0.8. ResultMap</a></p></li><li><p><a href="#09-%E5%88%86%E9%A1%B5">0.9. 分页</a></p></li><li><p><a href="#010-%E5%9C%A8mapper%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0">0.10. <strong>在mapper中如何传递多个参数?</strong></a></p></li><li><p><a href="#011-mapper-%E7%BC%96%E5%86%99%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F">0.11. Mapper 编写有哪几种方式？</a></p></li><li><p><a href="#012-%E6%B3%A8%E8%A7%A3">0.12. 注解</a></p></li><li><p><a href="#013-mybatis%E8%AF%A6%E7%BB%86%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B">0.13. Mybatis详细的执行流程</a></p></li><li><p><a href="#014-mybatis%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E4%BB%8B%E7%BB%8D">0.14. MyBatis的工作原理以及核心流程介绍</a></p><ul><li><a href="#0141-mybatis%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3">0.14.1. 、MyBatis的工作原理以及核心流程详解</a></li></ul></li><li><p><a href="#015-param">0.15. @Param</a></p></li><li><p><a href="#016-%E4%B8%8E%E7%9A%84%E5%8C%BA%E5%88%AB">0.16. #与$的区别</a></p></li><li><p><a href="#017-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%93%BE%E6%8E%A5%E4%B8%AD%E6%96%AD%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86">0.17. 数据库链接中断如何处理</a></p></li><li><p><a href="#018-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%92%E5%85%A5%E9%87%8D%E5%A4%8D%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86">0.18. 数据库插入重复如何处理</a></p></li><li><p><a href="#019-%E4%B8%80%E4%B8%AAconnection%E5%9C%A8mysql%E4%B8%AD%E5%AF%B9%E5%BA%94%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B">0.19. 一个Connection在MySQL中对应一个线程？</a></p></li><li><p><a href="#020-%E9%A2%84%E7%BC%96%E8%AF%91%E7%9A%84%E8%BF%87%E7%A8%8B">0.20. 预编译的过程</a></p><ul><li><a href="#0201-jdbc%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E7%94%A8%E6%B3%95">0.20.1. 、JDBC的预编译用法</a></li><li><a href="#0202-%E9%A2%84%E7%BC%96%E8%AF%91%E7%9A%84%E5%A5%BD%E5%A4%84">0.20.2. 、预编译的好处</a><ul><li><a href="#02021-%E9%A2%84%E7%BC%96%E8%AF%91%E8%83%BD%E9%81%BF%E5%85%8Dsql%E6%B3%A8%E5%85%A5">0.20.2.1. 、预编译能避免SQL注入</a></li><li><a href="#02022-%E9%A2%84%E7%BC%96%E8%AF%91%E8%83%BD%E6%8F%90%E9%AB%98sql%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87">0.20.2.2. 、预编译能提高SQL执行效率</a></li></ul></li><li><a href="#0203-%E9%A2%84%E7%BC%96%E8%AF%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B">0.20.3. 、预编译的实现过程</a></li></ul></li><li><p><a href="#021">0.21.</a></p></li><li><p><a href="#022-%E5%A4%9A%E5%AF%B9%E4%B8%80">0.22. 多对一</a></p><ul><li><a href="#0221-%E6%8C%89%E6%9F%A5%E8%AF%A2%E5%B5%8C%E5%A5%97%E5%A4%84%E7%90%86">0.22.1. 按查询嵌套处理</a></li><li><a href="#0222-%E6%8C%89%E7%BB%93%E6%9E%9C%E5%B5%8C%E5%A5%97%E5%A4%84%E7%90%86">0.22.2. 按结果嵌套处理</a></li></ul></li><li><p><a href="#023-%E4%B8%80%E5%AF%B9%E5%A4%9A">0.23. 一对多</a></p><ul><li><a href="#0231-%E6%8C%89%E7%BB%93%E6%9E%9C%E5%B5%8C%E5%A5%97%E5%A4%84%E7%90%86">0.23.1. 按结果嵌套处理</a></li><li><a href="#0232-%E6%8C%89%E6%9F%A5%E8%AF%A2%E5%B5%8C%E5%A5%97%E5%A4%84%E7%90%86">0.23.2. 按查询嵌套处理</a></li></ul></li><li><p><a href="#024-%E5%8A%A8%E6%80%81-sql">0.24. 动态 SQL</a></p></li><li><p><a href="#025-dao%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">0.25. Dao接口的工作原理</a></p></li><li><p><a href="#026-%E7%BC%93%E5%AD%98">0.26. 缓存</a></p><ul><li><a href="#0261-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98">0.26.1. 一级缓存</a></li><li><a href="#0262-%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98">0.26.2. 二级缓存</a></li></ul></li><li><p><a href="#027-%E5%92%8C%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">0.27. 、#{}和${}的区别是什么？</a></p></li><li><p><a href="#028-xml-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E4%B8%AD%E9%99%A4%E4%BA%86%E5%B8%B8%E8%A7%81%E7%9A%84-selectinsertupdatedelete-%E6%A0%87%E7%AD%BE%E4%B9%8B%E5%A4%96%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A0%87%E7%AD%BE">0.28. 、Xml 映射文件中，除了常见的 select|insert|update|delete 标签之外，还有哪些标签？</a></p></li><li><p><a href="#029-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%AD%E9%80%9A%E5%B8%B8%E4%B8%80%E4%B8%AA-xml-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E9%83%BD%E4%BC%9A%E5%86%99%E4%B8%80%E4%B8%AA-dao-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E4%B9%8B%E5%AF%B9%E5%BA%94%E8%AF%B7%E9%97%AE%E8%BF%99%E4%B8%AA-dao-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88dao-%E6%8E%A5%E5%8F%A3%E9%87%8C%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%B8%8D%E5%90%8C%E6%97%B6%E6%96%B9%E6%B3%95%E8%83%BD%E9%87%8D%E8%BD%BD%E5%90%97">0.29. 、最佳实践中，通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</a></p><ul><li><a href="#0291-%E8%A1%A5%E5%85%85">0.29.1. ==补充：==</a></li></ul></li><li><p><a href="#030-mybatis-%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%88%86%E9%A1%B5%E7%9A%84%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88">0.30. 、MyBatis 是如何进行分页的？分页插件的原理是什么？</a></p></li><li><p><a href="#031-%E7%AE%80%E8%BF%B0-mybatis-%E7%9A%84%E6%8F%92%E4%BB%B6%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%8F%92%E4%BB%B6">0.31. 、简述 MyBatis 的插件运行原理，以及如何编写一个插件。</a></p></li><li><p><a href="#032-mybatis-%E6%89%A7%E8%A1%8C%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E8%83%BD%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E9%94%AE%E5%88%97%E8%A1%A8%E5%90%97">0.32. 、MyBatis 执行批量插入，能返回数据库主键列表吗？</a></p></li><li><p><a href="#033-mybatis-%E5%8A%A8%E6%80%81-sql-%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8A%A8%E6%80%81-sql%E8%83%BD%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%8A%A8%E6%80%81-sql-%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E4%B8%8D">0.33. 、MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？</a></p></li><li><p><a href="#034-mybatis-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B0%86-sql-%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%B0%81%E8%A3%85%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E5%B9%B6%E8%BF%94%E5%9B%9E%E7%9A%84%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%98%A0%E5%B0%84%E5%BD%A2%E5%BC%8F">0.34. 、MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</a></p></li><li><p><a href="#035-mybatis-%E8%83%BD%E6%89%A7%E8%A1%8C%E4%B8%80%E5%AF%B9%E4%B8%80%E4%B8%80%E5%AF%B9%E5%A4%9A%E7%9A%84%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E5%90%97%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB">0.35. 、MyBatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。</a></p></li><li><p><a href="#036-mybatis-%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E5%A6%82%E6%9E%9C%E6%94%AF%E6%8C%81%E5%AE%83%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88">0.36. 、MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？</a></p></li><li><p><a href="#037-mybatis-%E7%9A%84-xml-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E4%B8%AD%E4%B8%8D%E5%90%8C%E7%9A%84-xml-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6id-%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%A4%8D">0.37. 、MyBatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？</a></p></li><li><p><a href="#038-mybatis-%E4%B8%AD%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E6%89%B9%E5%A4%84%E7%90%86">0.38. 、MyBatis 中如何执行批处理？</a></p></li><li><p><a href="#039-mybatis-%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B-executor-%E6%89%A7%E8%A1%8C%E5%99%A8%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">0.39. 、MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？</a></p></li><li><p><a href="#040-mybatis-%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8C%87%E5%AE%9A%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%80%E7%A7%8D-executor-%E6%89%A7%E8%A1%8C%E5%99%A8">0.40. 、MyBatis 中如何指定使用哪一种 Executor 执行器？</a></p></li><li><p><a href="#041-mybatis-%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%98%A0%E5%B0%84-enum-%E6%9E%9A%E4%B8%BE%E7%B1%BB">0.41. 、MyBatis 是否可以映射 Enum 枚举类？</a></p></li><li><p><a href="#042-mybatis-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E4%B8%AD%E5%A6%82%E6%9E%9C-a-%E6%A0%87%E7%AD%BE%E9%80%9A%E8%BF%87-include-%E5%BC%95%E7%94%A8%E4%BA%86-b-%E6%A0%87%E7%AD%BE%E7%9A%84%E5%86%85%E5%AE%B9%E8%AF%B7%E9%97%AEb-%E6%A0%87%E7%AD%BE%E8%83%BD%E5%90%A6%E5%AE%9A%E4%B9%89%E5%9C%A8-a-%E6%A0%87%E7%AD%BE%E7%9A%84%E5%90%8E%E9%9D%A2%E8%BF%98%E6%98%AF%E8%AF%B4%E5%BF%85%E9%A1%BB%E5%AE%9A%E4%B9%89%E5%9C%A8-a-%E6%A0%87%E7%AD%BE%E7%9A%84%E5%89%8D%E9%9D%A2">0.42. 、MyBatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？</a></p></li><li><p><a href="#043-%E7%AE%80%E8%BF%B0-mybatis-%E7%9A%84-xml-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E5%92%8C-mybatis-%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%97%B4%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB">0.43. 、简述 MyBatis 的 Xml 映射文件和 MyBatis 内部数据结构之间的映射关系？</a></p></li><li><p><a href="#044-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-mybatis-%E6%98%AF%E5%8D%8A%E8%87%AA%E5%8A%A8-orm-%E6%98%A0%E5%B0%84%E5%B7%A5%E5%85%B7%E5%AE%83%E4%B8%8E%E5%85%A8%E8%87%AA%E5%8A%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E5%93%AA%E9%87%8C">0.44. 、为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</a><br>MyBatis 是一个半自动化的<strong>ORM框架</strong> </p></li><li><p>所有的增删改操作都需要提交事务！</p></li><li><p>接口所有的普通参数，尽量都写上@Param参数，尤其是多个参数时，必须写上！</p></li><li><p>有时候根据业务的需求，可以考虑使用map传递参数！</p></li><li><p>为了规范操作，在SQL的配置文件中，我们尽量将Parameter参数和resultType都写上！</p></li></ul><p><img src="/images/Mybatis/20200606200123233.png" alt="20200606200123233"></p><p><img src="/images/Mybatis/image-20210818230659590.png" alt="image-20210818230659590"></p><p>Caching缓存</p><p>Simple</p><p>Batch批量</p><p>Reuse复用</p><p><a href="http://www.mybatis.cn/category/interview/">http://www.mybatis.cn/category/interview/</a></p><h2 id="maven静态资源过滤问题"><a href="#maven静态资源过滤问题" class="headerlink" title="maven静态资源过滤问题"></a>maven静态资源过滤问题</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0-1-MyBatis与Hibernate有哪些不同？"><a href="#0-1-MyBatis与Hibernate有哪些不同？" class="headerlink" title="0.1. MyBatis与Hibernate有哪些不同？"></a>0.1. <strong>MyBatis与Hibernate有哪些不同？</strong></h2><p>1、Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。</p><p>2、Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。</p><p>3、Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用hibernate开发可以节省很多代码，提高效率。</p><h2 id="0-2-模糊查询like"><a href="#0-2-模糊查询like" class="headerlink" title="0.2. 模糊查询like"></a>0.2. <strong>模糊查询like</strong></h2><p>第1种：<strong>在Java代码中添加sql通配符。</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">string wildcardname = “%smi%”;</span><br><span class="line">list<span class="tag">&lt;<span class="name">name</span>&gt;</span> names = mapper.selectlike(wildcardname);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">”selectlike”</span>&gt;</span></span><br><span class="line">select * from foo where bar like #&#123;value&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第2种：在sql语句中拼接通配符，会引起sql注入</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">string wildcardname = “smi”;</span><br><span class="line">list<span class="tag">&lt;<span class="name">name</span>&gt;</span> names = mapper.selectlike(wildcardname);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">”selectlike”</span>&gt;</span></span><br><span class="line">    select * from foo where bar like &quot;%&quot;#&#123;value&#125;&quot;%&quot;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>或是利用sql的contact函数。</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectLike&quot;</span>&gt;</span></span><br><span class="line">    select * from users where name like contact(&quot;%&quot;, #&#123;value&#125;, &quot;%&quot;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0-3-引入资源方式"><a href="#0-3-引入资源方式" class="headerlink" title="0.3. 引入资源方式"></a>0.3. <strong>引入资源方式</strong></h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用相对于类路径的资源引用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/PostMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用完全限定资源定位符（URL） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///var/mappers/AuthorMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">使用映射器接口实现类的完全限定类名</span></span><br><span class="line"><span class="comment">需要配置文件名称和接口名称一致，并且位于同一目录下</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.AuthorMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">将包内的映射器接口实现全部注册为映射器</span></span><br><span class="line"><span class="comment">但是需要配置文件名称和接口名称一致，并且位于同一目录下</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;org.mybatis.builder&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--优先级由上向下降低--&gt;</span> </span><br></pre></td></tr></table></figure><h2 id="0-4-namespace"><a href="#0-4-namespace" class="headerlink" title="0.4. namespace"></a>0.4. namespace</h2><p>namespace中文意思：命名空间，作用如下：</p><ul><li><ul><li>namespace的命名必须跟某个接口同名</li><li>接口中的方法与映射文件中sql语句id应该一一对应</li></ul></li><li><ol><li>namespace和子元素的id联合保证唯一  , 区别不同的mapper</li><li>绑定DAO接口</li><li>namespace命名规则 : 包名+类名</li></ol></li></ul><h2 id="0-5-Dao接口和XML文件里的SQL是如何建立关系的？"><a href="#0-5-Dao接口和XML文件里的SQL是如何建立关系的？" class="headerlink" title="0.5. Dao接口和XML文件里的SQL是如何建立关系的？"></a>0.5. <a href="http://www.mybatis.cn/archives/467.html">Dao接口和XML文件里的SQL是如何建立关系的？</a></h2><p><strong>通过Dao接口生成的动态代理调用查询，根据绑定的namespace确定唯一id，在注册中心里找到mappedStatement，通过sqlSource生成SQL语句，jdbc执行返回。</strong></p><h3 id="0-5-1-一、解析XML"><a href="#0-5-1-一、解析XML" class="headerlink" title="0.5.1. 一、解析XML"></a>0.5.1. 一、解析XML</h3><p>首先，Mybatis在初始化SqlSessionFactoryBean的时候，找到mapperLocations路径去解析里面所有的XML文件，这里我们重点关注两部分。</p><h4 id="0-5-1-1-、创建SqlSource"><a href="#0-5-1-1-、创建SqlSource" class="headerlink" title="0.5.1.1. 、创建SqlSource"></a>0.5.1.1. 、创建SqlSource</h4><p>Mybatis会把每个SQL标签封装成SqlSource对象，然后根据SQL语句的不同，又分为动态SQL和静态SQL。其中，静态SQL包含一段String类型的sql语句；而动态SQL则是由一个个SqlNode组成。</p><p><img src="/images/Mybatis/1118429449.jpg" alt="1118429449"></p><p><img src="/images/Mybatis/2906669416.jpg" alt="2906669416"></p><h4 id="0-5-1-2-、创建MappedStatement"><a href="#0-5-1-2-、创建MappedStatement" class="headerlink" title="0.5.1.2. 、创建MappedStatement"></a>0.5.1.2. 、创建MappedStatement</h4><p>XML文件中的每一个SQL标签就对应一个MappedStatement对象，这里面有两个属性很重要。</p><p><strong>id</strong>：全限定类名+方法名组成的ID。</p><p><strong>sqlSource</strong>：当前SQL标签对应的SqlSource对象。</p><p>创建完MappedStatement对象，将它缓存到Configuration#mappedStatements中。</p><p>Configuration对象就是Mybatis中的大管家，基本所有的配置信息都维护在这里。把所有的XML都解析完成之后，Configuration就包含了所有的SQL信息。</p><p><img src="/images/Mybatis/3090421271.jpg" alt="3090421271"></p><p>到目前为止，XML就解析完成了。当我们执行Mybatis方法的时候，就通过全限定类名+方法名找到MappedStatement对象，然后解析里面的SQL内容，执行即可。</p><h3 id="0-5-2-二、Dao接口代理"><a href="#0-5-2-二、Dao接口代理" class="headerlink" title="0.5.2. 二、Dao接口代理"></a>0.5.2. 二、Dao接口代理</h3><p>我们的Dao接口并没有实现类，那么，我们在调用它的时候，它是怎样最终执行到我们的SQL语句的呢？</p><p>首先，我们在Spring配置文件中，一般会这样配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.viewscenes.netsupervisor.dao&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者你的项目是基于SpringBoot的，那么肯定也见过这种：</p><p>@MapperScan(“com.xxx.dao”)</p><p>它们的作用是一样的。将包路径下的所有类注册到Spring Bean中，并且将它们的beanClass设置为MapperFactoryBean。MapperFactoryBean实现了FactoryBean接口，俗称工厂Bean。那么，当我们通过@Autowired注入这个Dao接口的时候，返回的对象就是MapperFactoryBean这个工厂Bean中的getObject()方法对象。</p><p>简单来说，它就是<strong>通过JDK动态代理，返回了一个Dao接口的代理对象，这个代理对象的处理器是MapperProxy对象。所有，我们通过@Autowired注入Dao接口的时候，注入的就是这个代理对象，我们调用到Dao接口的方法时，则会调用到MapperProxy对象的invoke方法。</strong></p><p>曾经有个朋友问过这样一个问题：</p><p>对于有实现的dao接口，mapper还会用代理么？</p><p>答案是肯定，只要你配置了MapperScan，它就会去扫描，然后生成代理。但是，如果你的dao接口有实现类，并且这个实现类也是一个Spring Bean，那就要看你在Autowired的时候，去注入哪一个了。</p><p>会报错，因为在注入的时候，找到了两个UserDao的实例对象。其实我们通过名字注入就可以了。</p><h3 id="0-5-3-三、执行"><a href="#0-5-3-三、执行" class="headerlink" title="0.5.3. 三、执行"></a>0.5.3. 三、执行</h3><p>如上所述，当我们调用Dao接口方法的时候，实际调用到代理对象的invoke方法。 在这里，实际上调用的就是SqlSession里面的东西了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlSession</span> <span class="keyword">implements</span> <span class="title">SqlSession</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">            <span class="keyword">return</span> executor.query(ms, </span><br><span class="line">                wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是通过statement全限定类型+方法名拿到MappedStatement 对象，然后通过执行器Executor去执行具体SQL并返回。</p><p><img src="/images/Mybatis/792538947.jpg" alt="792538947"></p><h2 id="0-6-作用域"><a href="#0-6-作用域" class="headerlink" title="0.6. 作用域"></a>0.6. <strong>作用域</strong></h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JdnS939HH5TayIhQo5s0aJbReBExSQO1U23XeLAXlhTWUeL87mJZL0lDzPstpY3CSIwvW0dN9ccA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>作用域理解</strong></p><ul><li>SqlSessionFactoryBuilder 的作用在于创建 SqlSessionFactory，创建成功后，SqlSessionFactoryBuilder 就失去了作用，所以它只能存在于创建 SqlSessionFactory 的方法中，而不要让其长期存在。因此 <strong>SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域</strong>（也就是局部方法变量）。</li><li>SqlSessionFactory 可以被认为是一个数据库连接池，它的作用是创建 SqlSession 接口对象。因为 MyBatis 的本质就是 Java 对数据库的操作，所以 SqlSessionFactory 的生命周期存在于整个 MyBatis 的应用之中，所以一旦创建了 SqlSessionFactory，就要长期保存它，直至不再使用 MyBatis 应用，所以可以认为 SqlSessionFactory 的生命周期就等同于 MyBatis 的应用周期。</li><li>由于 SqlSessionFactory 是一个对数据库的连接池，所以它占据着数据库的连接资源。如果创建多个 SqlSessionFactory，那么就存在多个数据库连接池，这样不利于对数据库资源的控制，也会导致数据库连接资源被消耗光，出现系统宕机等情况，所以尽量避免发生这样的情况。</li><li>因此在一般的应用中我们往往希望 SqlSessionFactory 作为一个单例，让它在应用中被共享。所以说 <strong>SqlSessionFactory 的最佳作用域是应用作用域。</strong></li><li>如果说 SqlSessionFactory 相当于数据库连接池，那么 SqlSession 就相当于一个数据库连接（Connection 对象），你可以在一个事务里面执行多条 SQL，然后通过它的 commit、rollback 等方法，提交或者回滚事务。所以它应该存活在一个业务请求中，处理完整个请求后，应该关闭这条连接，让它归还给 SqlSessionFactory，否则数据库资源就很快被耗费精光，系统就会瘫痪，所以用 try…catch…finally… 语句来保证其正确关闭。</li><li><strong>所以 SqlSession 的最佳的作用域是请求或方法作用域。</strong></li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JdnS939HH5TayIhQo5s0aJJq1YuJCr3e9PsTBpBgc1tbicoshHB3qLkwgn3Jp2q8qI1dY9vGhIia3w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="0-7-属性名和字段名不一致"><a href="#0-7-属性名和字段名不一致" class="headerlink" title="0.7. 属性名和字段名不一致"></a>0.7. 属性名和字段名不一致</h2><p>方案一：为列名指定别名 , 别名和java实体类的属性名一致 .</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  select id , name , pwd as password from user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>方案二：使用结果集映射-&gt;ResultMap</strong> 【推荐】</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- id为主键 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">  select id , name , pwd from user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0-8-ResultMap"><a href="#0-8-ResultMap" class="headerlink" title="0.8. ResultMap"></a>0.8. ResultMap</h2><p><strong>自动映射</strong></p><p>简单地将所有的列映射到 <code>HashMap</code> 的键上，这由 <code>resultType</code> 属性指定。虽然在大部分情况下都够用，但是 HashMap 不是一个很好的模型。你的程序更可能会使用 JavaBean 或 POJO（Plain Old Java Objects，普通老式 Java 对象）作为模型。</p><p><strong>手动映射</strong></p><p>返回值类型为resultMap</p><h2 id="0-9-分页"><a href="#0-9-分页" class="headerlink" title="0.9. 分页"></a>0.9. 分页</h2><p><strong>limit物理分页</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#语法</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> LIMIT stratIndex，pageSize</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> LIMIT <span class="number">5</span>,<span class="number">10</span>; <span class="operator">/</span><span class="operator">/</span> 检索记录行 <span class="number">6</span><span class="number">-15</span>  </span><br><span class="line"></span><br><span class="line">#为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 <span class="number">-1</span>：   </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> LIMIT <span class="number">95</span>,<span class="number">-1</span>; <span class="operator">/</span><span class="operator">/</span> 检索记录行 <span class="number">96</span><span class="operator">-</span>last.  </span><br><span class="line"></span><br><span class="line">#如果只给定一个参数，它表示返回最大的记录行数目：   </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> LIMIT <span class="number">5</span>; <span class="operator">/</span><span class="operator">/</span>检索前 <span class="number">5</span> 个记录行  </span><br><span class="line"></span><br><span class="line">#换句话说，LIMIT n 等价于 LIMIT <span class="number">0</span>,n。 </span><br></pre></td></tr></table></figure><p><strong>RowBounds逻辑分页</strong></p><p>除了使用Limit在SQL层面实现分页，也可以使用RowBounds在Java代码层面实现分页</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> currentPage = <span class="number">2</span>;  <span class="comment">//第几页</span></span><br><span class="line">   <span class="keyword">int</span> pageSize = <span class="number">2</span>;  <span class="comment">//每页显示几个</span></span><br><span class="line">   RowBounds rowBounds = <span class="keyword">new</span> RowBounds((currentPage-<span class="number">1</span>)*pageSize,pageSize);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//通过session.**方法进行传递rowBounds，[此种方式现在已经不推荐使用了]</span></span><br><span class="line">   List&lt;User&gt; users = session.selectList(<span class="string">&quot;com.kuang.mapper.UserMapper.getUserByRowBounds&quot;</span>, <span class="keyword">null</span>, rowBounds);</span><br></pre></td></tr></table></figure><p><strong>PageHelper</strong></p><h2 id="0-10-在mapper中如何传递多个参数"><a href="#0-10-在mapper中如何传递多个参数" class="headerlink" title="0.10. 在mapper中如何传递多个参数?"></a>0.10. <strong>在mapper中如何传递多个参数?</strong></h2><p>1、第一种：</p><p>DAO层的函数</p><p>2、第二种： 使用 @param 注解:</p><p>然后,就可以在xml像下面这样使用(推荐封装为一个map,作为单个参数传递给mapper):</p><p>3、第三种：多个参数封装成map</p><h2 id="0-11-Mapper-编写有哪几种方式？"><a href="#0-11-Mapper-编写有哪几种方式？" class="headerlink" title="0.11. Mapper 编写有哪几种方式？"></a>0.11. Mapper 编写有哪几种方式？</h2><ul><li><p>接口实现类继承 SqlSessionDaoSupport：使用此种方法需要编写mapper 接口，mapper 接口实现类、mapper.xml 文件</p><p>1、在 sqlMapConfig.xml 中配置 mapper.xml 的位置</p></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><pre><code>2、定义 mapper 接口3、实现类集成 SqlSessionDaoSupport，mapper 方法中可以 this.getSqlSession()进行数据增删改查。4、spring 配置</code></pre><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot; &quot;</span> <span class="attr">class</span>=<span class="string">&quot;mapper 接口的实现&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>使用 org.mybatis.spring.mapper.MapperFactoryBean ：<br>1、在 sqlMapConfig.xml 中配置 mapper.xml 的位置，如果 mapper.xml 和 mappre 接口的名称相同且在同一个目录，这里可以不用配置</li></ul><figure class="highlight xml"><figcaption><span><mappers></span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><pre><code>    2、定义 mapper 接口：    2.1、mapper.xml 中的 namespace 为 mapper 接口的地址    2.2、mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一 致    3、Spring 中定义</code></pre><ul><li><p>使用 mapper 扫描器：</p><p>1、mapper.xml 文件编写：<br>mapper.xml 中的 namespace 为 mapper 接口的地址；<br>mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致；<br>如果将 mapper.xml 和 mapper 接口的名称保持一致则不用在 sqlMapConfig.xml 中进行配置</p><p>2、定义 mapper 接口：<br>注意 mapper.xml 的文件名和 mapper 的接口名称保持一致，且放在同一个目录</p><p>3、配置 mapper 扫描器：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mapper 接口包地址&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4、使用扫描器后从 spring 容器中获取 mapper 的实现对象。</p></li></ul><h2 id="0-12-注解"><a href="#0-12-注解" class="headerlink" title="0.12. 注解"></a>0.12. 注解</h2><p>1、我们在我们的接口中添加注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询全部用户</span></span><br><span class="line"><span class="meta">@Select(&quot;select id,name,pwd password from user&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getAllUser</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>2、在mybatis的核心配置文件中注入</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用class绑定接口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.mapper.UserMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0-13-Mybatis详细的执行流程"><a href="#0-13-Mybatis详细的执行流程" class="headerlink" title="0.13. Mybatis详细的执行流程"></a>0.13. Mybatis详细的执行流程</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LZwwtchlelS8kzAAyVia5uNvhic22X8ahJy5BdOfjy1LlDRfo8Nf3GOAzwALgvriau4SzmXZIhUUd2A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="0-14-MyBatis的工作原理以及核心流程介绍"><a href="#0-14-MyBatis的工作原理以及核心流程介绍" class="headerlink" title="0.14. MyBatis的工作原理以及核心流程介绍"></a>0.14. MyBatis的工作原理以及核心流程介绍</h2><ul><li><p>JDBC有四个核心对象：<br>（1）DriverManager，用于注册数据库连接<br>（2）Connection，与数据库连接对象<br>（3）Statement/PrepareStatement，操作数据库SQL语句的对象<br>（4）ResultSet，结果集或一张虚拟表</p></li><li><p>MyBatis也有四大核心对象：<br>（1）SqlSession对象，该对象中包含了执行SQL语句的所有方法。类似于JDBC里面的Connection<br>（2）Executor接口，它将根据SqlSession传递的参数动态地生成需要执行的SQL语句，同时负责查询缓存的维护。类似于JDBC里面的Statement/PrepareStatement。<br>（3）MappedStatement对象，该对象是对映射SQL的封装，用于存储要映射的SQL语句的id、参数等信息。<br>（4）ResultHandler对象，用于对返回的结果进行处理，最终得到自己想要的数据格式或类型。可以自定义返回类型。</p></li></ul><h3 id="0-14-1-、MyBatis的工作原理以及核心流程详解"><a href="#0-14-1-、MyBatis的工作原理以及核心流程详解" class="headerlink" title="0.14.1. 、MyBatis的工作原理以及核心流程详解"></a>0.14.1. 、MyBatis的工作原理以及核心流程详解</h3><p>MyBatis的工作原理如下图所示：</p><p><img src="/images/Mybatis/326517643.png" alt="326517643"></p><p>（1）读取MyBatis的配置文件。mybatis-config.xml为MyBatis的全局配置文件，用于配置数据库连接信息。</p><p>（2）加载映射文件。映射文件即SQL映射文件，该文件中配置了操作数据库的SQL语句，需要在MyBatis配置文件mybatis-config.xml中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。</p><p>（3）构造会话工厂。通过MyBatis的环境配置信息构建会话工厂SqlSessionFactory。</p><p>（4）创建会话对象。由会话工厂创建SqlSession对象，该对象中包含了执行SQL语句的所有方法。</p><p>（5）Executor执行器。MyBatis底层定义了一个Executor接口来操作数据库，它将根据SqlSession传递的参数动态地生成需要执行的SQL语句，同时负责查询缓存的维护。</p><p>（6）MappedStatement对象。在Executor接口的执行方法中有一个MappedStatement类型的参数，该参数是对映射信息的封装，用于存储要映射的SQL语句的id、参数等信息。</p><p>（7）输入参数映射。输入参数类型可以是Map、List等集合类型，也可以是基本数据类型和POJO类型。输入参数映射过程类似于JDBC对preparedStatement对象设置参数的过程。</p><p>（8）输出结果映射。输出结果类型可以是Map、List等集合类型，也可以是基本数据类型和POJO类型。输出结果映射过程类似于JDBC对结果集的解析过程。</p><h2 id="0-15-Param"><a href="#0-15-Param" class="headerlink" title="0.15. @Param"></a>0.15. @Param</h2><p>@Param注解用于给方法参数起一个名字。以下是总结的使用原则：</p><ul><li><p>在方法只接受一个参数的情况下，可以不使用@Param。</p></li><li><p>在方法接受多个参数的情况下，建议一定要使用@Param注解给参数命名。</p></li><li><p>如果参数是 JavaBean ， 则不能使用@Param。</p></li><li><p>不使用@Param注解时，参数只能有一个，并且是Javabean。</p></li></ul><h2 id="0-16-与-的区别"><a href="#0-16-与-的区别" class="headerlink" title="0.16. #与$的区别"></a>0.16. #与$的区别</h2><p>/#{} 的作用主要是替换预编译语句(PrepareStatement)中的占位符? 【推荐使用】</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">INSERT INTO user (name) VALUES (#&#123;name&#125;);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (name) <span class="keyword">VALUES</span> (?);</span><br></pre></td></tr></table></figure><p>${} 的作用是直接进行字符串替换</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (name) <span class="keyword">VALUES</span> (<span class="string">&#x27;$&#123;name&#125;&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (name) <span class="keyword">VALUES</span> (<span class="string">&#x27;kuangshen&#x27;</span>);</span><br></pre></td></tr></table></figure><p>（3）使用#{}可以有效的防止SQL注入，提高系统安全性。原因在于：预编译机制。<strong>预编译完成之后，SQL的结构已经固定，即便用户输入非法参数，也不会对SQL的结构产生影响，从而避免了潜在的安全风险。</strong></p><p>（4）预编译是提前对SQL语句进行预编译，而其后注入的参数将不会再进行SQL编译。我们知道，SQL注入是发生在编译的过程中，因为恶意注入了某些特殊字符，最后被编译成了恶意的执行操作。而预编译机制则可以很好的防止SQL注入。</p><h2 id="0-17-数据库链接中断如何处理"><a href="#0-17-数据库链接中断如何处理" class="headerlink" title="0.17. 数据库链接中断如何处理"></a>0.17. 数据库链接中断如何处理</h2><p>数据库的访问底层是通过tcp实现的，如果数据库链接中断，那么应用程序是不知道的，跟时间有关的设置有：max_idle_time，connect_timeout。max_idle_time表明最大的空闲时间，超过这个时间socket就会关闭，timeout。</p><h2 id="0-18-数据库插入重复如何处理"><a href="#0-18-数据库插入重复如何处理" class="headerlink" title="0.18. 数据库插入重复如何处理"></a>0.18. 数据库插入重复如何处理</h2><p>插入的过程一般都是分两步的：先判断是否存在记录，没有存在则插入否则不插入。如果存在并发操作，那么同时进行了第一步，然后大家都发现没有记录，最后在第二步的时候都插入了数据从而造成数据的重复。解决插入重复的思路可以是这样的：</p><p>下面场景，假设同时有三个线程：线程a、线程b、线程c，进行插入操作。</p><p>（1）判断数据库是否有数据，有的话则无所作为。没有数据的话，则进行下面第2步。<br>（2）大家都要去竞争锁，用redis当锁，即：redis set key，其中只有一个操作a会成功，其他并发的线程b和c会失败的。<br>（3）上面set key 成功的线程a，开始执行插入数据操作，无论是否插入数据成功，都在最后del key。【注】插入不成功可以多尝试几次，增加成功的概率。<br>（4）如果拿到锁的线程a没有插入成功，即便是尝试了数次也没有插入成功，此时定是系统出现了bug，应该搞一个短信报警机制，让研发人员及时发现问题。</p><h2 id="0-19-一个Connection在MySQL中对应一个线程？"><a href="#0-19-一个Connection在MySQL中对应一个线程？" class="headerlink" title="0.19. 一个Connection在MySQL中对应一个线程？"></a>0.19. 一个Connection在MySQL中对应一个线程？</h2><p>在高性能服务器端端开发底层往往靠io复用来处理，这种模式就是：单线程+事件处理机制。在MySQL里面往往有一个主线程，这是单线程（与Java中处处强调多线程的思想有点不同哦），它不断的循环查看是否有socket是否有读写事件，如果有读写事件，再从线程池里面找个工作线程处理这个socket的读写事件，完事之后工作线程会回到线程池。所以：Java客户端中的一个Connection不是在MySQL中就对应一个线程来处理这个链接，而是由监听socket的主线程+线程池里面固定数目的工作线程来处理的。</p><h2 id="0-20-预编译的过程"><a href="#0-20-预编译的过程" class="headerlink" title="0.20. 预编译的过程"></a>0.20. 预编译的过程</h2><h3 id="0-20-1-、JDBC的预编译用法"><a href="#0-20-1-、JDBC的预编译用法" class="headerlink" title="0.20.1. 、JDBC的预编译用法"></a>0.20.1. 、JDBC的预编译用法</h3><p>相信每个人都应该了解JDBC中的PreparedStatement接口，它是用来实现SQL预编译的功能。其用法是这样的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">String url = <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/mybatis&quot;</span>;</span><br><span class="line">String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">String password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="comment">//建立数据库连接</span></span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">&quot;insert into user(username, sex, address) values(?,?,?)&quot;</span>;</span><br><span class="line">PreparedStatement ps = conn.preparedStatement(sql);</span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>);  <span class="comment">//为第一个问号赋值  </span></span><br><span class="line">ps.setInt(<span class="number">2</span>, <span class="number">2</span>);    <span class="comment">//为第二个问号赋值</span></span><br><span class="line">ps.setString(<span class="number">3</span>, <span class="string">&quot;北京&quot;</span>);    <span class="comment">//为第三个问号赋值</span></span><br><span class="line">ps.executeUpdate();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure><h3 id="0-20-2-、预编译的好处"><a href="#0-20-2-、预编译的好处" class="headerlink" title="0.20.2. 、预编译的好处"></a>0.20.2. 、预编译的好处</h3><h4 id="0-20-2-1-、预编译能避免SQL注入"><a href="#0-20-2-1-、预编译能避免SQL注入" class="headerlink" title="0.20.2.1. 、预编译能避免SQL注入"></a>0.20.2.1. 、预编译能避免SQL注入</h4><p>预编译功能可以避免SQL注入，因为SQL已经编译完成，其结构已经固定，用户的输入只能当做参数传入进去，不能再破坏SQL的结果，无法造成曲解SQL原本意思的破坏。</p><h4 id="0-20-2-2-、预编译能提高SQL执行效率"><a href="#0-20-2-2-、预编译能提高SQL执行效率" class="headerlink" title="0.20.2.2. 、预编译能提高SQL执行效率"></a>0.20.2.2. 、预编译能提高SQL执行效率</h4><p>预编译功能除了避免SQL注入，还能提高SQL执行效率。当客户发送一条SQL语句给服务器后，服务器首先需要校验SQL语句的语法格式是否正确，然后把SQL语句编译成可执行的函数，最后才是执行SQL语句。其中校验语法，和编译所花的时间可能比执行SQL语句花的时间还要多。</p><p>如果我们需要执行多次insert语句，但只是每次插入的值不同，MySQL服务器也是需要每次都去校验SQL语句的语法格式以及编译，这就浪费了太多的时间。如果使用预编译功能，那么只对SQL语句进行一次语法校验和编译，所以效率要高。</p><h3 id="0-20-3-、预编译的实现过程"><a href="#0-20-3-、预编译的实现过程" class="headerlink" title="0.20.3. 、预编译的实现过程"></a>0.20.3. 、预编译的实现过程</h3><p>预编译功能如此重要，那么数据库是如何实现预编译的呢？这个问题其实可以当做一个面试题，能很好的考察面试者对预编译的理解。下面以MySQL为例说明一下预编译的过程：</p><p>MySQL执行预编译分为如三步：</p><p>第一步：执行预编译语句，例如：prepare myperson from ‘select * from t_person where name=?’<br>第二步：设置变量，例如：set @name=’Jim’<br>第三步：执行语句，例如：execute myperson using @name</p><p>如果需要再次执行myperson，那么就不再需要第一步，即不需要再编译语句了：</p><p>设置变量，例如：set @name=’Tom’<br>执行语句，例如：execute myperson using @name</p><h2 id="0-21"><a href="#0-21" class="headerlink" title="0.21."></a>0.21.</h2><h2 id="0-22-多对一"><a href="#0-22-多对一" class="headerlink" title="0.22. 多对一"></a>0.22. 多对一</h2><p>多对一的理解：</p><ul><li>多个学生对应一个老师</li><li>如果对于学生这边，就是一个多对一的现象，即从学生这边关联一个老师！</li></ul><h3 id="0-22-1-按查询嵌套处理"><a href="#0-22-1-按查询嵌套处理" class="headerlink" title="0.22.1. 按查询嵌套处理"></a>0.22.1. 按查询嵌套处理</h3><p>1、给StudentMapper接口增加方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取所有学生及对应老师的信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">getStudents</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>2、编写对应的Mapper文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">       <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">       <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.kuang.mapper.StudentMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">   需求：获取所有学生及对应老师的信息</span></span><br><span class="line"><span class="comment">   思路：</span></span><br><span class="line"><span class="comment">       1. 获取所有学生的信息</span></span><br><span class="line"><span class="comment">       2. 根据获取的学生信息的老师ID-&gt;获取该老师的信息</span></span><br><span class="line"><span class="comment">       3. 思考问题，这样学生的结果集中应该包含老师，该如何处理呢，数据库中我们一般使用关联查询？</span></span><br><span class="line"><span class="comment">           1. 做一个结果集映射：StudentTeacher</span></span><br><span class="line"><span class="comment">           2. StudentTeacher结果集的类型为 Student</span></span><br><span class="line"><span class="comment">           3. 学生中老师的属性为teacher，对应数据库中为tid。</span></span><br><span class="line"><span class="comment">              多个 [1,...）学生关联一个老师=&gt; 一对一，一对多</span></span><br><span class="line"><span class="comment">           4. 查看官网找到：association – 一个复杂类型的关联；使用它来处理关联查询</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudents&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;StudentTeacher&quot;</span>&gt;</span></span><br><span class="line">    select * from student</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentTeacher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span>  <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Teacher&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getTeacher&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">   这里传递过来的id，只有一个属性的时候，下面可以写任何值</span></span><br><span class="line"><span class="comment">   association中column多参数配置：</span></span><br><span class="line"><span class="comment">       column=&quot;&#123;key=value,key=value&#125;&quot;</span></span><br><span class="line"><span class="comment">       其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;teacher&quot;</span>&gt;</span></span><br><span class="line">      select * from teacher where id = #&#123;id&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、编写完毕去Mybatis配置文件中，注册Mapper！</p><p>4、注意点说明：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentTeacher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span>  <span class="attr">column</span>=<span class="string">&quot;&#123;id=tid,name=tid&#125;&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Teacher&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getTeacher&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">这里传递过来的id，只有一个属性的时候，下面可以写任何值</span></span><br><span class="line"><span class="comment">association中column多参数配置：</span></span><br><span class="line"><span class="comment">   column=&quot;&#123;key=value,key=value&#125;&quot;</span></span><br><span class="line"><span class="comment">   其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;teacher&quot;</span>&gt;</span></span><br><span class="line">  select * from teacher where id = #&#123;id&#125; and name = #&#123;name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="0-22-2-按结果嵌套处理"><a href="#0-22-2-按结果嵌套处理" class="headerlink" title="0.22.2. 按结果嵌套处理"></a>0.22.2. 按结果嵌套处理</h3><p>1、接口方法编写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">getStudents2</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>2、编写对应的mapper文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">按查询结果嵌套处理</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">   1. 直接查询出结果，进行结果集的映射</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudents2&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;StudentTeacher2&quot;</span> &gt;</span></span><br><span class="line">  select s.id sid, s.name sname , t.name tname</span><br><span class="line">  from student s,teacher t</span><br><span class="line">  where s.tid = t.id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentTeacher2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span>/&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--关联对象property 关联对象在Student实体类中的属性--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tname&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0-23-一对多"><a href="#0-23-一对多" class="headerlink" title="0.23. 一对多"></a>0.23. 一对多</h2><p>对多的理解：</p><ul><li>一个老师拥有多个学生</li><li>如果对于老师这边，就是一个一对多的现象，即从一个老师下面拥有一群学生（集合）！</li></ul><h3 id="0-23-1-按结果嵌套处理"><a href="#0-23-1-按结果嵌套处理" class="headerlink" title="0.23.1. 按结果嵌套处理"></a>0.23.1. 按结果嵌套处理</h3><p>1、TeacherMapper接口编写方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取指定老师，及老师下的所有学生</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Teacher <span class="title">getTeacher</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure><p>2、编写接口对应的Mapper配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.kuang.mapper.TeacherMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">   思路:</span></span><br><span class="line"><span class="comment">       1. 从学生表和老师表中查出学生id，学生姓名，老师姓名</span></span><br><span class="line"><span class="comment">       2. 对查询出来的操作做结果集映射</span></span><br><span class="line"><span class="comment">           1. 集合的话，使用collection！</span></span><br><span class="line"><span class="comment">               JavaType和ofType都是用来指定对象类型的</span></span><br><span class="line"><span class="comment">               JavaType是用来指定pojo中属性的类型</span></span><br><span class="line"><span class="comment">               ofType指定的是映射到list集合属性中pojo的类型。</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;TeacherStudent&quot;</span>&gt;</span></span><br><span class="line">      select s.id sid, s.name sname , t.name tname, t.id tid</span><br><span class="line">      from student s,teacher t</span><br><span class="line">      where s.tid = t.id and t.id=#&#123;id&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;TeacherStudent&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span>  <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tname&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span> /&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span> /&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;tid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="0-23-2-按查询嵌套处理"><a href="#0-23-2-按查询嵌套处理" class="headerlink" title="0.23.2. 按查询嵌套处理"></a>0.23.2. 按查询嵌套处理</h3><p>1、TeacherMapper接口编写方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Teacher <span class="title">getTeacher2</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure><p>2、编写接口对应的Mapper配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher2&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;TeacherStudent2&quot;</span>&gt;</span></span><br><span class="line">select * from teacher where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;TeacherStudent2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--column是一对多的外键 , 写的是一的主键的列名--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;ArrayList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Student&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getStudentByTeacherId&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudentByTeacherId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">  select * from student where tid = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><p>1、关联-association</p><p>2、集合-collection</p><p>3、所以association是用于一对一和多对一，而collection是用于一对多的关系</p><p>4、JavaType和ofType都是用来指定对象类型的</p><ul><li>JavaType是用来指定pojo中属性的类型</li><li>ofType指定的是映射到list集合属性中pojo的类型。</li></ul><h2 id="0-24-动态-SQL"><a href="#0-24-动态-SQL" class="headerlink" title="0.24. 动态 SQL"></a>0.24. 动态 SQL</h2><p>动态SQL指的是根据不同的查询条件 , 生成不同的Sql语句.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-------------------------------</span><br><span class="line"> - if</span><br><span class="line"> - choose (when, otherwise)</span><br><span class="line"> - trim (where, set)</span><br><span class="line"> - foreach</span><br><span class="line"> -------------------------------</span><br></pre></td></tr></table></figure><h2 id="0-25-Dao接口的工作原理"><a href="#0-25-Dao接口的工作原理" class="headerlink" title="0.25. Dao接口的工作原理"></a>0.25. Dao接口的工作原理</h2><p>Dao接口即Mapper接口。接口的全限名，就是映射文件中的namespace的值；接口的方法名，就是映射文件中Mapper的Statement的id值；接口方法内的参数，就是传递给sql的参数。</p><p>Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MapperStatement。在Mybatis中，每一个 <select>、<insert>、<update>、<delete>标签，都会被解析为一个MapperStatement对象。</p><p>举例来说：cn.mybatis.mappers.StudentDao.findStudentById，可以唯一找到namespace为 com.mybatis.mappers.StudentDao下面 id 为 findStudentById 的 MapperStatement。</p><p>Mapper接口里的方法，是不能重载的，因为是使用 全限名+方法名 的保存和寻找策略。Mapper 接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Mapper接口生成代理对象proxy，代理对象会拦截接口方法，转而执行MapperStatement所代表的sql，然后将sql执行结果返回。</p><h2 id="0-26-缓存"><a href="#0-26-缓存" class="headerlink" title="0.26. 缓存"></a>0.26. 缓存</h2><p>1、什么是缓存 [ Cache ]？</p><ul><li>存在内存中的临时数据。</li><li>将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。</li></ul><p>2、为什么使用缓存？</p><ul><li>减少和数据库的交互次数，减少系统开销，提高系统效率。</li></ul><p>3、什么样的数据能使用缓存？</p><ul><li>经常查询并且不经常改变的数据。    </li></ul><blockquote><p>Mybatis的缓存实际上就是一个HashMap，key是真正执行的sql语句，value是缓存的结果。</p></blockquote><h3 id="0-26-1-一级缓存"><a href="#0-26-1-一级缓存" class="headerlink" title="0.26.1. 一级缓存"></a>0.26.1. 一级缓存</h3><p>一级缓存也叫本地缓存：</p><ul><li>与数据库同一次会话期间查询到的数据会放在本地缓存中。</li><li>以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；</li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KickRVspms8t4ZU0jXovPT2qe5QluO0MoibU09bTKiaGG923AzFwOSxICrM7BZFWNJqiaCUOGxDA54Tg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>一级缓存失效的四种情况：</p><p>一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；</p><p>一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！</p><p>1、sqlSession不同。<strong>每个sqlSession中的缓存相互独立</strong></p><p>2、sqlSession相同，查询条件不同。<strong>当前缓存中，不存在这个数据</strong></p><p>3、sqlSession相同，两次查询之间执行了增删改操作！<strong>因为增删改操作可能会对当前数据产生影响</strong></p><p>4、sqlSession相同，手动清除一级缓存。session.clearCache();</p><h3 id="0-26-2-二级缓存"><a href="#0-26-2-二级缓存" class="headerlink" title="0.26.2. 二级缓存"></a>0.26.2. 二级缓存</h3><ul><li><p>二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存</p></li><li><p>基于namespace级别的缓存，一个名称空间，对应一个二级缓存；</p></li><li><p>工作机制</p></li><li><ul><li>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中；</li><li>如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中；</li><li>新的会话查询信息，就可以从二级缓存中获取内容；</li><li>不同的mapper查出的数据会放在自己对应的缓存（map）中；</li></ul></li></ul><p><strong>总结</strong></p><ul><li>只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据</li><li>查出的数据都会被默认先放在一级缓存中</li><li>只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中</li><li>查询时顺序：二级 -&gt; 一级 -&gt; 数据库</li><li>对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KickRVspms8t4ZU0jXovPT2egdNicaJuVnzMYxibyYFvB0COWW4sgDhHPqvFbG9F9KS1vX7ibIMNqefg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="0-27-、-和-的区别是什么？"><a href="#0-27-、-和-的区别是什么？" class="headerlink" title="0.27. 、#{}和${}的区别是什么？"></a>0.27. 、#{}和${}的区别是什么？</h2><p>注：这道题是面试官面试我同事的。</p><p>答：</p><ul><li><code>$&#123;&#125;</code>是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如${driver}会被静态替换为<code>com.mysql.jdbc.Driver</code>。</li><li><code>#&#123;&#125;</code>是 sql 的参数占位符，MyBatis 会将 sql 中的<code>#&#123;&#125;</code>替换为?号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的?号占位符设置参数值，比如 ps.setInt(0, parameterValue)，<code>#&#123;item.name&#125;</code> 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 <code>param.getItem().getName()</code>。</li></ul><h2 id="0-28-、Xml-映射文件中，除了常见的-select-insert-update-delete-标签之外，还有哪些标签？"><a href="#0-28-、Xml-映射文件中，除了常见的-select-insert-update-delete-标签之外，还有哪些标签？" class="headerlink" title="0.28. 、Xml 映射文件中，除了常见的 select|insert|update|delete 标签之外，还有哪些标签？"></a>0.28. 、Xml 映射文件中，除了常见的 select|insert|update|delete 标签之外，还有哪些标签？</h2><p>注：这道题是京东面试官面试我时问的。</p><p>答：还有很多其他的标签，<code>&lt;resultMap&gt;</code>、<code>&lt;parameterMap&gt;</code>、<code>&lt;sql&gt;</code>、<code>&lt;include&gt;</code>、<code>&lt;selectKey&gt;</code>，加上动态 sql 的 9 个标签，<code>trim|where|set|foreach|if|choose|when|otherwise|bind</code>等，其中<sql>为 sql 片段标签，通过<code>&lt;include&gt;</code>标签引入 sql 片段，<code>&lt;selectKey&gt;</code>为不支持自增的主键生成策略标签。</p><h2 id="0-29-、最佳实践中，通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？"><a href="#0-29-、最佳实践中，通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="0.29. 、最佳实践中，通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？"></a>0.29. 、最佳实践中，通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</h2><p>注：这道题也是京东面试官面试我被问的。</p><p>答：Dao 接口，就是人们常说的 <code>Mapper</code>接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中<code>MappedStatement</code>的 id 值，接口方法内的参数，就是传递给 sql 的参数。<code>Mapper</code>接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个<code>MappedStatement</code>，举例：<code>com.mybatis3.mappers.StudentDao.findStudentById</code>，可以唯一找到 namespace 为<code>com.mybatis3.mappers.StudentDao</code>下面<code>id = findStudentById</code>的<code>MappedStatement</code>。在 MyBatis 中，每一个<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code>标签，都会被解析为一个<code>MappedStatement</code>对象。</p><p><del>Dao 接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</del></p><p>Dao 接口里的方法可以重载，但是Mybatis的XML里面的ID不允许重复。</p><p>Mybatis版本3.3.0，亲测如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** * Mapper接口里面方法重载 */</span><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StuMapper</span> </span>&#123;<span class="function">List&lt;Student&gt; <span class="title">getAllStu</span><span class="params">()</span></span>;    <span class="function">List&lt;Student&gt; <span class="title">getAllStu</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Integer id)</span></span>;&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>StuMapper.xml</code> 中利用Mybatis的动态sql就可以实现。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;getAllStu&quot; resultType=&quot;com.pojo.Student&quot;&gt; select * from student&lt;where&gt;&lt;if test=&quot;id != null&quot;&gt;id = #&#123;id&#125;&lt;/if&gt;&lt;/where&gt; &lt;/select&gt;</span><br></pre></td></tr></table></figure><p>能正常运行，并能得到相应的结果，这样就实现了在Dao接口中写重载方法。</p><p><strong>Mybatis 的 Dao 接口可以有多个重载方法，但是多个接口对应的映射必须只有一个，否则启动会报错。</strong></p><p>相关 issue ：<a href="https://github.com/Snailclimb/JavaGuide/issues/1122">更正：Dao 接口里的方法可以重载，但是Mybatis的XML里面的ID不允许重复！</a>。</p><p>Dao 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行<code>MappedStatement</code>所代表的 sql，然后将 sql 执行结果返回。</p><h3 id="0-29-1-补充："><a href="#0-29-1-补充：" class="headerlink" title="0.29.1. ==补充：=="></a>0.29.1. ==补充：==</h3><p>Dao接口方法可以重载，但是需要满足以下条件：</p><ol><li>仅有一个无参方法和一个有参方法</li><li>多个有参方法时，参数数量必须一致。且使用相同的 <code>@Param</code> ，或者使用 <code>param1</code> 这种</li></ol><p>测试如下：</p><p><code>PersonDao.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Person <span class="title">queryById</span><span class="params">()</span></span>;<span class="function">Person <span class="title">queryById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span></span>;<span class="function">Person <span class="title">queryById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id, <span class="meta">@Param(&quot;name&quot;)</span> String name)</span></span>;</span><br></pre></td></tr></table></figure><p><code>PersonMapper.xml</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;PersonMap&quot;</span>&gt;</span>    select      id, name, age, address    from person    <span class="tag">&lt;<span class="name">where</span>&gt;</span>        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != null&quot;</span>&gt;</span>            id = #&#123;id&#125;        <span class="tag">&lt;/<span class="name">if</span>&gt;</span>        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span>            name = #&#123;name&#125;        <span class="tag">&lt;/<span class="name">if</span>&gt;</span>    <span class="tag">&lt;/<span class="name">where</span>&gt;</span>    limit 1<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>org.apache.ibatis.scripting.xmltags.DynamicContext.ContextAccessor#getProperty</code>方法用于获取<code>&lt;if&gt;</code>标签中的条件值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProperty</span><span class="params">(Map context, Object target, Object name)</span> </span>&#123;  Map map = (Map) target;  Object result = map.get(name);  <span class="keyword">if</span> (map.containsKey(name) || result != <span class="keyword">null</span>) &#123;    <span class="keyword">return</span> result;  &#125;  Object parameterObject = map.get(PARAMETER_OBJECT_KEY);  <span class="keyword">if</span> (parameterObject <span class="keyword">instanceof</span> Map) &#123;    <span class="keyword">return</span> ((Map)parameterObject).get(name);  &#125;  <span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br></pre></td></tr></table></figure><p><code>parameterObject</code>为map，存放的是Dao接口中参数相关信息。</p><p><code>((Map)parameterObject).get(name)</code>方法如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;  <span class="keyword">if</span> (!<span class="keyword">super</span>.containsKey(key)) &#123;    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Parameter &#x27;&quot;</span> + key + <span class="string">&quot;&#x27; not found. Available parameters are &quot;</span> + keySet());  &#125;  <span class="keyword">return</span> <span class="keyword">super</span>.get(key);&#125;</span><br></pre></td></tr></table></figure><ol><li><code>queryById()</code>方法执行时，<code>parameterObject</code>为null，<code>getProperty</code>方法返回null值，<code>&lt;if&gt;</code>标签获取的所有条件值都为null，所有条件不成立，动态sql可以正常执行。</li><li><code>queryById(1L)</code>方法执行时，<code>parameterObject</code>为map，包含了<code>id</code>和<code>param1</code>两个key值。当获取<code>&lt;if&gt;</code>标签中<code>name</code>的属性值时，进入<code>((Map)parameterObject).get(name)</code>方法中，map中key不包含<code>name</code>，所以抛出异常。</li><li><code>queryById(1L,&quot;1&quot;)</code>方法执行时，<code>parameterObject</code>中包含<code>id</code>,<code>param1</code>,<code>name</code>,<code>param2</code>四个key值，<code>id</code>和<code>name</code>属性都可以获取到，动态sql正常执行。</li></ol><h2 id="0-30-、MyBatis-是如何进行分页的？分页插件的原理是什么？"><a href="#0-30-、MyBatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="0.30. 、MyBatis 是如何进行分页的？分页插件的原理是什么？"></a>0.30. 、MyBatis 是如何进行分页的？分页插件的原理是什么？</h2><p>注：我出的。</p><p>答：**(1)** MyBatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页；**(2)** 可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，**(3)** 也可以使用分页插件来完成物理分页。</p><p>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p><p>举例：<code>select _ from student</code>，拦截 sql 后重写为：<code>select t._ from （select \* from student）t limit 0，10</code></p><h2 id="0-31-、简述-MyBatis-的插件运行原理，以及如何编写一个插件。"><a href="#0-31-、简述-MyBatis-的插件运行原理，以及如何编写一个插件。" class="headerlink" title="0.31. 、简述 MyBatis 的插件运行原理，以及如何编写一个插件。"></a>0.31. 、简述 MyBatis 的插件运行原理，以及如何编写一个插件。</h2><p>注：我出的。</p><p>答：MyBatis 仅可以编写针对 <code>ParameterHandler</code>、<code>ResultSetHandler</code>、<code>StatementHandler</code>、<code>Executor</code> 这 4 种接口的插件，MyBatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 <code>InvocationHandler</code> 的 <code>invoke()</code>方法，当然，只会拦截那些你指定需要拦截的方法。</p><p>实现 MyBatis 的 Interceptor 接口并复写<code> intercept()</code>方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p><h2 id="0-32-、MyBatis-执行批量插入，能返回数据库主键列表吗？"><a href="#0-32-、MyBatis-执行批量插入，能返回数据库主键列表吗？" class="headerlink" title="0.32. 、MyBatis 执行批量插入，能返回数据库主键列表吗？"></a>0.32. 、MyBatis 执行批量插入，能返回数据库主键列表吗？</h2><p>注：我出的。</p><p>答：能，JDBC 都能，MyBatis 当然也能。</p><h2 id="0-33-、MyBatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？"><a href="#0-33-、MyBatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？" class="headerlink" title="0.33. 、MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？"></a>0.33. 、MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？</h2><p>注：我出的。</p><p>答：MyBatis 动态 sql 可以让我们在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能，MyBatis 提供了 9 种动态 sql 标签 <code>trim|where|set|foreach|if|choose|when|otherwise|bind</code>。</p><p>其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。</p><h2 id="0-34-、MyBatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#0-34-、MyBatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="0.34. 、MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>0.34. 、MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</h2><p>注：我出的。</p><p>答：第一种是使用<code>&lt;resultMap&gt;</code>标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，MyBatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，MyBatis 一样可以正常工作。</p><p>有了列名与属性名的映射关系后，MyBatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p><h2 id="0-35-、MyBatis-能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。"><a href="#0-35-、MyBatis-能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。" class="headerlink" title="0.35. 、MyBatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。"></a>0.35. 、MyBatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。</h2><p>注：我出的。</p><p>答：能，MyBatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把 <code>selectOne()</code>修改为 <code>selectList()</code>即可；多对多查询，其实就是一对多查询，只需要把 <code>selectOne()</code>修改为 <code>selectList()</code>即可。</p><p>关联对象查询，有两种实现方式，一种是单独发送一个 sql 去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用 join 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql 查询，就可以把主对象和其关联对象查出来。</p><p>那么问题来了，join 查询出来 100 条记录，如何确定主对象是 5 个，而不是 100 个？其去重复的原理是<code>&lt;resultMap&gt;</code>标签内的<code>&lt;id&gt;</code>子标签，指定了唯一确定一条记录的 id 列，MyBatis 根据<id>列值来完成 100 条记录的去重复功能，<code>&lt;id&gt;</code>可以有多个，代表了联合主键的语意。</p><p>同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。</p><p>举例：下面 join 查询出来 6 条记录，一、二列是 Teacher 对象列，第三列为 Student 对象列，MyBatis 去重复处理后，结果为 1 个老师 6 个学生，而不是 6 个老师 6 个学生。</p><table><thead><tr><th>t_id</th><th>t_name</th><th>s_id</th></tr></thead><tbody><tr><td>1</td><td>teacher</td><td>38</td></tr><tr><td>1</td><td>teacher</td><td>39</td></tr><tr><td>1</td><td>teacher</td><td>40</td></tr><tr><td>1</td><td>teacher</td><td>41</td></tr><tr><td>1</td><td>teacher</td><td>42</td></tr><tr><td>1</td><td>teacher</td><td>43</td></tr></tbody></table><h2 id="0-36-、MyBatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#0-36-、MyBatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="0.36. 、MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>0.36. 、MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h2><p>注：我出的。</p><p>答：MyBatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在 MyBatis 配置文件中，可以配置是否启用延迟加载 <code>lazyLoadingEnabled=true|false。</code></p><p>它的原理是，使用<code> CGLIB</code> 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 <code>a.getB().getName()</code>，拦截器 <code>invoke()</code>方法发现 <code>a.getB()</code>是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 <code>a.getB().getName()</code>方法的调用。这就是延迟加载的基本原理。</p><p>当然了，不光是 MyBatis，几乎所有的包括 Hibernate，支持延迟加载的原理都是一样的。</p><h2 id="0-37-、MyBatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？"><a href="#0-37-、MyBatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？" class="headerlink" title="0.37. 、MyBatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？"></a>0.37. 、MyBatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？</h2><p>注：我出的。</p><p>答：不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复；毕竟 namespace 不是必须的，只是最佳实践而已。</p><p>原因就是 namespace+id 是作为 <code>Map&lt;String, MappedStatement&gt;</code>的 key 使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然也就不同。</p><h2 id="0-38-、MyBatis-中如何执行批处理？"><a href="#0-38-、MyBatis-中如何执行批处理？" class="headerlink" title="0.38. 、MyBatis 中如何执行批处理？"></a>0.38. 、MyBatis 中如何执行批处理？</h2><p>注：我出的。</p><p>答：使用 BatchExecutor 完成批处理。</p><h2 id="0-39-、MyBatis-都有哪些-Executor-执行器？它们之间的区别是什么？"><a href="#0-39-、MyBatis-都有哪些-Executor-执行器？它们之间的区别是什么？" class="headerlink" title="0.39. 、MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？"></a>0.39. 、MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h2><p>注：我出的</p><p>答：MyBatis 有三种基本的 Executor 执行器，**<code>SimpleExecutor</code>、<code>ReuseExecutor</code>、<code>BatchExecutor</code>。**</p><p><strong><code>SimpleExecutor</code>：</strong>每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。</p><p><strong><code>ReuseExecutor</code>：</strong>执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用 Statement 对象。</p><p><strong><code>BatchExecutor</code>：</strong>执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。</p><p>作用范围：Executor 的这些特点，都严格限制在 SqlSession 生命周期范围内。</p><h2 id="0-40-、MyBatis-中如何指定使用哪一种-Executor-执行器？"><a href="#0-40-、MyBatis-中如何指定使用哪一种-Executor-执行器？" class="headerlink" title="0.40. 、MyBatis 中如何指定使用哪一种 Executor 执行器？"></a>0.40. 、MyBatis 中如何指定使用哪一种 Executor 执行器？</h2><p>注：我出的</p><p>答：在 MyBatis 配置文件中，可以指定默认的 ExecutorType 执行器类型，也可以手动给 <code>DefaultSqlSessionFactory</code> 的创建 SqlSession 的方法传递 ExecutorType 类型参数。</p><h2 id="0-41-、MyBatis-是否可以映射-Enum-枚举类？"><a href="#0-41-、MyBatis-是否可以映射-Enum-枚举类？" class="headerlink" title="0.41. 、MyBatis 是否可以映射 Enum 枚举类？"></a>0.41. 、MyBatis 是否可以映射 Enum 枚举类？</h2><p>注：我出的</p><p>答：MyBatis 可以映射枚举类，不单可以映射枚举类，MyBatis 可以映射任何对象到表的一列上。映射方式为自定义一个 <code>TypeHandler</code>，实现 <code>TypeHandler</code> 的 <code>setParameter()</code>和 <code>getResult()</code>接口方法。<code>TypeHandler</code> 有两个作用，一是完成从 javaType 至 jdbcType 的转换，二是完成 jdbcType 至 javaType 的转换，体现为 <code>setParameter()</code>和 <code>getResult()</code>两个方法，分别代表设置 sql 问号占位符参数和获取列查询结果。</p><h2 id="0-42-、MyBatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？"><a href="#0-42-、MyBatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？" class="headerlink" title="0.42. 、MyBatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？"></a>0.42. 、MyBatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？</h2><p>注：我出的</p><p>答：虽然 MyBatis 解析 Xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可以定义在任何地方，MyBatis 都可以正确识别。</p><p>原理是，MyBatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，MyBatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，MyBatis 会重新解析那些被标记为未解析的标签，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</p><h2 id="0-43-、简述-MyBatis-的-Xml-映射文件和-MyBatis-内部数据结构之间的映射关系？"><a href="#0-43-、简述-MyBatis-的-Xml-映射文件和-MyBatis-内部数据结构之间的映射关系？" class="headerlink" title="0.43. 、简述 MyBatis 的 Xml 映射文件和 MyBatis 内部数据结构之间的映射关系？"></a>0.43. 、简述 MyBatis 的 Xml 映射文件和 MyBatis 内部数据结构之间的映射关系？</h2><p>注：我出的</p><p>答：MyBatis 将所有 Xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部。在 Xml 映射文件中，<code>&lt;parameterMap&gt;</code>标签会被解析为 <code>ParameterMap</code> 对象，其每个子元素会被解析为 ParameterMapping 对象。<code>&lt;resultMap&gt;</code>标签会被解析为 <code>ResultMap</code> 对象，其每个子元素会被解析为 <code>ResultMapping</code> 对象。每一个<code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code>标签均会被解析为 <code>MappedStatement</code> 对象，标签内的 sql 会被解析为 BoundSql 对象。</p><h2 id="0-44-、为什么说-MyBatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？"><a href="#0-44-、为什么说-MyBatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？" class="headerlink" title="0.44. 、为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？"></a>0.44. 、为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</h2><p>注：我出的</p><p>答：Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 MyBatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。</p><p>面试题看似都很简单，但是想要能正确回答上来，必定是研究过源码且深入的人，而不是仅会使用的人或者用的很熟的人，以上所有面试题及其答案所涉及的内容，在我的 MyBatis 系列博客中都有详细讲解和原理分析。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;MyBatis 是一个半自动化的&lt;strong&gt;ORM框架&lt;/strong&gt; &lt;/p&gt;</summary>
    
    
    
    <category term="Study" scheme="https://memorykk.cn/categories/Study/"/>
    
    
    <category term="Mybatis" scheme="https://memorykk.cn/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>操作系统笔记</title>
    <link href="https://memorykk.cn/os-interview.html"/>
    <id>https://memorykk.cn/os-interview.html</id>
    <published>2021-03-24T10:10:19.000Z</published>
    <updated>2021-03-27T07:09:30.388Z</updated>
    
    <content type="html"><![CDATA[<p>概述、启动中断异常和系统调用、连续内存分配、非连续内存分配、虚拟内存、页面置换算法、进程、处理器调度、同步互斥问题、死锁问题。</p><p>5.5万字，252张图，150页，超长总结。</p><span id="more"></span><hr><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0">1. 操作系统概述</a><ul><li><a href="#1-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8">1.1. 操作系统的启动</a></li><li><a href="#1-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84">1.2. 操作系统的结构</a></li></ul></li><li><a href="#2-%E5%90%AF%E5%8A%A8%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">2. 启动、中断、异常和系统调用</a><ul><li><a href="#2-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8">2.1. 操作系统的启动</a></li><li><a href="#2-2-%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">2.2. 中断、异常、和系统调用</a></li></ul></li><li><a href="#3-%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">3. 连续内存分配</a><ul><li><a href="#3-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E5%86%85%E5%AD%98%E5%88%86%E5%B1%82%E4%BD%93%E7%B3%BB">3.1. 计算机体系结构及内存分层体系</a></li><li><a href="#3-2-%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8E%8B%E7%BC%A9%E5%BC%8F%E4%B8%8E%E4%BA%A4%E6%8D%A2%E5%BC%8F%E7%A2%8E%E7%89%87%E6%95%B4%E7%90%86">3.2. 连续内存分配：压缩式与交换式碎片整理</a></li></ul></li><li><a href="#4-%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">4. 非连续内存分配</a><ul><li><a href="#4-1-%E5%88%86%E6%AE%B5">4.1. 分段</a></li><li><a href="#4-2-%E5%88%86%E9%A1%B5">4.2. 分页</a></li><li><a href="#4-3-%E9%A1%B5%E8%A1%A8TLB">4.3. 页表、TLB</a></li><li><a href="#4-4-%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8">4.4. 多级页表</a></li><li><a href="#4-5-%E5%8F%8D%E5%90%91%E9%A1%B5%E8%A1%A8">4.5. 反向页表</a></li></ul></li><li><a href="#5-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">5. 虚拟内存</a><ul><li><a href="#5-1-%E8%B5%B7%E5%9B%A0">5.1. 起因</a></li><li><a href="#5-2-%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF">5.2. 覆盖技术</a></li><li><a href="#5-3-%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF">5.3. 交换技术</a></li><li><a href="#5-4-%E8%99%9A%E5%AD%98%E6%8A%80%E6%9C%AF">5.4. 虚存技术</a></li></ul></li><li><a href="#6-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">6. 页面置换算法</a><ul><li><a href="#6-1-%E6%9C%80%E4%BC%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">6.1. 最优页面置换算法</a></li><li><a href="#6-2-%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%AE%97%E6%B3%95">6.2. 先进先出算法</a></li><li><a href="#6-3-%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95">6.3. 最近最久未使用算法</a></li><li><a href="#6-4-%E6%97%B6%E9%92%9F%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">6.4. 时钟页面置换算法</a></li><li><a href="#6-5-%E4%BA%8C%E6%AC%A1%E6%9C%BA%E4%BC%9A%E6%B3%95">6.5. 二次机会法</a></li><li><a href="#6-6-%E6%9C%80%E4%B8%8D%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95">6.6. 最不常用算法</a></li><li><a href="#6-7-BELADY%E7%8E%B0%E8%B1%A1%E6%AF%94%E8%BE%83">6.7. BELADY现象、比较</a></li><li><a href="#6-8-%E9%97%AE%E9%A2%98%E5%B7%A5%E4%BD%9C%E9%9B%86%E6%A8%A1%E5%9E%8B">6.8. 问题、工作集模型</a></li><li><a href="#6-9-%E7%BC%BA%E9%A1%B5%E7%8E%87%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">6.9. 缺页率页面置换算法</a></li><li><a href="#6-10-%E6%8A%96%E5%8A%A8%E9%97%AE%E9%A2%98">6.10. 抖动问题</a></li></ul></li><li><a href="#7-%E8%BF%9B%E7%A8%8B">7. 进程</a><ul><li><a href="#7-1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89">7.1. 进程的定义</a></li><li><a href="#7-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90">7.2. 进程的组成</a></li><li><a href="#7-3-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9">7.3. 进程的特点</a></li><li><a href="#7-4-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84">7.4. 进程控制结构</a></li><li><a href="#7-5-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E6%9C%9F%E7%AE%A1%E7%90%86">7.5. 进程的生命期管理</a></li><li><a href="#7-6-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%E6%A8%A1%E5%9E%8B">7.6. 进程状态变化模型</a></li><li><a href="#7-7-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8C%82%E8%B5%B7">7.7. 进程的挂起</a></li><li><a href="#7-8-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B">7.8. 为什么使用线程</a></li><li><a href="#7-9-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B">7.9. 什么是线程</a></li><li><a href="#7-10-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0">7.10. 线程的实现</a></li><li><a href="#7-11-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2">7.11. 上下文切换</a></li><li><a href="#7-12-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B">7.12. 进程控制—创建进程</a></li><li><a href="#7-13-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B">7.13. 进程控制—加载和执行过程</a></li><li><a href="#7-14-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%AD%89%E5%BE%85%E5%92%8C%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B">7.14. 进程控制—等待和终止进程</a></li></ul></li><li><a href="#8-%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6">8. 处理器调度</a><ul><li><a href="#8-1-%E8%83%8C%E6%99%AF">8.1. 背景</a></li><li><a href="#8-2-%E8%B0%83%E5%BA%A6%E5%8E%9F%E5%88%99">8.2. 调度原则</a></li><li><a href="#8-3-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">8.3. 调度算法</a></li><li><a href="#8-4-%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6">8.4. 实时调度</a></li></ul></li><li><a href="#9-%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98">9. 同步互斥问题</a><ul><li><a href="#9-1-%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86">9.1. 背景知识</a></li><li><a href="#9-2-%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5PART1">9.2. 一些概念PART1</a></li><li><a href="#9-3-%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5PART2">9.3. 一些概念PART2</a></li><li><a href="#9-4-%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5PART3">9.4. 一些概念PART3</a></li><li><a href="#9-5-%E4%B8%B4%E7%95%8C%E5%8C%BA">9.5. 临界区</a></li><li><a href="#9-6-%E7%A6%81%E7%94%A8%E7%A1%AC%E4%BB%B6%E4%B8%AD%E6%96%AD">9.6. 禁用硬件中断</a></li><li><a href="#9-7-%E5%9F%BA%E4%BA%8E%E8%BD%AF%E4%BB%B6%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">9.7. 基于软件的解决方案</a></li><li><a href="#9-8-%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84%E6%8A%BD%E8%B1%A1--%E5%9F%BA%E4%BA%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C">9.8. 更高级的抽象 — 基于原子操作</a></li></ul></li><li><a href="#1-0-%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%A8%8B">10. 信号量与管程</a><ul><li><a href="#1-0-1-%E8%83%8C%E6%99%AF">10.1. 背景</a></li><li><a href="#1-0-2-%E4%BF%A1%E5%8F%B7%E9%87%8F">10.2. 信号量</a></li><li><a href="#1-0-3-%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8">10.3. 信号量的使用</a></li><li><a href="#1-0-4-%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0">10.4. 信号量的实现</a></li><li><a href="#1-0-5-%E7%AE%A1%E7%A8%8B">10.5. 管程</a></li><li><a href="#1-0-6-%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%981----%E8%AF%BB%E8%80%85%E4%BC%98%E5%85%88%E8%AF%BB%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98">10.6. 经典同步问题1—-读者优先读写者问题</a></li><li><a href="#1-0-7-%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%981%E5%86%99%E8%80%85%E4%BC%98%E5%85%88%E8%AF%BB%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98">10.7. 经典同步问题1—写者优先读写者问题</a></li><li><a href="#1-0-8-%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%982%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98">10.8. 经典同步问题2—哲学家就餐问题</a></li></ul></li><li><a href="#1-1-%E6%AD%BB%E9%94%81">11. 死锁</a><ul><li><a href="#11-1-%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98">11.1. 死锁问题</a></li><li><a href="#11-2-%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B">11.2. 系统模型</a></li><li><a href="#11-3-%E6%AD%BB%E9%94%81%E7%9A%84%E7%89%B9%E5%BE%81">11.3. 死锁的特征</a></li><li><a href="#11-4-%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86%E5%8A%9E%E6%B3%95">11.4. 死锁处理办法</a></li><li><a href="#11-5-%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2%E5%92%8C%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D">11.5. 死锁预防和死锁避免</a></li><li><a href="#11-6-%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E5%92%8C%E6%AD%BB%E9%94%81%E6%81%A2%E5%A4%8D">11.6. 死锁检测和死锁恢复</a></li><li><a href="#11-7-IPC%E6%A6%82%E8%BF%B0">11.7. IPC概述</a></li><li><a href="#11-8-%E4%BF%A1%E5%8F%B7%E7%AE%A1%E9%81%93%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98">11.8. 信号，管道，消息队列和共享内存</a></li></ul></li><li><a href="#1-2-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93">12. 面试总结</a><ul><li><a href="#12-1-%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81">12.1. 用户态和内核态</a></li><li><a href="#12-2-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA">12.2. 缓冲区溢出</a></li><li><a href="#12-3-%E4%B8%AD%E6%96%AD%E4%B8%8E%E8%BD%AE%E8%AF%A2">12.3. 中断与轮询</a></li><li><a href="#12-4-%E4%B8%B4%E7%95%8C%E5%8C%BA">12.4. 临界区</a></li><li><a href="#12-5-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB">12.5. 进程和线程的区别</a></li><li><a href="#12-6-%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB">12.6. 程序与进程的区别</a></li><li><a href="#12-7-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E4%BB%A3%E4%BB%B7">12.7. 进程和线程的上下文切换代价</a></li><li><a href="#12-8-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%8E%9F%E5%88%99">12.8. 进程同步的原则</a></li><li><a href="#12-9-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5">12.9. 进程同步</a><ul><li><a href="#12-9-1-%E7%A1%AC%E4%BB%B6%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6">12.9.1. 硬件同步机制</a></li><li><a href="#12-9-2-%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6">12.9.2. 信号量同步机制</a></li><li><a href="#12-9-3-%E7%AE%A1%E7%A8%8B%E6%9C%BA%E5%88%B6">12.9.3. 管程机制</a></li></ul></li><li><a href="#12-10-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1">12.10. 进程通信</a></li><li><a href="#12-11-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F">12.11. 线程同步的方式</a></li><li><a href="#12-12-%E6%AD%BB%E9%94%81">12.12. 死锁</a><ul><li><a href="#12-12-1-%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5">12.12.1. 死锁的概念</a></li><li><a href="#12-12-2-%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6">12.12.2. 死锁产生的四个必要条件</a></li><li><a href="#12-12-3-%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86">12.12.3. 死锁的处理</a></li></ul></li><li><a href="#12-13-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81">12.13. 进程状态</a></li><li><a href="#12-14-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81">12.14. 线程状态</a></li><li><a href="#12-15-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6">12.15. 进程调度</a></li><li><a href="#12-16-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">12.16. 虚拟内存</a></li><li><a href="#12-17-%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5">12.17. 分页和分段</a></li><li><a href="#12-18-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">12.18. 页面置换算法</a></li><li><a href="#12-19-%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86">12.19. 局部性原理</a></li></ul></li><li><a href="#13-%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">13. 参考链接</a></li></ul><!-- /TOC --><hr><h1 id="1-操作系统概述"><a href="#1-操作系统概述" class="headerlink" title="1. 操作系统概述"></a>1. 操作系统概述</h1><h2 id="1-1-操作系统的启动"><a href="#1-1-操作系统的启动" class="headerlink" title="1.1. 操作系统的启动"></a>1.1. 操作系统的启动</h2><p>用户角度：操作系统是一个控制软件</p><ul><li>管理应用程序</li><li>为应用程序提供服务</li><li>杀死应用程序</li><li>资源管理</li><li>管理外设/分配资源</li></ul><ol><li>在操作系统下，进程&lt;-&gt;CPU, 文件&lt;-&gt;磁盘，地址空间&lt;-&gt;内存。</li><li>操作系统的架构层次：硬件之上，应用软件之下(为应用软件提供服务支持)。</li><li>Linux，Windows界面属于外壳shell(与User交互)，而不是内核kernel，而kernel是研究重点，在shell之下。</li><li>Kernel包括：</li></ol><ul><li>CPU调度器</li><li>物理内存管理</li><li>虚拟内存管理</li><li>文件系统管理</li><li>中断处理和IO设备驱动 (底层硬件)</li></ul><ol start="5"><li>OS Kernel的特征：</li></ol><ul><li>并发(指一段时间内多个程序运行；而并行是指一个时间点上多个程序运行，要求多个CPU):计算机系统中同时存在多个运行的程序，需要OS管理和调度</li><li>共享：“同时”访问 或 互斥共享</li><li>虚拟：利用多道程序设计技术，让每一个用户都觉得有一个计算机专门为他服务</li><li>异步：程序的执行不是一步到底的，而是走走停停，向前推进的速度不可预知<br>但只要运行环境相同，OS要保证程序运行的结果也相同</li></ul><h2 id="1-2-操作系统的结构"><a href="#1-2-操作系统的结构" class="headerlink" title="1.2. 操作系统的结构"></a>1.2. 操作系统的结构</h2><ol><li>简单的操作系统：MS-DOS 不分模块的单体内核 (内部通过函数调用访问,缺点，复杂，紧耦合，易受攻击)</li><li>微内核，尽可能把内核功能移植到用户空间，缺点性能低。</li><li>外核，内核分为一块，一块负责和硬件打交道，另一部分和应用打交道。</li><li>虚拟机,VMs(虚拟机)-&gt;VMM(虚拟机监视器)-&gt;物理机硬件，多操作系统共享硬件资源。</li></ol><h1 id="2-启动、中断、异常和系统调用"><a href="#2-启动、中断、异常和系统调用" class="headerlink" title="2. 启动、中断、异常和系统调用"></a>2. 启动、中断、异常和系统调用</h1><h2 id="2-1-操作系统的启动"><a href="#2-1-操作系统的启动" class="headerlink" title="2.1. 操作系统的启动"></a>2.1. 操作系统的启动</h2><ol><li>CPU, I/O, 内存通过总线连接。</li><li>DISK:存放OS；<br>BIOS：基本I/O处理系统( basic I/O system); Bootloader: 加载OS到内存中。</li><li>当电脑通电时，段寄存器CS和指令寄存器IP能够确定一个内存地址，例如CS:IP = 0xf000:fff0.</li><li>POST(加电自检)，寻找显卡和执行BIOS。(显示器，键盘…是否正常)。</li><li>步骤：</li></ol><ul><li>BIOS: 将Bootloader从磁盘的磁盘的引导扇区(512字节)加载到0x7c00；跳转到CS:IP=0000:7c00的内存区域(以便下一步)</li><li>Bootloader：将操作系统的代码和数据从硬盘加载到内存中；跳转到操作系统的起始地址。</li></ul><p><img src="/images/os-interview/osStart"></p><ol start="6"><li><p>系统调用：(来源于应用程序)应用程序主动向操作系统发出服务请求。</p></li><li><p>异常：(来源于不良的应用程序)非法指令或其它花的处理状态(e.g.内存出错)。</p></li><li><p>中断：(来源于外设)来自不同的硬件设备的计时器和网络的中断。</p></li><li><p>为什么应用程序不能直接访问硬件而是通过操作系统？</p></li></ol><ul><li>计算机运行时，内核是被信任的第三方。</li><li>只有内核可以执行特权指令。</li><li>为了方便应用程序。</li></ul><ol start="10"><li><p>讨论的问题：操作系统如何设计和实现中断/异常和系统调用；他们三者的区别和特点。</p></li><li><p>产生的源头</p></li></ol><ul><li>中断：外设(键盘/鼠标/网卡/声卡/显卡，可以产生各种事件)</li><li>异常：应用程序意想不到的行为(e.g.异常，恶意程序，应用程序需要的资源未得到满足)</li><li>系统调用(system call)：应用程序请求操作提供服务(e.g.打开/关闭/读写文件，发送网络包)</li></ul><ol start="12"><li>处理时间</li></ol><ul><li>中断：异步；</li><li>异常：同步；</li><li>系统调用：同步或异步。</li></ul><ol start="13"><li>响应</li></ol><ul><li>中断：持续，对用户应用程序时透明的</li><li>异常：杀死或者重新执行意想不到的应用程序指令</li><li>系统调用：等待和持续</li></ul><h2 id="2-2-中断、异常、和系统调用"><a href="#2-2-中断、异常、和系统调用" class="headerlink" title="2.2. 中断、异常、和系统调用"></a>2.2. 中断、异常、和系统调用</h2><p>中断和异常的处理机制<br>中断是外设的事件<br>异常是内部迫使cpu访问一些被中断和异常服务访问的功能</p><p>中断和异常都一个硬件的处理过程和软件的处理过程，两者和在一起才构成操作系统的具体服务。<br>将中断和异常编号容易区分，每一个编号有一个对应的地址。<br>这些中断号会构成一个表，当发生中断或者是异常的时候，只需要去查找这个表，就可以容易查找到对应是哪一个。</p><p>中断的处理过程：（包括软件和硬件）<br>硬件：设置中断标记[cpu初始化]</p><ol><li>将内部、外部事件设置中断标记</li><li>中断事件的ID<br>软件：</li><li>保存当前的处理状态。便于后续从打断的点继续完成。</li><li>中断服务程序处理</li><li>清楚中断标记</li><li>恢复之前保存的处理状态</li></ol><p>异常的处理过程：（异常也会有一个异常的编号）</p><ol><li>保存现场</li><li>异常处理</li></ol><ul><li>杀死产生了异常的程序</li><li>重新执行异常指令，重新执行这个指令，程序可以继续的执行。</li></ul><ol start="3"><li>恢复现场</li></ol><p>系统调用：<br>程序访问主要是通过高层次的API接口，而不是直接进行系统调用。</p><p>这些API定义了可以提供哪些系统调用</p><p>通常情况下，与每个系统调用相关的序号<br>系统调用接口根据这些序号来维护表的索引。<br>系统调用接口调用内核态中预期的系统调用<br>并返回系统调用的状态和其他任何返回值<br>用户不需要知道系统调用是如何实现的</p><ul><li>只需要获取API和了解操作新系统将什么作为返回结果</li><li>操作系统接口的细节大部分都隐藏在API中</li><li>通过运行程序支持的库来管理（用包含编译器的库来创建函数集）<br>两个概念：用户态和内核态</li></ul><p>用户态：<br>应用程序在执行的过程中，cpu所处于的一个特权级的状态，其特权级特别低，不能访问某些特殊的机器指令和io<br>内核态：<br>操作系统运行过程中cpu所处于的一个状态，cpu可以执行任何的一条特权指令和io，可以完全的控制这个计算机系统<br><strong>ps</strong>当一个应用程序调用一个系统调用的时候，会完成从用户态到内核态的转换，从而使控制权从应用程序交到了操作系统来。操作系统就是可以对系统调用识别来完成具体的服务。</p><p>函数的调用和系统调用的区别：<br>函数的调用只是简单的在一个栈空间里完成函数的调用和返回。而在系统调用过程中，由于应用程序和内核都有各自的堆栈，所以这回涉及到一个堆栈的切换，还会涉及特权级的转换，从用户态转换到内核态。这个是有消耗的，但是会换来安全和可靠。</p><p>跨越操作系统边界的开销：</p><ol><li>建立中断、异常、系统调用号与对应服务例程映射关系的初始化开销，并且会有一个映射的表，需要对这个表进行维护。</li><li>操作系统有自己堆栈，需要对这个堆栈进行维护有消耗。（当然，应用程序也有自己的堆栈）</li><li>操作系统不信任应用程序，会对参数进行检查，会有一个时间是上的开销。</li><li>数据的内存拷贝，从内核到用户空间，会有一个拷贝的开销。</li></ol><h1 id="3-连续内存分配"><a href="#3-连续内存分配" class="headerlink" title="3. 连续内存分配"></a>3. 连续内存分配</h1><h2 id="3-1-计算机体系结构及内存分层体系"><a href="#3-1-计算机体系结构及内存分层体系" class="headerlink" title="3.1. 计算机体系结构及内存分层体系"></a>3.1. 计算机体系结构及内存分层体系</h2><p>计算机体系结构/内存分层体系内容：</p><ul><li>计算机系统结构</li><li>内存分层体系</li><li>在操作系统的内存管理范例</li></ul><p>一、计算机系统结构主要包含了三大内容：</p><ul><li>cpu：完成对整个程序的控制</li><li>内存：放置了程序的代码和管理的数据</li><li>外设：配合程序发挥更大的作用</li></ul><p><img src="/images/os-interview/os31.png"></p><p>二、内存的层次机构：cpu要访问的指令和数据所处的位置在什么地方</p><p><img src="/images/os-interview/os32.png"></p><p>cpu寄存器，cache：都是处于cpu内部，速度很快，容量很少，可以放的数据有限<br>主存，物理内存：容量大，但是速度小<br>硬盘：需要永久保存的数据就放在硬盘中，掉电也不会丢失，速度更慢，但是容量更大</p><p>三、操作系统到底要完成的重点事情</p><p><img src="/images/os-interview/os33.png"></p><ul><li>可以抽象出来，只需要考虑连续的地址空间，而不需要考虑细节</li><li>保护进程空间，有一个隔离的机制，避免应用程序破坏别人</li><li>进程空间的通信，共享的空间，使数据的传递安全，有效的</li><li>让正在运行的程序，放在内存汇总，让暂时不需要的访问的数据可以临时的放在硬盘中。（例如p4）</li></ul><p>四、两种不同的空间<br>主存硬盘的物理地址空间<br>运行程序锁看见的空间是逻辑地址空间</p><p>五、在操作系统中管理内存的不同方法<br>程序重定位，分段，分页，虚拟内存，按需分页虚拟内存<br>ps：其实现高度依赖于硬件，必须知道内存架构，MMU（内存管理单元）：硬件组件负责处理cpu的内存访问请求。</p><p>3.2地址空间与地址生成<br>涉及到几点：</p><ul><li>地址空间定义</li><li>地址生成</li><li>地址的安全检查</li></ul><p>一、地址空间的定义</p><ul><li>物理地址空间—与硬件直接对于（例如内存条所代表的主存）</li><li>逻辑地址空间—程序所看见的地址空间</li></ul><p><img src="/images/os-interview/os34.png"></p><p>像这条指令一样，其具体的映射关系，需要操作系统来处理的</p><p>二、逻辑地址生成</p><p><img src="/images/os-interview/os35.png"></p><p>执行文件放在内存中去，还是一个逻辑的地址</p><p>三、完成逻辑地址到物理地址的映射过程</p><p><img src="/images/os-interview/os36.png"></p><p>当cpu需要执行这条指令的过程如下：</p><ul><li>ALU运算器需要这条指令的内容</li><li>cpu里面的mmu（内存管理单元）查找逻辑地址的映射表，找出逻辑地址和物理地址之间的映射</li><li>cpu控制器会从总线发送物理地址的内存内容的请求（就是指令的内容）</li><li>主存会把总线拿到的物理地址内存的内容传给cpu<br>其中，操作系统的作用是建立起逻辑地址和物理地址之间的映射。</li></ul><p>四、地址的安全监测的过程</p><p><img src="/images/os-interview/os37.png"></p><p>操作系统的另一个目标是放在内存中的程序相互之间不能互相的干扰</p><ul><li>操作系统首先要确保每一个程序可以有效的访问地址空间。（包括起始地址和地址的长度）。</li><li>map会指出逻辑地址是否满足映射关系，然后就去到相应的物理地址，将指令数据取回来。</li><li>如果不满足，cpu将会产生一个memory异常（内存访问异常）</li></ul><p>3.3连续内存的分配：内存碎片与分区的动态分配<br>连续内存分配所涉及的问题：<br>内存碎片问题<br>分区的动态分配（第一分配，最佳适配，最差适配）<br>压缩式碎片整理<br>交换式碎片整理</p><p>一、内存碎片问题<br>可以理解为当给一个运行的程序分配一个空间之后，会出现一些无法进一步利用的空间。<br>1.外部碎片：分配单元之间无法利用的空间<br>2.内部碎片：运行的程序无法对所分配好的空间进一步的使用</p><p><img src="/images/os-interview/os38.png"></p><p>二、分区的动态分配<br>什么时候需要分配连续的内存：<br>1.当一个程序准许运行在内存中时候，需要在内存中分配一个连续的区间<br>2.分配一个连续的内存切间给运行的程序以访问数据</p><p><img src="/images/os-interview/os39.png"></p><p>操作系统中会有一些数据结构和算法对空余的内存空间进行有效的管理。<br>以下有三个简单的内存分配的算法。</p><ul><li>首次适配（first fit）</li><li>最优适配（best fit）</li><li>最差适配（worst fit）</li></ul><p>以下分别做简单的介绍：</p><ul><li>首次适配算法（first fit）–第一个内存块</li></ul><p><img src="/images/os-interview/os310.png"></p><p>基本原理和实现：<br>需求：<br>按地址排序的空闲块列表（从0地址开始），分配需要寻找一个合适的分区重分配需要检查，看是否自由分区能合并于相邻的空闲分区（若有）。<br>优点：<br>简单，并且容易产生更大的空闲块（没有被破坏），向这地址空间的结尾<br>缺点：<br>容易产生外碎片，两个空闲块的空间因为比较小，就可以不会被使用，并且随着时间这个特性会加剧。</p><ul><li>最优适配算法（best fit）–最适合分配请求的size</li></ul><p><img src="/images/os-interview/os311.png"></p><p>基本原理和实现：</p><ul><li><p>按尺寸排列空闲块列表</p></li><li><p>分配需要寻找一个合适的分区</p></li><li><p>重分配需要搜索及合并于相邻的空闲分区（若有）<br>优点：<br>对于大多数小内存分配的情况比较合适，比较简单。避免了分割大的空闲块，并且最小化外部碎片产生的尺寸<br>缺点：<br>将外碎片分配得比较细，重分配慢，而且容易产生很多没用的微小碎片（不怎么好）</p></li><li><p>最差适配算法（worst fit）—与请求差距最大的size分配</p></li></ul><p><img src="/images/os-interview/os312.png"></p><p>大块变成了小块，小块进行保留<br>基本原理和实现：</p><ul><li>按差距的尺寸最大进行排列空闲块列表</li><li>分配很快（获得更大的分区）</li><li>重分配需要合并相邻的空间分区（若有），然后调整空闲块列表<br>优点：<br>假如分配是中等尺寸效果最好<br>缺点：<br>易于破坏大的空闲块以致于大分区无法被分配</li></ul><p>小结：应用请求的需求是随机的和可变的，这些算法都不可能满足全部的应用请求的。</p><h2 id="3-2-连续内存分配：压缩式与交换式碎片整理"><a href="#3-2-连续内存分配：压缩式与交换式碎片整理" class="headerlink" title="3.2. 连续内存分配：压缩式与交换式碎片整理"></a>3.2. 连续内存分配：压缩式与交换式碎片整理</h2><p>以下两种方法减少碎片的产生<br>1.压缩式碎片整理<br>2.交互式碎片整理</p><p>一、压缩式（compression）碎片整理<br>重置程序以合并孔洞<br>要求所有程序是动态可重置的<br>内存拷贝前思考两个问题：</p><ul><li>什么时候考虑内存的重定位是合适的<br>当程序处于等待的状态之中可以开始内存的重定位</li><li>考虑开销大不大<br>仅仅利用软件的移动实现开销是很大的</li></ul><p><img src="/images/os-interview/os313.png"></p><p>二、交换式（swap）碎片整理</p><p><img src="/images/os-interview/os314.png"></p><p>考虑几个问题</p><ul><li>考虑将那一个程序拷贝到磁盘中去？</li><li>什么时候做这个换入和换出的操作？</li><li>换入换出的开销？</li></ul><h1 id="4-非连续内存分配"><a href="#4-非连续内存分配" class="headerlink" title="4. 非连续内存分配"></a>4. 非连续内存分配</h1><h2 id="4-1-分段"><a href="#4-1-分段" class="headerlink" title="4.1. 分段"></a>4.1. 分段</h2><p>分段的管理机制分为两点：</p><ul><li>在分段情况下，内存地址空间如何寻址的问题</li><li>如何去实现分段的寻址方案</li></ul><p>一、分段<br>计算机程序是由各种各样的段来存储的</p><p><img src="/images/os-interview/41.png"></p><p>分段：更好的分离和共享</p><p><img src="/images/os-interview/42.png"></p><p>通过分段，可以有效的隔离开来，相应的分离出来，更加有效进行管理，分配和保护。这中间需要一种映射机制来实现相关联。</p><p><img src="/images/os-interview/43.png"></p><p>映射之后：位置不一样，大小也不一样</p><p>二、段的访问机制<br>将一个一维的地址分成两块：<br>一个是段号的寻址，另一个是偏移的寻址</p><p><img src="/images/os-interview/44.png"></p><p>段号+段内偏移何合在一起就形成了一段机制来寻址的方式。<br>分两种情况：</p><ul><li>段寄存器+地址寄存器实现方案（x86）</li><li>将段和段内偏移合在一起，单地址实现方案</li></ul><p>三、将段的映射机制映射起来</p><p><img src="/images/os-interview/45.png"></p><p>过程：<br>1、通过段号找到段所在物理内存的起始地址<br>2、但是这个映射关系需要存储–段表，段表中存储中逻辑地址的段号和物理地址的段号的映射关系。<br>3、段表中存储着两个重要的信息：一个是段表的起始地址，另外一个是段长度的限制，两者合在一起就形成了一个物理地址。<br>4、 这样形成了物理地址之后，根据这个地址来查找在物理内存的位置，然后把相应的数据取出来，交给cpu做进一步的处理</p><p>段表有操作系统来建立，此时段机制就可以正常的工作了。<br>而且段机制用得比较少，现在大多数的cpu用的是分页机制。</p><h2 id="4-2-分页"><a href="#4-2-分页" class="headerlink" title="4.2. 分页"></a>4.2. 分页</h2><p>两个内容：</p><ul><li>分页地址空间</li><li>页寻址方案</li></ul><p>段需要一个段号和段内的偏移，而页也一样，需要页号和页内的偏移。<br>主要区别在于在段的机制里面，段的尺寸是可变的，而分页机制中页的大小是固定的，这个是最大的区别。</p><p>一、页的分类</p><p>划分物理内存至固定大小的帧<br>大小是2的幂，eg：512,4096（4k）,8192<br>划分逻辑地址空间至相同大小的页<br>大小是2的幂，eg：512,4096,8192<br>ps：页的大小是不变的，这样便于硬件对其实现</p><p>页帧（frame）是物理页<br>页（page）逻辑页</p><p>我们需要建立一个逻辑页地址和物理页地址的一个映射关系。<br>建立方案：转换逻辑地址为物理地址（page to frame）</p><ul><li>页表</li><li>MMU（内存管理单元）/TLB（块表）</li></ul><p>二、页帧（frame）—物理地址<br>定义：物理内存的组织和布局方式<br>页帧也有两部分组成：</p><ul><li>页帧号（frame number）</li><li>页帧偏移（frame offset）</li></ul><p><img src="/images/os-interview/46.png"></p><p>页帧号占 F 位，页帧本身的大小占 S 位<br>在整个的寻址空间中有 2^F 这么多个页帧的个数<br>页帧而每一页的总大小是 2^S</p><p><img src="/images/os-interview/47.png"></p><p>解析：<br>一帧包含了9位，所以没一页帧的大小都是2 ^9 这么大小，而页帧号是3，所以代表了有3个这么大的一个页，所以也就是2^9 * 3，最后，再加上偏移量o，为6，所以最后的结果是 2^9 * 3 + 6 = 1542.<br>所以地址就是0x1542</p><p>三、页（page）—逻辑地址<br>和页帧的区别是其页号和页帧号的szie大小可能不一样。但是每一个页的大小和每一个页帧的大小都是一样的。</p><p><img src="/images/os-interview/48.png"></p><p>其逻辑地址的计算方法与页帧的计算方法是一样的。</p><p>四、地址的转换</p><p><img src="/images/os-interview/49.png"></p><p>过程如下：<br>1、首先cpu会去寻址（逻辑地址或者是物理地址），这个地址会分为另两个内容，一个是offect偏移量，一个是页号。<br>2、将也号作为一个索引，查一个页表（Page table），其实以页号为索引的一向内容，可以根据其查找出页帧号。而且还有知道其基地址，就形成了页帧号和页帧偏移量大小的物理地址。（所以页的偏移大小和页帧的偏移大小是一样的）<br>3、这样就知道了对应的物理地址的所在位置。这个整个的大致过程。<br>ps：其中page table是操作系统在内存初始化的时候建立起来的。</p><p><img src="/images/os-interview/410.png"></p><h2 id="4-3-页表、TLB"><a href="#4-3-页表、TLB" class="headerlink" title="4.3. 页表、TLB"></a>4.3. 页表、TLB</h2><p>一、页表的结构</p><p><img src="/images/os-interview/411.png"></p><p>在页表中，有一系列的属性，eg：可读可写，是否存在等等…</p><p>二、页表的地址转换的例子</p><p>逻辑地址空间和物理地址空间大小是不对等的，但是每一个页内的偏移都是相等的。<br>其中，resident 位为0 代表 内存不存在，为1表示存在。如果cpu访问了为0的地址，这是会产生一个异常，就是内存访问异常。</p><p>如图所示：<br>页为（4,0）的逻辑地址，由于resident = 0，所以真是的物理内存不存在<br>页为（3，1024）的逻辑地址，由于resident = 1，地址存在，查表可知，frame物理地址的页帧号是4，偏移量与页的偏移量相同，一样为1023，所以结果地址便为（4,1023）<br>（页表的建立过程是有操作系统完成的）</p><p>三、分页机制的性能问题<br>1、空间的代价问题<br>2、时间的开销问题<br>（希望时间越短越好，效率越大越好）</p><p>问题一：页表可能非常大<br>64位机器如果每页是1k，那么一个页表的大小会是多少呢？<br>问题二：页表可能开销大<br>每一个应用程序都要生成一个自己的页表，开销比较大</p><p>如何处理？</p><ul><li>缓存（Caching）<br>将一些常用的数据缓存到黎cpu非常近的地方，提高访问的速度</li><li>间接（Indirection）访问<br>通过间接的方法，将一个很大的空间，拆分为一个很小的空间。通过多级的页表机制，可以缓解页表占用空间过大的问题。</li></ul><p>时间问题 —TLB<br>缓存近期访问的页帧转换表项</p><p><img src="/images/os-interview/412.png"></p><p>TLB是一个特殊的区域，位于CPU的内部。<br>Key和Value两个形成了TLB的表相，而这个表相是由相关存储器来实现的，这个是一种快速查询的存储器，速度很快，可以并发的查找，但是容量是有限的。所以可以将一些经常使用的页表项放在TLB中。可以通过查询TLB，避免了一次页表的访问。<br>当出现TLB访问不到的情况，这个情况叫做TLB miss，这是cpu就不得不查页表。<br>而对于TLB miss这个情况，将新的页帧加载到TLB中，部分是有cpu硬件来完成的，而部分是有操作系统完成的，也就是两种情况都存在。</p><h2 id="4-4-多级页表"><a href="#4-4-多级页表" class="headerlink" title="4.4. 多级页表"></a>4.4. 多级页表</h2><p>一、空间问题 — 二级页表解决</p><p><img src="/images/os-interview/413.png"></p><p>一级页表里面存储的是二级页表的地址，二级页表知道之后就会知道frame number页帧号。<br>通过这种方式可以极大的减少空间的消耗，因为如果一级页表中的resident = 0的话。就没有必要再二级页表中添加其索引的，比单级页表大大的减小了空间的开销。</p><p>二、多级页表<br>多级页表可以表示一个更大的地址空间，形成一个树状的结构。这个是以时间换取空间，但是时间问题也可以通过TLB方法来解决。</p><p><img src="/images/os-interview/414.png"></p><h2 id="4-5-反向页表"><a href="#4-5-反向页表" class="headerlink" title="4.5. 反向页表"></a>4.5. 反向页表</h2><p>一、反向页表：<br>以物理地址的页帧号（frame number）方向查找逻辑页的页号（page number）</p><p><img src="/images/os-interview/415.png"></p><p>这样使得寄存器的容量，只与物理地址空间的大小相关，与逻辑地址空间大小无关。</p><p>但是有一个主要的问题：如何将页号和页帧号建立起一个映射关系。<br>页存储器方案的权衡：<br>优点：</p><ul><li>转换表的大小相对于物理内存来说很小</li><li>转换表的大小跟逻辑地址空间的大小无关<br>缺点：</li><li>需要的信息对调了，既根据帧号可找到页号</li><li>如何转换回来？既根据页号找到帧号</li><li>在需要在反向表中搜索想要的页号</li></ul><p>二、关联存储器方案<br>可以并行的查找页号所对应的帧号，其key是他的页号，value是页帧号</p><p><img src="/images/os-interview/416.png"></p><p>存在的问题：</p><ul><li>设计成本太大，硬件处理很复杂</li><li>内存访问的开销问题</li><li>大量的关联内存非常昂贵，难以在单个时钟周期内完成且耗电</li></ul><p>三、基于哈希（hash）计算的反向页表<br>只需要建立好一个哈希的函数，输入一个值，就会得到一个输出。而输入的值是page number，输出的值是frame number。<br>为了能提高加速，需要硬件的加速。<br>为了提高效率，加一个PID的标识</p><p><img src="/images/os-interview/417.png"></p><p>可以有效的缓解完成映射的开销。</p><p>在反向页表中通过哈希算法来搜索一个页对应的帧号</p><ul><li>对页号做哈希计算，为了在“帧表”（每一帧用于一个表项）中获取对应的帧号</li><li>页i被放置在表中f(i)位置，其中f是设定的哈希函数</li><li>为了查找页i，执行下列操作：<br>计算哈希函数f(i)并且使用它作为页寄存器表的索引，获取对应的页寄存器，检查寄存器标签是否包含i，如果包含，则代表成功，否则失败。</li></ul><h1 id="5-虚拟内存"><a href="#5-虚拟内存" class="headerlink" title="5. 虚拟内存"></a>5. 虚拟内存</h1><h2 id="5-1-起因"><a href="#5-1-起因" class="headerlink" title="5.1. 起因"></a>5.1. 起因</h2><p>理想中的存储器：<br>更大，更快，更便宜的非易性存储器</p><p><img src="/images/os-interview/51.png"></p><p>硬盘的速度远远的慢于内存的执行。<br>磁带比硬盘的存储容量更加的庞大。<br>现有的物理内存掉电之后数据还是会丢失的。</p><p><img src="/images/os-interview/52.png"></p><p><img src="/images/os-interview/53.png"></p><p>以上设计了三种技术：</p><ul><li>手动覆盖技术：只把指令和数据保存在内存中</li><li>自动交换技术：将程序导出内存到硬盘上</li><li>虚拟内存技术（前两种是虚拟内存还没出现的情况下诞生的）：以更小的力度把数据导出导入到内存中来，充分的利用了内存空间的手段</li></ul><h2 id="5-2-覆盖技术"><a href="#5-2-覆盖技术" class="headerlink" title="5.2. 覆盖技术"></a>5.2. 覆盖技术</h2><p>一、覆盖技术的基础<br>目标：<br>是在较小的可用内存中运行较大（相对而言的）的程序。常用与多道程序系统，与分区存储管理配合使用。<br>原理：<br>把程序按照其自身的逻辑结构，划分为若干个功能上相对独立的程序模块，那些不会同时执行的模块共享同一块内存区域，按时间先后来运行。</p><p>必要部分（常用功能）的代码和数据常驻内存；<br>可选部分（不常用内存）在其他程序模块中实现，平时存放在外存中，在需要用到时才装入内存；<br>不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖，既这些模块共有一个分区。<br>二、应用例子<br>例子一：</p><p><img src="/images/os-interview/54.png"></p><ul><li>bc是对等的，相互之间不会调用，所以分在一个区；A调用b的时候，c是不会执行的，所以只需要将b放在内存中即可。</li><li>def也是对等的，相互之间也不会调用，所以也分在一个区；当C调用e的时候，df通用是不会被调用的，所以也只需要将e放在内存中即可。</li></ul><p>例子二：</p><p><img src="/images/os-interview/55.png"></p><p>所以覆盖技术是可以有多种方式选择的。</p><p>三、覆盖技术的优缺点<br>优点：<br>将一个大程序可以放在一个很小的内存里面通过交换技术执行。</p><p>缺点：</p><ul><li>由程序员来把一个大的程序划分为若干个小功能模块，并确定各个模块之间的覆盖技术，费时费力，增加了编程的复杂度。</li><li>覆盖模块从外存装入内存，实际上是以时间延长来换取空间节省</li></ul><h2 id="5-3-交换技术"><a href="#5-3-交换技术" class="headerlink" title="5.3. 交换技术"></a>5.3. 交换技术</h2><p>一、交换技术的基础<br>目标：<br>多道程序在内存中时，让正在运行的程序或需要运行的程序获得更多的内存资源。<br>方法：</p><ul><li>可将暂时不能运行的程序送到外存，从而获得空闲内存空间</li><li>操作系统把一个进程的整个地址空间的内容保存到外存中（换出swap out），而将外存中的某个进程的地址空间读入到内存中（换入swap in）。换入换出内容的大小为整个程序的地址空间。</li></ul><p>这个换入换出的交换技术是操作系统内存管理的重要组成部分。</p><p><img src="/images/os-interview/56.png"></p><p>二、交换技术实现的几个问题：</p><ul><li>交换时机的确定：何时小发生交换？只当内存空间不够或有不够危险的时候才换出。</li><li>交换区的大小：必须足够大以存放所以用户进程的所有内存映射的拷贝；必须能对这些内存映像进行直接存取。</li><li>程序换入时的重定位：换出后再换入的内存位置一定要在原来的位置上吗，寻址可能会出现问题？最好采用动态地址映射的方法，建好页表就行。<br>ps：交换技术是可以由操作系统来完成的，对于程序员来说是透明的。<br>三、小结–覆盖与交换的比较</li><li>覆盖只能发生在那些相互之间没有调用关系的程序模块之间，因此程序员必须给出程序内的各个模块之间的逻辑覆盖结构。</li><li>交换技术是以内存中的程序大小为单位来进行的，它不需要程序员给出各个模块之间的逻辑覆盖结构。换言之，交换发生在内存中程序与管理程序或操作系统之间，而覆盖则发生在运行程序内部。</li></ul><h2 id="5-4-虚存技术"><a href="#5-4-虚存技术" class="headerlink" title="5.4. 虚存技术"></a>5.4. 虚存技术</h2><p>（虚拟内存管理技术）<br>一、前诉<br>在内存不够用的情形下，可以采用覆盖技术和交换技术，但是：<br>覆盖技术：需要程序员自己把整个程序划分为若干个小的功能模块，并确定各个模块之间的覆盖关系，增加了程序员的负担；<br>交换技术：以进程作为交换的单位，需要把进程的整个地址空间都换进换出，增加了处理器的开销。<br>希望通过一种更好的办法，能够充分的解决交换技术和覆盖技术出现的问题。</p><p>二、虚拟内存的基础<br>目标：</p><ul><li>像覆盖技术那样，不是把程序的所有内容都放在内存中，因而能够运行比当前的空闲内存空间还要大的程序。但做得更好，由操作系统自动来完成，无须程序员的干涉；</li><li>像交换技术那样，能够实现进程在内存与外存之间的交换，因而获得更多的空闲内存空间。但做得更好，只对进程的部分内容在内存和外存之间进行交换。</li></ul><p><img src="/images/os-interview/57.png"></p><p>二、虚拟技术–程序的局部性原理<br>定义：<br>程序的局部性原理（principle of locality），指程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定的区域，这个可以表现为：</p><p>时间局部性：一条指令的一次执行和下次执行，一个数据的一次访问和下一次访问都集中在一个较短时期内。<br>空间局部性：当前指令和邻近的几条指令，当前访问的数据和邻近的几个数据都集中在一个较小区域内。<br>程序的局部性原理表明，从理论上说，虚拟存储技术是能够实现的，而且在实现了以后应该是能够取得一个满意的效果。访问的速度更快，并且可以提供一个很多的空间。<br>三、程序局部性的例子</p><p><img src="/images/os-interview/58.png"></p><p>可见：程序1是按照行来访问的，而程序2的按照列来访问的</p><p><img src="/images/os-interview/59.png"></p><p>结果分析：<br>由于程序1的没相邻的两次访问的地址差距较大，不满足时间局部性和空间局部性，所以会产生多次的缺页中断，对系统的开销较大。而程序2两个数据是相邻的，具有良好的时间局部性和空间局部性。<br>如果程序不具有局部性，这个高效的机制就很难的实现。</p><p>四、虚存技术的大致流程<br>前提：<br>操作系统有了硬件支持分段/分页机制，在此内存管理基础之上来实现一个以页或者是段为单位的虚存管理。<br>过程：</p><ul><li>在装入程序的时候，不必将所有的程序和数据装入内存中去，而只需将当前需要执行的部分的代码数据放在相关的段或者是页中，这样可以是的一小部分的代码放在内存中去了。</li><li>在程序执行过程中，如果需要执行的指令或访问的数据尚未在内存中（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序。</li><li>另一方面。操作系统将内存中暂时不使用的页面或段调出保存在外存上，从而腾出更多空闲空间存放将要装入的程序以及将要调入的页面或段。</li></ul><p>如图所示：程序只有少部分在内存中，而大部分都是在外存中存储。</p><p><img src="/images/os-interview/510.png"></p><p>五、虚拟内存的基本特征</p><ul><li>较大的用户空间：<br>通过把物理内存与外存结合，提供给用户的虚拟内存空间通常大于实际的物理内存，既实现了这两者的分离。如32位的虚拟地址理论上可以访问4GB，而可能计算机上仅有256M的物理内存，但硬盘的容量大于4GB</li><li>部分交换：<br>与交换技术相比较，虚拟存储的调入和调出是对部分虚拟地址空间进行的，其每次的换入换出是非常规整的，要么是段或者是页。不需要将整个程序交换出去。力度更小，但是效率更高。</li><li>不连续性：<br>物理内存分配不连续，虚拟地址空间使用也是不连续的。本来所有的数据都是连续的放在虚拟内存中的，但是操作系统要把某些数据换出去，而造成的不连续。操作系统会弥补好，正常的访问。</li></ul><p>六、虚拟内存技术的具体实现<br>基于页式虚拟内存管理，与前诉的一样。</p><p><img src="/images/os-interview/511.png"></p><p>大部分虚拟存储系统都采用虚拟页式存储管理技术，既在页式存储管理的基础上，增加请求调页和页面置换功能。<br>基本思路：</p><ul><li>当一个用户程序要调入内存运行时，不是将该程序的所以页面都装入内存，而是只装入部分的页面，就可以启动程序运行。</li><li>在运行的过程中，如果发现要运行的程序或要访问数据不在内存，则向系统发出缺页中断请求，系统在处理这个中断时，将外存中相应的页面调入内存，使得该程序能够继续运行。</li></ul><p>七、页表表项的设定</p><p><img src="/images/os-interview/512.png"></p><p>驻留位：表示该页是在内存还是外存。如果该位等于1，表示该页位于内存当中，既该页表项是有效的，可以使用；如果改为为0，表示该页当前还在外存当中，如果访问该页表项，将导致缺页中断。<br>保护位：表示允许对该页做何种类型的访问，如只读，可读写，可执行等。<br>修改位：表面此页面在内存中是否被修改过，当系统回收该物理页面时，根据此位来决定是否把他的内容写回外存。位为0就表示数据一样的，不需要写回外存中。<br>访问位：如果该页面被访问过（包括读操作或写操作），则设定词尾，用于页面的置换算法。<br>示例：</p><p><img src="/images/os-interview/513.png"></p><p>（左边是虚存页表的映射关系，每一个页表项有4K的物理页，X代表驻留位为0，如果是一个具体的数，就代表驻留位为1，映射关系有效。）</p><p>示例1：<br>MOV REG, 0 //将0地址的内容赋值给一个寄存器<br>可以看见，0地址是在最底下，有一个2，这表示驻留位是1，且页帧号是2。而一个页的大小是4096,既4k，所以2*4k为8k。也就是所将对应的8k的地址8192的内容给寄存器。<br>MOV REG, 0 ———&gt; MOV REG, 8192</p><p>示例2：<br>MOV REG, 32780<br>可以看见32780对应的页表项是32k，其驻留位的设置是0，没有对应的一个页帧号，意味着访问这一页会产生缺页（缺页异常）<br>MOV REG, 32780 ———&gt; MOV REG, 缺页中断</p><p>八、缺页中断处理过程</p><p><img src="/images/os-interview/514.png"></p><p>当cpu执行一条指令load一个内存地址，如果这个内存地址没有一个对应的关系，也就是说没有一个存在位，这时就会产生一个缺页异常，接来下操作系统就会完成一些列缺页中断的处理：</p><ul><li>如果在内存中有空闲的物理页面，则分配一空闲的物理页帧f，然后转第4步；否者转第2步。</li><li>采用某种页面置换算法，选择一个将被替换的物理页帧f，他所对应的逻辑页为q。如果该页在内存期间被修改过，则需把他写回外存。</li><li>对q所对应的页表项进行修改，把驻留位置置0。</li><li>将需要访问的页p装入到物理页面f当中。也就是把页所需要访问的地址对应的硬盘中的数据，以页为单位，从硬盘读到内存中去，读到刚分配到的那个内存地址。</li><li>修改p所对应的页表项的内容，把驻留位置1，把物理页帧号置为f。</li><li>重新运行被中断的指令。</li></ul><p>九、后备存储（Backing Store）<br>在何处保存未被映射的页？<br>能够简单地识别在二级存储器中的页<br>交换空间（磁盘或者文件）：特殊格式，用于存储未被映射的页面<br>概念：<br>一个虚拟地址空间的页面可以被映射到一个文件（在二级存储中）中的某个位置<br>代码段：映射到可执行二进制文件<br>动态加载的共享程序段：映射到动态调用的库文件<br>其他段：可能被映射到交换文件（swap file）</p><p>有了这个后背存储/二级存储，可以充分保证了虚存空间的有效性。</p><p>十、虚拟内存性能<br>为了便于理解分页的开销，使用有效存储器访问时间effective memory access</p><p><img src="/images/os-interview/515.png"></p><p>其实取决参数p，如果p足够小，就可以使平均的执行时间接近10nm，但是如果程序有局部性特点，就表面产生缺页的次数会很少，这是效率就会很高。</p><h1 id="6-页面置换算法"><a href="#6-页面置换算法" class="headerlink" title="6. 页面置换算法"></a>6. 页面置换算法</h1><p>1、局部页面置换算法</p><p>最优页面置换算法（OPT、optimal）<br>先进先出算法（FIFO）<br>最近最久未使用算法（LRU,Least Recently Used）<br>时钟页面置换算法（Clock）<br>最不常用算法（LFU，Least Frequently Used）<br>Belady现象<br>LRU、FIFO和Clock的比较<br>2、全局页面置换算法</p><p>工作集模型<br>工作集页置换算法<br>缺页率置换算法<br>功能：<br>当缺页中断发生，需要调入新的页面而内存已满时，选择内存当中哪个物理页面被置换。</p><p>目标：<br>尽可能地减少页面的换进换出次数（既缺页中断的次数）。具体来说，把未来不再使用的或短期内较少使用的页面换出，通常只能在局部性原理指导下依据过去的统计数据来进行预测。</p><p>页面锁定（frame locking）：<br>用于描述必须常驻内存的操作系统的关键部分或时间关键（time-critical）的应用程序。实现的方法是L在页表中添加锁定标志位（lock bit）。使其不在页面置换算法范围之内，也就说不会被换入换出。</p><p><img src="/images/os-interview/61.png"></p><p>通常只需要考虑页号，因为偏移号一般不起作用。只保留页号。基于这个list来设计各种的页面替换算法。<br>通过模拟一个页面置换的行为并且记录产生页缺失数的数量。一般情况下，产生的缺页次数越少，性能就越高。</p><h2 id="6-1-最优页面置换算法"><a href="#6-1-最优页面置换算法" class="headerlink" title="6.1. 最优页面置换算法"></a>6.1. 最优页面置换算法</h2><p>一、基础<br>基本思路：<br>当一个缺页中断发生时，对于保存在内存当中的每一个逻辑页面，计算在它的下一次访问之前，还需要等待多长时间，从中选择等待时间最长的那个，作为被置换的页面。</p><p>结论：</p><p>这只是一个理想的情况，在实际系统中是无法实现的，因为操作系统无从知道每一个页面要等待多长时间以后才会再次被访问。<br>可用作其他算法的性能评价的依据（在一个模拟器上运行某个程序，并记录每一次的页面访问情况，在第二遍运行时即可使用最优算法。然后以此为基础，评价其他的算法。）<br>二、示例</p><p><img src="/images/os-interview/62.png"></p><p>在上帝视角中，可以看出由于d是最长时间没有被使用，所以d将会被e所替换，如上所示。</p><h2 id="6-2-先进先出算法"><a href="#6-2-先进先出算法" class="headerlink" title="6.2. 先进先出算法"></a>6.2. 先进先出算法</h2><p>一、基础<br>先进先出算法（First-In First-Out，FIFO）：<br>1、基本思路：<br>选择在内存中驻留时间最长的页面并淘汰之。具体来说，系统维护着一个链表，记录了所有位于内存当中的逻辑页面。从链表的排列顺序来看，链首页面的驻留时间最长，链尾页面的驻留时间最短。当发生一个缺页中断时，把链首页面淘汰出局，并把新的页面添加到链表的末尾。</p><p>2、评价：<br>性能较差，调出的页面有可能是经常要访问的页面，并且有Belady现象（给的物理页帧越多，产生缺少的次数越大）。FIFO算法很少单独使用。</p><p>二、示例</p><p><img src="/images/os-interview/63.png"></p><p>实现简单，但是产生的缺页次数比较多</p><h2 id="6-3-最近最久未使用算法"><a href="#6-3-最近最久未使用算法" class="headerlink" title="6.3. 最近最久未使用算法"></a>6.3. 最近最久未使用算法</h2><p>一、基础<br>最近最久未使用算法（LRU,Least Recently Used）<br>1、基本思路：<br>当一个缺页中断发生时，选择最久未使用的那个页面，并淘汰之。</p><p>2、评价：<br>它是对最优页面置换算法的一个近似，其依据是程序的局部性原理，既在最近一小段时间（最近几条指令）内，如果某些页面被频繁地访问，那么在将来的一小段时间内。他们还可能会再一次地频繁地访问。反过来说，如果在过去某些页面长时间未被访问，那么在将来他们还可能会长时间地得不到访问。也就是根据过去推算出未来。</p><p>二、示例</p><p><img src="/images/os-interview/64.png"></p><p>LRU算法需要记录各个页面使用时间的先后顺序。<br>开销比较大。两种可能的实现方法是：<br>方法一：<br>系统维护一个页面链表，最近各个使用过的页面作为首节点，最久未使用的页面作为尾节点。每一次访问内存时，找到相应的页面，把它从链表中摘下来，在移动到链表之首。每次缺页中断发生时，也就是没有这个页表，所以会把新的页表查到链表头，然后淘汰链表末尾的页面。</p><p>方法二：<br>设置一个活动页面栈，当访问某页时，将此页号压入栈顶，然后考察栈内是否有与页面相同的页号，若有则抽出。然后压入栈顶。当需要淘汰一个页面时，总是选择栈底的页面，它就是最久未使用的。</p><p><img src="/images/os-interview/65.png"></p><p>效果比较好，但是系统的开销比较大</p><h2 id="6-4-时钟页面置换算法"><a href="#6-4-时钟页面置换算法" class="headerlink" title="6.4. 时钟页面置换算法"></a>6.4. 时钟页面置换算法</h2><p>一、基础<br>Clock页面置换算法，LRU的近视，对FIFO的一种改进<br>1、基本思路</p><ul><li>需要用到页表项当中的访问位，当一个页面被装入内存时，把该位初始化为0。然后如果这个页面被访问（读/写），则把该位置置1。</li><li>把各个页面组织形成环形链表（类似钟表面），把指针指向最老的页面（最先进来）。</li><li>当发生一个缺页中断时，考察指针所指向的最老页面。若它的访问位为0，立即淘汰；若访问位为1，则把该位置为0，然后指针往下移动一格。如此下去，直到找到被淘汰的页面，然后把指针移动到它的下一格。</li></ul><p>二、具体实现</p><p><img src="/images/os-interview/66.png"></p><p>resident bit：存在位，代表是否存在。如果是1，代表在物理内存是存在的，表示映射的关系是正常的。如果是0，就不能正常的映射。<br>used bit：如果是1代表当前的页被访问过一次，硬件支持将其置为1。（这个位可以硬件自动的操作，同时也可以由软件操作）<br>frame number：页帧号<br>时钟页面置换算法的依据就是第二个位——used bit</p><p>三、示例</p><p><img src="/images/os-interview/67.png"></p><p>其中的置1操作是由硬件自动实现的。<br>替换的情况是产生缺页中断时候才会执行的。如果本来就有此内存，则指针是不需要向下移动寻找最老页面。也就是说如果存在，则指针保持不动，只需要置1操作既可。</p><h2 id="6-5-二次机会法"><a href="#6-5-二次机会法" class="headerlink" title="6.5. 二次机会法"></a>6.5. 二次机会法</h2><p>一、基础</p><p><img src="/images/os-interview/68.png"></p><p>resident bit：存在位，代表是否存在。如果是1，代表在物理内存是存在的，表示映射的关系是正常的。如果是0，就不能正常的映射<br>used bit：如果是1代表当前的页被访问过一次，硬件支持将其置为1。（这个位可以硬件自动的操作，同时也可以由软件操作）<br>dirty bit：如果执行了一个写操作，那么这个位会置为1；如果只是读操作，那么这个位是0。这个bit的设置也是由硬件来完成的。<br>当某一个运行的程序，对某一页进行访问之后。</p><p>如果是写操作，硬件会将used bit和dirty bit都置为1.<br>如果是读操作。硬件会将used bit置为1，而dirty bit还是0.<br>这个bit可以区分读和写，但是对我们的置换算法有什么帮助呢？<br>解析：</p><p>因为我们的算法是换入换出算法，所以如果当应用程序对内存进行读操作的时候，这个内存与磁盘的内容是一样的，所以只需要将其释放掉就可以了，不需要进行换入换出的操作。<br>而如果应用程序对内存进行了写操作的时候，这时表面与磁盘的内容不一样，替换的时候就需要把内容换入换出。<br>这时，两个bit都用上了，来减少硬盘的访问也就是减少写回操作的次数。</p><p><img src="/images/os-interview/69.png"></p><p>由于used=1，dirty=1的页会循环两次才会被替换出去，所以很形象生动的称之为二次机会法。<br>通过这种方式，可以把经常使用dirty bit的这个页有更多的机会留着内存中来。而不会被换到内存中去。对硬盘的访问次数也会减少。</p><p>二、示例<br>带有w表示对此页进行的是写操作而不是读操作，读操作是不带w<br>此时考虑两个位，used bit和dirty bit</p><p><img src="/images/os-interview/610.png"></p><p>比较接近LRU算法，优先的把只读的页换出去了，对于可写的页减少了换出去的概率，对于可以减少回写的概率。</p><h2 id="6-6-最不常用算法"><a href="#6-6-最不常用算法" class="headerlink" title="6.6. 最不常用算法"></a>6.6. 最不常用算法</h2><p>一、基础<br>最不常用算法（Least Frequently Used，LFU）<br>基本思路：<br>当一个缺页中断发生时，选着访问次数最少的那个页面，并淘汰之。被访问的次数也会很少。</p><p>实现方法：<br>对每个页面设置一个访问计数器，每当一个页面被访问时，该页面的访问计数器加1。每当反生缺页中断时，淘汰计数器最小的那个页面。</p><p>问题：<br>增加计数器会消耗硬件资源，会浪费空间，而选择次数最少的那个意味在要遍历整个链表，耗费时间，实现比较费时费力。而且当一个页面在进程开始的时使用得很多，但是以后就不再使用了，LFU还是会保留。（根据该点的解决方法：定时的把次数寄存器右移一位）</p><p>LRU和LFU的区别：<br>LRU考察的是多久未访问，时间越短越好；而LFU考察的是访问的次数或频度，访问次数越多越好。</p><p>二、示例</p><p><img src="/images/os-interview/611.png"></p><p>以上操作是将访问次数最多的替换出去。</p><h2 id="6-7-Belady现象、比较"><a href="#6-7-Belady现象、比较" class="headerlink" title="6.7. Belady现象、比较"></a>6.7. Belady现象、比较</h2><p>一、Belady现象<br>（Belady是一个科学家的名字，不必纠结）<br>定义：<br>在采用FIFO算法时，有时会出现分配的物理页面数增加，缺页率反而提高的异常现象。</p><p>Belady现象的原因：<br>FIFO算法的置换特征与进程访问内存的动态特征是矛盾的，与置换算法的目标是不一致的（既替换较少使用的页面），因此，被它替换出去的页面并不一定是进程不会访问的。</p><p>二、Belady现象示例<br>1、当分3个物理页的情况—出现9次中断缺失</p><p><img src="/images/os-interview/612.png"></p><p>2、当分4个物理页的情况—出现10次中断缺失</p><p><img src="/images/os-interview/613.png"></p><p>结果：<br>出现了物理页，给了更多的物理页，但是出现页缺失的情况更多</p><p>相比之下，LRU算法是符合预期情况的，给的硬件资源越多，产生中断页缺失的情况就会越少。</p><p><img src="/images/os-interview/614.png"></p><p>原因：<br>LRU算法满足某种栈的属性，而FIFO算法不满足某种栈的属性，所以会导致Belady现象。</p><p>三、LRU、FIFO、Clock的比较<br>1、性质的比较</p><p><img src="/images/os-interview/615.png"></p><p>2、性能的比较</p><p><img src="/images/os-interview/616.png"></p><h2 id="6-8-问题、工作集模型"><a href="#6-8-问题、工作集模型" class="headerlink" title="6.8. 问题、工作集模型"></a>6.8. 问题、工作集模型</h2><p>局部页面置换算法都是针对一个正在运行的程序来讲的，但是操作系统支持多个应用程序。</p><p><img src="/images/os-interview/617.png"></p><p>以上可见，只是仅仅增加了一个物理页帧，就对整个页面置换算法造成很大的效果影响。如果对一个程序固定一个物理页帧，其实是在某一个程度上限制了这个程序产生缺页的特点。因为其对物理内存的需求是动态可变的。<br>而前面所诉的前提是物理页帧是假设为固定的。这样就限制了灵活性。但是可以根据不同的运行阶段，动态分配调整物理页帧的大小，这点就是全局页面置换算法要考虑的问题。</p><p>一、工作集模型<br>前面介绍的各种页面置换算法都是基于一个前提的，既程序的局部性原理。</p><p>如果局部性原理不成立，那么各种页面置换算法就没有什么分别，也没有什么意义。例如：假设进程对逻辑页面的访问顺序是1,2,3,4,5,6,7,8,9…,即单调递增，那么在物理页面数有限的前提下，不管采用何种置换算法，每次的页面访问都必然导致缺页中断。<br>如果局部性原理是成立的，那么如何来证明它的存在，如何来对它进行定量地分析？这就是工作集模型。<br>1、工作集的定义：<br>一个进程当前正在使用的逻辑页面集合，可以用一个二元函数W(t，△)来表示。<br>二元函数W(t，△) 其中参数如下：</p><p><img src="/images/os-interview/618.png"></p><p>例子：</p><p><img src="/images/os-interview/619.png"></p><p>这表明t2具有良好的局部性，t1有一定的局部性，但是整体的局部性不如t2的效果好。</p><p>2、工作集大小的变化：<br>进程开始执行后，随着访问新页面逐步建立较稳定的工作集。当内存访问的局部性区域的位置大致稳定时，工作集带下也大致稳定；局部性区域的位置改变时，工作集快速扩张和收缩过渡到下一个稳定值。</p><p><img src="/images/os-interview/619.png"></p><p>二、常驻集模型<br>常驻集是指在当前时刻，进程实际驻留在内存当中的页面集合。</p><p>工作集是进程运行过程中固有的性质，而常驻集取决于系统分配给进程的物理页面数目（物理空间的大小），以及所采用的页面置换算法。来决定到底把哪些页面放在内存中来。<br>常驻集是当前运行的程序访问的页在哪些在内存中；而工作集指的是程序运行中所需要访问的页是哪些，这表示有些页是不在内存中的，只有部分页是在内存中的。<br>如果一个进程的整个工作集读在内存当中，既常驻集属于工作集，那么进程将很顺利地进行运行，而不会造成太多的缺页中断（直到工作集发生剧烈变动，从而过渡到另一个状态）。<br>当进程常驻集的大小达到某个数目之后，再给它分配更多的物理页面，缺页率也不会明显下降，可以给其他运行的程序，使总的缺页比较少。<br>6.9两个全局置换算法<br>一、工作集页置换算法<br>1、基本思想<br>有一个size，代表了其过去形成工作集的大小。窗口里面的页是当前时间内被访问到的页。随着时间的挪动平移，如果某一个不在这个时间的窗口之内，这个页也会被丢到，而并不是说要等到缺页的时候才会丢页。也就是这个页不属于这个窗口了，就会被替换。</p><p>2、示例</p><p><img src="/images/os-interview/620.png"></p><p>结果如下：<br>1—-edac—-abcd 6—-dbce—-bcde<br>2—-dacc—-acd 7—-bcec—-bce<br>3—-accd—-acd 8—-cece—-ce<br>4—-ccdb—-bcd 9—-ecea—-ace<br>5—-cdbc—-bcd 10—cead—-acde</p><p>分析：<br>并不是因为缺页而丢弃，而是因为不在这个窗口当中的所以老页都会被换出去。这样可以确保物理内存中有足够的页存在，可以减少页面置换降低，这个是站着整个系统层面上看的。</p><h2 id="6-9-缺页率页面置换算法"><a href="#6-9-缺页率页面置换算法" class="headerlink" title="6.9. 缺页率页面置换算法"></a>6.9. 缺页率页面置换算法</h2><p>1、可变分配策略：<br>常驻集大小可变。例如：每个进程在刚开始运行的时候，先根据程序大小给它分配一定数目的物理页面，然后在进程运行过程中，再动态地调整常驻集的大小。根据缺页率来改变，缺页率高，可以增加常驻集；缺页率降低，可以减小常驻集。<br>缺页率算法（PFF，page fault frequency）</p><p>2、缺页率<br>定义：<br>表示“缺页次数/内存访问次数”（比率）或“缺页的平均时间间隔的倒数”。</p><p>影响缺页率的因素：</p><p>页面置换算法<br>分配给进程的物理页面数目<br>页面本身的大小<br>程序的编写方法</p><p><img src="/images/os-interview/621.png"></p><p>使整个系统保持一个平衡，使所有的程序到保持一个较低的缺页率。</p><p>一个交替的工作集计算明确的试图最小化页缺失</p><p>当缺页率高的时候-增加工作集<br>当缺页率低的时候-减少工作集<br>3、算法的实现</p><p><img src="/images/os-interview/622.png"></p><p>4、示例</p><p><img src="/images/os-interview/623.png"></p><p>分析：<br>当前的阈值是2，也就是如果两次产生中断的时间大于2的话，话增加工作；而如果中断的时间小于等于2的话，就会动态的减少工作集。</p><p>在时间1时刻，产生一个缺失中断。<br>在时间4时刻，由于没有b，所以也产生了一次缺失中断。并且，由于1-4之间的时刻大于2，所以会动态的去除在这段时刻中没有读取的页，也是就是ae，所以此时只有bcd三个工作页。<br>在时间6时刻，由于没有e，产生了一次缺失中断。并且，由于4-6之间的时刻等于2，所以会动态的增加所需要的页。<br>在时间9时刻，由于没有页a，所以产生了一次缺失中断。并且，由于6-9之间的时刻大于2，所以也会动态的去除在这段时间中没有读取的页，也就是bd，因为这段时间只有ec的页需要操作，此时就只有ace三个工作页。<br>5、小结<br>这两个算法是根据工作集的大小动态的调整的，前面只是满的时候才调整，这个是他们之间的主要区别。所有对于操作系统而言，为了应对多个应用程序，采用全局的页面置换算法更加的合适。</p><h2 id="6-10-抖动问题"><a href="#6-10-抖动问题" class="headerlink" title="6.10. 抖动问题"></a>6.10. 抖动问题</h2><p>抖动问题是对工作集和常驻集做进一步的讲解。<br>1、抖动的定义<br>如果分配给一个进程的物理页面太少，不能包含整个的工作集，既常驻集属于工作集，那么进程将会造成很多的缺页中断，需要频繁地在内存与外存之间替换页面，从而使进程的运行速度变得很慢，将这种状态称为“抖动”。</p><p>2、产生抖动的原因<br>随着驻留内存的进程的数目增加，分配给每个进程的物理页面数不断减小，缺页率不断上升。所以操作系统要选择一个适当的进程数目和进程需要的帧数，以便在并发水平和缺页率之间达到一个平衡。</p><p>3、解决<br>当运行的程序过多时，cpu要执行多次的换入换出换出io操作，而导致程序没有执行，导致cpu的利用率降低，造成了电脑的卡顿。</p><p><img src="/images/os-interview/624.png"></p><p>蓝线的比值越大，表示缺页的频率很低，cpu利用率较高。（其中页缺失的服务时间是不变的）<br>当平均页缺失时间 = 页缺失服务时间 的时候，这时候的效率就接近最完美的点。</p><h1 id="7-进程"><a href="#7-进程" class="headerlink" title="7. 进程"></a>7. 进程</h1><h2 id="7-1-进程的定义"><a href="#7-1-进程的定义" class="headerlink" title="7.1. 进程的定义"></a>7.1. 进程的定义</h2><p>在某种程度上， 可以将应用程序看成是一个进程，其将会消耗耕种各样的计算机资源。</p><p>定义：<br>一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。</p><p>只有当操作系统把执行程序调入到我们的内存之后，让这个程序可以执行起来。（能够让通过cpu对这个程序执行一条条的指令，读取数据完成一定的功能）。也就是静态的执行程序，通过cpu变成一个动态的执行过程，而这个动态的执行过程就是进程。<br>整个的功能是由程序的代码决定的。</p><h2 id="7-2-进程的组成"><a href="#7-2-进程的组成" class="headerlink" title="7.2. 进程的组成"></a>7.2. 进程的组成</h2><p>1、一个进程应该包括</p><p>程序的代码<br>程序处理的数据<br>程序计数器中的值，指示下一条将运行的指令<br>一组通用的寄存器的当前值，堆，栈<br>一组系统资源（如打开的文件）<br>总之，进程包含了正在运行的一个程序的所以状态信息。</p><p>2、进程与程序的联系</p><p>程序是产生进程的基础<br>程序是静态的代码，代码限制了进程完成是什么样的功能<br>程序的每次运行构成不同的进程<br>程序多次运行过程中输入的数据不一样，产生的结果是不一样的，所以构成了不一样的进程<br>进程是程序功能的体现<br>尽管输出可能不同，但是这个程序的功能是一样的<br>通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序。<br>进程和程序之间是一个多对多的关系。<br>3、进程与程序的区别</p><p>进程是动态的，程序是静态的；程序是有序代码的集合；进程是程序的执行，进程有核心态/用户态。<br>进程是暂时的，程序是永久的；进程是一个状态变化的过程，程序可长久保存。<br>进程与程序的组成不同；进程的组成包括程序、数据和进程控制块（既进程状态信息）<br>一个很有趣进程与cpu的类比：</p><p><img src="/images/os-interview/71.png"></p><p>cpu在工作中会存在切换处理不同程序的</p><h2 id="7-3-进程的特点"><a href="#7-3-进程的特点" class="headerlink" title="7.3. 进程的特点"></a>7.3. 进程的特点</h2><p>动态性：可动态地创建，结束进程；<br>并发性：进程间可以被独立调度并占有处理机运行；（并发与并行的区别，前者是可以为1个cpu，后者必须要多个cpu）<br>独立性：不同进程的工作不互相影响，也就是进程不会破坏代码数据的正常执行。（页表的支持）<br>制约性：因访问共享数据/资源或进程间同步而产生制约</p><p><img src="/images/os-interview/72.png"></p><p>a–体现了动态性 / b–体现了独立性 / c–体现了制约性<br>描述进程的数据结构：进程控制块（Process Control Block，PCB）<br>操作系统为每一个进程都维护了一个PCB，用来保存与该进程有关的各种状态信息和需要资源的情况等等。</p><h2 id="7-4-进程控制结构"><a href="#7-4-进程控制结构" class="headerlink" title="7.4. 进程控制结构"></a>7.4. 进程控制结构</h2><p>1、进程控制块：操作系统管理控制进程运行所用的信息集合。</p><p>操作系统用PCB来描述进程的基本情况以及运行变化的过程，PCB是进程存在的唯一标志，如果进程消失了那么其对应的PCB也会消失，是一一对应的关系。<br>2、使用进程控制块</p><p>进程的创建：为该进程生产一个PCB；<br>进程的终止：回收它的PCB；<br>进程的组织管理：通过对PCB的组织管理来实现；<br>问题：PCB具体包含什么信息？如何组织的？进程的状态转换…?</p><p>3、PCB包含的信息</p><ul><li>进程标识信息。<br>如本进程的标识（进程号，执行的次数…），本进程的产生者标识（父进程标识）；用户标识。</li><li>处理机状态信息保存区<br>保存进程的运行现场信息：</li></ul><p>用户可见寄存器：用户程序可以使用的数据，地址等寄存器。<br>控制和状态寄存器：如程序计数器（PC），程序状态字（PSW）<br>栈指针：过程调用/系统调用/中断处理和返回时需要用到它。找到当前运行的位置。</p><ul><li>进程控制信息<br>操作系统需要对这个进程进行管理和控制调度和</li></ul><p>调度和状态信息：用于操作系统调度进程并占用处理机使用。<br>进程间通信信息：为支持进程间与通信相关的各种标识，信号，信件等。这些信息存在接受方的进程控制块中<br>存储管理信息：包含有指向本进程映射存储空间的数据结构。<br>进程所用资源：说明有进程打开、使用的系统资源，如打开的文件等。<br>有关数据结构连接信息：进程可以连接到一个进程队列中，或连接到相关的其他进程的PCB<br>4、PCB的组织方式</p><p><img src="/images/os-interview/73.png"></p><p>链表：同一状态的进程其PCB称一链表，多个状态对应多个不同的链表。各个状态的进程形成不同的链表：就绪链表，阻塞链表。<br>索引表：同一个状态的进程归入一个index表（由index指向PCB），多个状态对应多个不同的index表。各个状态的进行形成不同的索引表：就绪索引表、阻塞索引表<br>一般来说会采取链表，因为进程的控制是动态的插入和删除的，所以链表组织方式比较方便，而索引开销比较大。当然如果一开始就固定住了进程的数目，索引也不失为一个选择。</p><p>以上是围绕进程静态部分说明，组成，特点等等。<br>一下是围绕进程动态的状态特点说明，有3个方面的内容：</p><p>进程的生命周期管理<br>进程状态变化模型<br>进程挂起模型</p><h2 id="7-5-进程的生命期管理"><a href="#7-5-进程的生命期管理" class="headerlink" title="7.5. 进程的生命期管理"></a>7.5. 进程的生命期管理</h2><p>进程的生命是指进程的创建到结束这么一整个的生命期。<br>进程的生命期管理有以下几个时期：</p><p>进程创建<br>进程运行：正在占用cpu，执行这个进程<br>进程等待：由于某种特殊原因需要等待<br>进程唤醒：当等待的条件满足，需要唤醒<br>进程结束<br>1、进程创建<br>引起进程创建的3个主要事件：</p><ul><li>系统初始化时</li><li>用户请求创建一个新进程</li><li>正在运行的进程执行了创建进程的系统调用<br>但是创建了新的进程不一定可以执行。</li></ul><p>2、进程运行<br>内核选择一个就绪的进程，让它占用处理机并执行<br>就绪态—–&gt;执行态</p><p><img src="/images/os-interview/74.png"></p><p>其中涉及两个问题：</p><ul><li>为何选择？</li><li>如何选择？（涉及调度算法）</li></ul><p>3、进程等待<br>在以下情况下，进程等待（阻塞）:</p><p>请求并等待系统服务，无法马上完成</p><ul><li>启动某种操作，无法马上完成</li><li>需要的数据没有到达</li></ul><p><img src="/images/os-interview/75.png"></p><p>ps：进程等待事件的发起是有自己发起的。因为进程只能自己阻塞自己，因为只有进程自身才能知道何时需要等待某种事件的发生。<br>4、进程唤醒<br>唤醒进程的原因：</p><ul><li> 被阻塞进程需要的资源可被满足</li><li> 被阻塞进程等待的事件到达</li><li> 将该进程的PCB插入到就绪队列</li></ul><p><img src="/images/os-interview/76.png"></p><p>ps：进程只能被别的进程或者操作系统唤醒</p><p>5、进程结束<br>在以下四种情况下，进程结束</p><ul><li>正常退出（自愿的）</li><li>错误退出（自愿的）</li><li>致命错误（操作系统强制性的）</li><li>被其他进程所杀（强制性的）</li></ul><p><img src="/images/os-interview/77.png"></p><h2 id="7-6-进程状态变化模型"><a href="#7-6-进程状态变化模型" class="headerlink" title="7.6. 进程状态变化模型"></a>7.6. 进程状态变化模型</h2><p>1、进程的三种基本状态：<br>进程在生命结束前处于且仅处于三种基本状态之一，不同系统设置的进程状态数目不同。</p><ul><li>运行状态（Running）：当一个进程正在处理机上运行时。</li><li>就绪状态（Ready）：一个进程获得了除处理机之外的一切所需资源。一旦得到处理机即可运行。</li><li>等待状态（又称阻塞状态Blocked）：一个进程正在等待某一事件而暂停运行时。如等待某资源，等待输入/输出完成。</li></ul><p>2、三状态变化图：</p><p><img src="/images/os-interview/78.png"></p><p>进程其他的基本状态：</p><p>创建状态（New）：一个进程正在被创建，还没被转到就绪状态之前的状态。<br>结束状态（Exit）：一个进程正在从系统中消失时的状态，这是因为进程结束或由于其他原因所导致。<br>3、五状态变化图：</p><p><img src="/images/os-interview/79.png"></p><p>就绪态的出现是由于调度机制的存在。</p><p>4、可能的状态变化如下：</p><p>NULL-&gt;New: 一个新进程被产生出来执行一个程序。<br>New-&gt;Ready: 当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态。（不会持续很久，也就只是一个PCB的初始化。）<br>Ready-&gt;Running ：处于就绪状态的进程被进程调度程序选中后，就分配到处理机上来运行。<br>Running-&gt;Exit ：当进程表示它已经完成或出现错误，当前运行进程会有操作系统作结束处理。<br>Running-&gt;Ready ：处于运行状态的进程在其运行过程中，由于分配给它的处理机时间片用完而让出处理机。（操作系统完成）<br>Runing-&gt;Blocked ：当进程请求某样东西切必须等待时。（例如等待一个定时器的到达，读写文件，因为过程比较慢）<br>Blocked-&gt;Ready ：当进程要等待某事件到来时，它从阻塞状态变到就绪状态。（同样由操纵系统完成）</p><h2 id="7-7-进程的挂起"><a href="#7-7-进程的挂起" class="headerlink" title="7.7. 进程的挂起"></a>7.7. 进程的挂起</h2><p>进程挂起和进程阻塞的不一样的。<br>进程在挂起状态意味着进程没有占有内存空间。处于挂起状态的进程影像在磁盘上。</p><p>1、挂起状态</p><ul><li>阻塞挂起状态（Blocked-suspend）：进程在外存并等待某事件的出现；</li><li>就绪挂起状态（Ready-suspend）：进程在外存，但只要进入内存，即可运行。</li></ul><p>2、与挂起中相关的状态转换<br>挂起（Suspend）：把一个进程从内存转到外存；可能有以下几种情况：</p><ul><li>阻塞到阻塞挂起：没有进程处于就绪状态或就绪进程要求更多内存资源时，会进行这种转换，以提高新进程或运行就绪进程；</li><li>就绪到就绪挂起：当有高优先级阻塞（系统认为会很快就绪的）进程和低优先级就绪进程时，系统会选择挂起低优先级就绪进程；</li><li>运行到就绪挂起：对抢先式分时系统，当有高优先级阻塞挂起进程因事件出现（空间不够）而进入就绪挂起，系统可能会把运行进程转到就绪挂起状态。</li></ul><p>在外存时的状态转换：<br>阻塞挂起到就绪挂起：当有阻塞挂起进程相关事件出现时（也就是条件满足），系统会把阻塞挂起进程转换到就绪挂起进程。</p><p>解挂/激活（Activate）：把一个进程从外存转到内存；可能有以下几种情况：</p><ul><li>就绪挂起到就绪：没有就绪进程或挂起就绪进程优先级高于就绪进程时，会进行这种转换。</li><li>阻塞挂起到阻塞：当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起（系统认为会很快出现所等待的事件）进程转换为阻塞进程。</li></ul><p>问题：操作系统怎么通过PCB的定义的进程状态来管理PCB，帮助完成进程的调度过程？</p><p><img src="/images/os-interview/710.png"></p><p>以进程为基本结构的os，选择某一个进程变成某一种状态都是有操作系统来完成的。最底层为CPU调度程序（包括中断处理等）。上面一层为一组各式各样的进程。</p><p>3、状态队列<br>状态队列是操作系统管理进程的一个很重要的数据结构</p><ul><li>由操作系统来维护一组队列，用来表示系统当中所以进程的当前状态；</li><li>不同的状态分别用不同的队列来表示（就绪队列，各种类型的阻塞队列）；</li><li>每个进程的PCB都根据它的状态加入到相应的队列当中，当一个进程的状态发生变化时，它的PCB从一个状态队列中脱离出来，加入到另外一个队列。</li></ul><p>4、状态表示方法</p><p><img src="/images/os-interview/711.png"></p><p>要注意，如果事件1只能满足一个进程，那么只能把这一个进程从阻塞态变成就绪态。如果事件1产生之后，所以等待事件1的进程都等到满足，那么这些进程都会挂到就绪队列里面去。</p><p>线程管理：<br>很久之前，操作系统一直以进程作为独立运行的基本单位，直到80年代中期，人们有提出了更小独立运行的基本单位—线程。</p><ul><li>为什么使用线程？</li><li>什么是线程</li><li>线程的实现</li><li>多线程编程接口举例</li></ul><h2 id="7-8-为什么使用线程"><a href="#7-8-为什么使用线程" class="headerlink" title="7.8. 为什么使用线程"></a>7.8. 为什么使用线程</h2><p>例子：</p><p><img src="/images/os-interview/712.png"></p><p>1、单进程的实现方法</p><p><img src="/images/os-interview/713.png"></p><p>可能出现的问题：</p><ul><li>播放出来的声音能否连续？</li><li>各个函数之间不是并发执行，影响资源的使用效率。</li></ul><p>2、多进程的实现方法</p><p><img src="/images/os-interview/714.png"></p><p>可能出现的问题：</p><ul><li>进程之前如何通信，共享数据？</li><li>维护进程的系统开销比较大：<br>创建进程时，分配资源，建立PCB；撤销进程时，回收资源，撤销PCB；进程切换时，保存当前进程的状态信息。</li></ul><p>根据以上问题，提出一个新的实体，满足一下特性：</p><ul><li>实体之间可以并发地执行；</li><li>实体之间共享相同的地址空间；</li></ul><p>这个实体就是：线程（Thread）</p><h2 id="7-9-什么是线程"><a href="#7-9-什么是线程" class="headerlink" title="7.9. 什么是线程"></a>7.9. 什么是线程</h2><p>1、定义：进程当中的一条执行流程</p><p>2、从两个方面来重新理解进程</p><ul><li>从资源组合的角度：<br>进程把一组相关的资源组合起来，构成了一个资源平台（环境），包括地址空间（代码段，数据段）、打开的文件等各种资源；</li><li>从运行的角度：<br>代码在这个资源平台上的一条执行流程（线程）。</li></ul><p><img src="/images/os-interview/715.png"></p><p>ps：进程中的堆，代码段，数据段是线程所共享的内容。而各自又有独特的内容，比如所堆栈，程序计数器，寄存器（不同的执行留和控制流）。所以其有独立拥有的部分，也有公有的部分。</p><p>3、线程 = 进程 - 共享资源<br>线程的优点：</p><ul><li>一个进程中可以同时存在多个线程</li><li>各个线程之间可以并发地执行</li><li>各个线程之间可以共享地址空间和文件等资源</li></ul><p>线程的缺点：<br>一个线程奔溃，会导致其所属进程的所以线程奔溃，安全没有一定的保障。</p><p>4、不同操作系统对线程的支持</p><p><img src="/images/os-interview/716.png"></p><p>5、线程所需的资源</p><p><img src="/images/os-interview/717.png"></p><p>6、线程与进程的比较</p><ul><li>进程是资源分配单位，线程是CPU调度；</li><li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；</li><li>线程同样具有就绪、阻塞和执行三种基本状态，同样具有状态之间的转换关系；</li><li>线程能减少并发执行的时间和空间开销；</li></ul><p>线程的创建时间比进程短；<br>线程的终止时间比进程短；<br>同一进程内的线程切换时间比进程短；<br>由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信。<br>（切换进程的时候，需要把页表也切换掉，切换页表的开销比较大，因为硬件的信息无效，需要重新加载）</p><h2 id="7-10-线程的实现"><a href="#7-10-线程的实现" class="headerlink" title="7.10. 线程的实现"></a>7.10. 线程的实现</h2><p>主要有三种线程的实现方式：</p><ul><li>用户线程：在用户空间实现；</li><li>内核线程：在内核中实现；</li><li>轻量级进程：在内核汇总实现，支持用户线程</li></ul><p>用户线程：操作系统看不到的线程称为用户线程<br>内核线程：操作系统管理起来（能够看见）的线程称为内核线程</p><p>1、用户线程与内核线程的对应关系</p><ul><li>多对一</li></ul><p><img src="/images/os-interview/718.png"></p><ul><li>一对一</li></ul><p><img src="/images/os-interview/719.png"></p><ul><li>多对多</li></ul><p><img src="/images/os-interview/720.png"></p><p>2、用户进程</p><p><img src="/images/os-interview/721.png"></p><p>线程控制块（TCB）是在库里面实现的，对于操作系统而言，其看不见TCB，只能看见进程的信息，但是进程里面的线程信息，是有线程管理的库来实现的。<br>在用户空间实现的线程机制，它不依赖与操作系统的内核，由一组用户级的线程库函数来完成线程的管理，包括进程的创建，终止，同步和调度等。</p><p>由于用户线程的维护由相应进程来完成（通过线程库函数），不需要操作系统内核了解用户线程的存在，可用于不支持线程技术的多进程操作系统；<br>每个进程都需要它自己私有的线程控制块（TCB）列表，用来跟踪记录它的各个线程的状态信息（PC，栈指针，寄存器），TCB由线程库函数来维护；<br>用户线程的切换也是由线程库函数来完成，无需用户态/核心态切换，所以速度特别快；<br>允许每个进程拥有自定义的线程调度算法。<br>否则如果进程被操作系统调度为阻塞态，则其下的所有线程都无法允许。</p><p>用户线程的缺点：</p><ul><li>阻塞性的系统调用如何实现？如果一个线程发起系统调用而阻塞，则整个进程在等待。因为操作系统只能看见进程，所以这个进程阻塞，旗下所以的线程都会阻塞。</li><li>当一个线程开始执行后，除非它主动地交出CPU的使用权，否则它所在的进程当中的其他线程将无法运行。</li><li>由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会较慢。</li></ul><p>3、内核线程<br>（操作系统看得见，TCB是放在内核里面的）</p><p><img src="/images/os-interview/722.png"></p><p>内核线程是指在操作系统的内核当中实现的一种线程机制，由操作系统的内核来完成线程的创建，终止和管理。</p><p>在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息（PCB和TCB）；<br>线程的创建，终止和切换都是通过系统调用/内核函数的方式来进行，由内核来完成，因此系统开销较大；<br>在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不影响其他内核线程的运行；<br>时间片分配给线程，多线程的进程获得更多的cpu时间；<br>Windows NT和Windows 200/XP支持内核线程<br>4、轻量级进程（LightWeight Process）<br>它是内核支持的用户线程，一个进程可有一个或多个轻量级进程，每个轻量级进程有一个单独的内核线程来支持，（Solaris/Linux）</p><p><img src="/images/os-interview/723.png"></p><h2 id="7-11-上下文切换"><a href="#7-11-上下文切换" class="headerlink" title="7.11. 上下文切换"></a>7.11. 上下文切换</h2><p>1、定义：停止当前运行的进程（从运行状态改变成其他状态）并且调度其他进程（转变成运行状态的）的过程，称为进程的上下文切换（Compress）</p><p>必须在切换之前存储许多部分的进程上下文<br>必须能够在之后恢复他们，所以进程不能显示它曾经被暂停过<br>必须快速（上下文准换是非常频繁的）<br>进程的上下文切换所具体切换的进程所用到的寄存器，使用要关注cpu有哪些寄存器（PC程序计数器，SP堆栈指针）。而在做进程切换的时候，需要将这新信息保存到进程控制块的某一个地方上。</p><p>2、切换的过程</p><p><img src="/images/os-interview/724.png"></p><p>所用的信息都是和硬件紧密相连的，所用一般是使用汇编代码来完成编写。</p><p>操作系统为活跃进程准备了进程控制块（PCB）<br>操作系统将进程控制块（PCB）放置在一个合适的队列里</p><p>就绪队列<br>等待I/O队列（每个设备的队列）<br>僵尸队列</p><p><img src="/images/os-interview/725.png"></p><h2 id="7-12-进程控制—创建进程"><a href="#7-12-进程控制—创建进程" class="headerlink" title="7.12. 进程控制—创建进程"></a>7.12. 进程控制—创建进程</h2><p>window系统下：</p><p><img src="/images/os-interview/726.png"></p><p>linux系统下：</p><p><img src="/images/os-interview/727.png"></p><p>fork（）创建一个继承的子进程</p><p>复制父进程的所有变量和内存<br>复制父进程的所以CPU寄存器（有一个寄存器除外）<br>fork（）的返回值</p><p>子进程的fork()返回0<br>父进程的fork()返回子进程标识符<br>fork()返回值可方便后续使用，子进程可使用getpid()获取PID<br>父子进程的主要区别—-childPID不一样：</p><p><img src="/images/os-interview/728.png"></p><h2 id="7-13-进程控制—加载和执行过程"><a href="#7-13-进程控制—加载和执行过程" class="headerlink" title="7.13. 进程控制—加载和执行过程"></a>7.13. 进程控制—加载和执行过程</h2><p>系统调用exec()加载程序取代当前运行的进程</p><p><img src="/images/os-interview/79.png"></p><p>其中：<br>exec是准备执行一个新的程序，所以当成功的执行了exec之后，后面的printf函数是不会执行到的。<br>wait(pid); wait返回了，表示子进程就结束了。</p><p>当执行exec的时候，代码数据都复制了一份，但是PID没有变化。但是执行的代码改变了，也就是另外程序的执行过程，如下所示。</p><p><img src="/images/os-interview/730.png"></p><p>执行exec之后，程序的整个控制流会放生完全的变化</p><p><img src="/images/os-interview/731.png"></p><ul><li>exec()调用允许一个进程“加载”一个不同的程序并且在main开始执行(事实上_start，系统调用)</li><li>它允许1一个进程指定参数的数量(argc)和它字符串参数数组(argv)</li><li>代码段，数据段，stack（栈）&amp;heap（堆）都会被覆盖</li></ul><p>fork()的简单实现</p><p>对子进程分配内存<br>复制父进程的内存和CPU寄存器到子进程里<br>在99%的情况里，我们在调用fork()之后调用exec()</p><p>在fork()操作中内存复制是没有作业的<br>子进程将可能关闭打开的文件和链接<br>对于此情况需要一个优化：<br>vfork(),vfork只是复制了一小部分的进程的内容，绝大多数的内容都没有被复制。但是这会使系统调用变成两个fork，增加了编程人员的开销。</p><p>另一个优化：<br>通过虚存管理科员实现一个高效的fork实现机制。也就是（Copy on Write，COW）技术，就是写的时候再进行复制。<br>当父进程创建子进程的时候，如果采用COW技术时，我们在做实际的子进程地址空间复制的时候并没有真是的复制，只是复制了父进程所需要的元数据—页表等等，实现按需写的情况来复制不同的页。</p><h2 id="7-14-进程控制—等待和终止进程"><a href="#7-14-进程控制—等待和终止进程" class="headerlink" title="7.14. 进程控制—等待和终止进程"></a>7.14. 进程控制—等待和终止进程</h2><p>wait()系统调用是被父进程用来等待子进程的结束</p><p>父进程先与子进程死亡—子进程为孤儿进程<br>子进程已经死亡，但父进程还没来得及回收—子进程为僵尸进程<br>状态转换图：</p><p><img src="/images/os-interview/732.png"></p><p>ps：执行exec的时候，程序有可能会处于不同的状态。<br>因为在执行exec有两个步骤，一个是加载执行程序，二个是运行执行程序。加载的时候，所需要的时间比较长，所以会处于阻塞状态。</p><h1 id="8-处理器调度"><a href="#8-处理器调度" class="headerlink" title="8. 处理器调度"></a>8. 处理器调度</h1><h2 id="8-1-背景"><a href="#8-1-背景" class="headerlink" title="8.1. 背景"></a>8.1. 背景</h2><p>1、上下文切换：</p><p>切换CPU的当前任务，从一个进程/线程到另一个<br>保存当前进程/线程在PCB/TCP中的执行上下文（CPU状态）<br>读取下一个进程/线程的上下文<br>2、CPU调度<br>从就绪队列中挑选一个进程/线程作为CPU将要运行的下一个进程/线程<br>调度程序：挑选进程/线程的内核函数（通过一些调度策略）<br>什么时候进程调度？调度算法实现</p><p>问题：在进程/线程的生命周期中的什么时候进行调度？</p><p><img src="/images/os-interview/80.png"></p><p>3、内核运行调度程序的条件（满足一条即可）</p><ul><li>一个进程从运行状态切换到等待状态</li><li>一个进程被终结了</li></ul><p>4、是否可以抢占<br>不可抢占：</p><p>调度程序必须等待事情结束<br>可以抢占：（常用，针对用户态的）</p><p>调度程序在中断被响应后执行<br>当前的进程从运行切换到就绪，或者一个进程从等待切换到就绪<br>当前运行的进程可以被换出<br>抢占使得系统程序更加的灵活和高效。</p><h2 id="8-2-调度原则"><a href="#8-2-调度原则" class="headerlink" title="8.2. 调度原则"></a>8.2. 调度原则</h2><p>根据什么原则去选择一个进程去执行，这个就是调度的原则<br>1、执行模型<br>程序在CPU突发和I/O中交替</p><p>每个调度决定都是关于在下一个CPU突发时将哪个动作交给CPU<br>在时间分片机制下，线程可能在结束当前CPU突发前被迫放弃CPU<br>2、评价的指标</p><ul><li>CPU利用率：CPU处于忙碌状态所占时间的百分比</li></ul><p>cpu利用率越高，可以认为当前系统的效率比较好。进程调度进行得好。</p><ul><li>吞吐量：在单位时间内完成的进程数量</li></ul><p>吞吐量越高，说明进程的效率越好。当然希望当操作系统跑一堆进程时，吞吐率都很高。</p><ul><li>周转时间：一个进程从初始化到结束，包括所有等待时间所花费的时间。</li></ul><p>周转时间越断越好。</p><ul><li>等待时间：进程在就绪队列中的总时间</li></ul><p>指的是出于就绪态的时间越短，就越快被cpu执行</p><ul><li>响应时间：从一个请求被提交到产生第一次响应所花费的总时间</li></ul><p>同样也是越短越好<br>以上可以对cpu调度的指标有一个分析。</p><p>人们通常都需要“更快”的服务<br>什么是更快：</p><p>传输文件时的高带宽<br>玩游戏时的低延迟<br>这两个因素是独立的<br>和水管类比：</p><p>低延迟：喝水的时候想要一代开水龙头水就流出来<br>高带宽：给游泳池充水时希望从水龙头里同时流出大量的水，并且不介意是否存在延迟<br>3、算法需达到的效果</p><ul><li>减少响应时间<br>及时处理用户的输出并且尽快将输出提供给用户</li><li>减少平均响应时间的波动<br>在交互系统中，可虞可预测性比高差异低平均更重要</li><li>增加吞吐量–两个方面<br>减少开销（操作系统开销，上下文切换）<br>系统资源的高效利用（CPU,I/O设备）</li><li>减少等待时间<br>减少每个进程的等待时间</li></ul><p>其实很难满足以上的全部效果，只能泽中或者在特定场合中选择某种特定效果。</p><p>4、公平性<br>公平的定义：</p><p>保证每个进程都占用相同的cpu时间<br>保证每个进程都等待相同的时间<br>公平通常会增加平均响应时间</p><h2 id="8-3-调度算法"><a href="#8-3-调度算法" class="headerlink" title="8.3. 调度算法"></a>8.3. 调度算法</h2><p>调度算法有三类：</p><ul><li>通常操作系统设计的基本调度算法</li><li>嵌入式设备实时的调度算法</li><li>针对多处理器的调度算法与考虑</li></ul><p>一、常用系统的调用算法</p><p>FCFS （先来先服务） （First Come， First Served）<br>SPN（SJF）SRT (短进程优先（短作业优先）剩余时间优先) Shortest Process Next(Shortest Job<br>First) Shortest Remaining Time<br>HRRN (最高响应比优先) Highest Response Ratio Next<br>Round Robin （轮循） 使用时间切片和抢占来轮流执行任务<br>Multilevel Feedback Queues （多级反馈队列） 优先级队列中的轮循<br>Fair Share Scheduling （公平共享调度）<br>二、先来先服务调度（FCFS）</p><p><img src="/images/os-interview/81.png"></p><p>如图所示，如果前面的进程越长，后面的进程等待的时间就越长，从而会影响整个系统的周转时间。</p><p>优点：<br>简单</p><p>缺点：</p><ul><li>平均等待时间波动较大，平均的周转时间也会比较大</li><li>花费时间少的任务可能排在花费时间长的任务后面，没有考虑抢占</li><li>可能导致I/O和CPU之间的重叠处理（cpu密集型进程会导致I/O设备闲置时，I/O密集型进程也在等待）</li></ul><p>三、短任务优先算法</p><p><img src="/images/os-interview/82.png"></p><p>当一个更短时间进程来了之后，有两种策略：</p><ul><li>不理，将这个时间更短的程序排在前面，但是继续执行本来在执行的进程，这种是非抢占性的。（SPN）</li><li>将这个时间更短的程序与正在执行的程序剩余所需要执行的时间进行比较，如果跟多，这打断正在执行的程序，这种是可抢占的。（SRT）</li></ul><p>优点：<br>平均等待时间最短</p><p><img src="/images/os-interview/83.png"></p><p>缺点：</p><ul><li>可能导致饥饿</li></ul><p>连续的短任务流会使长任务饥饿<br>短时间可用时的任何长任务的CPU时间都会增加平均等待时间</p><ul><li>需要预知未来</li></ul><p>怎么预估下一个CPU突发的持续时间<br>简单的解决方法：询问用户<br>如果用户欺骗就杀死进程<br>如果用户不知道就采用预估方法<br>根据过去，预测未来，大致的预测方法如下：</p><p><img src="/images/os-interview/84.png"></p><p>结果大致的相同</p><p><img src="/images/os-interview/85.png"></p><p>四、最高响应比优先算法<br>在SPN调度的基础上改进</p><p><img src="/images/os-interview/86.png"></p><p>R值越高表示等待的时间越长，就会优先的调度这种进程。</p><p>优点：<br>充分的考虑到了进程的等待时间，所有之前的饥饿现象会得到有效的化解。</p><p>缺点：</p><ul><li>不可抢占</li><li>依然需要知道执行的时间是多长，所以还是要预估</li></ul><p>五、轮循算法<br>各个cpu轮流占用cpu去执行，在叫做量子(或时间切片)的离散单元中分配处理器，时间片结束后，切换到下一个准备好的进程。</p><p><img src="/images/os-interview/87.png"></p><p>每一个进程都有机会去被cpu执行</p><p>例子：</p><p><img src="/images/os-interview/88.png"></p><p>可见，轮流算法的平均等待时间是比较大的。</p><p>特点：</p><ul><li>会比较到的切换时间，进程上下文的切换，确保公平</li><li>时间片太大（有可能退化为先来先服务）</li></ul><p>等待时间过长<br>极限情况退化成FCFS</p><ul><li>时间片太小（切换过于频繁）</li></ul><p>吞吐量由于大量的上下文切换开销收到影响<br>目标：</p><p>选择一个合适的时间量子<br>经验规则：维持上下文切换开销处于1%以内，这样的情况下99%的时间都是在<br>进程的执行过程中</p><p>与先来先服务算法 进行比较：</p><p><img src="/images/os-interview/89.png"></p><p>六、多级反馈队列<br>首先完成高优先级的进程，待其完成了所以的任务之后，再去完成第优先级的进程，这样通过分层不同级别的队列，可以实现调度的区分，使得调度的策略更加的合适。<br>而且进程在不同阶段的特点是不同的，所以调度算法可以考虑到进程各阶段的特点来调整其在队列中的级别。这个就是多级反馈队列可以体现。</p><p><img src="/images/os-interview/810.png"></p><p>特点：</p><ul><li>时间量子大小随优先级级别增加而增加</li><li>如果任务在当前的时间量子中没有完成，则降到下一个优先级</li><li>能够区分进程在动态执行过程中动态的调整进程优先级，使得IO密集型的任务可以很快的执行，而CPU密集型的任务放在优先级较低位置。</li></ul><p><img src="/images/os-interview/811.png"></p><p>七、公平共享调度<br>FFS控制用户对系统资源的访问</p><p>一些用户组比其他组更重要<br>保证不重要的组无法垄断资源<br>未使用的资源按照每个组所分配的资源比例来分配<br>没有达到资源使用率目标的组获得更高的优先级</p><p>八、小结</p><ul><li>FCFS先来先服务</li></ul><p>不公平，平均等待时间较差</p><ul><li>SPN/SRT段进程优先</li></ul><p>不公平，但是平均等待时间最小<br>需要精确预测计算时间<br>可能导致饥饿</p><ul><li>HRRN最好响应比优先</li></ul><p>基于SPN调度改进（考虑了等待时间）<br>不可抢占</p><ul><li>Round Robin轮循</li></ul><p>公平，但是平均等待时间较差<br>每一个进程有固定的时间片，但是上下文开销较大</p><ul><li>MLFQ舵机反馈对列</li></ul><p>和SPN类似<br>动态调整进程优先级</p><ul><li>公平共享调度</li></ul><p>公平是第一要素</p><h2 id="8-4-实时调度"><a href="#8-4-实时调度" class="headerlink" title="8.4. 实时调度"></a>8.4. 实时调度</h2><p>面向的是实时的系统，更多的是工业控制（火车，机床等等）<br>1、定义<br>正确性依赖于其时间和功能两个方面的一种操作系统</p><p>2、性能指标</p><ul><li>时间约束的及时性（deadlines）</li><li>速度和平均性能相对不重要</li></ul><p>3、主要特征<br>时间约束的可预测性</p><p>4、分类</p><ul><li>强实时系统<br>需要在保证的时间内完成重要的任务，必须完成</li><li>弱实时系统<br>要求重要的进程的优先级更高，尽量完成，并非必须</li></ul><p><img src="/images/os-interview/812.png"></p><p>Released ：让进程处于就绪态的时间<br>Execution time：执行时间<br>Absolute deadline：绝对的截止时间，任务的执行不可以操作这个时间<br>Relative deadline：相对截止时间，因为任务是间隔的，一段时间完成一个任务</p><p><img src="/images/os-interview/813.png"></p><p>（周期是5，执行的时间就是蓝色的区域）</p><p>5、特点<br>硬时限：</p><p>如果错过了最后的期限，可能会发生灾难性或非常严重的后果<br>必须验证：在最坏的情况下也能够满足时限<br>保证确定性<br>软时限：</p><p>理想情况下，时限应该被最大满足。如果有时限没有被满足，那么就相应地降低要求<br>尽量大努力去保证<br>表示一个实时系统是否能够满足deadline要求</p><p>决定实时任务执行的顺序<br>静态优先级调度<br>动态优先级调度<br>6、实时系统中的两类调度算法：</p><ul><li>RM（Rate Monotonic）速率单调调度</li></ul><p>最接静态优先级调度<br>通过周期安排优先级<br>周期越短优先级越高<br>执行周期最短的任务</p><ul><li>EDF（Earliest Deadline First）最早期限调度</li></ul><p>最佳的动态优先级调度<br>Deadline越早优先级越高<br>执行Deadline最早的任务<br>8.5多处理器调度与优先级反转<br>一、多处理器调度<br>1、多处理器的cpu调度更加复杂</p><p>多个相同的单处理器组成一个多处理器<br>负载平衡状态<br>2、对称多处理器（SMP）</p><p>每个处理器运行自己的调度程序<br>需要在调度程序中同步</p><p><img src="/images/os-interview/814.png"></p><p>二、优先级反转<br>出现的原因：<br>T1的执行时间受制于T2的执行时间，因为T2抢占了T3的cpu时间去执行，而T1的执行有必须等待T3处理完共享内容，所以T1的执行时间被T2延长了。从而导致T1不能及时的完成其任务，导致系统处于不稳定状态而重启。</p><p><img src="/images/os-interview/815.png"></p><p>特点：<br>可以发生在任何基于优先级的可抢占的调度机制中。<br>当系统内的环境强制性使高优先级任务等待低优先级任务时发生。</p><p>解决方法：<br>1、优先级继承（将问题发生时，提升T3的优先级）<br>低优先级继承高优先级任务的优先级依赖于他们共享的资源</p><p><img src="/images/os-interview/816.png"></p><p>2、天花板优先级</p><ul><li>“资源”的优先级和“所有可以锁定该资源的任务中优先级最高的那个任务”的优先级相同。</li><li>除非优先级高于系统中所有被锁定的资源的优先级上限，否则任务尝试执行临界区的时候会被阻塞</li><li>持有最高优先级上限信号量锁的任务，会继承被该锁所阻塞的任务的优先级</li></ul><h1 id="9-同步互斥问题"><a href="#9-同步互斥问题" class="headerlink" title="9. 同步互斥问题"></a>9. 同步互斥问题</h1><h2 id="9-1-背景知识"><a href="#9-1-背景知识" class="headerlink" title="9.1. 背景知识"></a>9.1. 背景知识</h2><p>1、如果资源处理不当，可能会出现一些意想不到的情况，合作的风险<br>独立的线程：</p><p>不和其他线程共享资源或状态<br>确定性-&gt;输入状态决定结果<br>可重现-&gt;能够重现起始条件<br>调度顺序不重要<br>合作线程：</p><p>在多喝线程中共享状态<br>不确定性<br>不可重现（不可重复性）<br>这些不确定性和不可重复以意味着bug可能是间歇性发生的，也就是合作是有风险的。</p><p>2、为什么要合作</p><ul><li>共享资源<br>资源是需要共享的，因为进程可能要访问同一个文件。</li><li>加速<br>通过并行和并发，可以提高系统的效率，实现更有效的资源的利用。相当于把一个大的任务，拆分成多个小的任务，每个任务通过并行的执行提高系统的性能。</li><li>模块化<br>在设计时将一个大的工作，变成一个小的工作，使之具有模块化，使系统便于扩展。</li></ul><p>3、问题出现的原因<br>例子：</p><p><img src="/images/os-interview/91.png"></p><p>以上四条汇编指令的意思是：</p><ul><li>把next_pid赋值给寄存器1（Reg1）</li><li>再把这个寄存器1存到了new_pid这个内存单元的去。此时new_pid就具有了next_pid这个值。</li><li>寄存器1加一操作。</li><li>完成next_pid的值增加了一个1的操作。<br>总的实现过程：<br>先把new_pid = next_pid，然后next_pid再加1.</li></ul><p>但是，如果这时有两个进程，就会出现意想不到的情况：</p><p><img src="/images/os-interview/92.png"></p><p>问题产生的原因：<br>在第二次进程的上下文切换时候，进程1的寄存器恢复之后依然100的值，是的next的值无法更新称为102。最终产生了切换使得最终的结果不是想要的结果。这是一种典型的异常现象。</p><h2 id="9-2-一些概念part1"><a href="#9-2-一些概念part1" class="headerlink" title="9.2. 一些概念part1"></a>9.2. 一些概念part1</h2><p>由于上述产生的异常现象（称之为竞态条件Race Condition），这就是为什么要引入同步互斥这些机制的原因，就是要解决这种不确定性的问题。</p><p>1、系统缺陷：结果依赖于并发执行或者事件的顺序/时间<br>不确定性<br>不可重现</p><p>2、怎样避免竞态？<br>让指令不被打断（比如上述的四条机器指令不被打断）</p><p>3、不被打断的方法：原子操作（Atomic Operation）—不可被打断操作<br>原子操作是指一次不存在任何中断或者失败的执行</p><p>该执行成功结束<br>或者根本没有执行<br>并且不应该发现任何部分执行的状态<br>实际上操作往往不是原子的</p><p>有些看上去是原子操作，实际不是<br>连x++这样简单的语句，实际上是由3条指令造成的<br>有时候甚至连条单条机器指令都不是原子的<br>例子：</p><p><img src="/images/os-interview/93.png"></p><p>所以需要后续的同步机制，确保或者是A赢或者是B赢。</p><p>4、一些基本概念</p><p>临界区（Critical section）<br>临界区是指进程中的一段需要访问共享资源并且当另一个进程处于相应代码区域时便不会被执行的代码区域。简单来说，就是访问共享资源的那段代码就是临界区。</p><p>互斥（Mutual exclusion）<br>当一个进程处于临界区并访问共享资源时，没有其他进程会处于临界区并且访问任何相同的共享资源。</p><p>死锁（Dead lock）<br>两个或以上的进程，在互相等待完成特定任务，而最终没法将自身任务进行下去。</p><p>饥饿（Starvation）<br>一个可执行的进程，被调度器持续忽略，以至于虽然处于可执行状态却不被执行</p><h2 id="9-3-一些概念part2"><a href="#9-3-一些概念part2" class="headerlink" title="9.3. 一些概念part2"></a>9.3. 一些概念part2</h2><p>1、一个有趣的类比：</p><p><img src="/images/os-interview/94.png"></p><p>2、解决的方法和概念</p><p><img src="/images/os-interview/95.png"></p><p>3、更好的解决方法（轻量级）</p><p><img src="/images/os-interview/96.png"></p><p>但是由于进程上下文切换的原因，问题还是会存在。</p><p><img src="/images/os-interview/97.png"></p><p>如果只是将Note往前面提简单的挪动一下还是不会解决问题，变成谁都不会去买面包了。</p><p><img src="/images/os-interview/98.png"></p><h2 id="9-4-一些概念part3"><a href="#9-4-一些概念part3" class="headerlink" title="9.4. 一些概念part3"></a>9.4. 一些概念part3</h2><p>1、再换一个方法</p><p><img src="/images/os-interview/99.png"></p><p>结果还是有问题的。</p><p><img src="/images/os-interview/910.png"></p><p>需要确保在任何情况下，只有一个进程在临界区中执行，其他的进程需要在外面等待。</p><p>一个更加合理的方案解析过程：</p><p><img src="/images/os-interview/911.png"></p><p><img src="/images/os-interview/912.png"></p><p><img src="/images/os-interview/913.png"></p><p>程序是有效的，但是导致代码不一样了。</p><p>最终的解决方案：<br>为每一个线程保护了一段“临界区”代码。使用临界区的思想，问题就可以较好的解决。其是讲前诉方法的一个抽象。<br>有了临界区的代码之后，就可以确保任何时候只有一个进程在临界区中执行，切其他进程在外面等待，知道临界区中的进程离开，其他进程中的一个会进入临界区去执行。这个是比较合理的一个实现。</p><h2 id="9-5-临界区"><a href="#9-5-临界区" class="headerlink" title="9.5. 临界区"></a>9.5. 临界区</h2><p>在临界区中执行所拥有的属性：<br>1、互斥：同一个时间临界区中最多存在一个线程<br>2、前进（Progress）：如果一个线程想要进入临界区，那么它最终会成功，不会一直的死等。<br>3、有限等待：如果一个线程i处于入口区，那么在i的请求被接受之前，其他线程进入临界区的时间是有限制的。如果是无限等待，就会出现饥饿状态，是Progress前进状态的一种进一步补充。<br>4、忙等（可选属性）：如果一个进程在等待进入临界区，那么在它可以进入之前会被挂起。</p><p>基于这些属性，设计一些方法对临界区进行保护：<br>方法一：禁用硬件中断<br>方法二：基于软件的解决方法<br>方法三：更高级的抽象（基于硬件原子操作的指令）</p><h2 id="9-6-禁用硬件中断"><a href="#9-6-禁用硬件中断" class="headerlink" title="9.6. 禁用硬件中断"></a>9.6. 禁用硬件中断</h2><p>一、基本实现<br>没有中断，也就是没有了上下文切换，因此没有并发。</p><p>硬件将中断处理延迟到中断被启用之后<br>大多数现代计算机体系结构都提供指令来完成<br>进入临界区时禁用中断，离开临界区时开启中断。这个方法是可以解决问题的。</p><p>二、缺点<br>1、一旦中断被禁用，线程就无法被停止</p><ul><li>整个系统都会为你停下来</li><li>可能导致其他线程处于饥饿状态</li></ul><p>2、要是临界区可以任意长<br>无法限制响应中断所需的时间（可能存在硬件影响）</p><p>需要注意：<br>执行这种课屏蔽中断的指令，只是把自身的响应中断的能力屏蔽了，并不意味着也将其他cpu的响应中断能力屏蔽，所以其实其他的cpu还是可以继续产生中断，所以在多cpu的情况下是无法解决互斥问题的。</p><h2 id="9-7-基于软件的解决方案"><a href="#9-7-基于软件的解决方案" class="headerlink" title="9.7. 基于软件的解决方案"></a>9.7. 基于软件的解决方案</h2><p>一、思考方案<br>1、思考方案一：<br>某一个进程，它想进入临界区，其有一个顺序（次序），根据这个次序决定谁会进入这个临界区。</p><p>方法如下所示：</p><p><img src="/images/os-interview/915.png"></p><p>假设这个线程的次序是0，那么当turn=0时，才去继续下面的执行临界区代码，否者在while循环中一直打转。条件满足时，改变使得turn=1。<br>而进程1的代码也是类似的，只是while循环中的判断条件是不等于0，下面的turn=0.</p><p>这个程序的弊端是：<br>必须进程1执行一次临界区，进程0执行一次临界区，然后两个交替执行，才能保证两继续的执行。一旦其中的一个进程不愿意再做这个事情，那按照之前的属性，其他进程先进去就应该能够进去，但是在这种模式下，就无法完成这个前进的属性。</p><p>2、思考方案二：<br>前面表示了一个turn是不够表示，所以接下来使用一个小数组flag[2]来表示这个进程是否想进入临界区。</p><p>flag[0] = 1 //表示进程0想进入临界区执行<br>flag[0] = 1 //表示进程1想进入临界区执行<br>方法1如下所示：</p><p><img src="/images/os-interview/916.png"></p><p>但是这个代码是有问题的，不能满足互斥这个属性。<br>因为在初始的时候，两个进程都不会想进入临界区，所以两个flag都会赋值为0，表面没有这个需求。这样就是的两个进程都会跳出这个循环，然后都会将直接复制为，想要进入临界区，也就出现了多买面包的想象。</p><p>方法2如下所示：</p><p><img src="/images/os-interview/917.png"></p><p>满足了互斥，但是倘若两个线程都赋值了1，出现上下文切换的时候，都无法跳出这个循环，也就是出现是死锁的情况。</p><p>可见，互斥的解决并没有想象的那么简单~~~</p><p>二、正确实现<br>1、正确的接法<br>将以上的两种思考都综合起来使用。三个变量共同的作用。</p><p><img src="/images/os-interview/918.png"></p><p>算法如下：</p><p><img src="/images/os-interview/919.png"></p><p>该算法可以满足互斥，前进和有限等待三个属性。<br>反证法来证明：<br>假定，现在两个进程都进入了临界区，都在执行临界区代码，但是turn只是一个值的，所以总会有一个线程会跳出循环的。</p><p>2、另外一种算法<br>所需的变量空间相同，但是更加的复杂</p><p><img src="/images/os-interview/920.png"></p><p>三、拓展<br>1、n进程解决方法1 （E&amp;M算法）<br>除了了针对两个进程之外，还可以拓展到n个进程如何保证互斥。</p><p><img src="/images/os-interview/921.png"></p><p>大致的思路：<br>对于进程i而言，对于其前面的进程而言，如果有进程想进入临界区，或者已经进入了临界区，那么i进程就必须等待。而对于i进程后面的进程，必须要等待i进程执行之后在进入临界区。这样就可以通过一个循环的方式完成n个进程有序的进入临界区。</p><p>2、n进程解决方法2（Bakery算法）<br>大致思路如下：</p><p><img src="/images/os-interview/922.png"></p><p>四、总结</p><ul><li>即使是针对两个进程的解决竞态的实现还是比较复杂的。</li><li>需要忙等待，浪费cpu时间。</li><li>没有硬件包装的情况下无真正的软件解决方案。对硬件的1需求比较低（只需要load操作和store是原子操作即可）</li></ul><h2 id="9-8-更高级的抽象-—-基于原子操作"><a href="#9-8-更高级的抽象-—-基于原子操作" class="headerlink" title="9.8. 更高级的抽象 — 基于原子操作"></a>9.8. 更高级的抽象 — 基于原子操作</h2><p>软件的处理比较复杂有没有更加简单的实现方法？<br>一、基础</p><p><img src="/images/os-interview/923.png"></p><p><img src="/images/os-interview/924.png"></p><p><img src="/images/os-interview/925.png"></p><p>使用了一些特殊的操作：<br>1、Test-and-Set测试和置位<br>（一条机器指令，但是完成了读写操作两条指令的功能）<br>从内存中读取值<br>测试该值是否为1（然后返回真或假）<br>内存值设置为1</p><p>2、交换<br>（交换内存中的两个值）</p><p>只要计算机系统提供了这两条的其中一条指令就可以很容易的完成互斥的问题。</p><p>二、解决的方法<br>1、Test-and-Set方式</p><p><img src="/images/os-interview/926.png"></p><p>解决忙等的情况：先让其睡眠，在加一步唤醒操作</p><p><img src="/images/os-interview/927.png"></p><p>两者的区别：</p><p>忙等：不需要上下文切换，但是利用率低，适用与临界区执行时间短的情况。<br>不忙等：需要上下文切换，上下文切换开销比较大大，适用于临界区很长，远远大于上下文切换所需要的开销。<br>2、交换的方式</p><p><img src="/images/os-interview/928.png"></p><p>解析：<br>1)当一个进程想要进入临界区的时候，key=1，而且lock的初始值是0，所以当执行到while循环的时候，由于执行了交换，交换执行的过程不会被打断进行上下文切换的操作，而后lock的变成了1，而key变成了0.所以会退出循环，执行临界区的代码。<br>2)需要注意的是，当进入临界区的时候，load已经是1，当其他进程进入临界区执行的时候，load是1，而key也是1，交换之后还是1，一直会循环的等待，进入不了临界区。知道进入临界区的进程，退出临界区之后，完成一个将load变成0的操作。其他等待的进程才会继续执行exchange。</p><p>三、采用这种原子操作的特点<br>1、优点</p><ul><li>简单并且容易证明</li><li>适用于单处理器或者共享主存的多处理器中任意数量的进程</li><li>可以很容易拓展n个进程，可以用于支持多临界区</li><li>开销比较小</li></ul><p>2、缺点</p><ul><li>忙等待消耗处理器时间</li><li>当进程离开临界区并且多个进程在等待的时候可能导致饥饿现象</li><li>出现死锁的情况（例子：如果一个低优先级的进程拥有临界区并且一个高优先级进程也需求，那么高优先级进程会获得处理器并且等待临界区 — 需要用优先级反转的方式进行处理）</li></ul><p>四、总结<br>1、锁是更高级的编程抽象</p><p>互斥可以使用锁来实现<br>通常需要一定等级的硬件支持<br>2、常用的三种实现方法</p><p>禁用中断（仅限于单处理器）<br>软件方法（复杂）<br>原子操作指令（但处理器或多处理器均可）—更常用<br>3、可选的实现内容</p><p>有忙等待<br>无忙等待</p><h1 id="10-信号量与管程"><a href="#10-信号量与管程" class="headerlink" title="10. 信号量与管程"></a>10. 信号量与管程</h1><h2 id="10-1-背景"><a href="#10-1-背景" class="headerlink" title="10.1. 背景"></a>10.1. 背景</h2><p>利用信号量和管程解决同步互斥的问题</p><p>1、并发问题：竞争条件（竞态条件）</p><p>多程序并发存在大的问题<br>2、同步</p><ul><li>线程共享公共数据的协调条件</li><li>包括互斥与条件同步</li><li>互斥：在同一时间只有一个线程可以执行临界区</li></ul><p>3、解决同步问题正确比较难</p><ul><li>需要高层次的编程抽象（如：锁）</li><li>从底层硬件支持编译</li></ul><p>解决的过程图如下所示：</p><p><img src="/images/os-interview/101.png"></p><h2 id="10-2-信号量"><a href="#10-2-信号量" class="headerlink" title="10.2. 信号量"></a>10.2. 信号量</h2><p>（与信号灯有类似之处）<br>1、抽象数据类型</p><ul><li>一个整形（sem），两个原子操作</li><li>p操作：sem减一</li></ul><p>如果信号量sem&lt;0，认为执行p操作的进程需要睡眠<br>如果信号量sem&gt;0，认为执行p操作的进程可以继续执行，可以进入临界区<br>如果挡住了，就不能执行后续的程序，起到了一个阻挡的作用。</p><ul><li>v操作：sem加一</li></ul><p>如果信号量sem&lt;=0，认为当前的进程等待在这一个信号量上面，然后会唤醒这个进程（一个或多个）<br>2、信号量的图解机制</p><p><img src="/images/os-interview/102.png"></p><p>如果再来一个列车，信号量就不够了，直到一个列车离开了这个临界区之后，会执行一个v操作，而进入临界区之前会执行一个p操作。</p><p><img src="/images/os-interview/103.png"></p><p>离开这个临界区执行v操作之后，这个进程将道空出来之后，还会通知等待的列车去执行</p><p><img src="/images/os-interview/104.png"></p><p>3、由来</p><p><img src="/images/os-interview/105.png"></p><h2 id="10-3-信号量的使用"><a href="#10-3-信号量的使用" class="headerlink" title="10.3. 信号量的使用"></a>10.3. 信号量的使用</h2><p>一、基础<br>1、属性</p><ul><li><p>信号量是整数（有符号数）<br>一开始通常会设定为一个大于0的数，所以一开始执行p操作不会被阻塞。但是多次执行p操作之后，执行p操作的进程就会等待在上面。这时需要起床进程执行v操作，然后唤醒等在这个上面的进程。（如果只能唤醒一个进程，一般是唤醒第一个等待的进程，FIFO对列）</p></li><li><p>信号量是被保护的变量</p></li></ul><p>初始化完成后，唯一改变一个信号量的值的办法是通过p操作或者是v操作<br>操作必须是原子</p><ul><li><p>p操作（信号量减一操作）能够阻塞，v操作（信号量加一操作）不会阻塞</p></li><li><p>假定信号量是公平的</p></li></ul><p>没有线程被阻塞在p操作仍然阻塞如果v操作被无限频繁地调用（在同一个信号量）<br>在实践中，FIFO经常被使用<br>2、两种类型信号量</p><ul><li>二进制信号量：可以是0或1（与前面的lock达到同样的效果）</li><li>一般/计数信号量：可取任何非负值</li><li>两者互相表现（给定一个可以实现另一个）</li></ul><p>3、信号量可以用在两个方面</p><ul><li>互斥</li><li>条件同步（调度约束–一个线程等待另一个线程的事件发生）</li></ul><p>二、信号量的使用<br>1、思想介绍</p><ul><li>用二进制信号量实现的互斥</li></ul><p><img src="/images/os-interview/106.png"></p><p>解析：<br>一开始要设置一个初始值，为了模仿lock操作，实质了初始值为1。然后在临界区之前，作一个信号量的p操作，在临界区执行之后，作一个信号量的v操作。这个就是二进制信号量的最常用法，完全可以代替前面的lock操作。</p><ul><li>用二进制信号量完成同步操作</li></ul><p><img src="/images/os-interview/107.png"></p><ul><li>其他复杂的问题<br>一个线程等待另一个线程处理事情<br>比如生产东西或消费东西<br>互斥（锁机制）是不够的</li></ul><p><img src="/images/os-interview/108.png"></p><p>2、正确性要求：</p><ul><li>buffer是有限的</li><li>任何一个时间只能有一个线程操作缓冲区（互斥）<br>允许一个或多个生产者往buffer中写数据，但是这时候不允许消费者读数据<br>允许一个或多个消费者往buffer中读数据，但是这时候不允许生产者写数据</li><li>当缓冲区为空时，消费者要休眠，消费者必须等待生产者（调度/同步约束）</li><li>当缓冲区已满时，生产者必须等待消费者（调度/同步约束）</li></ul><p>3、使用分析<br>每个约束用一个单独的信号量</p><ul><li>二进制信号量互斥</li></ul><p>对buffer做添加或者取出的保障</p><ul><li>一般信号量fullBuffers</li></ul><p>代表一开始buffer的数据多少，如果为0，则表示一开始的buffer是空的</p><ul><li>一般信号量emptyBuffers</li></ul><p>代表当前生产者可以往这个buffer塞多少个数据<br>以上两个技术信号量用于同步操作，当buffer还有空间时，应唤醒生产者继续生产。</p><p>4、代码操作</p><ul><li>数据可初始化如下：</li></ul><p><img src="/images/os-interview/109.png"></p><ul><li>生产者的操作：</li></ul><p><img src="/images/os-interview/1010.png"></p><p>调用这个函数实现生产者不停的添加数据</p><ul><li><p>消费者的操作：<br>调用这个函数实现消费者不停的取出数据</p></li><li><p>解决互斥同步总实现代码分析</p></li></ul><p><img src="/images/os-interview/1011.png"></p><p>解析：</p><ul><li>对于生产者来说，由于一开始的buffer设置允许塞进的数据是n，所以生产者可以往下执行。进行buffer的生产操作。</li><li>但是在生产之前，需要对mutex进程减操作，使之为0。。生产操作完成之后，将mutex加1操作。这次就保证了buffer的互斥问题，确保之间只有一个线程可以执行。两个操作确保了add buffer是一个互斥的操作，确保互斥性。</li><li>互斥操作完成之后，在将fullbuffer进行一个v操作，加1，提醒生产者可以正常的消费。</li><li>而对消费者来说，fullbuffer一开始初始值为0，所以是没有数据的。消费者不可能取到数据，所以在等待。所以刚刚生产者唤醒了消费者，和生产者fullbuffer的v操作相匹配。而后进行互斥的取数据操作</li><li>取出数据之后，会将emptybuffer进行v操作，表示唤醒生产者可以继续生产，也就是生产的进程可以继续执行。</li></ul><p>以上就运用了互斥机制和同步机制来实现了一个完成的消费者和生产者的问题。需要注意好初值的确定。</p><p>问题：p，v操作的顺序有影响吗？<br>v操作是加一操作，所以没有影响<br>p操作是减一操作，会导致阻塞，所以会产生严重的影响，比如死锁的情况</p><h2 id="10-4-信号量的实现"><a href="#10-4-信号量的实现" class="headerlink" title="10.4. 信号量的实现"></a>10.4. 信号量的实现</h2><p>不仅要会用信号量，还需要知道信号量使用的细节<br>1、伪代码实现</p><p><img src="/images/os-interview/1012.png"></p><p>2、需要注意的问题</p><ul><li>信号量的双用途</li></ul><p>互斥和条件同步<br>但等待条件是独立的互斥</p><ul><li>读/开发代码比较困难</li></ul><p>程序员必须非常精彩信号量</p><ul><li>容易出错</li></ul><p>使用的信号量已经被另一个线程占用<br>忘记释放信号量</p><ul><li>不能处理死锁问题</li></ul><h2 id="10-5-管程"><a href="#10-5-管程" class="headerlink" title="10.5. 管程"></a>10.5. 管程</h2><p>管程的抽象程度更高，更加容易的来完成相应的同步互斥的问题。<br>一、基础<br>1、目的：分离互斥和条件同步的关注<br>（一开始是完成编程语言的设计，而不是操作系统的设计的，所以其整体上是针对语言的并发机制来完成的）</p><p>2、什么是管程（moniter）<br>管程是包含了一系列的共享变量以及针对这些这些变量函数的一个组合或模块。其包括：</p><p>一个锁：指定临界区（确保互斥性，只能有一个线程）<br>0或者多个条件变量：等待/通知信号量用于管理并发访问共享数据<br>3、一般方法</p><p>收集在对象/模块中的相关共享数据<br>定义方法来访问共享数据<br>大致的结构图：</p><p><img src="/images/os-interview/1013.png"></p><p>一开始，所有进程在右上角的排队队列中，排队完后进行wait()操作，等到signal()操作唤醒后，执行这个进程的代码。</p><p>分析：</p><p><img src="/images/os-interview/1014.png"></p><p>实现：</p><p><img src="/images/os-interview/1015.png"></p><p>解析：</p><ul><li>这里的numwaiting代表的是当前等待线程的个数，而之前的sem是代表信号量的个数。</li><li>信号量的实现v操作和c操作是一定会执行的，也就是一定会执行加一操作或者是减一操作。</li><li>而这里的wait操作是会做加操作，而signal里面，不一定要做减操作。</li><li>这里在wait函数中，还没有require lock就要release（lock）的原因下面再进行讲解。</li><li>release(lock)之后，会做一次schedule(),表示会选择下一次线程去执行，因为本身这个线程已经处于睡眠状态了。</li><li>schedule()完毕再做一个require(lock)的操作，这里又是为什么？这里的release和require和之前的有所不同，下面讲解。</li><li>signal函数是作唤醒的操作，从等待队列里面取出一个线程唤醒，与之前的schedule()是对应的。wakeup(t)是对schedule的进一步触动机制。最后waiting再进行减减操作。</li><li>如果等待队列为0，则啥操作也不做这里的numwaiting代表的是当前等待线程的个数，而之前的sem是代表信号量的个数。</li></ul><p>二、使用<br>1、对管程进行初始化</p><p><img src="/images/os-interview/1016.png"></p><p>需要注意：</p><ul><li>lock变量是保证互斥的操作。</li><li>condition条件变量，这里有两个条件变量，一个是buffer满，一个是buffer空，也就是</li><li>count中记录了buffer中的空闲情况，count=0，表面buffer是空的，如果buffer是n，表面buffer是满的。</li></ul><p>2、互斥机制<br>生产者是Deposit()，消费者是Remove()。</p><p><img src="/images/os-interview/1017.png"></p><p>需要注意：</p><ul><li>这里不仅仅要对buffer做操作，响应的还要在count中记录下来。</li><li>信号量互斥的实现是仅仅靠着这个buffer的，而这里的互斥是在函数的头和尾。</li><li>buffer空了消费者会去睡眠，而buffer满了生产者会去睡眠。</li></ul><p>为什么？ —–这是管程的定义来决定的<br>·因为管程定义，进入管程的时候，只有一个线程可以进去，才能执行管程所管理的所以函数。而既然这图中的两个函数是属于管程管理的两个访问共享变量的函数，就要确保其互斥性和唯一性。所以一进入这个函数就是互斥的。</p><p>3、同步机制</p><ul><li>生产者的buffer未满操作<br>如何实现：buffer空了消费者会去睡眠，而buffer满了生产者会去睡眠的过程？</li></ul><p><img src="/images/os-interview/1018.png"></p><p>当buffer满的时候，也就是count=n，这时候会作一个 notfull.wait(&amp;lock)操作。notfull是一个条件变量，不需要有一个初始值。notfull.wait(&amp;lock)就表示当前已经满了，我需要睡眠，同时还带有一个lock。而这个lock就是管程的lock。</p><ul><li>小插曲<br>这时先解释前面的问题：为什么是先relase再require一个锁呢？</li></ul><p><img src="/images/os-interview/1019.png"></p><p>解析：<br>release(lock)：实际上说让当前的生产者释放到这个锁，这使得其他的线程才有可能进入管程去执行。因为这时候生产者要休眠了，所以必须要把这把锁释放。而其释放是由于之前其有一个lock-&gt;Acquire(),已经获得了这个锁。所以在wait操作一定要释放，不然所以等待的线程都在等待，系统会停滞。<br>一旦将来被唤醒了，也意味着可以继续从schedule中继续往下执行，再去完成一次require(lock)。一旦获取了lock之后，就会跳出wait操作，看看count是否等于n。</p><ul><li>消费者的buffer未满操作</li></ul><p><img src="/images/os-interview/1020.png"></p><p>而在notfull的另一边，需要有一个唤醒机制，所以消费者这边会有一个notfull.signal()操作。一旦count做了一个减减操作，buffer满了消费了一个操作，这是buffer句未满了，所以需要去进行唤醒，去唤醒正在等待在这上面的线程。</p><ul><li>消费者的buffer为空操作与生产者的buffer非空唤醒操作</li></ul><p><img src="/images/os-interview/1021.png"></p><p>这消费者这边，buffer空的时候，也同样会有一个while操作，会判断count是否等于0，如果是会作一个notempty的wait操作，直到生产有一个notempty.signal的信号唤醒才可以继续去执行。两者合在一起就是完整的管程来解决生产者消费者的问题。</p><ul><li>总的实现与和信号量的代码比较<br>管程实现：</li></ul><p><img src="/images/os-interview/1022.png"></p><p><img src="/images/os-interview/1023.png"></p><p>信号量实现：</p><p><img src="/images/os-interview/1024.png"></p><p>两者相比，可以看出，与信号量实现的总体功能是一样的，但是实现的细节不一样。</p><p>三、两种特别的方式<br>问题：<br>管程实现生产者消费者问题中，还需要注意到一点，当线程在管程中执行时，如果线程这时候要执行针对某一个条件变量的signal唤醒操作之后。这时候，是执行等待在这个条件变量上的线程？还是发出唤醒的线程执行完毕后再让那个等待的线程执行？</p><p>1、两种方法</p><ul><li>Hoare方法（比较完美）<br>一旦发出了signal操作之后，就应该让等待的线程继续执行，而其自身去睡眠。直到等待的线程执行了release之后，这个线程才能继续执行。</li></ul><p>特点：比较直观，但是实现起来比较困难</p><p>执行的流程如下：</p><p><img src="/images/os-interview/1025.png"></p><ul><li>Hansen方法：<br>当发出了signal操作之后，不一定要马上放出对cpu的控制权，而是等发出signal的线程执行完release操作之后才转移cpu控制权。</li></ul><p>特点：实现起来比较容易</p><p>执行的流程如下：</p><p><img src="/images/os-interview/1026.png"></p><p>2、比较<br>Hoare的while操作可以用if操作来实现，而Hansen的不行，这是唤醒机制不同而造成的。</p><p><img src="/images/os-interview/1027.png"></p><ul><li><p>对于Hansen来说，其并没有马上让等待在这上面的线程执行，所以其必须要做relseae才能释放，所以这时会存在多个被唤醒的线程，抢这个继续执行的count。所以当选择自己的时候，count已经不为n了，所以要循环的查询。</p></li><li><p>对于Hoare来说，执行之后会马上的转移cpu、控制权，而这时只要一个线程被唤醒，不存在多个的问题。而其一定可以往下执行，因为count一定不为n。</p></li></ul><p>四、总结</p><p><img src="/images/os-interview/1028.png"></p><p><img src="/images/os-interview/1029.png"></p><h2 id="10-6-经典同步问题1—-读者优先读写者问题"><a href="#10-6-经典同步问题1—-读者优先读写者问题" class="headerlink" title="10.6. 经典同步问题1—-读者优先读写者问题"></a>10.6. 经典同步问题1—-读者优先读写者问题</h2><p>一、读者写者问题<br>1、动机：共享数据的访问</p><p>2、两种类型的使用者</p><ul><li>读者：不需要修改数据</li><li>写者：读取和修改数据</li></ul><p>3、问题的约束</p><ul><li>允许同一时间有多个读者，但在任何时候只有一个写者</li><li>当没有写者时读者才能访问数据</li><li>当没有读者和写者时写者才能访问数据</li><li>在任何时候只能有一个线程可以操作共享变量</li><li>读者优先，不按时间顺序</li></ul><p>4、共享数据的设计</p><ul><li>数据集</li><li>信号量CountMutex初始化为1<br>保证count的读写是互斥的</li><li>信号量WriteMutex初始化为1<br>保证写者的互斥保护，因为只允许一个写操作</li><li>整数Rcount初始化1<br>当前读者的数量，因为可以有多个读者同时操作</li></ul><p>二、实现的过程</p><p><img src="/images/os-interview/1030.png"></p><p>sem_wait：就是p操作，也就是减一操作<br>sem_post：就是v操作，也就是加一操作<br>1、写者的互斥保证</p><p><img src="/images/os-interview/1031.png"></p><p>分析：<br>包起来之后确保只有一个线程可以进行写操作。且一旦写者在写，读者就不能读，只能等待。而当读者在读数据的时候，写者也不能写数据。完成了读者写者的互斥操作与写者与写者的互斥操作。<br>但是没有体现可以允许多个读者读数据</p><p>2、多读者体现</p><p><img src="/images/os-interview/1032.png"></p><p>分析：</p><ul><li>rcount=0，代表当时没有读者，所以只要没有写者，就可以继续的执行。</li><li>但是当如果rount！=0的时候，表明当前已经有读者线程在读数据了，也意味着接下来的操作，写者是一定进不来的，rcount++操作完成读就好。</li><li>当读完的时候，如果rcount=0，也就是说读者已经读完了，这时外面可能存在写者，所以要唤醒。</li></ul><p>3、多读者的互斥</p><p><img src="/images/os-interview/1033.png"></p><p>分析：<br>确保不会存在多个读者同时对rcount进行操作，也就是保证rcount数据的互斥性。</p><p>4、完整的读者优先的读者写者问题</p><p><img src="/images/os-interview/1034.png"></p><p>三、读者优先与写者优先的区别：</p><p><img src="/images/os-interview/1035.png"></p><h2 id="10-7-经典同步问题1—写者优先读写者问题"><a href="#10-7-经典同步问题1—写者优先读写者问题" class="headerlink" title="10.7. 经典同步问题1—写者优先读写者问题"></a>10.7. 经典同步问题1—写者优先读写者问题</h2><p>利用管程实现写者优先的读者写者问题<br>一、基础<br>1、方法构思</p><p><img src="/images/os-interview/1036.png"></p><p>需要注意：</p><ul><li>读者进行读操作时要注意当前是否有写者（两类：正在写数据的写者和正在等待的写者），这两类写者只要有一个存在，那么读者就需要等待。都不存在才有机会进行读操作。</li><li>读完之后，检测是否有写者正在等待，其有责任去唤醒。</li><li>当当前有读者正在读的读者或者正在写的写者时，需要等待。（正在等待的读者不需等待，写者优先）</li><li>写操作之后，唤醒正在等待的写者或者正在等待的读者。</li></ul><p>2、数据结构</p><p><img src="/images/os-interview/1037.png"></p><p>AR：当前处于读数据库读者的个数<br>AW：当前正在写的个数<br>WR：当前正在等待读者的个数<br>WW：当前正在等待写者的个数<br>oktoread：表示当前可以去读<br>oktowrite：表示当前可以去写<br>lock：确保只有一个函数进入管程去执行<br>二、实现<br>1、读者的具体实现</p><p><img src="/images/os-interview/1038.png"></p><p>解析：</p><ul><li>因为读者读数据的时候，要确保没有正在写的写者和正在等待的写者（写者优先），所以while语句中判断的依据是（AW+WW）&gt;0的时候，都需要等待，并且不断记录被等待的读者，也就是WR++。等到没有写者的时候，被唤醒，其中一个等待的读者可以继续执行，并且WR–。</li><li>当完成读数据库的操作时，正在读的读者减一操作。并且当此时已经没有读者而且正在有等待的写者时，进行唤醒写者的操作。但是当还有读者的时候，为了保证读写的互斥，就没有必要唤醒写者了。</li></ul><p>2、写者的具体实现</p><p><img src="/images/os-interview/1039.png"></p><p>解析：</p><ul><li>当一个写者想写数据的时候，首先进行判断当前有无正在读的读者或者是正在写的写，等待的不需考虑。若没有时，说明可以有机会被唤醒去执行后面的操作。否者继续等待，直到被唤醒，然后等待的写者++。</li><li>当写完数据时，正在写的写者减一操作（其实我认为AW只有01两个取值，有正在写的写者，或者没有正在写的写者），此时表面没有正在写的写者，而当有等待的写者，既去唤醒其中的一个写者执行。否则，当有正在等待的读者时，去唤醒全部的读者。</li><li>需要注意，signal是唤醒等待在这个条件变量上的一个，而broadcast是唤醒等待在这个条件变量上面的全部。</li></ul><h2 id="10-8-经典同步问题2—哲学家就餐问题"><a href="#10-8-经典同步问题2—哲学家就餐问题" class="headerlink" title="10.8. 经典同步问题2—哲学家就餐问题"></a>10.8. 经典同步问题2—哲学家就餐问题</h2><p>一、基础与尝试<br>1、问题描述</p><p><img src="/images/os-interview/1040.png"></p><p>拿叉子，减一的p操作<br>放叉子，加一的v操作<br>2、尝试解决（可以跳过）<br>方案一：</p><p><img src="/images/os-interview/1041.png"></p><p>结果：会导致死锁，谁都拿不了右边的叉子</p><p>方案二：</p><p><img src="/images/os-interview/1042.png"></p><p>结果：会重复过程</p><p>方案三：等待随机的时间</p><p><img src="/images/os-interview/1043.png"></p><p>结果：等待时间随机变化，可行，但非万全之策。可能等待时间长的哲学家一直在等待。</p><p>方案四：<br>使用信号量的互斥锁来保护</p><p><img src="/images/os-interview/1044.png"></p><p>结果：<br>互斥访问可以实现不会出现死锁的情况，但是每次只允许一个人进餐。本来可以并行两个哲学家同时吃饭，这与问题项背，效率较低。<br>其将就餐（而不是叉子）看成是必须互斥访问的临界资源，因此回造成（叉子）资源的浪费。</p><p>二、实现思路<br>1、不同的思考</p><ul><li>哲学家维度</li></ul><p><img src="/images/os-interview/1045.png"></p><ul><li>计算机维度</li></ul><p><img src="/images/os-interview/1046.png"></p><p>2、编写</p><ul><li>思路</li></ul><p><img src="/images/os-interview/1047.png"></p><ul><li>数据结构</li></ul><p><img src="/images/os-interview/1048.png"></p><ul><li>操作方法</li></ul><p><img src="/images/os-interview/1049.png"></p><p>3、具体的实现</p><ul><li>函数take_forks的定义</li></ul><p><img src="/images/os-interview/1050.png"></p><p>需要注意：<br>hungry的状态需要互斥保护<br>拿两把叉子的过程其实也是在互斥的保护之中</p><ul><li>函数test_take_left_right_forks的定义</li></ul><p><img src="/images/os-interview/1051.png"></p><p>分析：</p><ul><li>首先确保自己是出于饥饿状态的，然后判断两旁的人是否是出于eatting状态，如果都不是，意味两边都有叉子，就可以吃饭了。</li><li>可以看出，两把叉子到手，没有一个具体的变量来体现，而是说用状态来表示（因为拿一把叉子是没有意义的）。</li><li>而在前面赋初值的时候，s[i]的初值是0，v操作之后，自身编变成了1，也就是自己通知自己可以吃饭了。</li></ul><p>问题：为什么会通知自己吃饭？<br>因为在take_forks函数的最后，会有一个p操作，加1之后会减1操作，所以这里的p操作不会被阻塞。只是使得同步信号量加一操作之后，使这里的减一操作不会被阻塞。</p><ul><li>函数put_forks的定义<br>功能：把两把叉子放回原处，并在需要的时候去唤醒左岭右舍</li></ul><p><img src="/images/os-interview/1052.png"></p><p>需要注意：<br>这里查看自己的左邻居能否进餐的时候，还有看自己左邻居的左邻居的状态。如果自己左邻居的左邻居的状态是进餐状态，这左邻居不可能进餐。自己的右邻居同理。</p><ul><li>程序设计的思考过程<br>以一般的思路分许问题，写出一个伪代码，再将伪代码变成程序。<br>在这个过程中要设定好变量（同步和互斥的机制）<br>逐步细化的方式实现这个处理的过程，一般来说是会匹配的（p操作和v操作）</li></ul><h1 id="11-死锁"><a href="#11-死锁" class="headerlink" title="11. 死锁"></a>11. 死锁</h1><h2 id="11-1-死锁问题"><a href="#11-1-死锁问题" class="headerlink" title="11.1. 死锁问题"></a>11.1. 死锁问题</h2><p>1、死锁现象</p><p><img src="/images/os-interview/111.png"></p><p><img src="/images/os-interview/112.png"></p><p>出现的原因：进程并发运行</p><h2 id="11-2-系统模型"><a href="#11-2-系统模型" class="headerlink" title="11.2. 系统模型"></a>11.2. 系统模型</h2><p>1、资源概念</p><p><img src="/images/os-interview/113.png"></p><p>资源一旦是被使用状态，则其他的进程就不应该运用这个资源，有互斥性，如果没有互斥性，就不会产生死锁。<br>进程使用资源的有限的，资源恢复到空闲的情况。<br>2、可重复使用的资源</p><ul><li>在一个时间只能一个进程使用且不能删除</li><li>进程获得资源，后来释放有其他进程重用</li><li>处理器，io通道，主和副存储器，设备和数据结构，如文件，数据库和信号量都可以看作是资源的一种形式</li><li>如果每个进程拥有一个资源并且请求其他资源，死锁可能发生</li></ul><p>3、如何使用资源</p><ul><li>创建和销毁进行资源管理，内存管理</li><li>在op缓冲区中的中断，信号，消息，信息</li><li>如果接受消息阻塞可能会发生死锁</li><li>可能少见的组合事件会引起死锁</li><li>存在进程管理和调度的过程</li></ul><p>4、资源分配图</p><p><img src="/images/os-interview/114.png"></p><p>pi-&gt;rj：表示进程i需要j的资源<br>rj-&gt;pi：表示资源i被j所使用</p><p><img src="/images/os-interview/115.png"></p><p>5、死锁的判断</p><ul><li>情况一</li></ul><p><img src="/images/os-interview/116.png"></p><p>不会产生死锁</p><ul><li>情况二</li></ul><p><img src="/images/os-interview/117.png"></p><p>会产生死锁，这个图形成了一个环状的结构（一个大环和小环）</p><ul><li>情况三</li></ul><p><img src="/images/os-interview/118.png"></p><p>有环状的资源分配图没有死锁</p><p>总结：<br>死锁一定有环，但是有环不一样产生死锁</p><p><img src="/images/os-interview/119.png"></p><h2 id="11-3-死锁的特征"><a href="#11-3-死锁的特征" class="headerlink" title="11.3. 死锁的特征"></a>11.3. 死锁的特征</h2><p>这个是死锁出现的四个特征：</p><p><img src="/images/os-interview/1110.png"></p><p>需要注意：这四个特征出现并不意味着死锁的出现</p><p><img src="/images/os-interview/1111.png"></p><p>右图的p2和p4不满足持有并等待资源，所以不满足这四个特征，所以不是死锁。</p><h2 id="11-4-死锁处理办法"><a href="#11-4-死锁处理办法" class="headerlink" title="11.4. 死锁处理办法"></a>11.4. 死锁处理办法</h2><p><img src="/images/os-interview/1112.png"></p><p>以上的四个方法的约束一个比一个弱，死锁预防的约束最强，而死锁恢复的约束最差。</p><p>方法一：确保系统永远不会进入死锁状态<br>操作系统的功能会被限制，应用系统无法重复的利用cpu执行开销也很大</p><p>方法二：运行系统进入死锁状态，然后恢复<br>但是判断死锁的开销非常大</p><p>方法三：忽略这个问题，假装系统中从来没有发生死锁；用于绝大多数的操作系统。<br>靠假设来忽略这个问题，实际操作的常用方法</p><h2 id="11-5-死锁预防和死锁避免"><a href="#11-5-死锁预防和死锁避免" class="headerlink" title="11.5. 死锁预防和死锁避免"></a>11.5. 死锁预防和死锁避免</h2><p>1、死锁的预防 —- 让死锁不会出现<br>思路：只要将前诉的四个资源打破其中的一个，那么久不会出现死锁。</p><p><img src="/images/os-interview/1113.png"></p><p>针对死锁的四个必要条件，打破死锁进行一开始预防：</p><ul><li>互斥<br>本来资源是互斥的，通过使资源不互斥。</li><li>占用并等待<br>将条件变大，拿资源就拿全部的资源才去执行，否者不能资源去睡眠，这样就不会存在死锁。但是不同的执行过程中，需要的资源不同，导致一直占用资源但是没有使用，所以会导致系统资源的利用率低。</li><li>不抢占<br>直接将进程kill掉，也就将资源抢占过来了，但是手段比较的暴力，不合理。</li><li>循环等待<br>死锁的出现会出现一个环，打破这个环可以实现死锁的预防。如果对资源类型进行排序，进程按资源顺序进行申请，也就是资源只能往上进行申请，这样就不会形成循环的圈。但是前提是要讲资源排好序，但是资源利用还是不合理的。</li></ul><p>2、死锁避免<br>比上诉的约束条件放松一点<br>思路：当进程在申请资源的过程中，然后判断这个申请合不合理，如果会存在死锁的概率，就会拒绝这个请求。</p><p>需要注意：<br>其中，不安全状态不一定对导致死锁状态，所以不安全状态是包含着死锁状态，我们需要的是安全状态。将是否会形成环来作为判断依据。</p><p>问题：什么是安全状态？<br>针对所有的进程，存在一个时间序列，按照这个序列执行，先后顺序执行，所以的进程都可以正常的等待所需要的资源，正常的结束。</p><p><img src="/images/os-interview/1114.png"></p><p>要避免进入unsafe空间。而在safe状态不会出现一个环。</p><p><img src="/images/os-interview/1115.png"></p><p>11.6银行家算法<br>一、基础<br>1、算法的背景</p><p><img src="/images/os-interview/1116.png"></p><p>2、前提基础</p><p><img src="/images/os-interview/1117.png"></p><p>很重要的判断：safe还是unsafe</p><p>二、算法设计<br>1、数据结构的设计</p><ul><li>n = 进程数量</li><li>m = 资源类型数量<br>（其中，每一个资源类型还要一个量）</li><li>Max（某种类型的总需求量）：nxm矩阵。<br>如果Max[i，j] = k，表示进程Pi最多请求资源类型Rj的k个示例<br>（可以知道其整个生命周期中共需要该类多少个资源）</li></ul><p><img src="/images/os-interview/1118.png"></p><p>其中存在一条关系式：</p><p><img src="/images/os-interview/1119.png"></p><p>2、初始化</p><p><img src="/images/os-interview/1120.png"></p><p>3、操作</p><p><img src="/images/os-interview/1121.png"></p><p>执行之后：</p><p>可申请的资源变少，变少了request<br>已分配的资源变多，变多了request<br>还需要的资源变少，变少了request<br>根据返回值做出改变：</p><p><img src="/images/os-interview/1122.png"></p><p>以上就是银行家算法的一个大致思路。</p><p>三、示例<br>第一个例子<br>1、首先系统和进程所拥有的资源如下图所示</p><p><img src="/images/os-interview/1123.png"></p><p>需要注意：</p><p>Max：所有进程需要资源的情况<br>Need：当前进程需要进程的情况<br>Available：系统还剩下资源的情况<br>Allocation：当前进程已经拥有的资源<br>Resource：当前系统中总资源的个数<br>2、可见，p2可以满足情况，执行后可返回其所占有的资源</p><p><img src="/images/os-interview/1124.png"></p><p>3、回收资源之后，按照顺序，p1所需要的资源是可以满足的，可以执行</p><p><img src="/images/os-interview/1125.png"></p><p>4、p1执行完之后，对资源进行回收，接下来剩下的两个进程偶读可以满足要求。可以随便选一个，比如p3，然后再选择p4.</p><p><img src="/images/os-interview/1126.png"></p><p>结论：<br>所以，这样我们就已经找到了一个序列，如果按照p2-p1-p3-p4这个顺序去执行，就可以实现所以的进程都可以正常的执行并结束，其所需要的资源都可以得到满足。这个就是安全的执行序列，safe。</p><p>第二个例子：</p><p><img src="/images/os-interview/1127.png"></p><p>如果一开始p1提出了一个101请求，执行之后</p><p><img src="/images/os-interview/1128.png"></p><p>此时系统所剩余的资源为011，此时不能满足任何的其他进程，会进入一个unsafe的状态。<br>所以，一开始银行家算法是不会接受p1的101的请求的。</p><p>总结：<br>银行家算法的思路是判断当前的资源分配操作是否安全的，如果安全则可以执行，如果不安全就不能分配出去。</p><h2 id="11-6-死锁检测和死锁恢复"><a href="#11-6-死锁检测和死锁恢复" class="headerlink" title="11.6. 死锁检测和死锁恢复"></a>11.6. 死锁检测和死锁恢复</h2><p>一、基础<br>1、背景<br>死锁的检测又将条件放宽了一点。</p><p>前面的死锁避免是既是不会导致死锁的现象方法，但是如果会出现不安全状态，也不会执行。<br>这里的死锁检测允许系统进入unsafe状态，在某一个状态判断当前的系统是否出现死锁，如果是，就启动恢复机制；如果没有，就继续执行，将死锁的检测放在了系统运行中，更往后了。<br>2、死锁检测的大致思路</p><p>允许系统进入死锁状态<br>死锁检测算法<br>恢复机制<br>3、检测原理</p><ul><li>将资源分配图中资源的节点简化，只留下进程。从而将资源分配图，变成进程等待图。然后再判断这个等待图是否具有环。有环就代表有可能死锁。</li></ul><p><img src="/images/os-interview/1128.png"></p><ul><li>死锁检测算法</li></ul><p><img src="/images/os-interview/1129.png"></p><p>死锁检测算法，定期的执行对操作系统运行比较大，更多是起调试的作用。而已银行家算法需要提前知道进程未来所需要的资源，这个是比较难实现的，只能去预估。</p><p>二、示例<br>1、例子一</p><p><img src="/images/os-interview/1130.png"></p><p>2、例子二</p><p><img src="/images/os-interview/1131.png"></p><p>结果：<br>没有一个进程的需求可以得到满足，死锁会检测出一个环，与银行家算法是比较类似的。</p><p>三、算法是使用</p><p><img src="/images/os-interview/1132.png"></p><p>四、死锁的恢复</p><p><img src="/images/os-interview/1134.png"></p><p>都存在某种程度上的强制性和不合理性。所以死锁恢复是最后的手段。</p><p><img src="/images/os-interview/1135.png"></p><h2 id="11-7-IPC概述"><a href="#11-7-IPC概述" class="headerlink" title="11.7. IPC概述"></a>11.7. IPC概述</h2><p>一、基础<br>IPC的意思就是进程间通信<br>1、问题：为什么要进行进程间通信？<br>进程之间可能要完成一个大的任务，这需要一定的数据的沟通和信息的传递，保存进程独立性的通信，保证其可以有效的沟通。</p><p>2、IPC提供2个操作<br>send message<br>receive message</p><p>3、通信的前提<br>在他们之间建立通信链路<br>通过send/receive交换消息</p><p>4、通信链路实现<br>物理（例如共享内存，硬件总线）<br>逻辑（例如，逻辑属性）</p><p>二、间接通信与直接通信</p><p><img src="/images/os-interview/1136.png"></p><ul><li>直接通信</li></ul><p><img src="/images/os-interview/1137.png"></p><ul><li>间接通信</li></ul><p><img src="/images/os-interview/1138.png"></p><p><img src="/images/os-interview/1139.png"></p><p>主需要关注在哪里收数据或者将数据丢到哪里去就行了。一般是os中的共享数据。</p><p>三、阻塞或是非阻塞的</p><p><img src="/images/os-interview/1140.png"></p><h2 id="11-8-信号，管道，消息队列和共享内存"><a href="#11-8-信号，管道，消息队列和共享内存" class="headerlink" title="11.8. 信号，管道，消息队列和共享内存"></a>11.8. 信号，管道，消息队列和共享内存</h2><p>（这里只是作简单的介绍，没有涉及具体的实现方法）<br>1、数据的缓冲</p><p><img src="/images/os-interview/1141.png"></p><p>需要注意：<br>无论是哪种情况，当缓冲中没有数据的时候，接收方都必须等待数据的到来</p><p>一、信号<br>1、介绍</p><p><img src="/images/os-interview/1142.png"></p><p>关注某一种信号，发生了某一种响应之后，可以编写特定的处理函数。效率比较高。<br>处理完之后，会回到被打断的函数重新的实现。</p><p>2、如何实现</p><p><img src="/images/os-interview/1143.png"></p><p>应用程序针对某种新号作定点处理，要完成的操作是：</p><ul><li>开始的时候，要针对某种信号的handle，把这个作为系统调用发给操作系统。操作系统就知道当这个进程发出某种信号就会跳转到预先编写的处理函数中。</li><li> 操作系统将系统调用返回用户空间的堆栈进行修改，使得本来是返回调用语句的后条执行变成到这个信号处理函数的入口，同时在把信号处理函数的之后的地址作为栈帧的返回地址。所以要修改应用程序的堆栈。</li></ul><p>二、管道<br>管道是用来实现数据的交换。其以文件的操作。<br>思路：将一个文件的输出，重定向到令一个文件的输入，这样就可以完成一系列的操作。（重定向符为“&gt;”）</p><p><img src="/images/os-interview/1144.png"></p><p>如何实现：<br>shell进程收到了这条命令之后，会创建两个进程，ls进程和more进程。同时将ls的输出到一个管道中，而不是屏幕上（内存中的一个buffer）。而对于more，不是从键盘接受信息，而是从管道中接受数据，这样就完成了输入输出的重定向功能。这样就完成了分页显示目录的功能。（存在阻塞现象）</p><p>特点：</p><ul><li>管道是通过父进程帮子进程建立好的一个通道，如果没有父子关系，这样就不能正常工作了。</li><li>管道的数据是一种字节流。</li><li>有bufffer满和buffer空的限制</li></ul><p>三、消息队列</p><p><img src="/images/os-interview/1145.png"></p><p>特点：</p><ul><li>数据是结构化的数据，而不是字节流，传进去的是一个有意义的数据结构</li><li>可以实现多个互不相关的进程完成数据交换</li></ul><p>四、共享内存<br>上面两种都是间接通信。共享内存是直接通信的方式。<br>（通过内核，读写内存，实现进程的数据的交换）</p><p><img src="/images/os-interview/1146.png"></p><p>共享内存的实现机制：</p><p><img src="/images/os-interview/1147.png"></p><h1 id="12-面试总结"><a href="#12-面试总结" class="headerlink" title="12. 面试总结"></a>12. 面试总结</h1><h2 id="12-1-用户态和内核态"><a href="#12-1-用户态和内核态" class="headerlink" title="12.1. 用户态和内核态"></a>12.1. 用户态和内核态</h2><p>计算机系统中的两类程序：系统程序和应用程序，为了保证系统程序不被应用程序有意或无意地破坏，为计算机设置了两种状态：</p><ul><li>系统态(也称为管态或核心态)，操作系统在系统态运行——运行操作系统程序</li><li>用户态(也称为目态)，应用程序只能在用户态运行——运行用户程序</li></ul><p>将 CPU 的指令集分为特权指令和非特权指令两类：</p><ul><li><p>特权指令——在内核态时运行的指令<br>对内存空间的访问范围基本不受限制，不仅能访问用户存储空间，也能访问系统存储空间，<br>特权指令只允许操作系统使用，不允许应用程序使用，否则会引起系统混乱。<br>特权指令：启动IO、内存清零、修改程序状态字、设置时钟、允许/禁止中断、停机；</p></li><li><p>非特权指令——在用户态时运行的指令<br>一般应用程序所使用的都是非特权指令，它只能完成一般性的操作和任务，不能对系统中的硬件和软件直接进行访问，其对内存的访问范围也局限于用户空间。<br>非特权指令：控制转移、算术运算、访管指令、取数指令</p></li></ul><p><strong>UNIX</strong> 系统把进程的执行状态分为两种:</p><ul><li>用户态执行，表示进程正处于用户状态中执行；</li><li>核心态执行，表示一个应用进程执行系统调用后，或 I/O 中断、时钟中断后，进程便处于核心态执行。</li></ul><p>差别在于：</p><ul><li>处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所占有的处理机是可被抢占的；</li><li>而处于核心态执行中的进程，则能访问所有的内存空间和对象，且所占用的处理机是不允许被抢占的。 </li></ul><p><strong>注意</strong></p><p>用户态切换到内核态的唯一途径——&gt;中断/异常/陷入/系统调用（就是陷入指令）<br>内核态切换到用户态的途径——&gt;设置程序状态字</p><p>注意一条特殊的指令——陷入指令（又称为访管指令，因为内核态也被称为管理态，访管就是访问管理态）。该指令给用户提供接口，用于调用操作系统的服务。</p><h2 id="12-2-缓冲区溢出"><a href="#12-2-缓冲区溢出" class="headerlink" title="12.2. 缓冲区溢出"></a>12.2. 缓冲区溢出</h2><p>缓冲区溢出是指当计算机向缓冲区内填充数据时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</p><p><strong>危害</strong><br>而缓冲区溢出中，最为危险的是堆栈溢出，因为入侵者可以利用堆栈溢出，在函数返回时改变返回程序的地址，让其跳转到任意地址；<br>带来的危害一种是程序崩溃导致拒绝服务，另外一种就是跳转并且执行一段恶意代码，比如得到shell，然后为所欲为。通过往程序的缓冲区写超出其长度的内容，造成缓冲区的溢出，从而破坏程序的堆栈，使程序转而执行其它指令，以达到攻击的目的。</p><p>造成缓冲区溢出的主原因是程序中没有仔细检查用户输入的参数。</p><h2 id="12-3-中断与轮询"><a href="#12-3-中断与轮询" class="headerlink" title="12.3. 中断与轮询"></a>12.3. 中断与轮询</h2><ul><li><p>中断是指在计算机执行期间，系统内发生任何非寻常的或非预期的急需处理事件，使得CPU暂时中断当前正在执行的程序而转去执行相应的事件处理程序。待处理完毕后又返回原来被中断处继续执行或调度新的进程执行的过程。<br>中断和轮询的特点</p></li><li><p>对I/O设备的程序轮询的方式，是早期的计算机系统对I/O设备的一种管理方式。它定时对各种设备轮流询问一遍有无处理要求。轮流询问之后，有要求的，则加以处理。在处理I/O设备的要求之后，处理机返回继续工作。尽管轮询需要时间，但轮询要比I/O设备的速度要快得多，所以一般不会发生不能及时处理的问题。当然，再快的处理机，能处理的输入输出设备的数量也是有一定限度的。而且，程序轮询毕竟占据了CPU相当一部分处理时间，因此，程序轮询是一种效率较低的方式，在现代计算机系统中已很少应用。</p></li></ul><p>轮询——效率低，等待时间很长，CPU利用率不高。<br>中断——容易遗漏一些问题，CPU利用率高。</p><h2 id="12-4-临界区"><a href="#12-4-临界区" class="headerlink" title="12.4. 临界区"></a>12.4. 临界区</h2><p>资源的共享有两种方式：互斥共享和同时访问。<br>临界资源：一次仅允许一个进程使用的资源，包括硬件和软件<br>临界区：每个进程中访问临界资源的那段程序。每次只准许一个进程进入临界区，进入后不允许其他进程进入。</p><ol><li>如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入；</li><li>任何时候，处于临界区内的进程不可多于一个。如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待；</li><li>进入临界区的进程要在有限时间内退出，以便其它进程能及时进入自己的临界区；</li><li>如果进程不能进入自己的临界区，则应让出CPU，避免进程出现“忙等”现象。</li></ol><h2 id="12-5-进程和线程的区别"><a href="#12-5-进程和线程的区别" class="headerlink" title="12.5. 进程和线程的区别"></a>12.5. 进程和线程的区别</h2><ul><li><p>进程是具有一定功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源调度和分配的一个独立单位。</p></li><li><p>线程是进程的实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。</p></li><li><p>资源分配给进程，同一进程的所有线程共享该进程的所有资源。 同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量</p></li><li><p>处理机分给线程，即真正在处理机上运行的是线程</p></li><li><p>进程是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</p></li><li><p>线程是CPU调度和分派的基本单位，用于保证程序的 实时性，实现进程内部的并发；</p></li><li><p>一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在；</p></li><li><p>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。</p></li><li><p>通信方式不同。线程之间的通信比较方便，同一进程下的线程共享数据（比如全局变量，静态变量）。而进程之间的通信只能通过进程通信的方式进行</p></li></ul><h2 id="12-6-程序与进程的区别"><a href="#12-6-程序与进程的区别" class="headerlink" title="12.6. 程序与进程的区别"></a>12.6. 程序与进程的区别</h2><ul><li>进程是一个动态概念，而程序是一个静态概念。</li><li>进程具有并行特征，而程序不反映执行所以没有并行特征</li><li>进程是竞争计算机系统资源的基本单位，而程序不反映执行也就不会竞争计算机系统资源</li><li>不同的进程可以包含同一程序，只要该程序所对应的数据集不同。</li></ul><h2 id="12-7-进程和线程的上下文切换代价"><a href="#12-7-进程和线程的上下文切换代价" class="headerlink" title="12.7. 进程和线程的上下文切换代价"></a>12.7. 进程和线程的上下文切换代价</h2><p>进程切换分两步：</p><ul><li>切换页目录以使用新的地址空间（进程）</li><li>切换内核栈和硬件上下文（进程、线程）</li></ul><p>切换的性能消耗：</p><ul><li>线程上下文切换虚拟内存空间依然是相同的，但是进程切换是不同的。这两种上下文切换的处理都是通过操作系统内核来完成的。</li><li>上下文的切换会扰乱处理器的缓存机制。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（processor’s Translation Lookaside Buffer (TLB)）或者相当的神马东西会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题。<h2 id="12-8-进程同步的原则"><a href="#12-8-进程同步的原则" class="headerlink" title="12.8. 进程同步的原则"></a>12.8. 进程同步的原则</h2></li><li>空闲让进；</li><li>忙则等待（保证对临界区的互斥访问）；</li><li>有限等待（有限代表有限的时间，避免死等）；</li><li>让权等待（当进程不能进入自己的临界区时，应该释放处理机，以免陷入忙等状态）</li></ul><p>死等状态：<br>进程在有限时间内根本不能进入临界区，而一直在尝试进入，陷入一种无结果的等待状态。<br>（没有进入临界区的正在等待的某进程根本无法获得临界资源而进入进程，这种等待是无结果的，是死等状态）-&gt; 这个时候应该放弃这个无结果的事情，保证自己等待的时间是有限的</p><p>忙等状态：<br>当一个进程正处在某临界区内，任何试图进入其临界区的进程都必须进入代码连续循环，陷入忙等状态。连续测试一个变量直到某个值出现为止，称为忙等。<br>（没有进入临界区的正在等待的某进程不断的在测试循环代码段中的变量的值，占着处理机而不释放，这是一种忙等状态）-&gt; 这个时候应该释放处理机让给其他进程</p><p>有限等待：对要求访问临界资源的进程，应保证有限时间内能进入自己的临界区，以免陷入“死等”状态（受惠的是进程自己）</p><p>让权等待：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”状态（受惠的是其他进程）</p><h2 id="12-9-进程同步"><a href="#12-9-进程同步" class="headerlink" title="12.9. 进程同步"></a>12.9. 进程同步</h2><p>在OS中引入进程后，一方面使系统的吞吐量和资源的利用率得到提升，另一方面也使得系统变得复杂，如果没有合理的方式对进程进行妥善的管理，必然会引起进程对系统资源的无序竞争，使系统变得混乱；为了实现对并发进程的有效管理，在多道程序系统中引入了同步机制，常见的同步机制有：硬件同步机制、信号量机制、管程机制等，利用它们确保程序执行的可再现性；</p><h3 id="12-9-1-硬件同步机制"><a href="#12-9-1-硬件同步机制" class="headerlink" title="12.9.1. 硬件同步机制"></a>12.9.1. 硬件同步机制</h3><p>通常计算机会提供一些特殊的硬件指令，允许对一个字中的内容进行检测和修正，或者对两个字的内容进行交换；对临界区的管理，可以视为对“锁”的管理：当“锁”开的时候，就允许进入，然后把“锁”关上；当“锁”关上的时候，就只能在外面等待；显然，对“锁”的检测（相当于进入区代码）和打开“锁”（相当于临界区）的操作必须是连续的；常见的硬件同步机制有：</p><p><strong>关中断</strong></p><p>是实现互斥的最简单方法之一。在进入锁检测之前，关闭中断，直到完成锁检测并上锁之后才打开中断。这样，进程在临界区执行期间，计算机系统不响应中断，从而不会引发调度，自然不会发生进程或者线程切换。但是关中断的方法有许多缺点：</p><ul><li>滥用关中断权利，可能会造成严重后果；</li><li>关中断时间过长，会影响系统效率，限制处理器交叉执行程序的能力；</li><li>关中断的方法不适合多CPU系统；</li></ul><p><strong>Test-and-Set</strong></p><p>TS指令的一般描述如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean TS(boolean *lock)&#123;</span><br><span class="line">    boolean old;</span><br><span class="line">    old&#x3D;*lock;</span><br><span class="line">    *lock&#x3D;true;</span><br><span class="line">    return old;</span><br><span class="line">&#125;</span><br><span class="line">相应的进入区代码为：</span><br><span class="line">while(TS(&amp;lock));</span><br></pre></td></tr></table></figure><p>TS指令中，当lock为false时，就将其设置为true，然后返回false;当lock为true时，就返回true；返回false表示资源可用；返回true表示资源不可用；</p><p>上面这段代码实现的功能：如果lock为false，那么设置它为true，但是要返回false；如果lock为true，不做改变，那么仍旧返回true；但实际上，它是这么做的：不论lock是什么，都把它设置为true。而返回它原来的值；</p><p><strong>Swap</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Swap(boolean* lock,boolean* key)&#123;</span><br><span class="line">    boolean temp&#x3D;*lock;</span><br><span class="line">    *lock&#x3D;*key;</span><br><span class="line">    *key&#x3D;temp;</span><br><span class="line">&#125;</span><br><span class="line">相应的进入区代码为：</span><br><span class="line">key&#x3D;true;</span><br><span class="line">do&#123;</span><br><span class="line">    Swap(&amp;lock,&amp;key);</span><br><span class="line">&#125;while(key!&#x3D;false);</span><br><span class="line">&#x2F;&#x2F;进入临界区</span><br></pre></td></tr></table></figure><p>Swap指令中，do-while循环中的退出条件是key为false ；而key为false 意味着lock为false，表示资源可用；当lock为true的时候，key就为true；那么循环就会一直进行下去；</p><p>利用TS机制和Swap机制，都会让进程处于忙等状态，并不符合同步机制的要求；（准确的说，不是实现不了同步，而是效率不高，不太高效~）</p><h3 id="12-9-2-信号量同步机制"><a href="#12-9-2-信号量同步机制" class="headerlink" title="12.9.2. 信号量同步机制"></a>12.9.2. 信号量同步机制</h3><p>信号量同步机制由Dijkstra（很厉害的大神，单源最短路劲算法就是他提出的）；信号量机制已被广泛应用到单处理机和多处理机系统以及计算机网络中；</p><p><strong>整型信号量</strong></p><p>整型信号量S表示资源数目，除初始化外，仅能通过两个标准的原子操作进行修改：wait(S)和signal(S)；这两个操作长期以来也别称为P、V操作；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wait(S)&#123;</span><br><span class="line">    while(S&lt;&#x3D;0);</span><br><span class="line">    S--；</span><br><span class="line">&#125;</span><br><span class="line">signal(S)&#123;</span><br><span class="line">    S++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实问题就是，wait和signal两个原子操作仍旧会产生“忙等”——进程不断测试，一直问，你说烦不烦？</p><p><strong>记录型信号量</strong></p><p>记录型信号量机制是一种不存在忙等现象的进程同步机制；但是采取了让权等待策略后，就会有多个进程等待访问统一资源的情况，于是还需要把这些进城组织起来，于是除了S用来表示资源的数量外，还需要一个指针；这也是记录型信号量的名称来源：使用了记录型的数据结构；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">    int value;</span><br><span class="line">    sturct process_control_block *list;</span><br><span class="line">&#125;semaphore;</span><br><span class="line">wait(semaphore *S)&#123;</span><br><span class="line">    S-&gt;value--;</span><br><span class="line">    if(S-&gt;value&lt;0)&#123;</span><br><span class="line">        block(S-&gt;list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">signal(semaphore *S)&#123;</span><br><span class="line">    S-&gt;value++;</span><br><span class="line">    if(S-&gt;value&lt;&#x3D;0)&#123;</span><br><span class="line">        wakeup(S-&gt;list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记录型信号量中，value不仅指示资源的数量，由于每次wait操作value都会递减，所以value的值会反映出等待资源的进程有多少个。在signal中，value经过自增后，如果还&lt;=0，说明还有进程在等待该资源，所以需要wakeup一个进程。</p><p><strong>AND型信号量</strong></p><p>前面所述的进程互斥问题针对的是多个并发进程共享一个临界资源的情况，但是如果<strong>多个进程共享多个资源</strong>时仍旧采取这样单个的分配方法，就有可能发生死锁现象；为了避免这样的现象，提出来AND型信号量：将进程在整个运行过程中需要的所有资源，要么一次性全部分配给进程，然后使用完后再一起释放。要么一个都不分配，这样便可以避免死锁现象。wait和signal操作要做出相应改变。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Swait(S1,S2,S3,S4,S5....)&#123;</span><br><span class="line">while(true)&#123;</span><br><span class="line">        if(S1&gt;&#x3D;1&amp;&amp;S2&gt;&#x3D;1...)&#123;</span><br><span class="line">       for(i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">            Si--;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">            &#x2F;&#x2F;找到第一个小于等于0的Si,然后将进程放置到与其相关的等待队列中</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Ssignal(S1,S2...Sn)&#123;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        for(i&#x3D;0;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">            Si++;</span><br><span class="line">            &#x2F;&#x2F;唤醒一个等待Si资源的进程——该进程将进入Swait中的while循环里继续判断其他资源是否可用。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>信号量集</strong></p><p>前面介绍的几种信号量同步机制都是对某一资源进行一个单位的申请和释放。当一次需要N个的时候，就需要进行N次请求，这不但低效而且容易发生死锁情况；还有些情况下，为了保证系统的安全性，当所申请的资源低于某个值时，就需要停止对该类资源的分配。解决办法就是当进程申请某类临界资源时，都必须测试资源的数量，判断是否大于可分配的下限值，然后决定是否分配；</p><p>基于上述提到的两点问题，需要对AND信号量机制加以扩充，对进程所申请的所有资源以及每类资源不同的资源需求量，再一次PV原语操作中完成申请和释放。对信号量Si的测试值不再是1，而是ti。当Si&lt;=ti时就不再分配；同时，进程需要传递给wait方法每类资源所需要的数目，由此形成一般化的“信号量集”机制；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Swait(S1,t1,d1....Sn,tn,dn);表示对Si类资源的需求是di个，当Si的数量小于ti时就不再分配；</span><br><span class="line">Ssignal(S1,d1....Sn,dn);表示归还Si类资源的数目是di个；</span><br></pre></td></tr></table></figure><p>特殊的，Swait(S,d,d)表示信号量集中只有一个信号量；它允许每次申请d个资源，当资源数量小于d时不予分配；</p><p>Swait(S,1,1)表示普通的一般记录型信号量；</p><p><strong>信号量的应用</strong></p><p>实现进程互斥：基本操作；<br>实现前驱关系：当进程A中的X1操作结束后才进行进程B中的X2操作，像这种需求即为前驱关系。可以设置一种虚拟的资源S，并设置其状态为不可用，然后在X1的后面加上signal(S)，在X2语句前加上wait（S），以此实现这种执行顺序上的控制；</p><h3 id="12-9-3-管程机制"><a href="#12-9-3-管程机制" class="headerlink" title="12.9.3. 管程机制"></a>12.9.3. 管程机制</h3><p>信号量机制虽然是一种既方便又实用的进程同步机制，但是要访问临界资源的进程需要自备同步操作wait（S）和signal(S)，这就使得对共享资源进行访问的代码遍布各个进程，不利于系统管理，还增加系统死锁的风险；管程机制是一种解决该问题的方法；</p><p>操作系统的作用之一就是实现对计算机系统资源的抽象，管程机制使用少量的信息和对该资源所执行的操作来表征该资源，所以共享系统资源就变为了共享数据结构，并将对这些共享数据结构的操作定义为一组过程。进程对共享资源的申请、释放和其他操作必须通过这组过程。代表共享资源的数据结构以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序共同构成了一个操作系统的资源管理模块，我们称之为管程；</p><p>管程由四部分组成：名称、局部于管程的共享数据结构说明、对该数据结构进行操作的一组过程、对局部于管程的共享数据结构设置初始值的语句；</p><p>所有进程访问临界资源时，都只能通过管程间接访问，而管程每次只准许一个进程进入管程，从而实现互斥。管程体现了面向对象程序设计的思想；具有：模块化，即管程是一个独立的基本单位，可单独编译；抽象数据类型，不仅有数据还有对数据的操作；信息隐蔽，管程中的数据结构只能被管程中的过程访问，这些过程也是在管程内部定义的，而管程之外的进程只需调用而无需了解其内部的具体实现细节。（这样，原来遍布系统的共享资源的访问代码，就集中到管程中啦）；</p><p><strong>管程和进程的对比</strong></p><p>两者都定义了各自的数据结构，但是管程定义的数据结构是对公用资源的抽象，进程定义的是私有数据结构PCB；<br>两者都有对各自数据结构的操作，但是管程的操作是为了实现同步和初始化，进程是由顺序程序执行有关操作；<br>进程的目的是在于实现系统的并发，而管程的目的是解决共享资源的互斥访问；<br>进程是主动工作的，管程需要被其他程序使用，属于被动工作的；<br>进程有动态性，管程是操作系统中的一个资源管理模块；</p><p>管程中还有一个比较重要的概念就是条件变量。当一个进程进入了管程但在管程中被阻塞或者挂起，此时该进程需要释放对管程的占有，并且根据阻塞或者挂起的原因，也就是条件变量，进入相应的等待队列，等待其他进程的唤醒。条件变量x具有两种操作：x.wait()和x.signal()；</p><p>x.wait()：正在调用管程的进程因x条件而需要被挂起或者阻塞，则调用x.wait()将自己插入到条件变量x的等待队列上并释放管程，直到x条件变化；</p><p>x.signal()：正在调用管程的进程发现x条件发生了变化，重新启动一个因x而阻塞的进程，如果有多个进程因x而阻塞，也只能选择一个；</p><p>如果进程Q因为x条件而处于阻塞状态，当P调用管程时，执行了x.signal()操作后，Q重新启动，此时P和Q到底谁来继续拥有管程呢？答案是两者均可；</p><h2 id="12-10-进程通信"><a href="#12-10-进程通信" class="headerlink" title="12.10. 进程通信"></a>12.10. 进程通信</h2><p>进程通信，是指进程之间的信息交换（信息量少则一个状态或数值，多者则是成千上万个字节）。因此，对于用信号量进行的进程间的互斥和同步，由于其所交换的信息量少而被归结为低级通信</p><p>所谓高级进程通信指：用户可以利用操作系统所提供的一组通信命令传送大量数据的一种通信方式。操作系统隐藏了进程通信的实现细节。或者说，通信过程对用户是透明的</p><p>高级通信机制可归结为三大类：</p><ul><li><p>共享存储器系统（存储器中划分的共享存储区）；实际操作中对应的是“剪贴板”（windows剪贴板实际上是系统维护管理的一块内存区域）的通信方式。</p></li><li><p>消息传递系统（进程间的数据交换以消息（message）为单位，当今最流行的微内核操作系统中，微内核与服务器之间的通信，无一例外地都采用了消息传递机制。应用举例：邮槽（MailSlot）是基于广播通信体系设计出来的，它采用无连接的不可靠的数据传输。邮槽是一种单向通信机制，创建邮槽的服务器进程读取数据，打开邮槽的客户机进程写入数据</p></li><li><p>管道通信系统（管道即：连接读写进程以实现他们之间通信的共享文件（pipe文件，类似先进先出的队列，由一个进程写，另一进程读））。实际操作中，管道分为：匿名管道、命名管道。</p><ul><li>匿名管道是一个未命名的、单向管道，通过父进程和一个子进程之间传输数据。匿名管道只能实现本地机器上两个进程之间的通信，而不能实现跨网络的通信。</li><li>命名管道不仅可以在本机上实现两个进程间的通信，还可以跨网络实现两个进程间的通信</li></ul></li><li><p>管道：管道是单向的、先进先出的、无结构的、固定大小的字节流，它把一个进程的标准输出和另一个进程的标准输入连接在一起。写进程在管道的尾端写入数据，读进程在管道的道端读出数据。数据读出后将从管道中移走，其它读进程都不能再读到这些数据。管道提供了简单的流控制机制。进程试图读空管道时，在有数据写入管道前，进程将一直阻塞。同样地，管道已经满时，进程再试图写管道，在其它进程从管道中移走数据之前，写进程将一直阻塞。管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；</p></li><li><p>信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生，调用特定的函数处理；</p></li><li><p>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其它进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段</p></li><li><p>消息队列：是一个在系统内核中用来保存消 息的队列，它在系统内核中是以消息链表的形式出现的。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点</p></li><li><p>共享内存：共享内存允许两个或多个进程访问同一个逻辑内存。这一段内存可以被两个或两个以上的进程映射至自身的地址空间中，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取读出，从而实现了进程间的通信。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。共享内存是最快的IPC方式，它是针对其它进程间通信方式运行效率低而专门设计的。它往往与其它通信机制（如信号量）配合使用，来实现进程间的同步和通信</p></li><li><p>套接字：套接字也是一种进程间通信机制，与其它通信机制不同的是，它可用于网络中不同机器间的进程通信</p></li></ul><h2 id="12-11-线程同步的方式"><a href="#12-11-线程同步的方式" class="headerlink" title="12.11. 线程同步的方式"></a>12.11. 线程同步的方式</h2><ul><li>互斥量 Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</li><li>信号量 Semphare：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</li><li>事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作<h2 id="12-12-死锁"><a href="#12-12-死锁" class="headerlink" title="12.12. 死锁"></a>12.12. 死锁</h2><h3 id="12-12-1-死锁的概念"><a href="#12-12-1-死锁的概念" class="headerlink" title="12.12.1. 死锁的概念"></a>12.12.1. 死锁的概念</h3>　　在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。<h3 id="12-12-2-死锁产生的四个必要条件"><a href="#12-12-2-死锁产生的四个必要条件" class="headerlink" title="12.12.2. 死锁产生的四个必要条件"></a>12.12.2. 死锁产生的四个必要条件</h3></li><li>互斥：至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他申请使用该资源，那么申请进程必须等到该资源被释放为止；</li><li>占有并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有；</li><li>非抢占：进程不能被抢占，即资源只能被进程在完成任务后自愿释放</li><li>循环等待：若干进程之间形成一种头尾相接的环形等待资源关系<h3 id="12-12-3-死锁的处理"><a href="#12-12-3-死锁的处理" class="headerlink" title="12.12.3. 死锁的处理"></a>12.12.3. 死锁的处理</h3>　　解决死锁的基本方法主要有 预防死锁、避免死锁、检测死锁、解除死锁 、鸵鸟策略 等。</li></ul><ol><li>死锁预防<br>　　<br>　　死锁预防的基本思想是 只要确保死锁发生的四个必要条件中至少有一个不成立，就能预防死锁的发生，具体方法包括：</li></ol><ul><li>打破互斥条件：允许进程同时访问某些资源。但是，有些资源是不能被多个进程所共享的，这是由资源本身属性所决定的，因此，这种办法通常并无实用价值。</li><li>打破占有并等待条件：可以实行资源预先分配策略(进程在运行前一次性向系统申请它所需要的全部资源，若所需全部资源得不到满足，则不分配任何资源，此进程暂不运行；只有当系统能满足当前进程所需的全部资源时，才一次性将所申请资源全部分配给该线程)或者只允许进程在没有占用资源时才可以申请资源（一个进程可申请一些资源并使用它们，但是在当前进程申请更多资源之前，它必须全部释放当前所占有的资源）。但是这种策略也存在一些缺点：在很多情况下，无法预知一个进程执行前所需的全部资源，因为进程是动态执行的，不可预知的；同时，会降低资源利用率，导致降低了进程的并发性。</li><li>打破非抢占条件：允许进程强行从占有者哪里夺取某些资源。也就是说，但一个进程占有了一部分资源，在其申请新的资源且得不到满足时，它必须释放所有占有的资源以便让其它线程使用。这种预防死锁的方式实现起来困难，会降低系统性能。</li><li>打破循环等待条件：实行资源有序分配策略。对所有资源排序编号，所有进程对资源的请求必须严格按资源序号递增的顺序提出，即只有占用了小号资源才能申请大号资源，这样就不回产生环路，预防死锁的发生。</li></ul><ol start="2"><li>死锁避免　<br>　　动态地检测资源分配状态，以确保系统处于安全状态，只有处于安全状态时才会进行资源的分配。所谓安全状态是指：即使所有进程突然请求需要的所有资源，也能存在某种对进程的资源分配顺序，使得每一个进程运行完毕。</li><li>死锁检测<br>检测有向图是否存在环；或者使用类似死锁避免的检测算法。</li><li>死锁解除<br>　　死锁解除的常用两种方法为进程终止和资源抢占。所谓进程终止是指简单地终止一个或多个进程以打破循环等待，包括两种方式：终止所有死锁进程和一次只终止一个进程直到取消死锁循环为止；所谓资源抢占是指从一个或多个死锁进程那里抢占一个或多个资源，此时必须考虑三个问题：</li></ol><ul><li>利用抢占：挂起某些进程，并抢占它的资源。但应防止某些进程被长时间挂起而处于饥饿状态；</li><li>利用回滚：让某些进程回退到足以解除死锁的地步，进程回退时自愿释放资源。要求系统保持进程的历史信息，设置还原点；</li><li>利用杀死进程：强制杀死某些进程直到死锁解除为止，可以按照优先级进行。<h2 id="12-13-进程状态"><a href="#12-13-进程状态" class="headerlink" title="12.13. 进程状态"></a>12.13. 进程状态</h2></li><li>就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源；</li><li>运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数；</li><li>阻塞状态： 进程等待某种条件，在条件满足之前无法执行；<br><img src="/images/os-interview/i1.jpg"></li></ul><h2 id="12-14-线程状态"><a href="#12-14-线程状态" class="headerlink" title="12.14. 线程状态"></a>12.14. 线程状态</h2><p>　　在 Java虚拟机 中，线程从最初的创建到最终的消亡，要经历若干个状态：创建(new)、就绪(runnable/start)、运行(running)、阻塞(blocked)、等待(waiting)、时间等待(time waiting) 和 消亡(dead/terminated)。在给定的时间点上，一个线程只能处于一种状态，各状态的含义如下图所示：<br>　　　　　　　　　　<br>　　线程各状态之间的转换如下：<br><img src="/images/os-interview/i2.jpg"></p><h2 id="12-15-进程调度"><a href="#12-15-进程调度" class="headerlink" title="12.15. 进程调度"></a>12.15. 进程调度</h2><p><strong>调度种类</strong></p><ul><li>高级调度：(High-Level Scheduling)又称为作业调度，它决定把后备作业调入内存运行</li><li>中级调度：(Intermediate-Level Scheduling)交换调度。又称为在虚拟存储器中引入，在内、外存对换区进行进程对换</li><li>低级调度：(Low-Level Scheduling)又称为进程调度，它决定就绪队列的某进程获得CPU</li><li>线程调度</li></ul><p><strong>非抢占式调度与抢占式调度</strong></p><ul><li>非抢占式：分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生进程调度进程调度某事件而阻塞时，才把处理机分配给另一个进程</li><li>抢占式：操作系统将正在运行的进程强行暂停，由调度程序将CPU分配给其他就绪进程的调度方式</li></ul><p><strong>调度算法</strong></p><ul><li>FIFO或First Come, First Served (FCFS)先来先服务</li></ul><p>调度的顺序就是任务到达就绪队列的顺序<br>公平、简单(FIFO队列)、非抢占、不适合交互式<br>未考虑任务特性，平均等待时间可以缩短</p><ul><li>Shortest Job First (SJF)</li></ul><p>最短的作业(CPU区间长度最小)最先调度<br>SJF可以保证最小的平均等待时间，但难以知道下一个CPU区间长度</p><ul><li>Shortest Remaining Job First (SRJF)</li></ul><p>SJF的可抢占版本，比SJF更有优势<br>SJF(SRJF): 如何知道下一CPU区间大小？根据历史进行预测: 指数平均法</p><ul><li>优先权调度</li></ul><p>每个任务关联一个优先权，调度优先权最高的任务<br>注意：优先权太低的任务一直就绪，得不到运行，出现“饥饿”现象</p><ul><li>Round-Robin(RR)轮转调度算法</li></ul><p>设置一个时间片，按时间片来轮转调度（“轮叫”算法）<br>优点: 定时有响应，等待时间较短；缺点: 上下文切换次数较多<br>时间片太大，响应时间太长；吞吐量变小，周转时间变长；当时间片过长时，退化为FCFS</p><ul><li>多级队列调度</li></ul><p>按照一定的规则建立多个进程队列，一个进程根据自身属性被永久地分配到一个队列中。<br>不同的队列有固定的优先级（高优先级有抢占权）<br>不同的队列可以给不同的时间片和采用不同的调度方法<br>存在问题1：没法区分I/O bound和CPU bound<br>存在问题2：也存在一定程度的“饥饿”现象</p><ul><li>多级反馈队列</li></ul><p>在多级队列的基础上，任务可以在队列之间移动，更细致的区分任务<br>可以根据“享用”CPU时间多少来移动队列，阻止“饥饿”<br>最通用的调度算法，多数OS都使用该方法或其变形，如UNIX、Windows等<br>若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。</p><h2 id="12-16-虚拟内存"><a href="#12-16-虚拟内存" class="headerlink" title="12.16. 虚拟内存"></a>12.16. 虚拟内存</h2><ol><li>内存的发展历程<br>　　没有内存抽象(单进程，除去操作系统所用的内存之外，全部给用户程序使用) —&gt; 有内存抽象（多进程，进程独立的地址空间，交换技术(内存大小不可能容纳下所有并发执行的进程)—&gt; 连续内存分配(固定大小分区(多道程序的程度受限)，可变分区(首次适应，最佳适应，最差适应)，碎片) —&gt; 不连续内存分配（分段，分页，段页式，虚拟内存）</li><li>虚拟内存<br>　　虚拟内存允许执行进程不必完全在内存中。虚拟内存的基本思想是：每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页(Page)，每个页都是一段连续的地址。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。这样，对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上，如图5所示。<br>注意，请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。</li></ol><p><img src="/images/os-interview/i3.jpg">　　<br>　　由图5可以看出，虚拟内存实际上可以比物理内存大。当访问虚拟内存时，会访问MMU（内存管理单元）去匹配对应的物理地址（比如图5的0，1，2）。如果虚拟内存的页并不存在于物理内存中（如图5的3,4），会产生缺页中断，从磁盘中取得缺的页放入内存，如果内存已满，还会根据某种算法将磁盘中的页换出。<br>3. 虚拟内存的应用与优点<br>　　虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。虚拟内存的使用可以带来以下好处：</p><ul><li>在内存中可以保留多个进程，系统并发度提高</li><li>解除了用户与内存之间的紧密约束，进程可以比内存的全部空间还大</li></ul><ol start="4"><li>抖动<br>　　抖动本质上是指频繁的页调度行为，具体来讲，进程发生缺页中断，这时，必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此，会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸（抖动）。<br>　　内存颠簸的解决策略包括：<br>如果是因为页面替换策略失误，可以修改替换算法来解决这个问题；<br>如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量；<br>否则，还剩下两个办法：终止该进程或增加物理内存容量。</li></ol><h2 id="12-17-分页和分段"><a href="#12-17-分页和分段" class="headerlink" title="12.17. 分页和分段"></a>12.17. 分页和分段</h2><p>　　段式存储管理是一种符合用户视角的内存分配管理方案。在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）<br>　　页式存储管理方案是一种用户视角内存与物理内存相分离的内存分配管理方案。在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的帧，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）。<br><strong>区别</strong></p><ul><li>目的不同：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息；</li><li>大小不同：页的大小固定且由系统决定，而段的长度却不固定，由其所完成的功能决定；</li><li>地址空间不同： 段向用户提供二维地址空间；页向用户提供的是一维地址空间；</li><li>信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；</li><li>内存碎片：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。</li></ul><h2 id="12-18-页面置换算法"><a href="#12-18-页面置换算法" class="headerlink" title="12.18. 页面置换算法"></a>12.18. 页面置换算法</h2><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘中来腾出空间。页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p><ul><li>最佳页面置换算法OPT（Optimal replacement algorithm）：置换以后不需要或者最远的将来才需要的页面，是一种理论上的算法，是最优策略；</li><li>先进先出FIFO：置换在内存中驻留时间最长的页面。缺点：有可能将那些经常被访问的页面也被换出，从而使缺页率升高；</li><li>二次机会算法SCR：按FIFO选择某一页面，若其访问位为1，给第二次机会，并将访问位置0；</li><li>时钟算法 Clock：SCR中需要将页面在链表中移动（第二次机会的时候要将这个页面从链表头移到链表尾），时钟算法使用环形链表，再使用一个指针指向最老的页面，避免了移动页面的开销；</li><li>最近未使用算法NRU（Not Recently Used）：检查访问位R、修改位M，优先置换R=M=0，其次是（R=0, M=1）；</li><li>最近最少使用算法LRU（Least Recently Used）：置换出未使用时间最长的一页；实现方式：维护时间戳，或者维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</li><li>最不经常使用算法NFU：置换出访问次数最少的页面<h2 id="12-19-局部性原理"><a href="#12-19-局部性原理" class="headerlink" title="12.19. 局部性原理"></a>12.19. 局部性原理</h2></li><li>时间上的局部性：最近被访问的页在不久的将来还会被访问；</li><li>空间上的局部性：内存中被访问的页周围的页也很可能被访问。</li></ul><h1 id="13-参考链接"><a href="#13-参考链接" class="headerlink" title="13. 参考链接"></a>13. 参考链接</h1><ul><li><a href="https://blog.csdn.net/weixin_44751294?spm=1001.2014.3001.5509">CSDN-Clichong</a></li><li><a href="https://blog.csdn.net/justloveyou_/article/details/78304294">面试/笔试第二弹 —— 操作系统面试问题集锦</a></li><li><a href="https://blog.csdn.net/qq_41371349/article/details/108042666">【操作系统】死等状态、忙等状态、有限等待、让权等待</a></li><li><a href="https://zhuanlan.zhihu.com/p/86629244">操作系统面试题目总结</a></li><li><a href="https://blog.csdn.net/qq_29996285/article/details/88078906">面试考点——用户态和内核态的区别</a></li><li><a href="https://blog.csdn.net/slx3320612540/article/details/80726305">操作系统之进程同步和通信——进程同步的基本概念及其实现方式、进程通信及其实现方式</a></li><li><a href="https://www.nowcoder.com/discuss/22395">面试CS基础之操作系统</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;概述、启动中断异常和系统调用、连续内存分配、非连续内存分配、虚拟内存、页面置换算法、进程、处理器调度、同步互斥问题、死锁问题。&lt;/p&gt;
&lt;p&gt;5.5万字，252张图，150页，超长总结。&lt;/p&gt;</summary>
    
    
    
    <category term="Study" scheme="https://memorykk.cn/categories/Study/"/>
    
    
    <category term="OS" scheme="https://memorykk.cn/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统引论</title>
    <link href="https://memorykk.cn/os.html"/>
    <id>https://memorykk.cn/os.html</id>
    <published>2021-03-16T07:34:23.000Z</published>
    <updated>2021-03-24T11:35:58.044Z</updated>
    
    <content type="html"><![CDATA[<p>准备的书太拉跨，不准备继续总结了</p><span id="more"></span><hr><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA">1. 操作系统引论</a><ul><li><a href="#1-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9B%AE%E6%A0%87">1.1. 操作系统的目标</a></li><li><a href="#1-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8">1.2. 操作系统的作用</a></li><li><a href="#1-3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B">1.3. 操作系统的发展过程</a><ul><li><a href="#1-3-1-%E6%9C%AA%E9%85%8D%E7%BD%AE%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F">1.3.1. 未配置操作系统的计算机系统</a><ul><li><a href="#1-3-1-1-%E4%BA%BA%E5%B7%A5%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F">1.3.1.1. 人工操作方式</a></li><li><a href="#1-3-1-2-%E8%84%B1%E6%9C%BA%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%96%B9%E5%BC%8F">1.3.1.2. 脱机输入输出方式</a></li></ul></li><li><a href="#1-3-2-%E5%8D%95%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F">1.3.2. 单道批处理系统</a></li><li><a href="#1-3-3-%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F">1.3.3. 多道批处理系统</a></li><li><a href="#1-3-4-%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F">1.3.4. 分时系统</a></li><li><a href="#1-3-5-%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F">1.3.5. 实时系统</a></li><li><a href="#1-3-6-%E5%BE%AE%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">1.3.6. 微机操作系统</a></li></ul></li><li><a href="#1-4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7">1.4. 操作系统的基本特性</a><ul><li><a href="#1-4-1-%E5%B9%B6%E5%8F%91">1.4.1. 并发</a></li><li><a href="#1-4-2-%E5%85%B1%E4%BA%AB">1.4.2. 共享</a></li><li><a href="#1-4-3-%E8%99%9A%E6%8B%9F">1.4.3. 虚拟</a></li><li><a href="#1-4-4-%E5%BC%82%E6%AD%A5">1.4.4. 异步</a></li></ul></li><li><a href="#1-5-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD">1.5. 操作系统的主要功能</a><ul><li><a href="#1-5-1-%E5%A4%84%E7%90%86%E6%9C%BA%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD">1.5.1. 处理机管理功能</a></li><li><a href="#1-5-2-%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD">1.5.2. 存储器管理功能</a></li><li><a href="#1-5-3-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD">1.5.3. 设备管理功能</a></li><li><a href="#1-5-4-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD">1.5.4. 文件管理功能</a></li><li><a href="#1-5-5-OS%E4%B8%8E%E7%94%A8%E6%88%B7%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8E%A5%E5%8F%A3">1.5.5. OS与用户之间的接口</a></li><li><a href="#1-5-6-%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%96%B0%E5%8A%9F%E8%83%BD">1.5.6. 现代操作系统的新功能</a></li></ul></li><li><a href="#1-6-OS%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">1.6. OS结构设计</a><ul><li><a href="#1-6-1-%E4%BC%A0%E7%BB%9FOS%E7%BB%93%E6%9E%84">1.6.1. 传统OS结构</a><ul><li><a href="#1-6-1-1-%E6%97%A0%E7%BB%93%E6%9E%84OS">1.6.1.1. 无结构OS</a></li><li><a href="#1-6-1-2-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BB%93%E6%9E%84OS">1.6.1.2. 模块化结构OS</a></li><li><a href="#1-6-1-3-%E5%88%86%E5%B1%82%E5%BC%8F%E7%BB%93%E6%9E%84OS">1.6.1.3. 分层式结构OS</a></li></ul></li><li><a href="#1-6-2-%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%BC%8F">1.6.2. 客户服务器模式</a></li><li><a href="#1-6-3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%8A%80%E6%9C%AF">1.6.3. 面向对象的程序设计技术</a></li><li><a href="#1-6-4-%E5%BE%AE%E5%86%85%E6%A0%B8OS%E7%BB%93%E6%9E%84">1.6.4. 微内核OS结构</a><ul><li><a href="#1-6-4-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.6.4.1. 基本概念</a></li><li><a href="#1-6-4-2-%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD">1.6.4.2. 基本功能</a></li><li><a href="#1-6-4-3-%E4%BC%98%E7%BC%BA%E7%82%B9">1.6.4.3. 优缺点</a></li></ul></li></ul></li></ul></li><li><a href="#2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6">2. 进程的描述与控制</a><ul><li><a href="#2-1-%E5%89%8D%E8%B6%8B%E5%9B%BE%E5%92%8C%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C">2.1. 前趋图和程序执行</a><ul><li><a href="#2-1-1-%E5%89%8D%E8%B6%8B%E5%9B%BE">2.1.1. 前趋图</a></li><li><a href="#2-1-2-%E7%A8%8B%E5%BA%8F%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C">2.1.2. 程序顺序执行</a></li><li><a href="#2-1-3-%E7%A8%8B%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C">2.1.3. 程序并发执行</a></li></ul></li><li><a href="#2-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0">2.2. 进程的描述</a><ul><li><a href="#2-2-1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89">2.2.1. 进程的定义</a></li><li><a href="#2-2-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81">2.2.2. 进程的特征</a></li></ul></li><li><a href="#2-3-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E5%8F%8A%E8%BD%AC%E6%8D%A2">2.3. 进程的基本状态及转换</a><ul><li><a href="#2-3-1-%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81">2.3.1. 三种基本状态</a></li><li><a href="#2-3-2-%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2">2.3.2. 状态转换</a></li><li><a href="#2-3-3-%E5%88%9B%E5%BB%BA%E7%8A%B6%E6%80%81%E5%92%8C%E7%BB%88%E6%AD%A2%E7%8A%B6%E6%80%81">2.3.3. 创建状态和终止状态</a></li></ul></li><li><a href="#2-4-%E6%8C%82%E8%B5%B7%E6%93%8D%E4%BD%9C">2.4. 挂起操作</a><!-- /TOC --></li></ul></li></ul><hr><h1 id="1-操作系统引论"><a href="#1-操作系统引论" class="headerlink" title="1. 操作系统引论"></a>1. 操作系统引论</h1><p>操作系统是一组能有效地组织和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序的集合。</p><h2 id="1-1-操作系统的目标"><a href="#1-1-操作系统的目标" class="headerlink" title="1.1. 操作系统的目标"></a>1.1. 操作系统的目标</h2><ul><li>方便性：裸机上难以使用；</li><li>有效性：<strong>提高资源利用率，提高系统吞吐量</strong>；</li><li>可扩充性：适应硬件、体系结构发展；</li><li>开放性：软硬件的兼容性。</li></ul><h2 id="1-2-操作系统的作用"><a href="#1-2-操作系统的作用" class="headerlink" title="1.2. 操作系统的作用"></a>1.2. 操作系统的作用</h2><ul><li>OS作为用户与计算机硬件系统之间的接口。三种使用方式：系统调用、命令、图形窗口；</li><li>OS作为计算机系统资源的管理者。资源分四类：<ul><li>处理机：分配和控制处理机：</li><li>存储器：内存的分配与回收；</li><li>I/O设备：I/O设备的分配与操纵；</li><li>文件：文件的存取、共享、保护；</li></ul></li><li>OS实现了对计算机资源的抽象。通过I/O设备管理软件、文件系统、窗口等多层次抽象，使裸机称为更强的虚机器。不仅实现了功能，而且隐藏了细节。</li></ul><h2 id="1-3-操作系统的发展过程"><a href="#1-3-操作系统的发展过程" class="headerlink" title="1.3. 操作系统的发展过程"></a>1.3. 操作系统的发展过程</h2><h3 id="1-3-1-未配置操作系统的计算机系统"><a href="#1-3-1-未配置操作系统的计算机系统" class="headerlink" title="1.3.1. 未配置操作系统的计算机系统"></a>1.3.1. 未配置操作系统的计算机系统</h3><h4 id="1-3-1-1-人工操作方式"><a href="#1-3-1-1-人工操作方式" class="headerlink" title="1.3.1.1. 人工操作方式"></a>1.3.1.1. 人工操作方式</h4><p>早期的操作方式是由程序员将事先已穿孔的纸带（或卡片），装入纸带输入机（或卡片输入机），再启动它们将纸带（或卡片）上的程序和数据输入计算机，然后启动计算机运行。仅当程序运行完毕并取走计算结果后，才允许下一个用户上机。这种人工操作方式有以下两方面的缺点：</p><ol><li>用户独占全机，即一台计算机的全部资源由上机用户所独占。</li><li>CPU等待人工操作。当用户进行装带（卡）、卸带（卡）等人工操作时，CPU及内存等资源是空闲的。</li></ol><h4 id="1-3-1-2-脱机输入输出方式"><a href="#1-3-1-2-脱机输入输出方式" class="headerlink" title="1.3.1.2. 脱机输入输出方式"></a>1.3.1.2. 脱机输入输出方式</h4><p>为了解决人机矛盾及CPU和I/O设备之间速度不匹配的矛盾，出现了脱机IO技术。该技术是事先将装有用户程序和数据的纸带装入纸带输入机，在一台外围机的控制下，把纸带（卡片）上的数据（程序）输入到磁带上。当CPU需要这些程序和数据时，再从磁带上高速地调入内存。</p><p><img src="/images/os/offLine.png"></p><p>由于程序和数据的输入和输出都是在外围机的控制下完成的，或者说，它们是在脱离主机的情况下进行的，故称为脱机输入输出方式。反之，把在主机的直接控制下进行输入输出的方式称为联机输入/输出方式。<br>优点是：</p><ul><li>减少了CPU的空闲时间：外围机操作并不占用主机时间；</li><li>提高了I/O速度。</li></ul><h3 id="1-3-2-单道批处理系统"><a href="#1-3-2-单道批处理系统" class="headerlink" title="1.3.2. 单道批处理系统"></a>1.3.2. 单道批处理系统</h3><p><strong>处理过程</strong><br>为实现对作业的连续处理，先把一批作业以脱机方式输入到磁带上，配上监督程序。首先由监督程序将磁带上的第一个作业装入内存，并把运行控制权交给该作业；当该作业处理完成时，又把控制权交还给监督程序，再由监督程序把磁带上的第二个作业调入内存。计算机系统就这样自动地一个作业紧接一个作业地进行处理，直至磁带上的所有作业全部完成，这样便形成了早期的批处理系统。虽然系统对作业的处理是成批进行的，但在内存中始终只保持一道作业，故称为单道批处理系统。</p><p><img src="/images/os/simpleBatchProcess.png"></p><p>旨在解决人机矛盾和CPU与IO设备速度不匹配矛盾的过程中形成的，提高系统资源的利用率和系统吞吐量。</p><p><strong>缺点</strong><br>系统中的资源得不到充分的利用。因为在内存中仅有一道程序，每逢该程序在运行中发出I/O请求后，CPU便处于等待状态，必须在其I/O完成后才继续运行。又因I/O设备的低速性，更使CPU的利用率显著降低。</p><h3 id="1-3-3-多道批处理系统"><a href="#1-3-3-多道批处理系统" class="headerlink" title="1.3.3. 多道批处理系统"></a>1.3.3. 多道批处理系统</h3><p><strong>处理过程</strong><br>用户所提交的作业先存放在外存上，并排成一个队列，称为“后备队列”。然后由作业调度程序按一定的算法，从后备队列中选择若干个作业调入内存，使它们共享CPU和系统中的各种资源。由于同时在内存中装有若干道程序，这样便可以在运行程序A时，利用其因I/O操作而暂停执行时的CPU空档时间，再调度另一道程序B运行，同样可以利用程序B在I/O操作时的CPU空档时间，再调度程序C运行，使多道程序交替地运行，这样便可以保持CPU处于忙碌状态。</p><p><img src="/images/os/multiBatchProcess.png"></p><p><strong>优缺点</strong></p><ul><li>资源利用率高。引入多道批处理能使多道程序交替运行，以保持CPU处于忙碌状态；在内存中装入多道程序可提高内存的利用率；此外还可以提高IO设备的利用率。</li><li>系统吞吐量大。能提高系统吞吐量的主要原因可归结为：①CPU和其它资源保持“忙碌”状态；仅当作业完成时或运行不下去时才进行切换，系统开销小。</li><li>平均周转时间长。由于作业要排队依次进行处理，因而作业的周转时间较长，通常需几个小时，甚至几天。</li><li>无交互能力。用户一旦把作业提交给系统后，直至作业完成，用户都不能调试修改。</li></ul><p><strong>需要解决的问题</strong></p><ul><li>处理机争用问题。既要能满足各道程序运行的需要，又要能提高处理机的利用率。</li><li>内存分配和保护问题。系统应能为每道程序分配必要的内存空间，使它们“各得其所”，且不会因某道程序出现异常情况而破坏其它程序。</li><li>I/O设备分配问题。系统应采取适当的策略来分配系统中的IO设备，以达到既能方便用户对设备的使用，又能提高设备利用率的目的。</li><li>文件的组织和管理问题。系统应能有效地组织存放在系统中的大量的程序和数据，使它们既便于用户使用，又能保证数据的安全性。</li><li>作业管理问题。系统中存在着各种作业（应用程序），系统应能对系统中所有的作业进行合理的组织，以满足这些作业用户的不同要求</li><li>用户与系统的接口问题。为使用户能方便的使用操作系统，OS还应提供用户与操作系统之间的接口。</li></ul><h3 id="1-3-4-分时系统"><a href="#1-3-4-分时系统" class="headerlink" title="1.3.4. 分时系统"></a>1.3.4. 分时系统</h3><p>为了满足人机交互和共享主机的需求。OS能提供终端，系统及时接收处理命令。</p><ul><li>及时接收：配置多路卡，实现分时多路复用；</li><li>及时处理：<ul><li>作业直接进入内存；</li><li>采用轮转运行方式。设置时间片避免一个作业长期独占CPU。</li></ul></li></ul><p><strong>特征</strong><br>多路性、独立性、及时性、交互性。</p><h3 id="1-3-5-实时系统"><a href="#1-3-5-实时系统" class="headerlink" title="1.3.5. 实时系统"></a>1.3.5. 实时系统</h3><p>“实时计算”，则可以定义为这样一类计算：系统的正确性，不仅由计算的逻辑结果来确定，而且还取决于产生结果的时间。实时系统最主要的特征，是将时间作为关键参数。</p><p><strong>实时任务的类型</strong></p><ul><li><p>周期性</p></li><li><p>非周期性：开始截止时间和完成截止时间</p></li><li><p>硬实时任务：必须</p></li><li><p>软实时任务：不严格</p></li></ul><p><strong>实时系统与分时系统特征的比较</strong></p><ol><li>多路性。分时系统中表现为系统按分时原则为多个终端用户服务：实时控制指系统周期性地对多路现场信息进行采集；</li><li>独立性。分时系统每个终端在与系统交互时彼此相互独立互不干扰；实时系统中对信息的采集和对对象的控制也都是彼此互不干扰的</li><li>及时性。分时系统对实时性的要求是依据人所能接受的等待时间确定的；实时控制系统的实时性则是以控制对象所要求的截止时间来确定的。<br>（4）交互性。实时系统交互性仅限于访问系统中某些特定的专用服务程序；分时系统能向终端用户提供数据处理、资源共享等服务。<br>（5）可靠性。分时系统要求系统可靠，实时系统要求系统高度可靠。</li></ol><h3 id="1-3-6-微机操作系统"><a href="#1-3-6-微机操作系统" class="headerlink" title="1.3.6. 微机操作系统"></a>1.3.6. 微机操作系统</h3><ul><li>单用户单任务操作系统：MS-DOS</li><li>单用户多任务操作系统：windows</li><li>多用户多任务操作系统：unix，linux</li></ul><h2 id="1-4-操作系统的基本特性"><a href="#1-4-操作系统的基本特性" class="headerlink" title="1.4. 操作系统的基本特性"></a>1.4. 操作系统的基本特性</h2><h3 id="1-4-1-并发"><a href="#1-4-1-并发" class="headerlink" title="1.4.1. 并发"></a>1.4.1. 并发</h3><ol><li>并行与并发</li></ol><p>并行性是指两个或多个事件在同一时刻发生。而并发性是指两个或多个事件在同一时间间隔内发生。在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。</p><ol start="2"><li>引入进程<br>在一个未引入进程的系统中，在程序执行IO操作时，计算程序也不能执行。但在为计算程序和IO程序分别建立一个进程后，这两个进程便可并发执行。若对内存中的多个程序都分别建立一个进程，它们就可以并发执行，这样便能极大地提高系统资源的利用率，增加系统的吞吐量。</li></ol><p>所谓进程，是指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。多个进程之间可以并发执行和交换信息。</p><h3 id="1-4-2-共享"><a href="#1-4-2-共享" class="headerlink" title="1.4.2. 共享"></a>1.4.2. 共享</h3><p>OS环境下的资源共享或称为资源复用，是指系统中的资源可供内存中多个并发执行的进程共同使用。这里在宏观上既限定了时间（进程在内存期间），也限定了地点（内存）。</p><ol><li><p>互斥共享方式：进程A要访问某资源时，必须先提出请求。若此时该资源空闲，系统便可将之分配给请求进程A使用。<br>把这种在一段时间内只允许一个进程访问的资源，称为临界资源（或独占资源）。</p></li><li><p>同时访问方式<br>系统中还有另一类资源，允许在一段时间内由多个进程“同时”对它们进行访问。这里所谓的“同时”，在单处理机环境下是宏观意义上的，而在微观上，这些进程对该资源的访问是交替进行的。例如磁盘。</p></li></ol><p>并发和共享是多用户（多任务）OS的两个最基本的特征。它们又是互为存在的条件。即方面资源共享是以进程的并发执行为条件的，若系统不允许并发执行也就不存在资源共享问题；另一方面，若系统不能对资源共享实施有效管理，以协调好诸进程对共享资源的访问，也必然会影响到诸进程间并发执行的程度，甚至根本无法并发执行。</p><h3 id="1-4-3-虚拟"><a href="#1-4-3-虚拟" class="headerlink" title="1.4.3. 虚拟"></a>1.4.3. 虚拟</h3><ol><li>时分复用技术：虚拟处理机技术：虚拟设备技术。</li><li>空分复用技术：利用存储器的空闲空间分区域存放和运行其它的多道程序，以此来提高内存的利用率，但并不能实现在逻辑上扩大存储器容量的功能，还必须引入<strong>虚拟存储技术</strong>才能达到此目的。虚拟存储技术在本质上是实现内存的分时复用，即它可以通过分时复用内存的方式，使一道程序仅在远小于它的内存空间中运行。</li></ol><h3 id="1-4-4-异步"><a href="#1-4-4-异步" class="headerlink" title="1.4.4. 异步"></a>1.4.4. 异步</h3><p>进程是以人们不可预知的速度向前推进的，此即进程的异步性。</p><h2 id="1-5-操作系统的主要功能"><a href="#1-5-操作系统的主要功能" class="headerlink" title="1.5. 操作系统的主要功能"></a>1.5. 操作系统的主要功能</h2><h3 id="1-5-1-处理机管理功能"><a href="#1-5-1-处理机管理功能" class="headerlink" title="1.5.1. 处理机管理功能"></a>1.5.1. 处理机管理功能</h3><ul><li>进程控制：为作业创建进程、撤消（终止）已结束的进程，以及控制进程在运行过程中的状态转换；</li><li>进程同步：为多个进程（含线程）的运行进行协调<ul><li>进程互斥方式：诸进程在对临界资源进行访问</li><li>进程同步方式：指在相互合作去完成共同任务的诸进程间，由同步机构对它们的执行次序加以协调。例如锁。</li></ul></li><li>进程通信：通常在相互合作的进程之间采用直接通信方式，即由源进程利用发送命令直接将消息挂到目标进程的消息队列上，以后由目标进程利用接收命令从其消息队列中取出消息。</li><li>调度：<ul><li>作业调度：后备队列调入内存</li><li>进程调度：就绪队列分配处理机</li></ul></li></ul><h3 id="1-5-2-存储器管理功能"><a href="#1-5-2-存储器管理功能" class="headerlink" title="1.5.2. 存储器管理功能"></a>1.5.2. 存储器管理功能</h3><ul><li>内存分配；<ul><li>静态分配：装入时确定；</li><li>动态分配：允许运行中申请。</li></ul></li><li>内存保护：<ul><li>程序之间的内存空间不干扰；</li><li>用户程序和OS程序数据不干扰。</li></ul></li><li>地址映射：将程序地址空间中的逻辑地址转物理地址。</li><li>内存扩充：借助虚拟存储技术：<ul><li>请求调入功能：装入部分数据便可运行，中途调入；</li><li>置换功能：将暂时不用的程序和数据调至硬盘。</li></ul></li></ul><h3 id="1-5-3-设备管理功能"><a href="#1-5-3-设备管理功能" class="headerlink" title="1.5.3. 设备管理功能"></a>1.5.3. 设备管理功能</h3><ul><li>缓冲管理：缓和CPU与I/O设备速度不匹配的的矛盾，常见的缓冲区机制：单缓冲、双缓冲机制、公用缓冲池机制</li><li>设备分配：根据用户进程的IO请求、系统现有资源情况以及按照某种设备分配策略，为之分配其所需的设备。使用完后由系统回收。</li><li>设备处理：设备驱动程序。CPU向设备控制器发出I/O命令，完成指定的I/O操作；由CPU接收中断请求并给予迅速的响应和相应的处理。</li></ul><h3 id="1-5-4-文件管理功能"><a href="#1-5-4-文件管理功能" class="headerlink" title="1.5.4. 文件管理功能"></a>1.5.4. 文件管理功能</h3><ul><li>文件存储空间的管理：为每个文件分配外存空间，回收。</li><li>目录管理：按名存取，目录查询，文件共享。</li><li>文件的读写管理：利用文件指针从外存检索文件。</li><li>文件保护：存取控制。</li></ul><h3 id="1-5-5-OS与用户之间的接口"><a href="#1-5-5-OS与用户之间的接口" class="headerlink" title="1.5.5. OS与用户之间的接口"></a>1.5.5. OS与用户之间的接口</h3><ul><li>用户接口：直接或间接控制作业的命令接口<ul><li>联机用户接口：为联机用户提供的，包括一组键盘操作命令及命令解释程序；</li><li>脱机用户接口：为批处理作业的用户提供的。把需要对作业进行的控制和干预的命令事先写在作业说明书上，提交系统；</li><li>图形用户接口。</li></ul></li><li>程序接口：为用户程序访问系统资源而设置，是用户程序取得操作系统服务的唯一途径。它是由一组系统调用组成的，每一个系统调用都是一个能完成特定功能的子程序。早期的系统调用都是用汇编语言提供的，只有在用汇编语言书写的程序中才能直接使用系统调用。但在高级语言中，往往提供了与各系统调用一一对应的库函数这样。</li></ul><h3 id="1-5-6-现代操作系统的新功能"><a href="#1-5-6-现代操作系统的新功能" class="headerlink" title="1.5.6. 现代操作系统的新功能"></a>1.5.6. 现代操作系统的新功能</h3><ul><li>系统安全</li><li>网络功能</li><li>多媒体</li></ul><h2 id="1-6-OS结构设计"><a href="#1-6-OS结构设计" class="headerlink" title="1.6. OS结构设计"></a>1.6. OS结构设计</h2><h3 id="1-6-1-传统OS结构"><a href="#1-6-1-传统OS结构" class="headerlink" title="1.6.1. 传统OS结构"></a>1.6.1. 传统OS结构</h3><h4 id="1-6-1-1-无结构OS"><a href="#1-6-1-1-无结构OS" class="headerlink" title="1.6.1.1. 无结构OS"></a>1.6.1.1. 无结构OS</h4><p>在早期开发操作系统时，设计者只是把他的注意力放在功能的实现和获得高的效率上，缺乏首尾一致的设计思想。此时的OS是为数众多的一组过程的集合，每个过程可以任意地相互调用其它过程，致使操作系统内部既复杂又混乱，因此，这种OS是无结构的，也有人把它称为整体系统结构</p><h4 id="1-6-1-2-模块化结构OS"><a href="#1-6-1-2-模块化结构OS" class="headerlink" title="1.6.1.2. 模块化结构OS"></a>1.6.1.2. 模块化结构OS</h4><p>模块化程序设计技术是20世纪60年代出现的一种结构化程序设计技术。该技术“模块化”的原则来控制大型软件的复杂度。OS不再是由众多的过程直接构成的，而是按其功能精心地划分为若干个具有一定独立性和大小的模块。每个模块具有某方面的管理功能，并仔细地规定好各模块间的接口，使各模块之间能通过接口实现交互。这种设计方法称为模块-接口法。</p><p>模块的独立性要符合高内聚、低耦合的原则。</p><p>缺点：</p><ul><li>在OS设计时，对各模块间的接口规定很难满足在模块设计完成后对接口的实际需求。</li><li>各模块的设计齐头并进，无法寻找一个可靠的决定顺序，造成各种决定的“无序性”，这将使程序人员很难做到“设计中的每一步决定”都是建立在可靠的基础上，因此模块-接口法又被称为“无序模块法”。</li></ul><h4 id="1-6-1-3-分层式结构OS"><a href="#1-6-1-3-分层式结构OS" class="headerlink" title="1.6.1.3. 分层式结构OS"></a>1.6.1.3. 分层式结构OS</h4><p>为了将模块-接口法中“决定顺序”的无序性变为有序性，引入了有序分层法，分层法的设计任务是，在目标系统An和裸机系统（又称宿主系统）A0之间，铺设若干个层次的软件A1、A2、A3、…、An-1，使An通过An-1、An-2、…、A2、A1层，最终能在A0上运行。<br>在操作系统中，常采用自底向上法来铺设这些中间层。</p><p>自底向上的分层设计的基本原则是：每一步设计都建立在可靠的基础上。</p><p>优点：</p><ul><li>易保证系统的正确性和可靠性。</li><li>易扩充和易维护性。</li></ul><p>缺点：</p><p>分层结构的主要缺点是系统效率降低。由于层次结构是分层单向依赖的，必须在每层之间都建立层次间的通信机制，OS每执行一个功能，通常要自上而下地穿越多个层次，这无疑会增加系统的通信开销，从而导致系统效率的降低。</p><h3 id="1-6-2-客户服务器模式"><a href="#1-6-2-客户服务器模式" class="headerlink" title="1.6.2. 客户服务器模式"></a>1.6.2. 客户服务器模式</h3><p><strong>组成</strong></p><ul><li>客户机：每台客户机都是一个自主计算机，具有一定的处理能力。</li><li>服务器：通常是一台规模较大的机器，应能为网上所有的用户提供一种或多种服务。平时它一直处于工作状态，被动地等待来自客户机的请求。</li><li>网络系统：是用于连接所有客户机和服务器，实现它们之间通信和网络资源共享的系统。</li></ul><p><strong>优点</strong></p><ul><li>数据的分布处理和存储。由于客户机具有相当强的处理和存储能力，可进行本地处理和数据的分布存储，摆脱主机瓶颈。</li><li>便于集中管理。较好地保障系统重要数据的“可靠”和“安全”。</li><li>灵活性和可扩充性。理论上，客户机和服务器的数量不受限制，可以配置多种类型的客户机和服务器。</li><li>易于改编应用软件。在客户服务器模式中，对于客户机程序的修改和增删，比传统集中模式要容易得多，必要时也允许由客户进行修改。</li></ul><p><strong>缺点</strong></p><p>基本客户/服务器模式的不足之处是存在着不可靠性和瓶颈问题。在系统仅有一个服务器时，一旦服务器故障，将导致整个网络瘫痪。当服务器在重负荷下工作时，会因忙不过来而显著地延长对用户请求的响应时间。如果在网络中配置多个服务器，并采取相应的安全措施，则这种不足可加以改善。</p><h3 id="1-6-3-面向对象的程序设计技术"><a href="#1-6-3-面向对象的程序设计技术" class="headerlink" title="1.6.3. 面向对象的程序设计技术"></a>1.6.3. 面向对象的程序设计技术</h3><p>略。</p><h3 id="1-6-4-微内核OS结构"><a href="#1-6-4-微内核OS结构" class="headerlink" title="1.6.4. 微内核OS结构"></a>1.6.4. 微内核OS结构</h3><p>有效地支持多处理机运行，适用于分布式系统环境。</p><h4 id="1-6-4-1-基本概念"><a href="#1-6-4-1-基本概念" class="headerlink" title="1.6.4.1. 基本概念"></a>1.6.4.1. 基本概念</h4><ul><li>足够小的内核：实现核心功能，并非完整功能；</li><li>基于C/S模式：核心之外的功能通过进程实现，运行在用户态，CS借助微内核的消息传递机制实现信息交互；</li></ul><p><img src="/images/os/kernelcs.png"></p><ul><li>应用“机制与策略分离”原理；<blockquote><p>所谓机制是指实现某一功能的具体执行机构，策略则是在机制的基础上借助于某些参数和算法来实现该功能的优化，或达到不同的功能目标。通常，机制处于一个系统的基层，而策略则处于系统的高层。在传统的OS中，将机制放在OS的内核的较低层，把策略放在内核的较高层次中。而在微内核操作系统中，通常将机制放在OS的微内核中。正因为如此，才有可能将内核做得很小。<br>例如，为实现进程（线程）调度功能，须在进程管理中设置一个或多个进程（线程）优先级队列，能将指定优先级进程（线程）从所在队列中取出，并将其投入执行。由于这一部分属于调度功能的机制部分，应将它放入微内核中。而对于用户（进程）如何进行分类，以及其优先级的确认方式或原则，则都是属于策略问题。可将它们放入微内核外的进程线程）管理服务器中。<br>由于进程（线程）之间的通信功能是微内核OS最基本的功能，被频繁使用，因此几乎所有的微内核OS都是将进程（线程）之间的通信功能放入微内核中。此外，还将进程的切换、线程的调度，以及多处理机之间的同步等功能也放入微内核中。</p></blockquote></li><li>采用面向对象技术；</li></ul><h4 id="1-6-4-2-基本功能"><a href="#1-6-4-2-基本功能" class="headerlink" title="1.6.4.2. 基本功能"></a>1.6.4.2. 基本功能</h4><p>要注意，特指的是微内核功能，而微内核实现的是使用最频繁的、最核心的功能，还可将一些功能一分为二，核心放入内核，绝大部分核外实现。</p><ul><li>进程（线程）管理：应用“机制与策略分离”原理实现；</li><li>低级存储器管理；</li><li>中断和陷入处理；</li></ul><h4 id="1-6-4-3-优缺点"><a href="#1-6-4-3-优缺点" class="headerlink" title="1.6.4.3. 优缺点"></a>1.6.4.3. 优缺点</h4><p><strong>优点</strong></p><ul><li>可扩展性：开发新的软硬件只需在核外增加专用服务器；</li><li>可靠性：严格测试而成；精简的API；服务器运行在用户态，出错不会影响内核和其他服务器；</li><li>可移植性强：所有与特定CPU和MO设备硬件有关的代码均放在内核和内核下面的硬件隐藏层中，而各种服务器均与硬件平台无关；</li><li>支持分布式：广泛使用消息传递通信机制，有一张进程和服务器的标识符与它们所驻留的机器之间的映射表；</li><li>面向对象技术。</li></ul><p><strong>缺点</strong></p><p>OS运行效率降低。</p><p>原因：效率降低最主要的原因是，在完成一次客户对操作系统提出的服务请求时，需要利用消息实现多次交互和进行用户/内核模式与上下文的多次切换。然而，在早期的OS中，用户进程在请求取得OS服务时，一般只需进行两次上下文的切换：一次是在执行系统调用后由用户态转向系统态时；另一次是在系统完成用户请求的服务后，由系统态返回用户态时。</p><p>在微内核OS中，由于客户和服务器、服务器和服务器之间的通信都需通过微内核，致使同样的服务请求至少需要进行四次上下文切换。</p><ul><li>客户发送请求消息给内核，以请求取得某服务器特定的服务；第二次是发生在由</li><li>内核把客户的请求消息发往服务器：</li><li>服务器完成客户请求后，把响应消息发送到内核；</li><li>内核将响应消息发送给客户。</li></ul><p><img src="/images/os/miniKernlPeoblem.png"></p><p>实际上更多，应为服务器不一定靠自身独立完成功能。</p><p>为了改善运行效率，可以重新把一些常用的操作系统基本功能由服务器移入微内核中，但这又会使微内核的容量明显地增大。</p><h1 id="2-进程的描述与控制"><a href="#2-进程的描述与控制" class="headerlink" title="2. 进程的描述与控制"></a>2. 进程的描述与控制</h1><h2 id="2-1-前趋图和程序执行"><a href="#2-1-前趋图和程序执行" class="headerlink" title="2.1. 前趋图和程序执行"></a>2.1. 前趋图和程序执行</h2><h3 id="2-1-1-前趋图"><a href="#2-1-1-前趋图" class="headerlink" title="2.1.1. 前趋图"></a>2.1.1. 前趋图</h3><p>为了能更好地描述程序的顺序和并发执行情况,我们先介绍用于描述程序执行先后顺序的前趋图。所谓前趋图是指一个有向无循环图,它用于描述进程之间执行的先后顺序。图中的每个结点可用来表示一个进程或程序段,乃至一条语句,结点间的有向边则表示两个结点之间存在的偏序或前趋关系进程(或程序之间的前趋关系可用“→”来表示,如果进程P和P存在着前趋关系,写成P1→P2,表示在P2开始执行之前P1必须完成。</p><h3 id="2-1-2-程序顺序执行"><a href="#2-1-2-程序顺序执行" class="headerlink" title="2.1.2. 程序顺序执行"></a>2.1.2. 程序顺序执行</h3><p>单道程序系统。<br>通常,一个应用程序由若干个程序段组成,每一个程序段完成特定的功能,它们在执行时,都需要按照某种先后次序顺序执行,仅当前一程序段执行完后,才运行后一程序段。</p><p><strong>特征</strong></p><ul><li>顺序性：指处理机严格地按照程序所规定的顺序执行,即每一操作必须在下一个操作开始之前结東；</li><li>封闭性：指程序在封闭的环境下运行,即程序运行时独占全机资源,资源的状态(除初始状态外)只有本程序才能改变它,程序一旦开始执行,其执行结果不受外界因素影响；</li><li>可再现性:指只要程序执行时的环境和初始条件相同,当程序重复执行时,不论它是从头到尾不停顿地执行,还是“停停走走”地执行,都可获得相同的结果。</li></ul><h3 id="2-1-3-程序并发执行"><a href="#2-1-3-程序并发执行" class="headerlink" title="2.1.3. 程序并发执行"></a>2.1.3. 程序并发执行</h3><p>多道程序技术。<br>只有在不存在前趋关系的程序之间才有可能并发执行,否则无法并发执行。</p><p>对于具有下述四条语句的程序段:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S1:a:&#x3D;x+2</span><br><span class="line">S2:b:&#x3D;y+4</span><br><span class="line">S3:c:&#x3D;a+b</span><br><span class="line">S4:d:&#x3D;c+b</span><br></pre></td></tr></table></figure><p>可以看出:S3必须在a和b被赋值后方能执行:S4必须在S3之后执行;但S1和S2则可以并发执行,因为它们彼此互不依赖。</p><p><strong>特征</strong></p><ul><li>间断性。程序在并发执行时,由于它们共享系统资源,以及为完成同一项任务而相互合作,致使在这些并发执行的程序之间形成了相互制约的关系。</li><li>失去封闭性。当系统中存在着多个可以并发执行的程序时,系统中的各种资源将为它们所共享,而这些资源的状态也由这些程序来改变,致使其中任一程序在运行时,其环境都必然会受到其它程序的影响。</li><li>不可再现性。程序在并发执行时,由于失去了封闭性,也将导致其又失去可再现性。</li></ul><h2 id="2-2-进程的描述"><a href="#2-2-进程的描述" class="headerlink" title="2.2. 进程的描述"></a>2.2. 进程的描述</h2><h3 id="2-2-1-进程的定义"><a href="#2-2-1-进程的定义" class="headerlink" title="2.2.1. 进程的定义"></a>2.2.1. 进程的定义</h3><p>为了使参与并发执行的每个程序(含数据)都能独立地运行,在操作系统中必须为之配置一个专门的数据结构,称为进程控制块( Process Control block,PCB)。系统利用PCB来描述进程的基本情况和活动过程,进而控制和管理进程。这样,由程序段、相关的数据段和pCB三部分便构成了进程实体(又称进程映像)。一般情况下,我们把进程实体就简称为进程。</p><p>传统OS中的进程定义为:“进程是进程实体的运行过程,是系统进行资源分配和调度的一个独立单位。”</p><h3 id="2-2-2-进程的特征"><a href="#2-2-2-进程的特征" class="headerlink" title="2.2.2. 进程的特征"></a>2.2.2. 进程的特征</h3><ul><li>动态性：进程的实质是进程实体的执行过程,进程实体有一定的生命期,而程序则只是一组有序指令的集合,并存放于某种介质上,其本身并不具有活动的含义,因而是静态的。</li><li>并发性。是指多个进程实体同存于内存中,且能在一段时间内同时运行。引入进<br>程的目的也正是为了使其进程实体能和其它进程实体并发执行。程序(没有建立PCB)是不能参与并发执行的。</li><li>独立性。在传统的OS中,独立性是指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。凡未建立PCB的程序都不能作为一个独立的单位参与运行。</li><li>异步性,是指进程是按异步方式运行的,即按各自独立的、不可预知的速度向前推进。正是源于此因,才导致了传统意义上的程序若参与并发执行,会产生其结果的不可再现性。</li></ul><h2 id="2-3-进程的基本状态及转换"><a href="#2-3-进程的基本状态及转换" class="headerlink" title="2.3. 进程的基本状态及转换"></a>2.3. 进程的基本状态及转换</h2><h3 id="2-3-1-三种基本状态"><a href="#2-3-1-三种基本状态" class="headerlink" title="2.3.1. 三种基本状态"></a>2.3.1. 三种基本状态</h3><ul><li>就绪( Ready)状态。进程已处于准备好运行的状态,即进程已分配到除CPU以外的所有必要资源后,只要再获得CPU,便可立即执行。如果系统中有许多处于就绪状态的进程,通常将它们按一定的策略(如优先级策略)排成一个队列,称该队列为就绪队列。</li><li>执行( Running)状态。进程已获得CPU,其程序正在执行的状态。对任何个时刻而言,在单处理机系统中,只有一个进程处于执行状态,而在多处理机系统中,则有多个进程处于执行状态；</li><li>阻塞( Block)状态。正在执行的进程由于发生某事件暂时无法继续执行时的状态,亦即进程的执行受到阻塞。此时引起进程调度,OS把处理机分配给另一个就绪进程,而让受阻进程处于暂停状态,一般将这种暂停状态称为阻塞状态,有时也称为等待状态或封锁状态。通常系统将处于阻塞状态的进程也排成一个队列,称该队列为阻塞队列。</li></ul><h3 id="2-3-2-状态转换"><a href="#2-3-2-状态转换" class="headerlink" title="2.3.2. 状态转换"></a>2.3.2. 状态转换</h3><p><img src="/images/os/3status.png"></p><h3 id="2-3-3-创建状态和终止状态"><a href="#2-3-3-创建状态和终止状态" class="headerlink" title="2.3.3. 创建状态和终止状态"></a>2.3.3. 创建状态和终止状态</h3><ul><li>创建状态：如果进程所需的资源尚不能得到满足,创建工作尚未完成,进程不能被调度运行,于是把此时进程所处的状态称为创建状态。</li></ul><p>当其获得了所需的资源以及对其PCB的初始化工作完成后,便可由创建状态转入就绪状态</p><ul><li>终止状态：进当一个进程到达了自然结束点,或是出现了无法克服的错误,或是被操作系统所终结,或是被其他有终止权的进程所终结,它将进入终止状态。进入终止状态。</li></ul><p>进入终止态的进程以后不能再执行,但在操作系统中依然保留一个记录,其中保存状态码和一些计时统计数据,供其他进程收集。一旦其他进程完成了对其信息的提取之后,操作系统将删除该进程,即将其PCB清零,并将该空白PCB返还系统。</p><p><img src="/images/os/5status.png"></p><h2 id="2-4-挂起操作"><a href="#2-4-挂起操作" class="headerlink" title="2.4. 挂起操作"></a>2.4. 挂起操作</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;准备的书太拉跨，不准备继续总结了&lt;/p&gt;</summary>
    
    
    
    <category term="Study" scheme="https://memorykk.cn/categories/Study/"/>
    
    
    <category term="OS" scheme="https://memorykk.cn/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://memorykk.cn/network-basic.html"/>
    <id>https://memorykk.cn/network-basic.html</id>
    <published>2021-03-14T03:39:36.000Z</published>
    <updated>2021-03-16T07:17:42.382Z</updated>
    
    <content type="html"><![CDATA[<p>概述、物理层、数据链路层、网络层、运输层、应用层。</p><p>70页、5万字，超长总结。</p><span id="more"></span><hr><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#1-%E6%A6%82%E8%BF%B0">1. 概述</a><ul><li><a href="#1-1-%E4%BA%92%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0">1.1. 互联网概述</a></li><li><a href="#1-2-%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E7%BB%84%E6%88%90">1.2. 互联网的组成</a><ul><li><a href="#1-2-1-%E8%BE%B9%E7%BC%98%E9%83%A8%E5%88%86">1.2.1. 边缘部分</a><ul><li><a href="#1-2-1-1-%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%B9%E5%BC%8F">1.2.1.1. 客户-服务器方式</a></li><li><a href="#1-2-1-2-%E5%AF%B9%E7%AD%89%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F">1.2.1.2. 对等连接方式</a></li></ul></li><li><a href="#1-2-2-%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86">1.2.2. 核心部分</a><ul><li><a href="#1-2-2-1-%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2">1.2.2.1. 电路交换</a></li><li><a href="#1-2-2-2-%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2">1.2.2.2. 分组交换</a></li><li><a href="#1-2-2-3-%E6%8A%A5%E6%96%87%E4%BA%A4%E6%8D%A2">1.2.2.3. 报文交换</a></li></ul></li></ul></li><li><a href="#1-3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87">1.3. 计算机网络的性能指标</a><ul><li><a href="#1-3-1-%E9%80%9F%E7%8E%87">1.3.1. 速率</a></li><li><a href="#1-3-2-%E5%B8%A6%E5%AE%BD">1.3.2. 带宽</a></li><li><a href="#1-3-3-%E5%90%9E%E5%90%90%E9%87%8F">1.3.3. 吞吐量</a></li><li><a href="#1-3-4-%E6%97%B6%E5%BB%B6">1.3.4. 时延</a></li><li><a href="#1-3-5-%E6%97%B6%E5%BB%B6%E5%B8%A6%E5%AE%BD%E7%A7%AF">1.3.5. 时延带宽积</a></li><li><a href="#1-3-6-%E5%BE%80%E8%BF%94%E6%97%B6%E9%97%B4RTT">1.3.6. 往返时间RTT</a></li><li><a href="#1-3-7-%E5%88%A9%E7%94%A8%E7%8E%87">1.3.7. 利用率</a></li></ul></li><li><a href="#1-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">1.4. 计算机网络体系结构</a><ul><li><a href="#1-4-1-OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B">1.4.1. OSI七层模型</a><ul><li><a href="#1-4-1-1-%E7%89%A9%E7%90%86%E5%B1%82">1.4.1.1. 物理层</a></li><li><a href="#1-4-1-2-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">1.4.1.2. 数据链路层</a></li><li><a href="#1-4-1-3-%E7%BD%91%E7%BB%9C%E5%B1%82">1.4.1.3. 网络层</a></li><li><a href="#1-4-1-4-%E4%BC%A0%E8%BE%93%E5%B1%82">1.4.1.4. 传输层</a></li><li><a href="#1-4-1-5-%E4%BC%9A%E8%AF%9D%E5%B1%82">1.4.1.5. 会话层</a></li><li><a href="#1-4-1-6-%E8%A1%A8%E7%A4%BA%E5%B1%82">1.4.1.6. 表示层</a></li><li><a href="#1-4-1-7-%E5%BA%94%E7%94%A8%E5%B1%82">1.4.1.7. 应用层</a></li></ul></li><li><a href="#1-4-2-%E6%80%BB%E7%BB%93">1.4.2. 总结</a></li></ul></li></ul></li><li><a href="#2-%E7%89%A9%E7%90%86%E5%B1%82">2. 物理层</a><ul><li><a href="#2-1-%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1">2.1. 数据通信</a><ul><li><a href="#2-1-1-%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F">2.1.1. 数据通信系统</a></li><li><a href="#2-1-2-%E4%BF%A1%E9%81%93">2.1.2. 信道</a></li><li><a href="#2-1-3-%E4%BF%A1%E9%81%93%E7%9A%84%E6%9E%81%E9%99%90%E5%AE%B9%E9%87%8F">2.1.3. 信道的极限容量</a></li></ul></li><li><a href="#2-2-%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B%E7%9A%84%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93">2.2. 物理层下的传输媒体</a></li><li><a href="#2-3-%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF">2.3. 信道复用技术</a></li><li><a href="#2-4-%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF">2.4. 宽带接入技术</a></li></ul></li><li><a href="#3-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">3. 数据链路层</a><ul><li><a href="#3-1-%E4%BD%BF%E7%94%A8%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93">3.1. 使用点对点信道</a><ul><li><a href="#3-1-1-%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98">3.1.1. 三个基本问题</a><ul><li><a href="#3-1-1-1-%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7">3.1.1.1. 封装成帧</a></li><li><a href="#3-1-1-2-%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93">3.1.1.2. 透明传输</a></li><li><a href="#3-1-1-3-%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B">3.1.1.3. 差错检测</a></li></ul></li><li><a href="#3-1-2-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP">3.1.2. 点对点协议PPP</a><ul><li><a href="#3-1-2-1-%E5%8D%8F%E8%AE%AE%E7%BB%84%E6%88%90">3.1.2.1. 协议组成</a></li><li><a href="#3-1-2-2-PPP%E5%B8%A7%E6%A0%BC%E5%BC%8F">3.1.2.2. PPP帧格式</a></li><li><a href="#3-1-2-3-PPP%E5%8D%8F%E8%AE%AE%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81">3.1.2.3. PPP协议工作状态</a></li></ul></li></ul></li><li><a href="#3-2-%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93">3.2. 使用广播信道</a><ul><li><a href="#3-2-1-%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">3.2.1. 局域网的数据链路层</a><ul><li><a href="#3-2-1-1-%E4%BB%A5%E5%A4%AA%E7%BD%91%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%A0%87%E5%87%86">3.2.1.1. 以太网的两个标准</a></li><li><a href="#3-2-1-2-%E9%80%82%E9%85%8D%E5%99%A8">3.2.1.2. 适配器</a></li></ul></li><li><a href="#3-2-2-CSMACD%E5%8D%8F%E8%AE%AE">3.2.2. CSMA/CD协议</a></li><li><a href="#3-2-3-%E4%BD%BF%E7%94%A8%E9%9B%86%E7%BA%BF%E5%99%A8%E7%9A%84%E6%98%9F%E5%BD%A2%E6%8B%93%E6%89%91">3.2.3. 使用集线器的星形拓扑</a></li><li><a href="#3-2-4-%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87">3.2.4. 信道利用率</a></li><li><a href="#3-2-5-MAC%E5%B1%82">3.2.5. MAC层</a><ul><li><a href="#3-2-5-1-MAC%E5%9C%B0%E5%9D%80">3.2.5.1. MAC地址</a></li><li><a href="#3-2-5-2-MAC%E5%B8%A7%E7%9A%84%E6%A0%BC%E5%BC%8F">3.2.5.2. MAC帧的格式</a></li></ul></li><li><a href="#3-2-6-%E6%89%A9%E5%B1%95%E7%9A%84%E4%BB%A5%E5%A4%AA%E7%BD%91">3.2.6. 扩展的以太网</a><ul><li><a href="#3-2-6-1-%E7%89%A9%E7%90%86%E5%B1%82%E6%89%A9%E5%B1%95">3.2.6.1. 物理层扩展</a></li><li><a href="#3-2-6-2-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%89%A9%E5%B1%95">3.2.6.2. 数据链路层扩展</a><ul><li><a href="#3-2-6-2-1-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%89%B9%E7%82%B9">3.2.6.2.1. 交换机特点</a></li><li><a href="#3-2-6-2-2-%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB">3.2.6.2.2. 路由器与交换机的主要区别</a></li><li><a href="#3-2-6-2-3-%E4%BB%A5%E5%A4%AA%E7%BD%91%E7%9A%84%E8%87%AA%E5%AD%A6%E4%B9%A0%E5%8A%9F%E8%83%BD">3.2.6.2.3. 以太网的自学习功能</a></li></ul></li></ul></li></ul></li></ul></li><li><a href="#4-%E7%BD%91%E7%BB%9C%E5%B1%82">4. 网络层</a><ul><li><a href="#4-1-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1">4.1. 网络层提供的两种服务</a></li><li><a href="#4-2-%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AEIP">4.2. 网际协议IP</a><ul><li><a href="#4-2-1-%E5%88%86%E7%B1%BB%E7%9A%84IP%E5%9C%B0%E5%9D%80">4.2.1. 分类的IP地址</a><ul><li><a href="#4-2-1-1-IP%E5%9C%B0%E5%9D%80%E7%9A%84%E8%A1%A8%E7%A4%BA">4.2.1.1. IP地址的表示</a></li><li><a href="#4-2-1-2-%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%89%E7%B1%BBIP%E5%9C%B0%E5%9D%80">4.2.1.2. 常见的三类IP地址</a></li></ul></li><li><a href="#4-2-2-%E7%A7%81%E6%9C%89%E5%9C%B0%E5%9D%80">4.2.2. 私有地址</a></li><li><a href="#4-2-3-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2NAT">4.2.3. 网络地址转换NAT</a></li><li><a href="#4-2-4-DHCP%E5%8D%8F%E8%AE%AE">4.2.4. DHCP协议</a></li><li><a href="#4-2-5-IP%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%9C%B0%E5%9D%80">4.2.5. IP地址与硬件地址</a></li><li><a href="#4-2-6-%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AEARP">4.2.6. 地址解析协议ARP</a><ul><li><a href="#4-2-6-1-%E5%90%8C%E4%B8%80%E5%B1%80%E5%9F%9F%E7%BD%91">4.2.6.1. 同一局域网</a></li><li><a href="#4-2-6-2-%E4%B8%8D%E5%9C%A8%E5%90%8C%E4%B8%80%E5%B1%80%E5%9F%9F%E7%BD%91">4.2.6.2. 不在同一局域网</a></li></ul></li><li><a href="#4-2-7-%E9%80%86%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AERARP">4.2.7. 逆地址解析协议RARP</a></li><li><a href="#4-2-8-IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E6%A0%BC%E5%BC%8F">4.2.8. IP数据报的格式</a></li><li><a href="#4-2-9-IP%E5%B1%82%E8%BD%AC%E5%8F%91%E5%88%86%E7%BB%84%E7%9A%84%E6%B5%81%E7%A8%8B">4.2.9. IP层转发分组的流程</a></li></ul></li><li><a href="#4-3-%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91%E5%92%8C%E6%9E%84%E9%80%A0%E8%B6%85%E7%BD%91">4.3. 划分子网和构造超网</a><ul><li><a href="#4-3-1-%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91">4.3.1. 划分子网</a><ul><li><a href="#4-3-1-1-%E4%B8%89%E7%BA%A7IP%E5%9C%B0%E5%9D%80">4.3.1.1. 三级IP地址</a></li><li><a href="#4-3-1-2-%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81">4.3.1.2. 子网掩码</a></li><li><a href="#4-3-1-3-%E4%BD%BF%E7%94%A8%E5%AD%90%E7%BD%91%E7%9A%84%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91">4.3.1.3. 使用子网的分组转发</a></li></ul></li><li><a href="#4-3-2-%E6%9E%84%E9%80%A0%E8%B6%85%E7%BD%91">4.3.2. 构造超网</a><ul><li><a href="#4-3-2-1-%E7%BD%91%E7%BB%9C%E5%89%8D%E7%BC%80">4.3.2.1. 网络前缀</a></li></ul></li></ul></li><li><a href="#4-4-ICMP%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE">4.4. ICMP网际控制报文协议</a></li><li><a href="#4-5-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE">4.5. 路由选择协议</a><ul><li><a href="#4-5-1-%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AERIP">4.5.1. 内部网关协议RIP</a><ul><li><a href="#4-5-1-1-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">4.5.1.1. 工作原理</a></li><li><a href="#4-5-1-2-%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E7%AE%97%E6%B3%95">4.5.1.2. 距离向量算法</a></li></ul></li><li><a href="#4-5-2-%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AEOSPF">4.5.2. 内部网关协议OSPF</a></li><li><a href="#4-5-3-%E5%A4%96%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AEBGP">4.5.3. 外部网关协议BGP</a></li></ul></li></ul></li><li><a href="#5-%E8%BF%90%E8%BE%93%E5%B1%82">5. 运输层</a><ul><li><a href="#5-1-%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0">5.1. 协议概述</a><ul><li><a href="#5-1-1-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1">5.1.1. 进程之间的通信</a></li><li><a href="#5-1-2-%E4%B8%A4%E4%B8%AA%E4%B8%BB%E8%A6%81%E5%8D%8F%E8%AE%AE">5.1.2. 两个主要协议</a></li><li><a href="#5-1-3-%E7%AB%AF%E5%8F%A3">5.1.3. 端口</a></li></ul></li><li><a href="#5-2-%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AEUDP">5.2. 用户数据报协议UDP</a></li><li><a href="#5-3-%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AETCP%E6%A6%82%E8%BF%B0">5.3. 传输控制协议TCP概述</a><ul><li><a href="#5-3-1-TCP%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9">5.3.1. TCP的主要特点</a></li><li><a href="#5-3-2-TCP%E7%9A%84%E8%BF%9E%E6%8E%A5">5.3.2. TCP的连接</a></li></ul></li><li><a href="#5-4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">5.4. 可靠传输的工作原理</a><ul><li><a href="#5-4-1-%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE">5.4.1. 停止等待协议</a><ul><li><a href="#5-4-1-1-%E6%97%A0%E5%B7%AE%E9%94%99%E6%83%85%E5%86%B5">5.4.1.1. 无差错情况</a></li><li><a href="#5-4-1-2-%E5%87%BA%E7%8E%B0%E5%B7%AE%E9%94%99">5.4.1.2. 出现差错</a></li><li><a href="#5-4-1-3-%E7%A1%AE%E8%AE%A4%E4%B8%A2%E5%A4%B1%E5%92%8C%E7%A1%AE%E8%AE%A4%E8%BF%9F%E5%88%B0">5.4.1.3. 确认丢失和确认迟到</a></li><li><a href="#5-4-1-4-%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87">5.4.1.4. 信道利用率</a></li></ul></li><li><a href="#5-4-2-%E8%BF%9E%E7%BB%ADARQ%E5%8D%8F%E8%AE%AE">5.4.2. 连续ARQ协议</a></li></ul></li><li><a href="#5-5-TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E6%A0%BC%E5%BC%8F">5.5. TCP报文段格式</a></li><li><a href="#5-6-TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0">5.6. TCP可靠传输的实现</a><ul><li><a href="#5-6-1-%E4%BB%A5%E5%AD%97%E8%8A%82%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">5.6.1. 以字节为单位的滑动窗口</a></li><li><a href="#5-6-2-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E7%9A%84%E9%80%89%E6%8B%A9">5.6.2. 超时重传时间的选择</a></li><li><a href="#5-6-3-%E9%80%89%E6%8B%A9%E7%A1%AE%E8%AE%A4SACK">5.6.3. 选择确认SACK</a></li></ul></li><li><a href="#5-7-TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">5.7. TCP的流量控制</a><ul><li><a href="#5-7-1-%E5%88%A9%E7%94%A8%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">5.7.1. 利用滑动窗口实现流量控制</a></li><li><a href="#5-7-2-TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E6%95%88%E7%8E%87">5.7.2. TCP的传输效率</a></li></ul></li><li><a href="#5-8-TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">5.8. TCP的拥塞控制</a><ul><li><a href="#5-8-1-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E4%B8%80%E8%88%AC%E5%8E%9F%E7%90%86">5.8.1. 拥塞控制的一般原理</a></li><li><a href="#5-8-2-TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95">5.8.2. TCP的拥塞控制方法</a><ul><li><a href="#5-8-2-1-%E6%85%A2%E5%BC%80%E5%A7%8B">5.8.2.1. 慢开始</a></li><li><a href="#5-8-2-2-%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D">5.8.2.2. 拥塞避免</a></li><li><a href="#5-8-2-3-%E5%BF%AB%E9%87%8D%E4%BC%A0">5.8.2.3. 快重传</a></li><li><a href="#5-8-2-4-%E5%BF%AB%E6%81%A2%E5%A4%8D">5.8.2.4. 快恢复</a></li><li><a href="#5-8-2-5-%E6%80%BB%E7%BB%93">5.8.2.5. 总结</a></li></ul></li><li><a href="#5-8-3-%E4%B8%BB%E5%8A%A8%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86AQM">5.8.3. 主动队列管理AQM</a></li></ul></li><li><a href="#5-9-TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86">5.9. TCP的连接管理</a><ul><li><a href="#5-9-1-TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B">5.9.1. TCP的连接建立</a></li><li><a href="#5-9-2-TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE">5.9.2. TCP的连接释放</a></li><li><a href="#5-9-3-TCP%E7%9A%84%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA">5.9.3. TCP的有限状态机</a></li></ul></li></ul></li><li><a href="#6-%E5%BA%94%E7%94%A8%E5%B1%82">6. 应用层</a><ul><li><a href="#6-1-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS">6.1. 域名系统DNS</a></li><li><a href="#6-2-%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AE">6.2. 文件传送协议</a><ul><li><a href="#6-2-1-FTP">6.2.1. FTP</a></li><li><a href="#6-2-2-TFTP">6.2.2. TFTP</a></li></ul></li><li><a href="#6-3-%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AEHTTP">6.3. 超文本传送协议HTTP</a><ul><li><a href="#6-3-1-HTTP%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B">6.3.1. HTTP基本过程</a></li><li><a href="#6-3-2-HTTP%E6%8A%A5%E6%96%87">6.3.2. HTTP报文</a><ul><li><a href="#6-3-2-1-HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87">6.3.2.1. HTTP请求报文</a></li><li><a href="#6-3-2-2-HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E6%8A%A5%E6%96%87">6.3.2.2. HTTP响应报文报文</a></li></ul></li><li><a href="#6-3-3-HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB">6.3.3. HTTP协议的区别</a></li><li><a href="#6-3-4-HTTPS">6.3.4. HTTPS</a><ul><li><a href="#6-3-4-1-HTTPS%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">6.3.4.1. HTTPS的工作原理</a></li><li><a href="#6-3-4-2-HTTPS%E5%92%8CHTTP%E7%9A%84%E5%8C%BA%E5%88%AB">6.3.4.2. HTTPS和HTTP的区别</a></li></ul></li><li><a href="#6-3-5-HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6">6.3.5. HTTP缓存机制</a><ul><li><a href="#6-3-5-1-%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98">6.3.5.1. 强制缓存</a></li><li><a href="#6-3-5-2-%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98">6.3.5.2. 协商缓存</a></li><li><a href="#6-3-5-3-%E6%80%BB%E7%BB%93">6.3.5.3. 总结</a></li></ul></li><li><a href="#6-3-6-SESSION%E5%92%8CCOOKIE">6.3.6. SESSION和COOKIE</a></li></ul></li><li><a href="#6-4-%E8%BE%93%E5%85%A5URL%E4%B9%8B%E5%90%8E%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88">6.4. 输入URL之后会发生什么</a><ul><li><a href="#6-4-1-%E5%A4%A7%E7%BA%B2">6.4.1. 大纲</a></li><li><a href="#6-4-2-%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B">6.4.2. 具体过程</a></li></ul></li></ul></li><li><a href="#7-%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">7. 参考链接</a><!-- /TOC --></li></ul><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><h2 id="1-1-互联网概述"><a href="#1-1-互联网概述" class="headerlink" title="1.1. 互联网概述"></a>1.1. 互联网概述</h2><ul><li>三大网：电信网、有线电视网、计算机网络。</li><li>计算机网络：简称为“网络”，由若干结点和连接这些节点的链路组成。</li><li>互连网（internet）：网络通过路由器互连起来构成更大的计算机网络，即“网络的网络”。</li><li>主机：与网络相连的计算机。</li><li>互联网（Internet）：当前全球最大的、开放的、众多网络互连而成的特定互连网，采用TCP/IP协议族作为通信规则。</li><li>互联网服务提供者ISP：商业公司ISP共同拥有整个互联网。</li><li>互联网的多层次ISP结构：主干ISP、地区ISP、本地ISP。</li></ul><p><img src="/images/network-basic/multi-isp.png" alt="multi-isp.png"></p><ul><li>互联网交换点IXP：允许两个网络直接相连并交换分组，而不再需要通过更高层的ISP转发分组，从而加快效率。IXP常采用工作在数据链路层的网络交换机，用局域网连接起来。</li></ul><h2 id="1-2-互联网的组成"><a href="#1-2-互联网的组成" class="headerlink" title="1.2. 互联网的组成"></a>1.2. 互联网的组成</h2><p>从工作方式上看，分为：</p><ul><li>边缘部分：由所有来凝结在互联网上的主机组成，用户直接使用，用来进行通信和资源共享，即资源子网。</li><li>核心部分：由大量网络和连接这些网络的路由器组成，为边缘部分提供连通性和交换，即通信子网。</li></ul><h3 id="1-2-1-边缘部分"><a href="#1-2-1-边缘部分" class="headerlink" title="1.2.1. 边缘部分"></a>1.2.1. 边缘部分</h3><p>连接在互联网上的所有主机又称为“端系统”。端系统之间的通信实质是进程之间的通信。<br>通信方式有两类：客户服务器方式（C/S）、对等方式（P2P）。</p><h4 id="1-2-1-1-客户-服务器方式"><a href="#1-2-1-1-客户-服务器方式" class="headerlink" title="1.2.1.1. 客户-服务器方式"></a>1.2.1.1. 客户-服务器方式</h4><p>描述的是两个应用进程之间服务与被服务的关系。<br>客户是服务请求方，服务器是服务提供方。</p><p><img src="/images/network-basic/cs.png" alt="cs.png"></p><p><strong>客户程序</strong></p><ul><li>被用户调用后运行，通信时主动想S发起请求，C必须知道S的地址；</li><li>不需要特殊的硬件和复杂的OS。</li></ul><p><strong>服务器程序</strong></p><ul><li>系统启动后自动调用并不断运行，被动地等待并接受C请求，可同时处理多个请求；</li><li>一般需要强大的硬件和复杂的OS支持。</li></ul><h4 id="1-2-1-2-对等连接方式"><a href="#1-2-1-2-对等连接方式" class="headerlink" title="1.2.1.2. 对等连接方式"></a>1.2.1.2. 对等连接方式</h4><p>两台主机在通信时不区分哪个是C或S，运行P2P软件即可平等通信，本质上看认识C/S方式。</p><p><img src="/images/network-basic/p2p.png" alt="p2p.png"></p><h3 id="1-2-2-核心部分"><a href="#1-2-2-核心部分" class="headerlink" title="1.2.2. 核心部分"></a>1.2.2. 核心部分</h3><p>起特殊作用的是<strong>路由器</strong>，实现分组交换。<br>三种交换方式：电路交换、报文交换、分组交换。</p><h4 id="1-2-2-1-电路交换"><a href="#1-2-2-1-电路交换" class="headerlink" title="1.2.2.1. 电路交换"></a>1.2.2.1. 电路交换</h4><p>从通信资源的分配角度来看，交换就是按照某种方式动态地分配传输线路的资源。</p><p>在通话之前，必须先拨号请求建立连接，也就是一条专用的物理通路。挂机后，交换机释放刚才使用的这条专用的物理通路。这种必须经过“建立连接（占用通信资源）→通话（一直占用通信资源）→释放连接（归还通信资源）”的交换方式即“电路交换”。</p><p>在通话的全部时间内，通话的两个用户始终占用端到端的通信资源。</p><p><img src="/images/network-basic/circuitSwitch.png" alt="circuitSwitch.png"></p><p>使用电路交换的线路的传输效率十分低。</p><h4 id="1-2-2-2-分组交换"><a href="#1-2-2-2-分组交换" class="headerlink" title="1.2.2.2. 分组交换"></a>1.2.2.2. 分组交换</h4><p>采用存储转发技术，待发送的在整个数据块称为报文，发送之前将报文划分成等长的数据段，再加上必要的控制信息组成的首部构成分组，又称为“包”。</p><p><img src="/images/network-basic/message.png" alt="message.png"></p><p>主机H1向主机H5发送数据。主机H1先将分组逐个地发往与它直接相连的路由器A。此时，除链路H1-A外，其他通信链路并不被目前通信的双方所占用。需要注意的是，即使是链路H1-A，也只是当分组正在此链路上传送时才被占用。在各分组传送之间的空闲时间，链路H1-A仍可为其他主机发送的分组使用。</p><p><img src="/images/network-basic/packetSwitch.png" alt="packetSwitch.png"></p><table><thead><tr><th>优点</th><th>所采用的手段</th></tr></thead><tbody><tr><td>高效</td><td>在分组传输的过程中动态分配传输带宽，对通信链路是逐段占用</td></tr><tr><td>灵活</td><td>为每一个分组独立地选择最合适的转发路由</td></tr><tr><td>迅速</td><td>以分组作为传送单位，可以不先建立连接就能向其他主机发送分组</td></tr><tr><td>可靠</td><td>保证可靠性的网络协议:分布式多路由的分组交换网，使网络有很好的生存性</td></tr></tbody></table><p>问题：</p><ul><li>分组在各路由器存储转发时需要排队，造成时延；</li><li>各分组携带的控制信息造成开销</li></ul><h4 id="1-2-2-3-报文交换"><a href="#1-2-2-3-报文交换" class="headerlink" title="1.2.2.3. 报文交换"></a>1.2.2.3. 报文交换</h4><p>采用存储转发原理，但每次交换整个报文。</p><p>三种交换方式的比较：</p><p><img src="/images/network-basic/switch.png"></p><h2 id="1-3-计算机网络的性能指标"><a href="#1-3-计算机网络的性能指标" class="headerlink" title="1.3. 计算机网络的性能指标"></a>1.3. 计算机网络的性能指标</h2><h3 id="1-3-1-速率"><a href="#1-3-1-速率" class="headerlink" title="1.3.1. 速率"></a>1.3.1. 速率</h3><p>用的信息量的单位。网络技术中的速率指的是数据的传送速率，它也称为数据率或比特率( bit rate)。速率是计算机网络中最重要的一个性能指标。速率的单位是bit/s。</p><p>当提到网络的速率时，往往指的是额定速率或标称速率，而并非网络实际上运行的</p><h3 id="1-3-2-带宽"><a href="#1-3-2-带宽" class="headerlink" title="1.3.2. 带宽"></a>1.3.2. 带宽</h3><p>带宽本来是指某个信号具有的频带宽度。在计算机网络中，带宽用来表示网络中某通道传送数据的能力，因此网络带宽表示在单位时间内网络中的某信道所能通过的“最高数据率”，单位bit/s。</p><p>前者为频域称谓，而后者为时域称谓，其本质是相同的。</p><h3 id="1-3-3-吞吐量"><a href="#1-3-3-吞吐量" class="headerlink" title="1.3.3. 吞吐量"></a>1.3.3. 吞吐量</h3><p>吞吐量表示在单位时间内通过某个网络(或信道、接口)的实际的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。显然，吞吐量受网络的带宽或网络的额定速率的限制。</p><h3 id="1-3-4-时延"><a href="#1-3-4-时延" class="headerlink" title="1.3.4. 时延"></a>1.3.4. 时延</h3><p>时延包括以下几个部分：</p><ul><li>发送时延：主机或路由器发送数据帧所需要的时间</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">发送时延&#x3D;数据帧长度bit&#x2F;发送速率bit&#x2F;s</span><br></pre></td></tr></table></figure><ul><li>传播时延 电磁波在信道中传播一定的距离需要花费的时间。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">传播时延&#x3D;信道长度m&#x2F;电磁波在信道上的传播速率m&#x2F;s</span><br></pre></td></tr></table></figure><p>发送时延与传输信道的长度没有关系，传播时延与信号的发送速率无关。</p><ul><li><p>处理时延：主机或路由器在收到分组时要花费一定的时间进行处理，例如分析分<br>组的首部、从分组中提取数据部分、进行差错检验或査找适当的路由等。</p></li><li><p>排队时延 分组在经过网络传输时，要经过许多路由器。但分组在进入路由器后<br>要先在输入队列中排队等待处理。排队时延的长短往往取决于网络当时的通信量。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总时延&#x3D;发送时延+传播时延+处理时延+排队时延</span><br></pre></td></tr></table></figure><p><img src="/images/network-basic/delay.png"></p></li></ul><p>对于高速链路，提高的仅仅是数据的发送速率而非比特在链路上的传播速率，减小了数据的发送时延，所以比特不会传送得更快。</p><h3 id="1-3-5-时延带宽积"><a href="#1-3-5-时延带宽积" class="headerlink" title="1.3.5. 时延带宽积"></a>1.3.5. 时延带宽积</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">时延带宽积&#x3D;传播时延*带宽</span><br></pre></td></tr></table></figure><p>管道中的比特数表示发送端发出的但未到达接收端的比特。</p><h3 id="1-3-6-往返时间RTT"><a href="#1-3-6-往返时间RTT" class="headerlink" title="1.3.6. 往返时间RTT"></a>1.3.6. 往返时间RTT</h3><p>信息双向交互一次所需的时间。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有效数据率&#x3D;数据长度&#x2F;发送时间+RTT</span><br></pre></td></tr></table></figure><h3 id="1-3-7-利用率"><a href="#1-3-7-利用率" class="headerlink" title="1.3.7. 利用率"></a>1.3.7. 利用率</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前时延&#x3D;网络空闲时的时延&#x2F;1-利用率</span><br></pre></td></tr></table></figure><p>这里U是网络的利用率，数值在0到1之间。当网络的利用率达到其容量的1/2时<br>时延就要加倍。</p><p>当网络的利用率接近最大值1时，网络的时延就趋于无穷大。因此我们必须有这样的概念:信道或网络的利用率过高会产生非常大的时延。</p><p><img src="/images/network-basic/delay-U.png"></p><h2 id="1-4-计算机网络体系结构"><a href="#1-4-计算机网络体系结构" class="headerlink" title="1.4. 计算机网络体系结构"></a>1.4. 计算机网络体系结构</h2><p>法律上的国际标准：OSI<br>事实上的国籍标准：TCP/IP</p><p>网络协议：未进行网络中的数据交换而建立的规则、标准或约定。包括：</p><ul><li>语法：即数据与控制信息的结构或格式</li><li>语义：即需要发出何种控制信息，完成何种动作以及做出何种响应，例如重传或丢弃的时间</li><li>同步：即事件实现顺序的详细说明</li></ul><p><img src="/images/network-basic/OSI.png"></p><h3 id="1-4-1-OSI七层模型"><a href="#1-4-1-OSI七层模型" class="headerlink" title="1.4.1. OSI七层模型"></a>1.4.1. OSI七层模型</h3><p>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><p>下4层完成通信子网的功能，上3层完成资源子网的功能。</p><p><img src="/images/network-basic/osi7.png"></p><h4 id="1-4-1-1-物理层"><a href="#1-4-1-1-物理层" class="headerlink" title="1.4.1.1. 物理层"></a>1.4.1.1. 物理层</h4><p>利用传输介质为数据链路层提供物理连接，实现比特流的透明传输，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。</p><p>考虑多大的电压代表“1”“0”，接收方应如何识别，电缆的插头应有多少根引脚、如何连接等。</p><h4 id="1-4-1-2-数据链路层"><a href="#1-4-1-2-数据链路层" class="headerlink" title="1.4.1.2. 数据链路层"></a>1.4.1.2. 数据链路层</h4><p>在物理层提供的比特流的基础上，通过差错控制、封装成帧、流量控制提供可靠的通过物理介质传输数据的方法。</p><p>该层通常又被分为介质访问控制（MAC）和逻辑链路控制（LLC）两个子层。</p><p>数据链路层的具体工作是接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层；并且，还负责处理接收端发回的确认帧的信息，以便提供可靠的数据传输。</p><h4 id="1-4-1-3-网络层"><a href="#1-4-1-3-网络层" class="headerlink" title="1.4.1.3. 网络层"></a>1.4.1.3. 网络层</h4><p>将上层的报文段或用户数据报封装成分组，也叫IP数据报。</p><p>另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。</p><p>数据链路层是解决同一网络内节点之间的通信，而网络层主要解决不同子网间的通信。</p><ul><li>寻址：数据链路层中使用的物理地址（如MAC地址）仅解决网络内部的寻址问题。在不同子网之间通信时，为了识别和找到网络中的设备，每一子网中的设备都会被分配一个唯一的地址。由于各子网使用的物理技术可能不同，因此这个地址应当是逻辑地址（如IP地址）。</li><li>交换：规定不同的信息交换方式。常见的交换技术有：线路交换技术和存储转发技术，后者又包括报文交换技术和分组交换技术。</li><li>路由算法：当源节点和目的节点之间存在多条路径时，本层可以根据路由算法，通过网络为数据分组选择最佳路径，并将信息从最合适的路径由发送端传送到接收端。</li><li>连接服务：与数据链路层流量控制不同的是，前者控制的是网络相邻节点间的流量，后者控制的是从源节点到目的节点间的流量。其目的在于防止阻塞，并进行差错检测。</li></ul><h4 id="1-4-1-4-传输层"><a href="#1-4-1-4-传输层" class="headerlink" title="1.4.1.4. 传输层"></a>1.4.1.4. 传输层</h4><p>OSI下3层的主要任务是数据通信，上3层的任务是数据处理。而传输层是通信子网和资源子网的接口和桥梁，起到承上启下的作用。</p><ul><li>传输连接管理：提供建立、维护和拆除传输连接的功能。传输层在网络层的基础上为高层提供“面向连接”和“面向无接连”的两种服务。</li><li>处理传输差错：提供可靠的“面向连接”和不太可靠的“面向无连接”的数据传输服务、差错控制和流量控制。在提供“面向连接”服务时，通过这一层传输的数据将由目标设备确认，如果在指定的时间内未收到确认信息，数据将被重发。</li></ul><h4 id="1-4-1-5-会话层"><a href="#1-4-1-5-会话层" class="headerlink" title="1.4.1.5. 会话层"></a>1.4.1.5. 会话层</h4><p>向两个实体的表示层提供建立和使用连接的方法。将不同实体之间的表示层的连接称为会话。因此会话层的任务就是组织和协调两个会话进程之间的通信，并对数据交换进行管理。</p><ul><li>会话管理：允许用户在两个实体设备之间建立、维持和终止会话，并支持它们之间的数据交换。例如提供单方向会话或双向同时会话，并管理会话中的发送顺序，以及会话所占用时间的长短。</li><li>会话流量控制：提供会话流量控制和交叉会话功能。</li><li>寻址：使用远程地址建立会话连接。l</li><li>出错控制：从逻辑上讲会话层主要负责数据交换的建立、保持和终止，但实际的工作却是接收来自传输层的数据，并负责纠正错误。会话控制和远程过程调用RPC均属于这一层的功能。但应注意，此层检查的错误不是通信介质的错误，而是磁盘空间、打印机缺纸等类型的高级错误。</li></ul><h4 id="1-4-1-6-表示层"><a href="#1-4-1-6-表示层" class="headerlink" title="1.4.1.6. 表示层"></a>1.4.1.6. 表示层</h4><p>对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。</p><p>其主要功能是“处理用户信息的表示问题，如编码、数据格式转换和加密解密”等。</p><ul><li>数据格式处理：协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异。</li><li>数据的编码：处理字符集和数字的转换。例如由于用户程序中的数据类型（整型或实型、有符号或无符号等）、用户标识等都可以有不同的表示方式，因此，在设备之间需要具有在不同字符集或格式之间转换的功能。</li><li>压缩和解压缩：为了减少数据的传输量，这一层还负责数据的压缩与恢复。</li><li>数据的加密和解密：可以提高网络的安全性。</li></ul><h4 id="1-4-1-7-应用层"><a href="#1-4-1-7-应用层" class="headerlink" title="1.4.1.7. 应用层"></a>1.4.1.7. 应用层</h4><p>计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，通过应用进程间的交互完成特定的网络应用。</p><ul><li>用户接口：应用层是用户与网络，以及应用程序与网络间的直接接口，使得用户能够与网络进行交互式联系。</li><li>实现各种服务：该层具有的各种应用程序可以完成和实现用户请求的各种服务。</li></ul><h3 id="1-4-2-总结"><a href="#1-4-2-总结" class="headerlink" title="1.4.2. 总结"></a>1.4.2. 总结</h3><p>OSI七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br>TCP/IP四层：网络接口层、 网际层、运输层、 应用层。<br>五层协议：物理层、数据链路层、网络层、运输层、 应用层。</p><p><strong>协议</strong><br>物理层：RJ45、CLOCK、IEEE802.3（网卡，网线，集线器，中继器，调制解调器）<br>数据链路：PPP、FR、HDLC、VLAN、MAC（网桥，交换机）<br>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器、网关）<br>传输层：TCP、UDP、SPX<br>会话层：NFS、SQL、NETBIOS、RPC<br>表示层：JPEG、MPEG、ASII<br>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</p><p><img src="/images/network-basic/protocolFamily.png"></p><p><strong>作用</strong><br>物理层：通过媒介传输比特，确定机械及电气规范（比特Bit）<br>数据链路层：将比特组装成帧和点到点的传递（帧Frame）<br>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）<br>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）<br>会话层：建立、管理和终止会话（会话协议数据单元SPDU）<br>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）<br>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）  </p><p><img src="/images/network-basic/data.png"></p><p>协议数据单元PDU：对等层次之间传送的数据单位。<br>服务数据单元SDU：层间交换的数据单位。<br>服务访问点SAP：同意系统中相邻两层的实体交换信息的地方。</p><p><img src="/images/network-basic/service-relation.png"></p><p>协议是水平的，服务是垂直的。</p><p><strong>交换机、路由器、网关</strong></p><ul><li><p>交换机<br>在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背 部总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部 交换矩阵迅速将数据包传送到目的端口。目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表中。<br>交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张 ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不 能划分网络层广播，即广播域。<br>交换机被广泛应用于二层网络交换，俗称“二层交换机”。<br>交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在OSI七层模型中的第二层、第三层、第四层盒第七层，并因此而得名。</p></li><li><p>路由器<br>路由器（Router）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。<br>路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。</p></li><li><p>网关<br>网关（Gateway），网关顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP/IP 的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家 庭中或者小型企业网络中使用，用于连接局域网和Internet。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。<br>在传统TCP/IP术语中，网络设备只分成两种，一种为网关（gateway），另一种为主机（host）。网关能在网络间转递数据包，但主机不能 转送数据包。在主机（又称终端系统，end system）中，数据包需经过TCP/IP四层协议处理，但是在网关（又称中介系 统，intermediate system）只需要到达网际层（Internet layer），决定路径之后就可以转送。在当时，网关 （gateway）与路由器（router）还没有区别。<br>在现代网络术语中，网关（gateway）与路由器（router）的定义不同。网关（gateway）能在不同协议间移动数据，而路由器（router）是在不同网络间移动数据，相当于传统所说的IP网关（IP gateway）。<br>网关是连接两个网络的设备，对于语音网关来说，他可以连接PSTN网络和以太网，这就相当于VOIP，把不同电话中的模拟信号通过网关而转换成数字信号，而且加入协议再去传输。在到了接收端的时候再通过网关还原成模拟的电话信号，最后才能在电话机上听到。<br>对于以太网中的网关只能转发三层以上数据包，这一点和路由是一样的。而不同的是网关中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。</p></li></ul><h1 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2. 物理层"></a>2. 物理层</h1><p>首先要强调指岀，物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而通信手段也有许多不同方式。物理层的作用正是要尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异。</p><p>可以将物理层的主要任务描述为确定与传输媒体的接口有关的一些特性，即</p><ol><li>机械特性指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置，等。平时常见的各种规格的接插件都有严格的标准化的规定。</li><li>电气特性指明在接口电缆的各条线上出现的电压的范围。</li><li>功能特性指明某条线上出现的某一电平的电压的意义。</li><li>过程特性指明对于不同功能的各种可能事件的出现顺序</li></ol><p>物理层还要完成串行-&gt;并行传输的转换。</p><h2 id="2-1-数据通信"><a href="#2-1-数据通信" class="headerlink" title="2.1. 数据通信"></a>2.1. 数据通信</h2><h3 id="2-1-1-数据通信系统"><a href="#2-1-1-数据通信系统" class="headerlink" title="2.1.1. 数据通信系统"></a>2.1.1. 数据通信系统</h3><p>可划分为三大部分，即源系统(或发送端、发送方)、传输系统(或传输网络)和目的系统(或接收端、接收方)。</p><p><img src="/images/network-basic/DataCommunication.png"></p><ul><li>模拟信号，或连续信号：代表消息的参数的取值是连续的。</li><li>数字信号，或离散信号：代表消息的参数的取值是离散的。代表不同离散数值的基本波形就称为码元。</li></ul><h3 id="2-1-2-信道"><a href="#2-1-2-信道" class="headerlink" title="2.1.2. 信道"></a>2.1.2. 信道</h3><p>从通信的双方信息交互的方式来看，可以有以下三种基本方式：</p><ul><li>单向通信：称为单工通信，即只能有一个方向的通信而没有反方向的交互。无<br>线电广播或有线电广播以及电视广播就属于这种类型</li><li>双向交替通信：又称为半双工通信，即通信的双方都可以发送信息，但不能双方<br>同时发送(当然也就不能同时接收)。</li><li>双向同时通信：又称为全双工通信，即通信的双方可以同时发送和接收信息<br>单向通信只需要一条信道，而双向交替通信或双向同时通信则都需要两条信道(每个<br>方向各一条)。</li></ul><p>显然，双向同时通信的传输效率最高。</p><p>来自信源的基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。所以必须对基带信号进行调制，分为两大类：</p><ul><li>基带调制：对基带信号的波形进行变换，使它能够与信道特性相适应，变换后的信号仍然是基带信号，也称为编码。<ul><li>不归零制</li><li>归零制</li><li>曼彻斯特编码</li><li>差分曼彻斯特编码</li></ul></li><li>带通调制：使用载波把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，经过载波调制后的信号称为带通信号，即仅在一段频率范围内能够通过信道。<ul><li>调幅（AM）</li><li>调频（FM）</li><li>调相（PM）</li></ul></li></ul><h3 id="2-1-3-信道的极限容量"><a href="#2-1-3-信道的极限容量" class="headerlink" title="2.1.3. 信道的极限容量"></a>2.1.3. 信道的极限容量</h3><p>码间串扰：接收端收到的信号波形就失去了码元之间的清晰界限。<br>严重的码间串扰使得本来分得很清楚的一串码元变得模糊而无法识别。</p><p>奈氏准则：在任何信道中，码元传输的速率是有上限的，传输速率超过此上限，就会出现严重的码间串扰的问题。</p><p>信噪比：所谓信噪比就是信号的平均功率和噪声的平均功率之比，常记为S/N，并用分贝(dB)作为度量单位。</p><p><img src="/images/network-basic/SNR.png"></p><p>香农公式：信道的极限信息传输速率C是</p><p><img src="/images/network-basic/shannon.png"></p><p>式中，W为信道的带宽(Hz);S为信道内所传信号的平均功率;N为信道内<br>部的高斯噪声功率。</p><p>香农公式的意义在于:只要信息传输速率低于信道的极限信息传输速率，就一定存在某种办法来实现无差错的传输。</p><p>从以上所讲的不难看出，对于频带宽度已确定的信道，可以用编码的方法让每一个码元携带更多比特的信息量。</p><h2 id="2-2-物理层下的传输媒体"><a href="#2-2-物理层下的传输媒体" class="headerlink" title="2.2. 物理层下的传输媒体"></a>2.2. 物理层下的传输媒体</h2><ul><li>导引型<ul><li>双绞线</li><li>同轴线缆</li><li>光缆</li></ul></li><li>非导引型<ul><li>短波通信</li><li>无线电微波通信</li><li>卫星通信</li></ul></li></ul><h2 id="2-3-信道复用技术"><a href="#2-3-信道复用技术" class="headerlink" title="2.3. 信道复用技术"></a>2.3. 信道复用技术</h2><p><img src="/images/network-basic/multiplexing.png"></p><ul><li>频分复用（FDM）：所有用户在同样的时间占用不同的带宽资源。</li><li>时分复用（TDM）：所有用户在不同的时间占用同样的频带宽度，又称为同步时分复用。</li></ul><p><img src="/images/network-basic/FDM-TDM.png"></p><ul><li>统计时分复用（STDM）：改进的时分复用，缓存用户数据放入STDM帧，又称为异步时分复用</li><li>波分复用（WDM）：光的频分复用。</li><li>码分复用（CDM）：共享信道。</li></ul><h2 id="2-4-宽带接入技术"><a href="#2-4-宽带接入技术" class="headerlink" title="2.4. 宽带接入技术"></a>2.4. 宽带接入技术</h2><ul><li>ADSL技术：改造电话用户线；</li><li>光纤同轴混合网（HFC网）：改造有线电视网；</li><li>光纤到户（FTTx）：光信号转电信号。</li></ul><h1 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3. 数据链路层"></a>3. 数据链路层</h1><p>数据链路层使用的信道：</p><ul><li>点对点信道。这种信道使用一对一的点对点通信方式。</li><li>广播信道。这种信道使用一对多的广播通信方式。</li></ul><h2 id="3-1-使用点对点信道"><a href="#3-1-使用点对点信道" class="headerlink" title="3.1. 使用点对点信道"></a>3.1. 使用点对点信道</h2><h3 id="3-1-1-三个基本问题"><a href="#3-1-1-三个基本问题" class="headerlink" title="3.1.1. 三个基本问题"></a>3.1.1. 三个基本问题</h3><p>封装成帧。透明传输、差错检测</p><h4 id="3-1-1-1-封装成帧"><a href="#3-1-1-1-封装成帧" class="headerlink" title="3.1.1.1. 封装成帧"></a>3.1.1.1. 封装成帧</h4><p>封装成帧就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧，</p><p>首部和尾部的一个重要作用就是进行帧定界(即确定帧的界限)。此外，首部和尾部还包括许多必要的控制信息。应当使帧的数据部分长度尽可能地大于首部和尾部的长度。每一种链路层协议都规定了所能传送的帧的数据部分长度上限—最大传送<br>单元MTU。</p><p><img src="/images/network-basic/MTU.PNG"></p><p>帧定界符SOH和EOT标识真的开始与结束，用以判断一个完整的帧。</p><h4 id="3-1-1-2-透明传输"><a href="#3-1-1-2-透明传输" class="headerlink" title="3.1.1.2. 透明传输"></a>3.1.1.2. 透明传输</h4><p>当传送的用文本组成的帧时，不管从键盘上输入什么字符都可以放在这样的帧中传输过去，因此这样的传输就是透明传输。</p><p>但当数据部分是非ASCI码的文本文件时(如二进制代码的计算机程序或图像等)，情<br>况就不同了。如果数据中的某个字节的二进制代码恰好和SOH或EOT这种控制字符一样<br>，数据链路层就会错误地“找到帧的边界”，把部分帧收下(误认为是个完整的<br>帧)，而把剩下的那部分数据丢弃(这部分找不到帧定界控制字符SOH)。</p><p><img src="/images/network-basic/EOT.PNG"></p><p><strong>字符填充</strong></p><p>为了解决透明传输问题，发送端的数据链路层在数据中出现控制字符<br>SOH”或“EOT”的前面插入一个转义字符“ESC”。而在接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符。</p><h4 id="3-1-1-3-差错检测"><a href="#3-1-1-3-差错检测" class="headerlink" title="3.1.1.3. 差错检测"></a>3.1.1.3. 差错检测</h4><p>比特差错：比特在传输过程中可能会产生差错：1可能会变成0，而0也可能变成1。</p><p>误码率BER：在一段时间内，传输错误的比特占所传输比特总数的比率。</p><p><strong>循环冗余检验CRC</strong></p><p><img src="/images/network-basic/CRC1.PNG"><br><img src="/images/network-basic/CRC2.PNG"></p><p>判定这个帧有差错，但无法确定究竟是哪一位或哪几位出现了差错。</p><p>在数据链路层若仅仅使用循环冗余检验CRC差错检测技术，则只能做到对帧的无差错接受</p><p>即:“凡是接收端数据链路层接受的帧，我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错”。接收端丢弃的帧虽然曾收到了，但最终还是因为有差错被丢弃，即没有被接受。</p><p>传输差错：帧丢失、帧重复或帧失序。</p><p>过去oSI的观点是:必须让数据链路层向上提供可靠传输。因此在CRC检错的基础上，增加了帧编号、确认和重传机制。</p><h3 id="3-1-2-点对点协议PPP"><a href="#3-1-2-点对点协议PPP" class="headerlink" title="3.1.2. 点对点协议PPP"></a>3.1.2. 点对点协议PPP</h3><p>在TCP/P协议族中，可靠传输由运输层的TCP协议负责，因此数据链路层的PPP协<br>议不需要进行纠错，不需要设置序号，也不需要进行流量控制。PPP协议不支持多点线路，只支持点对点的链路通信。此外，PPP协议只支持全双工链路。</p><h4 id="3-1-2-1-协议组成"><a href="#3-1-2-1-协议组成" class="headerlink" title="3.1.2.1. 协议组成"></a>3.1.2.1. 协议组成</h4><p>PPP协议有三个组成部分：</p><ol><li>将P数据报封装到串行链路的方法。PP既支持异步链路(无奇偶检验的8比<br>特数据)，也支持面向比特的同步链路。IP数据报在PPP帧中就是其信息部分。这个信息部分的长度受最大传送单元MTU的限制。</li><li>用来建立、配置和测试数据链路连接的链路控制协议LCP( Link Cont<br>Protoco)。通信的双方可协商一些选项。在RFC1661中定义了11种类型的LCP分组</li><li>一套网络控制协议 NCP(Network Control Protocol)°，其中的每一个协议支持不同的网络层协议，如IP、OSI的网络层、 DECnet，以及 AppleTalk等</li></ol><h4 id="3-1-2-2-PPP帧格式"><a href="#3-1-2-2-PPP帧格式" class="headerlink" title="3.1.2.2. PPP帧格式"></a>3.1.2.2. PPP帧格式</h4><p><img src="/images/network-basic/PPP.PNG"></p><ul><li>F：0x7E 01111110，标志字段，标识帧的开始或结束</li><li>A、C：无意义</li><li>协议：表示信息部分使用的协议类型</li><li>FCS：检验序列</li></ul><p><strong>字节填充</strong><br>使用异步传输时，它把转义符定义为0xD(即ol11101)，并使用字节填充<br>RFC1662规定了如下所述的填充方法</p><ol><li>把信息字段中出现的每一个0x7E字节转变成为2字节序列(0x7D，0x5E)</li><li>若信息字段中出现一个0x7D的字节(即出现了和转义字符一样的比特组合)，则<br>把0x7D转变成为2字节序列(0x7D，0x5D)</li><li>若信息字段中出现ASCI码的控制字符(即数值小于0x20的字符)，则在该字符前<br>面要加入一个αx⑦D字节，同时将该字符的编码加以改变。例如，出现0x03(在控制字符中是“传输结束”ETX)就要把它转变为2字节序列(0x7D，Ox23)。</li></ol><p><strong>零比特填充</strong><br>使用同步传输时，在发送端，只要发现有5个连续1，则立即填入一个0。因此经过这种填充后的数据，就可以保证在信息字段中不会出现6个连续1。接收端在收到一个帧<br>时，先找到标志字段F以确定一个帧的边界，接着再用硬件对其中的比特流进行扫描。每当发现5个连续1时，就把这5个连续1后的一个0删除，以还原成原来的信息比特流。</p><h4 id="3-1-2-3-PPP协议工作状态"><a href="#3-1-2-3-PPP协议工作状态" class="headerlink" title="3.1.2.3. PPP协议工作状态"></a>3.1.2.3. PPP协议工作状态</h4><p><img src="/images/network-basic/PPPstatus.PNG"></p><p>当用户拨号接入ISP后，就建立了一条从用户个人电脑到IsP的物理连接。这时，用户个人电脑向ISSP发送一系列的链路控制协议LCP分组(封装成多个PPP帧)，以便建立LCP连接。这些分组及其响应选择了将要使用的一些PPP参数。接着还要进行网络层配置，网络控制协议NCP给新接入的用户个人电脑分配一个临时的IP地址。这样，用户个人电脑就成为互联网上的一个有IP地址的主机</p><p>当用户通信完毕时，NCP释放网络层连接，收回原来分配出去的IP地址。接着，LCP释放数据链路层连接。最后释放的是物理层的连接。</p><p>在“网络层协议”状态，PPP链路的两端的网络控制协议NCP根据网络层的不同协议互相交换网络层特定的网络控制分组。这个步骤是很重要的，因为现在的路由器都能够同时支持多种网络层协议。总之，PPP协议两端的网络层可以运行不同的网络层协议，但仍然可使用同一个PP协议进行通信<br>如果在PPP链路上运行的是IP协议，则对PP链路的每一端配置IP协议模块(如分配IP地址)时就要使用NCP中支持IP的协议——IP控制协议IPCP( IP ControlProtoco)IPCP分组也封装成PPP帧(其中的协议字段为0x8021)在PP链路上传送。在低速链路上运行时，双方还可以协商使用压缩的TCP和P首部，以减少在链路上发送的比特数。</p><p>PPP协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。</p><h2 id="3-2-使用广播信道"><a href="#3-2-使用广播信道" class="headerlink" title="3.2. 使用广播信道"></a>3.2. 使用广播信道</h2><h3 id="3-2-1-局域网的数据链路层"><a href="#3-2-1-局域网的数据链路层" class="headerlink" title="3.2.1. 局域网的数据链路层"></a>3.2.1. 局域网的数据链路层</h3><p>局域网使用的就是广播信道。按照网络拓扑分为星形网、环形网、总线网。总线网以传统以太网最为著名，之后出现的快速以太网、吉比特以太网在市场中占据绝对优势，以太网成为局域网的同义词。</p><p>共享信道技术：</p><ul><li>静态划分信道：复用分用技术；</li><li>动态媒体接入控制：又称多点接入<ul><li>随机接入：用户随机发送信息，需要解决碰撞；</li><li>受控接入：用户发送信息需要服从控制。轮询。</li></ul></li></ul><h4 id="3-2-1-1-以太网的两个标准"><a href="#3-2-1-1-以太网的两个标准" class="headerlink" title="3.2.1.1. 以太网的两个标准"></a>3.2.1.1. 以太网的两个标准</h4><ul><li>DIX Ethernet V2</li><li>IEEE 802.3</li></ul><p>二者差别很小。后来IEEE 802将数据链路层拆分为逻辑链路控制LLC( Logical Link Contro)子层和媒体接入控制MAC( Medium Access Control)子层。与接入到传输媒体有关的内容都放在MAC子层，而LLC子层则与传输媒体无关。</p><p>后来市场稳定，LLC子层的作用消失，DIX Ethernet V2市场更大。</p><h4 id="3-2-1-2-适配器"><a href="#3-2-1-2-适配器" class="headerlink" title="3.2.1.2. 适配器"></a>3.2.1.2. 适配器</h4><p>计算机与外界局域网的连接时通过通信适配器进行的，又称为网络接口卡NIC。装有处理器和存储器（包括RAM和ROM）</p><p>作用：</p><ul><li>串并行的转换</li><li>缓存</li><li>实现以太网协议</li></ul><p>工作：</p><p>适配器在接收和发送时不使用计算机的CPU。当适配器收到有差错的帧时，就把这个帧直接丢弃而不必通知计算机。收到正确的帧时，它就使用中断来通知该计算机，并交付协议栈中的网络层。</p><p>当计算机要发送IP数据报时，就由协议栈把IP数据报向下交给适配器，组装成帧后发送到局域网。</p><p>计算机的硬件地址就在适配器的ROM中，而计算机的软件地址（IP地址）则在计算机的存储器中。</p><h3 id="3-2-2-CSMA-CD协议"><a href="#3-2-2-CSMA-CD协议" class="headerlink" title="3.2.2. CSMA/CD协议"></a>3.2.2. CSMA/CD协议</h3><p>总线使用。</p><p>为了通信简便，采用两个措施：</p><ol><li>采用较为灵活的无连接的工作方式，即不必先建立连接就可以直接发送数据<br>适配器对发送的数据帧不进行编号，也不要求对方发回确认。以太网提供的服务是尽最大努力的交付，即不可靠的交付。</li></ol><p>当目的站收到有差错的数据帧时，就把帧丢弃，其他什么也不做。对有差错帧是否需要重传则由高层来决定。</p><p>总线上在同一时间只能允许一台计算机发送数据，否则各计算机之间就会互相干扰，因此以太网使用CSMA/CD协议。</p><ol start="2"><li>以太网发送的数据都使用曼彻斯特( Manchester)编码的信号。</li></ol><p><strong>要点</strong></p><ul><li>先听后发<br>在发送前检测信道，是为了获得发送权。如果检测出已经有其他站在发送，则自己就暂时不许发送数据，必须要等到信道变为空闲时才能发送。</li><li>边听边发<br>在发送中检测信道，是为了及时发现有没有其他站的发送和本站发送的碰撞。</li><li>冲突停止<br>当适配器检测到的信号电压变化幅度超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。适配器就要立即停止发送，免得继续进行无效的<br>发送，白白浪费网络资源，然后等待一段随机时间后再次发送。</li><li>延迟重发<br>使用截断二进制指数退避算法确定延迟重发时机。</li></ul><p>因为传播时延的存在导致先听后发之后人有可能发生碰撞。发送数据后，最迟要经过多长时间才能知道自己发送的数据和其他站发送的数据有没有发生碰撞?这个时间最多是两倍的总线端到端的传播时延(2r)，称为争用期，又叫碰撞窗口。，即经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><p>因此局域网必须按最坏情况设计，即取总线两端的两个站之间的传播时延(这两个站之间的距离最大)为端到端传播时延。</p><p><img src="/images/network-basic/crash.PNG"></p><p>显然，在使用 CSMA/CD协议时，一个站不可能同时进行发送和接收(但必须边发送<br>边监听信道)。因此使用 CSMA/CD协议的以太网不可能进行全双工通信而只能进行双向交替通信(半双工通信)。</p><p>凡长度小于64字节的帧都是由于冲突而中止的无效帧。</p><p><strong>强化碰撞</strong><br>当发送数据的站一旦发现发生了碰撞时，除了立即停止发送数据外，还要再继续发送3比特或48比特的人为干扰信号，以便让所有用户都知道现在已经发生了碰撞。</p><p><strong>帧间最小间隔</strong><br>以太网还规定了帧间最小间隔为96μs，相当于96比特时间。这样做是为了使刚刚收<br>到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。</p><h3 id="3-2-3-使用集线器的星形拓扑"><a href="#3-2-3-使用集线器的星形拓扑" class="headerlink" title="3.2.3. 使用集线器的星形拓扑"></a>3.2.3. 使用集线器的星形拓扑</h3><p>集线器和每个站之间使用两对双绞线，用于发送和接收。<br>IEEE制定了10BASE-T星形以太网标准802.3i。“10”代表10Mbit/s的数据率，BASE表示连接线上的信号是基带信号，T代表双绞线。每个站到集线器的距离不超过100m。</p><p><strong>特点</strong></p><ul><li>用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是<br>CSMA/CD协议。</li><li>一个集线器有许多接口，每个接口通过RJ-45插头用两对双绞线与一台计算机上的适配器相连。因此，一个集线器很像一个多接口的转发器。</li><li>集线器工作在物理层，它的每个接口仅仅简单地转发比特，收到1就转发1，收<br>到0就转发0，不进行碰撞检测。</li></ul><h3 id="3-2-4-信道利用率"><a href="#3-2-4-信道利用率" class="headerlink" title="3.2.4. 信道利用率"></a>3.2.4. 信道利用率</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">信道利用率a&#x3D;\frac&#123;单程端到端时延r&#125;&#123;帧的发送时间T&#125;</span><br></pre></td></tr></table></figure><p>因此，以太网的连线的长度受到限制(否则r数值会太大)，同时以太网的帧长不能太短(否则T的值会太小，使a值太大)。</p><h3 id="3-2-5-MAC层"><a href="#3-2-5-MAC层" class="headerlink" title="3.2.5. MAC层"></a>3.2.5. MAC层</h3><h4 id="3-2-5-1-MAC地址"><a href="#3-2-5-1-MAC地址" class="headerlink" title="3.2.5.1. MAC地址"></a>3.2.5.1. MAC地址</h4><p>规定了一种48位的全球地址，是指局域网上的每一台计算机中固化在适配器的ROM中的地址。</p><p>适配器从网络上每收到一个MAC帧就先用硬件检査MAC帧中的目的地址。如果是发往本站的帧则收下，然后再进行其他的处理。否则就将此帧丢弃，不再进行其他的处理。</p><p>“发往本站的帧”包括以下三种帧：</p><ul><li>单播(unicast)帧(一对一)，即收到的帧的MAC地址与本站的硬件地址相同。</li><li>广播(broadcast帧(一对全体)，即发送给本局域网上所有站点的帧(全1地址)。</li><li>多播(multicas帧(一对多)，即发送给本局域网上一部分站点的帧</li></ul><p>所有的适配器都至少应当能够识别前两种帧，即能够识别单播和广播地址。显然，只有目的地址才能使用广播地址和多播地址。</p><h4 id="3-2-5-2-MAC帧的格式"><a href="#3-2-5-2-MAC帧的格式" class="headerlink" title="3.2.5.2. MAC帧的格式"></a>3.2.5.2. MAC帧的格式</h4><ol><li>DIX Ethernet V2</li></ol><p><img src="/images/network-basic/MAC.PNG"></p><p>类型：标注上一层是什么协议。</p><p><strong>帧长度</strong><br>在曼彻斯特编码的每一个码元(不管码元是1或0)的正中间一定有次电压的转换(从高到低或从低到高)。当发送方把一个以太网帧发送完毕后，就不再发送其他码元了(既不发送1，也不发送0)。因此，发送方网络适配器的接口上的电压也就不再变化了。这样，接收方就可以很容易地找到以太网帧的结束位置。在这个位置往前数4字节<br>(FCS字段长度是4字节)，就能确定数据字段的结束位置。</p><p><strong>8字节</strong><br>第一个字段是7个字节的前同步码(1和0交替码)，它的作用是使接收端的适配器在接收MAC帧时能够迅速调整其时钟频率，使它和发送端的时钟同步<br>也就是“实现位同步”(位同步就是比特同步的意思)。第二个字段是帧开始定界符，定义为10101011。</p><p><strong>定界</strong><br>以太网在传送帧时，各帧之间还必须有一定的间隙。因此，接收端只要找到帧开始定界符，其后面的连续到达的比特流就都属于同一个MAC帧。可见以太网不需要使用帧结束定界符，也不需要使用字节插入来保证透明传输。</p><ol start="2"><li>IEEE802.3</li></ol><ul><li>IEEE8023规定的MAC帧的第三个字段是“长度/类型”。当这个字段值大于<br>0x0600时(相当于十进制的1536)，就表示“类型”。这样的帧和以太网V2 MAC帧完全<br>样。只有当这个字段值小于0x0600时才表示“长度”，即MAC帧的数据部分长度。实际上，前面我们已经讲过，由于以太网采用了曼彻斯特编码，长度字段并无实际意义。</li><li>当“长度/类型”字段值小于0x0600时，数据字段必须装入上面的逻辑链路控制<br>JC子层的LLC帧。</li></ul><h3 id="3-2-6-扩展的以太网"><a href="#3-2-6-扩展的以太网" class="headerlink" title="3.2.6. 扩展的以太网"></a>3.2.6. 扩展的以太网</h3><p>扩展的以太网在网络层看来仍是一个网络。</p><h4 id="3-2-6-1-物理层扩展"><a href="#3-2-6-1-物理层扩展" class="headerlink" title="3.2.6.1. 物理层扩展"></a>3.2.6.1. 物理层扩展</h4><p>使用多级结构的集线器。</p><p><img src="/images/network-basic/physical-ex.PNG"></p><p><strong>缺点</strong></p><ol><li>通过集线器互连起来后就把三个碰撞域变成一个碰撞域，而这时的最大吞吐量没有变化。</li><li>如果不同的系使用不同的以太网技术，那么就不可能用集线器将们互连起来。</li></ol><h4 id="3-2-6-2-数据链路层扩展"><a href="#3-2-6-2-数据链路层扩展" class="headerlink" title="3.2.6.2. 数据链路层扩展"></a>3.2.6.2. 数据链路层扩展</h4><p>以太网交换机的出现代替了网桥转发帧。</p><h5 id="3-2-6-2-1-交换机特点"><a href="#3-2-6-2-1-交换机特点" class="headerlink" title="3.2.6.2.1. 交换机特点"></a>3.2.6.2.1. 交换机特点</h5><ul><li>实质是一个多接口的网桥，全双工工作，具有并行性，即同时连通多对接口使之同时通信。主机独占传输媒体，无碰撞地传输数据；</li><li>接口有存储器帮助缓存；</li><li>即插即用，内部的交换表通过自学习算法自动建立；</li><li>用户独享带宽，增加了总吞吐量；</li><li>多种速率的接口</li></ul><h5 id="3-2-6-2-2-路由器与交换机的主要区别"><a href="#3-2-6-2-2-路由器与交换机的主要区别" class="headerlink" title="3.2.6.2.2. 路由器与交换机的主要区别"></a>3.2.6.2.2. 路由器与交换机的主要区别</h5><ol><li>工作层次不同 <br>最初的的交换机是工作在数据链路层，而路由器一开始就设计工作在网络层。由于交换机工作在数据链路层，所以它的工作原理比较简单，而路由器工作在网络层，可以得到更多的协议信息，路由器可以做出更加智能的转发决策。 </li><li>数据转发所依据的对象不同 <br>交换机是利用物理地址或者说MAC地址来确定转发数据的目的地址。而路由器则是利用IP地址来确定数据转发的地址。IP地址是在软件中实现的，描述的是设备所在的网络。MAC地址通常是硬件自带的，由网卡生产商来分配的，而且已经固化到了网卡中去，一般来说是不可更改的。而IP地址则通常由网络管理员或系统自动分配。 </li><li>传统的交换机只能分割冲突域，不能分割广播域；而路由器可以分割广播域 <br>由交换机连接的网段仍属于同一个广播域，广播数据包会在交换机连接的所有网段上传播，在某些情况下会导致通信拥挤和安全漏洞。连接到路由器上的网段会被分配成不同的广播域，广播数据不会穿过路由器。虽然第三层以上交换机具有VLAN功能，也可以分割广播域，但是各子广播域之间是不能通信交流的，它们之间的交流仍然需要路由器。 </li><li>路由器提供了防火墙的服务 <br>路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴。</li></ol><h5 id="3-2-6-2-3-以太网的自学习功能"><a href="#3-2-6-2-3-以太网的自学习功能" class="headerlink" title="3.2.6.2.3. 以太网的自学习功能"></a>3.2.6.2.3. 以太网的自学习功能</h5><p><img src="/images/network-basic/self-learn.PNG"></p><p>A先向B发送一帧，从接口1进入到交换机。交换机收到帧后，先查找交换表，没有<br>查到应从哪个接口转发这个帧(在MAC地址这一列中，找不到目的地址为B的项目)。接<br>着，交换机把这个帧的源地址A和接口1写入交换表中，并向除接口1以外的所有接口<br>播这个帧(这个帧就是从接口1进来的，当然不应当把它再从接口1转发出去)。<br>C和D将丢弃这个帧，因为目的地址不对。只B才收下这个目的地址正确的帧。这也<br>称为过滤。<br>从新写入交换表的项目(A，1)可以看出，以后不管从哪一个接口收到帧，只要其目的地<br>址是A，就应当把收到的帧从接口1转发出去。这样做的依据是:既然A发出的帧是从接<br>口1进入到交换机的，那么从交换机的接口1转发出的帧也应当可以到达A。<br>假定接下来B通过接口3向A发送一帧。交换机查找交换表，发现交换表中的MAC地址有A。表明要发送给A的帧(即目的地址为A的帧)应从接口1转发。于是就把这个帧传送到接口1转发给A。显然，现在已经没有必要再广播收到的帧。交换表这时新增加的项目(B，3)，表明今后如有发送给B的帧，就应当从接口3转发出去。<br>经过一段时间后，只要主机C和D也向其他主机发送帧，以太网交换机中的交换表就会把转发到C或D应当经过的接口号(2或4)写入到交换表中。这样，交换表中的项目就齐全了。要转发给任何一台主机的帧，都能够很快地在交换表中找到相应的转发接口考虑到有时可能要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更改交换表中的项目。为此，在交换表中每个项目都设有一定的有效时间。过期的项目就<br>自动被删除。用这样的方法保证交换表中的数据都符合当前网络的实际状况。<br>以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置。</p><p><strong>生成树协议STP</strong></p><p><img src="/images/network-basic/STP.PNG"></p><p>假定一开始主机A通过接口交换机#1向主机B发送一帧。交换机#1收到这个帧后就向所有其他接口进行广播发送。现观察其中一个帧的走向:离开交换机#1的<br>接口3→交换机#2的接口1→接口2→交换机#1的接口4→接口3→交换机#的接口这样就无限制地循环兜圈子下去，白白消耗了网络资源<br>为了解决这种兜圈子问题，IEE的8021D标准制定了一个生成树协议STP( Spanning<br>Tree Protocol)。其要点就是不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从台主机到所有其他主机的路径是无环路的树状结构，从而消除了兜圈子现象。</p><h1 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4. 网络层"></a>4. 网络层</h1><h2 id="4-1-网络层提供的两种服务"><a href="#4-1-网络层提供的两种服务" class="headerlink" title="4.1. 网络层提供的两种服务"></a>4.1. 网络层提供的两种服务</h2><ul><li>面向连接：虚电路</li><li>无连接的</li></ul><p>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服。<br>网络在发送分组时不需要先建立连接。每一个分组(也就是IP数据报)独立发送，与其前后的分组无关(不进行编号)。网络层不提供服务质量的承诺。</p><p>虚电路服务与数据报服务的对比：</p><table><thead><tr><th>对比的方面</th><th>虚电路服务</th><th>数据报服务</th></tr></thead><tbody><tr><td>思路</td><td>靠通信应当由网络来保证</td><td>可靠通信应当由用户主机来保证</td></tr><tr><td>连接的建立</td><td>必须有</td><td>不需要</td></tr><tr><td>终点地址</td><td>仅在连接建立阶段使用，每个分组使用短</td><td>每个分组都有终点的完整地址</td></tr><tr><td>的虚电路号</td><td></td><td></td></tr><tr><td>分组的转发</td><td>属于同一条虚电路的分组均按照同一路由进行转发</td><td>每个分组独立选择路由进行转发</td></tr><tr><td>当结点出故障时</td><td>所有通过出故障的结点的虚电路均不能工作</td><td>出故障的结点可能会丢失分组</td></tr><tr><td>分组的顺序</td><td>总是按发送顺序到达终点</td><td>到达终点的时间不一定按发送顺序</td></tr><tr><td>端到端的差错处理和流量控制</td><td>可以由网络负责，也可以由用户主机负责</td><td>由用户主机负责</td></tr></tbody></table><h2 id="4-2-网际协议IP"><a href="#4-2-网际协议IP" class="headerlink" title="4.2. 网际协议IP"></a>4.2. 网际协议IP</h2><p>与IP协议配套使用的还有三个协议：</p><ul><li>地址解析协议ARP</li><li>网际控制报文协议ICMP</li><li>网际组管理协议IGMP</li><li><del>逆地址解析协议RARP</del>：使只知道自己硬件地址的主机能够通过RARP协议找出其IP地址。现在的DHCP协议已经包含RARP协议的功能。</li></ul><h3 id="4-2-1-分类的IP地址"><a href="#4-2-1-分类的IP地址" class="headerlink" title="4.2.1. 分类的IP地址"></a>4.2.1. 分类的IP地址</h3><p>IP编址经历的三个历史阶段：</p><ol><li>分类的IP地址</li><li>划分子网</li><li>构造超网</li></ol><h4 id="4-2-1-1-IP地址的表示"><a href="#4-2-1-1-IP地址的表示" class="headerlink" title="4.2.1.1. IP地址的表示"></a>4.2.1.1. IP地址的表示</h4><p>一个网络号在整个互联网范围内必须是唯一的，一台主机号在它前面的网络号所指明的网络范围内必须是唯一的，一个IP地址在整个互联网范围内是唯一的。</p><p>两级的IP地址可以记为:<br>IP地址:={&lt;网络号&gt;，&lt;主机号&gt;}</p><p><img src="/images/network-basic/divideClassIP.PNG"></p><h4 id="4-2-1-2-常见的三类IP地址"><a href="#4-2-1-2-常见的三类IP地址" class="headerlink" title="4.2.1.2. 常见的三类IP地址"></a>4.2.1.2. 常见的三类IP地址</h4><p>A类地址的网络号字段占1个字节，只有7位可供使用(该字段的第一位已固定为0)，但可指派的网络号是126个(即27-2)。减2的原因是:第一，IP地址中的全0表示“这个this”。网络号字段为全0的IP地址是个保留地址，意思是“本网络”;第二，网络号为127(即01111111作为本地软件环回测试( loopback test)本主机的进程之间的通信之用。目的地址为环回地址的IP数据报永远不会出现在任何网络上，因为网络号为127的地址根本不是一个网络地址。</p><p>A类地址的主机号占3个字节，因此每一个A类网络中的最大主机数是24-2，即6770214。这里减2的原因是:全0的主机号字段表示该IP地址是“本主机”所连接到的单个网络地址(例如，一主机的IP地址为567.8，则该主机所在的网络地址就是567.0.0.0)而全1表示“所有的(a)”，因此全1的主机号字段表示该网络上的所有主机</p><p>B类地址的网络号字段有2个字节，但前面两位(10)已经固定了，只剩下14位可以进行分配。因为网络号字段后面的14位无论怎样取值也不可能出现使整个2字节的网络号字段成为全0或全1，因此这里不存在网络总数减2的问题。</p><p>C类地址有3个字节的网络号字段，最前面的3位是(110)，还有21位可以进行分配。C类网络地址1920.0.0也是不指派的，可以指派的C类最小网络地址是92010</p><p><strong>IP地址的指派范围</strong></p><table><thead><tr><th>网络类别</th><th>最大可指派的网络数</th><th>第一个可指派的网络号</th><th>最后一个可指派的网络号</th><th>每个网络中的最大主机数</th></tr></thead><tbody><tr><td>A</td><td>2{7}-2</td><td>1</td><td>126</td><td>16777214</td></tr><tr><td>B</td><td>2{14}-2</td><td>128.1</td><td>191.255</td><td>65534</td></tr><tr><td>C</td><td>2{21}-2</td><td>192.0.1</td><td>223.255.255</td><td>254</td></tr></tbody></table><p><strong>一般不使用的特殊IP地址</strong></p><table><thead><tr><th>网络号</th><th>主机号</th><th>源地址使用</th><th>目的地址使用</th><th>代表的意思</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>可以</td><td>不可</td><td>在本网络上的本主机(DHCP)</td></tr><tr><td>0</td><td>host-id</td><td>可以</td><td>不可</td><td>在本网络上的某台主机 host-id</td></tr><tr><td>全1</td><td>全1</td><td>不可</td><td>可以</td><td>只在本网络上进行广播(各路由器均不转发)</td></tr><tr><td>net-id</td><td>全1</td><td>不可</td><td>可以</td><td>对net-id上的所有主机进行广播</td></tr><tr><td>127</td><td>非全0或全1的任何数</td><td>可以</td><td>可以</td><td>用于本地软件环回测试</td></tr></tbody></table><p><strong>特点</strong></p><ul><li>每一个IP地址都由网络号和主机号两部分组成。所以IP地址是一种<br>分等级的地址结构。分两个等级的好处是:<ul><li>IP地址管理机构在分配I地址时只分配网络号(第一级)，而剩下的主机号(第二级)则由得到该网络号的单位自行分配。</li><li>路由器仅根据目的主机所连接的网络号来转发分组(而不考虑目的主机号)，这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间以及查找路由表的时间。</li></ul></li><li>实际上IP地址是标志一台主机(或路由器)和一条链路的接口。当一台主机同时连<br>接到两个网络上时，该主机就必须同时具有两个相应的IP地址，其网络号必须是不同的<br>这种主机称为多归属主机。</li><li>用转发器或网桥连接起来的若干个局域网仍为一个网络，因为这些局域网都具有同样的网络号。具有不同网络号的局域网必须使用路由器进行互连。</li><li>所有分配到网络号的网络(不管是范围很小的局域网，还是可能覆盖很大地理范围的广域网)都是平等的。所谓平等，是指互联网同等对待每一个IP地址。</li></ul><p><img src="/images/network-basic/IPofInternet.PNG"></p><h3 id="4-2-2-私有地址"><a href="#4-2-2-私有地址" class="headerlink" title="4.2.2. 私有地址"></a>4.2.2. 私有地址</h3><p>由于IP地址的紧缺，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机数。考虑到互联网并不很安全，一个机构内也并不需要把所有的主机接入到外部的互联网.实际上，在许多情况下，很多主机主要还是和本机构内的其他主机进行通信。假定在一个机构内部的计算机通信也是采用 TCP/IP协议，那么从原则上讲，对于这些仅在机构内部使用的计算机就可以由本机构自行分配其IP地址。这就是说，让这些计算机使用仅在本机构有效的酽地址(这种地址称为私有地址)，而不需要向互联网的管理机构申请全球唯一的IP地址(这种地址称为公有地址)。这样就可以大大节约宝贵的全球IP地址资源。</p><p>为了解决这一问题，RFC1918指明了一些专用地址( private address)这些地址只能用<br>于一个机构的内部通信，而不能用于和互联网上的主机通信。在互联网中的所有路由器，对目的地址是专用地址的数据报<br>律不进行转发，即</p><ul><li>10.0.0.0到10.255.255.255(或记为10.0.0.0/8，它又称为24位块)</li><li>172.16.0.0到172.16.255.255(或记为172.16.0.0/12，它又称为20位块)</li><li>192.168.0.0到192.168.255.255(或记为192.168.0.0/16，它又称为16位块)</li></ul><p>采用这样的专用IP地址的互连网络就叫做专用网。专用IP地址也叫做可重用地址。</p><h3 id="4-2-3-网络地址转换NAT"><a href="#4-2-3-网络地址转换NAT" class="headerlink" title="4.2.3. 网络地址转换NAT"></a>4.2.3. 网络地址转换NAT</h3><p>下面讨论另一种情况，就是在专用网内部的一些主机本来已经分配到了本地IP地址，即仅在本专用网内使用的专用地址)，但现在又想和互联网上的主机通信(并不需要加密)，那么应当采取什么措施呢?</p><p>网络地址转换NAT需要在专用网连接到互联网的路由器上安装NAT软件。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。这样，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和互联网连接。</p><h3 id="4-2-4-DHCP协议"><a href="#4-2-4-DHCP协议" class="headerlink" title="4.2.4. DHCP协议"></a>4.2.4. DHCP协议</h3><p>DHCP动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p><h3 id="4-2-5-IP地址与硬件地址"><a href="#4-2-5-IP地址与硬件地址" class="headerlink" title="4.2.5. IP地址与硬件地址"></a>4.2.5. IP地址与硬件地址</h3><p>从层次的角度看，物理地址是数据链路层和物理层使用的地址，而IP地址是网络层和以上各层使用的地址，是一种逻辑地址(用软件实现的)。</p><p>IP地址放在IP数据报的首部，而硬件地址则放在MAC帧的首部。在网络层和网络层以上使用的是IP地址，而数据链路层及以下使用的是硬件地址。当IP数据报放入数据链路层的MAC帧中以后，整个的IP数据报就成为MAC帧的数据，因而在数据链路层看不见数据报的IP地址。</p><p><img src="/images/network-basic/ip-dl.PNG"></p><p><strong>要点</strong></p><ol><li>在IP层抽象的互联网上只能看到IP数据报。</li><li>虽然在P数据报首部有源站IP地址，但路由器只根据目的站的I地址的网络号进行路由选择</li><li>在局域网的链路层，只能看见MAC帧。<br>IP数据报被封装在MAC帧中。MAC帧在不同网络上传送时，其MAC帧首部中的源地址和目的地址要发生变化。开始在H1到R1间传送时，MAC帧首部中写的是从硬件地址HA1发送到硬件地址HA3，路由器R1收到此MAC帧后，在数据链路层，要丢弃原来的MAC帧的首部和尾部。在转发时在数据链路层，要重新添加上MAC帧的首部和尾部。这时首部中的源地址和目的地址分别便成为HA4和HA5。路由器R2收到此帧后，再次更换MAC帧的首部和尾部，首部中的源地址和目的地址分别变成为HA6和HA2。MAC帧的首部的这种变化，在上面的IP层上是看不见的。</li><li>尽管互连在一起的网络的硬件地址体系各不相同，但IP层抽象的互联网却屏蔽了<br>下层这些很复杂的细节。只要我们在网络层上讨论问题，就能够使用统一的、抽象的IP地址研究主机和主机或路由器之间的通信。</li></ol><p>既然在网络链路上传送的帧最终是按照硬件地址找到目的主机的，那么为什么我们还要使用抽象的IP地址，而不直接使用硬件地址进行通信?</p><p>由于全世界存在着各式各样的网络，它们使用不同的硬件地址。要使这些异构网络能<br>够互相通信就必须进行非常复杂的硬件地址转换工作，因此由用户或用户主机来完成这项作几乎是不可能的事。但IP编址把这个复杂问题解决了。连接到互联网的主机只需各自拥有一个唯一的IP地址，它们之间的通信就像连接在同一个网络上那样简单方便，因为上述的调用ARP的复杂过程都是由计算机软件自动进行的，对用户来说是看不见这种调用过程的。</p><h3 id="4-2-6-地址解析协议ARP"><a href="#4-2-6-地址解析协议ARP" class="headerlink" title="4.2.6. 地址解析协议ARP"></a>4.2.6. 地址解析协议ARP</h3><p>网络层使用的是IP地址，但在实际网络的链路上传送数据帧时还是必须使用该网络的硬件地址。但IP地址和下面的网络的硬件地址之间由于格式不同而不存在简单的映射关系。此外，IP或MAC地址可能会改变。地址解析协议ARP解决这个问题的方法是在主机ARP高速缓存中存放一个从IP地址到硬件地址的映射表，并且这个映射表还经常动态更新(新增或超时删除)。<br>每一台主机都设有一个ARP高速缓存( ARP cache)，里面有本局域网上的各主机和路由器的IP地址到硬件地址的映射表，这些都是该主机目前知道的一些地址。</p><h5 id="4-2-6-1-同一局域网"><a href="#4-2-6-1-同一局域网" class="headerlink" title="4.2.6.1. 同一局域网"></a>4.2.6.1. 同一局域网</h5><p>当主机A要向本局域网上的某台主机B发送IP数据报时，就先在其ARP高速缓存中<br>查看有无主机B的IP地址。</p><p>若有，就在ARP高速缓存中查出其对应的硬件地址，再把这硬件地址写入MAC帧，然后通过局域网把该MAC帧发往此硬件地址；<br>若没有，主机A就自动运行ARP，然后按以下步骤找出主机B的硬件地址。</p><ol><li>ARP进程在本局域网上广播发送一个ARP请求分组；</li><li>在本局域网上的所有主机上运行的ARP进程都收到此ARP请求分组</li><li>主机B的IP地址与ARP请求分组中要查询的P地址一致，就收下这个ARP请求分组，并向主机A发送ARP响应分组，同时在这个ARP响应分组中写入自己的硬件地址。由于其余的所有主机的IP地址都与ARP请求分组中要查询的IP地址不一致，因此都不理睬这个ARP请求分组。<br>ARP请求分组是广播发送的，但ARP响应分组是普通的单播。</li><li>主机A收到主机B的ARP响应分组后，就在其ARP高速缓存中写入主机B的IP地址到硬件地址的映射。同时主机B记录主机A的映射。</li></ol><p>ARP对保存在高速缓存中的每一个映射地址项目都设置生存时间凡超过生存时间的项目就从高速缓存中删除掉。</p><h5 id="4-2-6-2-不在同一局域网"><a href="#4-2-6-2-不在同一局域网" class="headerlink" title="4.2.6.2. 不在同一局域网"></a>4.2.6.2. 不在同一局域网</h5><p>四种情况：</p><p><img src="/images/network-basic/ARPfour.PNG"></p><ol><li>发送方是主机(如H1)，要把IP数据报发送到同一个网络上的另一台主机(如H2)。这时H发送ARP请求分组(在网1上广播)，找到目的主机H2的硬件地址。</li><li>发送方是主机(如H1)，要把IP数据报发送到另一个网络上的一台主机(如H3或H4)。这时H1发送ARP请求分组(在网1上广播)，找到网1上的一个路由器R1的硬件地址。剩下的工作由路由器R1来完成。R1要做的事情是下面的(3)或(4)。</li><li>发送方是路由器(如R1)，要把P数据报转发到与R1连接在同一个网络(网2)上的主机(如H3)。这时R1发送ARP请求分组(在网2上广播)，找到目的主机H3的硬件地址</li><li>发送方是路由器(如R1)，要把IP数据报转发到网3上的一台主机(如H4)。H4与不是连接在同一个网络上。这时R1发送ARP请求分组(在网2上广播)，找到连接在网2上的一个路由器R2的硬件地址。剩下的工作由这个路由器R2来完成</li></ol><h3 id="4-2-7-逆地址解析协议RARP"><a href="#4-2-7-逆地址解析协议RARP" class="headerlink" title="4.2.7. 逆地址解析协议RARP"></a>4.2.7. 逆地址解析协议RARP</h3><p>功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址，比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。</p><p><strong>工作流程</strong></p><ol><li>给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；</li><li>本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；</li><li>如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；</li><li>如果不存在，RARP服务器对此不做任何的响应；</li><li>源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。</li></ol><h3 id="4-2-8-IP数据报的格式"><a href="#4-2-8-IP数据报的格式" class="headerlink" title="4.2.8. IP数据报的格式"></a>4.2.8. IP数据报的格式</h3><p><img src="/images/network-basic/ip.PNG"></p><ul><li>版本：占4位，指P协议的版本。通信双方使用的P协议的版本必须一致。</li><li>首部长度：占4位，可表示的最大十进制数值是15。</li></ul><p>首部长度字段所表示数的单位是32位字(4字节)，因此首部长度字段的最小值是5，最大值15。当IP分组的首部长度不是4字节的整数倍时，必须利用最后的填充字段加以填充。因此IP数据报的数据部分永远在4字节的整数倍时开始，这样在实现IP协议时较为方便。</p><ul><li>区分服务：占8位，用来获得更好的服务。旧标准中叫做服务类型，但实际上一直没有被使用过。</li><li>总长度：总长度指首部和数据之和的长度，单位为字节。</li></ul><p>最常用的以太网规定其MTU值是1500字节。若所传送的数据报长度超过数据链路层的MTU值，就必须把过长的数据报进行分片处理。</p><p>虽然使用尽可能长的PP数据报会使传输效率得到提高，但每一个IP数据报越短，路由<br>转发的速度就越快。为此，IP协议规定，在互联网中所有的主机和路由器，必须能够接<br>受长度不超过576字节的数据报。这是假定上层交下来的数据长度有512字节，加上最长的IP首部60字节，再加上4字节的富余量，就得到576字节。当主机需要发送长度超过576字节的数据报时，应当先了解一下，目的主机能否接受所要发送的数据报长度。否则，就要进行分片。</p><p>在进行分片时(见后面的“片偏移”字段)，数据报首部中的“总长度”字段是指分片<br>后的每一个分片的首部长度与该分片的数据长度的总和。</p><ul><li>标识：占16位。IP软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。</li></ul><p>但这个“标识”并不是序号，因为IP是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的MTU而必须分片时，这个标识字段的值就被复制到所有的数据报片的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。</p><ul><li>标志：占3位，但目前只有两位有意义<ul><li>标志字段中的最低位记为MF(More Fragment)。MF=1即表示后面“还有分片”的数据报。MF=0表示这已是若干数据报片中的最后一个。</li><li>标志字段中间的一位记为DF(Don’ t Fragment)，意思是“不能分片”。只有当DF<br>0时才允许分片。</li></ul></li><li>片偏移：占13位。片偏移指出:较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对于用户数据字段的起点，该片从何处开始。片偏移以8个字节为偏移单位。这就是说，每个分片的长度一定是8字节(64位)的整数倍。</li></ul><p><img src="/images/network-basic/ip-shard.PNG"></p><ul><li>生存时间：占8位，生存时间字段常用的英文缩写是TTL( Time To live)，表明<br>这是数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在互联网中兜圈子。</li></ul><p>然而随着技术的进步，路由器处理数据报所需的时间不断在缩短，一般都远远小于1秒，后来就把TTL字段的功能改为“跳数限制”(但名称不变)。路由器在每次转发数据报之前就把TTL值减1。若TTL值减小到零，就丢弃这个数据报，不再转发。因此，现在TTL的单位不再是秒，而是跳数。TTL的意义是指明数据报在互联网中至多可经过多少路由器。显然，数据报能在互联网中经过的路由器的最大数值是255。若把TTL的初始值设置为1，就表示这个数据报只能在本局域网中传送。因为这个数据报一传送到局域网上的某个路由器，在被转发之前TIL值就减小到零，因而就会被这个路由器丢弃。</p><ul><li>协议：占8位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的<br>主机的IP层知道应将数据部分上交给哪个协议进行处理。</li><li>首部检验和占16位。这个字段只检验数据报的首部，但不包括数据部分。非CRC。</li><li>源地址：占32位。</li><li>目的地址：占32位。</li></ul><h3 id="4-2-9-IP层转发分组的流程"><a href="#4-2-9-IP层转发分组的流程" class="headerlink" title="4.2.9. IP层转发分组的流程"></a>4.2.9. IP层转发分组的流程</h3><p>在路由表中，对每一条路由最主要的是以下两个信息：</p><p><strong>(目的网络地址，下一跳地址)</strong></p><ol><li>从数据报的首部提取目的主机的IP地址D，得出目的网络地址为N；</li><li>若N就是与此路由器直接相连的某个网络地址，则进行直接交付，不需要再经过其<br>他的路由器，直接把数据报交付目的主机(这里包括把目的主机地址D转换为具体的硬件地址，把数据报封装为MAC帧，再发送此帧);否则就是间接交付，执行3；</li><li>若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的<br>下一跳路由器;否则，执行4；</li><li>若路由表中有到达网络N的路由，则把数据报传送给路由表中所指明的下一跳路由<br>器;否则，执行5；</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器;否<br>则，执行6；</li><li>报告转发分组出错。</li></ol><p>当路由器收到一个待转发的数据报，在从路由表得出下一跳路由器的IP地址后，不是<br>把这个地址填入IP数据报，而是送交数据链路层的网络接口软件。网络接口软件负责把下跳路由器的IP地址转换成硬件地址(必须使用ARP)，并将此硬件地址放在链路层的<br>MAC帧的首部，然后根据这个硬件地址找到下一跳路由器。由此可见，当发送一连串的数据报时，上述的这种查找路由表、用ARP得到硬件地址、把硬件地址写入MAC帧的首部等过程，将不断地重复进行，造成了一定的开销。</p><h2 id="4-3-划分子网和构造超网"><a href="#4-3-划分子网和构造超网" class="headerlink" title="4.3. 划分子网和构造超网"></a>4.3. 划分子网和构造超网</h2><h3 id="4-3-1-划分子网"><a href="#4-3-1-划分子网" class="headerlink" title="4.3.1. 划分子网"></a>4.3.1. 划分子网</h3><h4 id="4-3-1-1-三级IP地址"><a href="#4-3-1-1-三级IP地址" class="headerlink" title="4.3.1.1. 三级IP地址"></a>4.3.1.1. 三级IP地址</h4><p><strong>两级IP地址的缺点</strong></p><ul><li>IP地址空间的利用率有时很低。</li><li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。</li><li>两级IP地址不够灵活。</li></ul><p><strong>基本思路</strong></p><ul><li>一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个子网( subne划分子网纯属一个单位内部的事情。本单位以外的网络看不见这个网络是由多少个子网组成，因为这个单位对外仍然表现为一个网络。</li><li>划分子网的方法是从网络的主机号借用若干位作为子网号 ibnet-id，当然主机号<br>也就相应减少了同样的位数。于是两级IP地址在本单位内部就变为三级IP地址:网络号子网号和主机号。也可以用以下记法来表示</li></ul><p><strong>IP地址:={&lt;网络号&gt;，&lt;子网号&gt;，&lt;主机号&gt;}</strong></p><ul><li>凡是从其他网络发送给本单位某台主机的IP数据报，路由器在收到IP数据报后，再按目的网络号和子网号找到目的子网，把IP数据报交付目的主机。</li></ul><h4 id="4-3-1-2-子网掩码"><a href="#4-3-1-2-子网掩码" class="headerlink" title="4.3.1.2. 子网掩码"></a>4.3.1.2. 子网掩码</h4><p>使用子网掩码的好处:不管网络有没有划分子网，只要把子网掩码和IP地址进行<br>逐位的“与”运算(AND)，就立即得出网络地址来。这样在路由器处理到来的分组时就可采用同样的算法。</p><p><img src="/images/network-basic/subnetMask.PNG"></p><p>所有的网络都必须使用子网掩码，同时在路由器的路由表中也必须有子网掩码这一栏。如果一个网络不划分子网，那么该网络的子网掩码就使用默认子网掩码。默认子网掩码中1的位置和I地址中的网络号字段net-id正好相对应。因此，若用默认子网掩码和某个不划分子网的IP地址逐位相“与”(AND)，就应当能够得出该IP地址的网络地址来。这样做可以不用査找该地址的类别位就能知道这是哪一类的IP地址。显然，</p><p>A类地址的默认子网掩码是255.0.0.0，或0xFF000000<br>B类地址的默认子网掩码是255.255.0.0，或0 XFFFF0000。<br>C类地址的默认子网掩码是255.255.255.0，或0 XFFFFFF00。</p><p>B类地址的子网划分选择(使用固定长度子网)：</p><table><thead><tr><th>子网号的位数</th><th>子网掩码</th><th>子网数</th><th>每个子网的主机数</th></tr></thead><tbody><tr><td>2</td><td>255.255.192.0</td><td>2{2次方}-2</td><td>2{14次方}-2</td></tr><tr><td>2</td><td>255.255.224.0</td><td>2{3次方}-2</td><td>2{13次方}-2</td></tr><tr><td>2</td><td>255.255.240.0</td><td>2{4次方}-2</td><td>2{12次方}-2</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><p>子网号的位数中没有0，1，15和16这四种情况，因为这没有意义。</p><p>划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数。</p><h4 id="4-3-1-3-使用子网的分组转发"><a href="#4-3-1-3-使用子网的分组转发" class="headerlink" title="4.3.1.3. 使用子网的分组转发"></a>4.3.1.3. 使用子网的分组转发</h4><p>我们应当注意到，使用子网划分后，路由表必须包含以下三项内容:</p><p><strong>目的网络地址，子网掩码，下一跳地址</strong></p><p>在划分子网的情况下，路由器转发分组的算法如下：</p><ol><li>从收到的数据报的首部提取目的IP地址D；</li><li>先判断是否为直接交付。对路由器直接相连的网络逐个进行检查:用各网络的子网掩码和D逐位相“与”(AND操作)，看结果是否和相应的网络地址匹配。若匹配，则把分组进行直接交付(当然还需要把D转换成物理地址，把数据报封装成帧发送出去)，转发任务结束。否则就是间接交付，执行3；</li><li>若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的<br>下一跳路由器;否则，执行4；</li><li>对路由表中的每一行(目的网络地址，子网掩码，下一跳地址)，用其中的子网掩<br>码和D逐位相“与”(AND操作)，其结果为N。若N与该行的目的网络地址匹配，则把数<br>据报传送给该行指明的下一跳路由器;否则，执行5；</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器;否<br>则，执行6；</li><li>报告转发分组出错。</li></ol><h3 id="4-3-2-构造超网"><a href="#4-3-2-构造超网" class="headerlink" title="4.3.2. 构造超网"></a>4.3.2. 构造超网</h3><h4 id="4-3-2-1-网络前缀"><a href="#4-3-2-1-网络前缀" class="headerlink" title="4.3.2.1. 网络前缀"></a>4.3.2.1. 网络前缀</h4><p>因为IPv4的地址即将耗尽，出现无分类域间路由选择CIDR。</p><p><strong>特点</strong></p><ul><li>CIDR消除了传统的A类、B类和C类地址以及划分子网的概念，32位的IP地址划分为用来指明网络的“网络前缀”和主机号。其记法是：</li></ul><p><strong>IP地址∷={网络前缀&gt;，&lt;主机号&gt;}</strong></p><p>CDR还使用“斜线记法”，或称为CIDR记法，即在IP地址后面加上斜线然后写上网络前缀所占的位数。</p><p>CIDR使用32位的地址掩码。地址掩码由串1和一串0组成，而1的个数就是网络前缀的长度。斜线记法中，斜线后面的数字就是地址掩码中1的个数。</p><ul><li>CIDR把网络前缀都相同的连续的P地址组成一个“CIDR地址块”。</li></ul><p>由于一个CIDR地址块中有很多地址，所以在路由表中就利用CIDR地址块来查找目的<br>网络。这种地址的聚合常称为路由聚合( route aggregation)，它使得路由表中的一个项目可以表示原来传统分类地址的很多个(例如上千个)路由。路由聚合也称为构成超网。</p><p>常用的CIDR地址块：</p><table><thead><tr><th>CIDR前缀长度</th><th>点分十进制</th><th>包含的地址数</th><th>相当于包含分类的网络数</th></tr></thead><tbody><tr><td>/13</td><td>255.248.0.0</td><td>512K</td><td>8个B类或2048个C类</td></tr><tr><td>/14</td><td>255.252.0.0</td><td>256K</td><td>4个B类或1024个C类</td></tr><tr><td>/15</td><td>255.254.0.0</td><td>128K</td><td>2个B类或512个C类</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><p>使用CIDR的一个好处就是可以更加有效地分配IPv4的地址空间，可根据客户的需要<br>分配适当大小的CIDR地址块。然而在分类地址的环境中，向一个部门分配IP地址，就只能以/8，/16或/24为单位来分配，这就很不灵活。</p><p>构成超网是将网络前缀缩短。网络前缓越短，其地址块所包含的地址数就越多。而在三级结构的IP地址中，划分子网是使网络前缀变长。</p><h2 id="4-4-ICMP网际控制报文协议"><a href="#4-4-ICMP网际控制报文协议" class="headerlink" title="4.4. ICMP网际控制报文协议"></a>4.4. ICMP网际控制报文协议</h2><p>为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了网际控制报文协<br>议ICMP。ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP报文是装在IP数据报中，作为其中的数据部分。</p><p>两种常用的ICMP报文类型：</p><table><thead><tr><th>ICMP报文种类</th><th>类型的值</th><th>ICMP报文的类型</th></tr></thead><tbody><tr><td>差错报告报文</td><td>3</td><td>终点不可达：不能交付数据报</td></tr><tr><td>差错报告报文</td><td>11</td><td>时间超过：生存时间为零的数据报</td></tr><tr><td>差错报告报文</td><td>12</td><td>参数问题：数据报首部的参数不正确</td></tr><tr><td>差错报告报文</td><td>5</td><td>改变路由：最佳路由</td></tr><tr><td>询问报文</td><td>8或0</td><td>回送请求或回答：测试目的站是否可达以及了解其有关状态</td></tr><tr><td>询问报文</td><td>13或14</td><td>时间戳请求或回答：用于时钟同步和时间测量</td></tr></tbody></table><h2 id="4-5-路由选择协议"><a href="#4-5-路由选择协议" class="headerlink" title="4.5. 路由选择协议"></a>4.5. 路由选择协议</h2><p>倘若从路由算法能否随网络的通信量或拓扑自适应地进行调整变化来划分：</p><ul><li>静态路由选择策略：也叫做非自适应路由选择，特点是简单和开销较小，但不能及时适应网络状态的变化。对于很简单的小网络，完全可以采用静态路由选择，用人工配置每一条路由。</li><li>动态路由选择策略。也叫做自适应路由选择，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。适用于较复杂的大网络。</li></ul><p><strong>分层次的路由选择协议</strong></p><p>把整个互联网划分为许多较小的自治系统(autonomous system)，记为AS。一个AS对其他AS表现出的是一个单一的和一致的路由选择策略。</p><p>在目前的互联网中，一个大的ISP就是一个自治系统。这样，互联网就把路由选择协议<br>划分为两大类：</p><ul><li>内部网关协议IGP：即在一个自治系统内部使用的路由选择协议，而这与在互联网中的其他自治系统选用什么路由选择协议无关。如RIP和OSPF协议。</li><li>外部网关协议EGP：若源主机和目的主机处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议EGP。目前使用最多的外部网关协议是BGP的版本4(BGP4)。</li></ul><p>自治系统之间的路由选择也叫做域间路由选择，而在自治系统内部的路由选择叫做域内路由选择。</p><h3 id="4-5-1-内部网关协议RIP"><a href="#4-5-1-内部网关协议RIP" class="headerlink" title="4.5.1. 内部网关协议RIP"></a>4.5.1. 内部网关协议RIP</h3><h4 id="4-5-1-1-工作原理"><a href="#4-5-1-1-工作原理" class="headerlink" title="4.5.1.1. 工作原理"></a>4.5.1.1. 工作原理</h4><p>一种分布式的基于距离向量的路由选择协议。</p><p>RIP协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记<br>录。RIP协议将“距离”定义为从一路由器到直接连接的网络的距离定义为1。从一路由器到非直接连接的网络的距离定义为所经过的路由器数加1。</p><p><strong>特点</strong></p><ul><li>仅和相邻路由器交换信息。不相邻的路由器不交换信息</li><li>路由器交换的信息是当前本路由器所知道的全部信息，即自己现在的路由表。</li><li>按固定的时间间隔交换路由信息。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。</li></ul><h4 id="4-5-1-2-距离向量算法"><a href="#4-5-1-2-距离向量算法" class="headerlink" title="4.5.1.2. 距离向量算法"></a>4.5.1.2. 距离向量算法</h4><p>对每一个相邻路由器发送过来的RIP报文，进行以下步骤：</p><ul><li>对地址为ⅹ的相邻路由器发来的RIP报文，先修改此报文中的所有项目:把“下一跳”字段中的地址都改为X，并把所有的“距离”字段的值加1。每一个项目都有三个关键数据，即:到目的网络N，距离是d，下一跳路由器是X</li><li>对修改后的RP报文中的每一个项目，进行以下步骤:<ul><li>若原来的路由表中没有目的网络N，则把该项目添加到路由表中</li><li>否则(即在路由表中有目的网络N，这时就再査看下一跳路由器地址<ul><li>若下一跳路由器地址是Ⅹ，则把收到的项目替换原路由表中的项目</li><li>否则(即这个项目是:到目的网络N，但下一跳路由器不是X<ul><li>若收到的项目中的距离d小于路由表中的距离，则进行更新</li><li>否则什么也不做。</li></ul></li></ul></li></ul></li><li>若3分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达的路<br>由器，即把距离置为16(距离为16表示不可达)。</li><li>返回。</li></ul><p>RIP协议使得从每一个路由器到每一个目的网络的路由都是最短的。虽然所有的路由器最终都拥有了整个自治系统的全局路由信息，但由于每一个路由器的位置不同，它们的路由表当然也应当是不同的。</p><p><strong>优点</strong></p><ul><li>实现简单、开销较小。</li><li>好消息传播得快，但是坏消息传播得慢。</li></ul><p><strong>缺点</strong>n</p><ul><li>RIP限制了网络的规模，它能使用的最大距离为15(16表示不可达)。</li><li>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。最后，“坏消息传播得慢”，使更新过程的收敛时间过长。</li></ul><h3 id="4-5-2-内部网关协议OSPF"><a href="#4-5-2-内部网关协议OSPF" class="headerlink" title="4.5.2. 内部网关协议OSPF"></a>4.5.2. 内部网关协议OSPF</h3><p>开放最短路径优先OSPF，使用最短路径算法SPF，使用分布式的链路状态协议。它是为克服RIP的缺点而开发。</p><p><strong>特点</strong></p><ul><li>向本自治系统中所有路由器发送信息。这里使用的方法是洪泛法，路由器通过所有输出端口向所有相邻的路由器发送信息。而每一个相邻路由器又再将此信息发往其所有的相邻路由器(但不再发送给刚刚发来信息的那个路由器)。这样，最终整个区域中所有的路由器都得到了这个信息的一个副本。RIP协议是仅仅向自己相邻的几个路由器发送信息。</li><li>发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。所谓“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的度量”，称这个度量为“代价”。RIP协议发送的信息是到所有网络的距离和下一跳路由器。</li><li>只有当链路状态发生变化时，路由器才向所有路由器用洪泛法发送此信息。而不像<br>RIP那样，不管网络拓扑有无发生变化，路由器之间都要定期交换路由表的信息。</li></ul><p><strong>优点</strong></p><p>所有的路由器最终都能建立一个链路状态数据库，实际上就是全网的拓扑结构图。这个拓扑结构图在全网范围内是一致的。RIP协议的每一个路由器虽然知道到所有的网络的距离以及下一跳路由器，但却不知道全网的拓扑结构(只有到了下一跳路由器，才能知道再下一跳应当怎样走。</p><p>OSPF的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表，更新过程收敛得快是其重要优点。</p><p>OSPF不用UDP而是直接用IP数据报传送。</p><h3 id="4-5-3-外部网关协议BGP"><a href="#4-5-3-外部网关协议BGP" class="headerlink" title="4.5.3. 外部网关协议BGP"></a>4.5.3. 外部网关协议BGP</h3><p>内部网关协议(如RIP或OSPF)主要是设法使数据报在一个AS中尽可能有效地从源站传送到目的站。在一个AS内部也不需要考虑其他方面的策略。然而BGP使用的环境却不同。这主要是因为互联网的规模太大，使得自治系统AS之间路由选择非常困难，并且自治系统AS之间的路由选择必须考虑有关策略（自愿连接、安全等）。</p><p>所以边界网关协议BGP只能是力求寻找一条能够到达目的网络且比较好的<br>路由(不能兜圈子)，而并非要寻找一条最佳路由。</p><p>BGP采用了路径向量路由选择协议。</p><ol><li>每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“BGP发言人”。一般两个BGP发言人都是通过一个共享网络连接在一起的，而BGP发言人往往就是BGP边界路由器，也可以不是。</li><li>BGP发言人与其他AS的BGP发言人要交换路由信息，就要先建立TCP连接，彼此成为对方的邻站( neighbor〕或对等站(peer)。</li><li>边界网关协议BGP所交换的网终可达性的信息就是要到达某个网络所要经过的一系列自治系统。发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的较好路由。</li></ol><h1 id="5-运输层"><a href="#5-运输层" class="headerlink" title="5. 运输层"></a>5. 运输层</h1><h2 id="5-1-协议概述"><a href="#5-1-协议概述" class="headerlink" title="5.1. 协议概述"></a>5.1. 协议概述</h2><h3 id="5-1-1-进程之间的通信"><a href="#5-1-1-进程之间的通信" class="headerlink" title="5.1.1. 进程之间的通信"></a>5.1.1. 进程之间的通信</h3><p>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。当网络的边缘部分中的两台主机使用网络的核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。</p><p>运输层有一个很重要的功能—复用和分用。这里的“复用是指在发送方不同的应用进程都可以使用同一个运输层协议传送数据，而“分用”是指接收方的运输层在剥去报文的首部后能够把这些数据正确交付目的应用进程。</p><p>网络层为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。向高层用户屏蔽了下面网络核心的细节。</p><h3 id="5-1-2-两个主要协议"><a href="#5-1-2-两个主要协议" class="headerlink" title="5.1.2. 两个主要协议"></a>5.1.2. 两个主要协议</h3><ul><li>用户数据报协议UDP：UDP用户数据报，无连接，不可靠，尽最大努力交付的。</li><li>传输控制协议TCP：TCP报文段，面向连接，可靠的</li></ul><h3 id="5-1-3-端口"><a href="#5-1-3-端口" class="headerlink" title="5.1.3. 端口"></a>5.1.3. 端口</h3><p>为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法(而这种方法必须与特定操作系统无关)对TCP体系的应用进程进行标志。</p><p>解决这个问题的方法就是在运输层使用协议端口号，常简称为端口(port)。这就是说，虽然通信的终点是应用进程，但只要把所传送的报文交到目的主机的某个合适的目的端口，剩下的工作(即最后交付目的进程)就由TCP或UDP来完成。<br>这种在协议栈层间的抽象的协议端口是软件端口。</p><p>用一个16位端口号来标志一个端口。但端口号只具有本地意义，它只是为了标志本计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网不同计算机中，相同的端口号是没有关联的。16位的端口号可允许有65535个不同的端口。分为：</p><ul><li>服务器端使用的端口号<ul><li>熟知端口号 0~1023</li><li>等级端口号 1024~49151</li></ul></li><li>客户端使用的端口号 49152~65535</li></ul><p><strong>常见的熟知端口号</strong></p><table><thead><tr><th>FTP</th><th>TELNET</th><th>SMTP</th><th>DNS</th><th>TFTP</th><th>HTTP</th><th>SNMP</th><th>HTTPS</th></tr></thead><tbody><tr><td>21</td><td>23</td><td>25</td><td>53</td><td>69</td><td>80</td><td>161</td><td>443</td></tr></tbody></table><table><thead><tr><th>POP3</th><th>SSH</th><th>MySQL</th><th>Oracle</th><th>SQLServer</th><th>Sockets</th><th>Tomcat</th></tr></thead><tbody><tr><td>110</td><td>22</td><td>3306</td><td>1521</td><td>1433</td><td>1080</td><td>8080</td></tr></tbody></table><h2 id="5-2-用户数据报协议UDP"><a href="#5-2-用户数据报协议UDP" class="headerlink" title="5.2. 用户数据报协议UDP"></a>5.2. 用户数据报协议UDP</h2><ul><li>无连接的：减小开销和时延</li><li>尽最大努力：交付不可靠的</li><li>面向报文：保留上层报文的边界，一次交付一个完整的报文</li><li>没有拥塞控制：实时应用允许丢失，但需要低时延</li><li>支持一对一、一对多、多对一和多对多的交互通信</li><li>首部开销小：8字节</li></ul><p><img src="/images/network-basic/UDP.PNG"></p><ul><li>源端口：源端口号。在需要对方回信时选用。不需要时可用全0。</li><li>目的端口：目的端口号。这在终点交付报文时必须使用</li><li>长度：UDP用户数据报的长度，其最小值是8(仅有首部)。</li><li>检验和：检测UDP用户数据报在传输中是否有错。有错就丢弃，并由ICMP发送“终点不可达”。IP数据报只检验首部，UDP把首部和数据一起检验。</li></ul><h2 id="5-3-传输控制协议TCP概述"><a href="#5-3-传输控制协议TCP概述" class="headerlink" title="5.3. 传输控制协议TCP概述"></a>5.3. 传输控制协议TCP概述</h2><h3 id="5-3-1-TCP的主要特点"><a href="#5-3-1-TCP的主要特点" class="headerlink" title="5.3.1. TCP的主要特点"></a>5.3.1. TCP的主要特点</h3><ul><li>面向连接：建立连接、释放连接</li><li>每条TCP连接只能有两个端点：一对一</li><li>可靠交付</li><li>全双工通信：发送、接收缓存</li><li>面向字节流：然应用程序和TCP的交互是一次一个数据块(大小不等)，但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。TCP并不知道所传送的字节流的含义。</li></ul><h3 id="5-3-2-TCP的连接"><a href="#5-3-2-TCP的连接" class="headerlink" title="5.3.2. TCP的连接"></a>5.3.2. TCP的连接</h3><p>TCP的连接有两个断电，断电指的是套接字，即端口号拼接到IP地址：</p><p><strong>套接字 socket=(IP地址:端口号)</strong></p><p>每一条TCP连接唯一地被通信两端的两个端点(即两个套接字)所确定。即</p><p><strong>TCP连接:(socket1， socket2)=((IP1:port1)，(IP2:port2)</strong></p><h2 id="5-4-可靠传输的工作原理"><a href="#5-4-可靠传输的工作原理" class="headerlink" title="5.4. 可靠传输的工作原理"></a>5.4. 可靠传输的工作原理</h2><h3 id="5-4-1-停止等待协议"><a href="#5-4-1-停止等待协议" class="headerlink" title="5.4.1. 停止等待协议"></a>5.4.1. 停止等待协议</h3><p>“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。</p><h4 id="5-4-1-1-无差错情况"><a href="#5-4-1-1-无差错情况" class="headerlink" title="5.4.1.1. 无差错情况"></a>5.4.1.1. 无差错情况</h4><p>A发送分组M1，发完就暂停发送，等待B的确认。B收到了M1就向A发送确认。A在收到了对M1的确认后，就再发送下一个分组M2。同样，在收到B对M2的确认后，再发送M3。</p><p><img src="/images/network-basic/TCPstopwait.PNG"></p><h4 id="5-4-1-2-出现差错"><a href="#5-4-1-2-出现差错" class="headerlink" title="5.4.1.2. 出现差错"></a>5.4.1.2. 出现差错</h4><p>B接收M1时检测出了差错，就丢弃M1，其他什么也不做(不通知A收到有差错的分组)。A只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组，。这就叫做超时重传。要实现超时重传，就要在每发送完一个分组时设置一个超时计时器。如果在超时计时器到期之前收到了对方的确认，就撤销已设置的超时计时器。</p><p>因此要注意：</p><ol><li>A在发送完一个分组后，必须暂时保留已发送的分组的副本；</li><li>分组和确认分组都必须进行编号。</li><li>超时计时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些。</li></ol><h4 id="5-4-1-3-确认丢失和确认迟到"><a href="#5-4-1-3-确认丢失和确认迟到" class="headerlink" title="5.4.1.3. 确认丢失和确认迟到"></a>5.4.1.3. 确认丢失和确认迟到</h4><p><img src="/images/network-basic/TCPconfirmLossLate.PNG"></p><p><strong>确认丢失</strong></p><p>B所发送的对M1的确认丢失了。A在设定的超时重传时间内没有收到确认，并无法知道是自己发送的分组出错、丢失，或者是B发送的确认丢失了。因此A在超时计时器到期后就要重传M1。现在应注意B的动作。假定B又收到了重传的分组M1。这时应采取两个行动。</p><ol><li>丢弃这个重复的分组M1，不向上层交付。</li><li>向A发送确认。不能认为已经发送过确认就不再发送，因为A之所以重传M</li></ol><p><strong>确认迟到</strong></p><p>传输过程中没有出现差错，但B对分组M1的确认迟到了。A会收到重复的确认。对重复的确认的处理很简单:收下后就丢弃。B仍然会收到重复的M1，并且同样要丢弃重复的M1，并重传确认分组。</p><p>像上述的这种可靠传输协议常称为自动重传请求ARQ( Automatic Repeat reQuest)。意思<br>是重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组。</p><h4 id="5-4-1-4-信道利用率"><a href="#5-4-1-4-信道利用率" class="headerlink" title="5.4.1.4. 信道利用率"></a>5.4.1.4. 信道利用率</h4><p>停止等待协议的优点是简单，但缺点是信道利用率太低。</p><p><img src="/images/network-basic/TcpARQ.PNG"></p><p>当往返时间RTT远大于分组发送时间TD时，信道的利用率就会非常低。若出现重传，信道的利用率就还要降低。</p><p>为了提高传输效率，发送方可以采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地在传送。显然，这种传输方式可以获得很高的信道利用率。</p><p>即使用连续ARQ协议和滑动窗口协议。</p><h3 id="5-4-2-连续ARQ协议"><a href="#5-4-2-连续ARQ协议" class="headerlink" title="5.4.2. 连续ARQ协议"></a>5.4.2. 连续ARQ协议</h3><p>发送窗口的意义是:位于发送窗口内的5个分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。</p><p><img src="/images/network-basic/TcpSendWindow.PNG"></p><p>发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。接收方一般都是采用累积确认的方式。接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对按序到达的最后一个分组发送确认，这就表示:到这个分组为止的所有分组都已正确收到了。</p><p><strong>优缺点</strong></p><p>累积确认有优点也有缺点。优点是:容易实现，即使确认丢失也不必重传。但缺点是<br>不能向发送方反映出接收方已经正确收到的所有分组的信息，在通信质量不好时会多次重传。</p><h2 id="5-5-TCP报文段格式"><a href="#5-5-TCP报文段格式" class="headerlink" title="5.5. TCP报文段格式"></a>5.5. TCP报文段格式</h2><p>TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段。</p><p><img src="/images/network-basic/TCP.PNG"></p><ul><li>源端口和目的端口：各占2个字节，分别写入源端口号和目的端口号。</li><li>序号：占4字节。本报文段所发送的数据的第一个字节的序号。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。</li><li>确认号：占4字节，是期望收到对方下一个报文段的第一个数据字节的序号。若确认号=N，则表明:到序号N-1为止的所有数据都已正确收到。</li><li>数据偏移：占4位，实际上是指出TCP报文段的首部长度，单位是32位字(即以4字节）。</li><li>保留占6位，保留为今后使用，但目前应置为0。</li><li>紧急URG：当URG=1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(高优先级的数据)，而不要按原来的排队顺序来传送，例如<kbd>Ctrl + C</kbd>。TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据，这时要与首部中紧急指针字段配合使用。</li><li>确认ACK：仅当ACK=1时确认号字段才有效。当ACK=0时，确认号无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1。</li><li>推送PSH：当两个应用进程进行交互式的通信时，一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。发送方TCP把PSH置1，并立即创建一个报文段发送出去。接收方TCP收到PSH=1的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。</li><li>复位RST：当RST=1时，表明TCP连接中出现严重差错(如由于主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接。RST置1还用来拒绝一个非法的报文段或拒绝打开一个连接。</li><li>同步SYN：在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1。因此，SYN置为1就表示这是一个连接请求或连接接受报文。</li><li>终止FIN：用来释放一个连接。</li><li>窗口：占2字节。窗口指的是发送本报文段的的接收窗口(而不是自己的发送窗口)。窗口值代表目前允许对方发送的数据量(以字节为单位)。作为接收方让发送方设置其发送窗口的依据。</li><li>检验和：占2字节。检验和字段检验的范围包括首部和数据这两部分。</li><li>紧急指针：占2字节。紧急指针仅在URG=1时才有意义，它指出本报文段中的紧急数据的字节数，即紧急数据的末尾在报文段中的位置。</li><li>选项：长度可变，最长可达40字节。<ul><li>窗口扩大：高吞吐量下增大窗口数值的位数</li><li>时间戳：计算RTT；处理序号过大，防止序号取模绕回PAWS</li><li>选择确认</li></ul></li></ul><p>最大报文段长度MSS：每一个TCP报文段中的数据字段的最大长度。MSS太小，网络利用率降低；太大，IP层需要分片。</p><h2 id="5-6-TCP可靠传输的实现"><a href="#5-6-TCP可靠传输的实现" class="headerlink" title="5.6. TCP可靠传输的实现"></a>5.6. TCP可靠传输的实现</h2><h3 id="5-6-1-以字节为单位的滑动窗口"><a href="#5-6-1-以字节为单位的滑动窗口" class="headerlink" title="5.6.1. 以字节为单位的滑动窗口"></a>5.6.1. 以字节为单位的滑动窗口</h3><p>发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示己发送且己收到了确认。这些数据显然不需要再保留，而发送窗口前沿的前面部分表示不允许发送的。</p><p>发送窗口的位置由窗口前沿和后沿的位置共同确定。发送窗口后沿的变化情况有两种可能，即不动(没有收到新的确认)和前移(收到了新的确认)。发送窗口后沿不可能向后移动，因为不能撤销掉已收到的确认。发送窗口前沿通常是不断向前移动，但也有可能不动。</p><p><img src="/images/network-basic/TcpASend11.PNG"></p><p>B只能对按序收到的数据中的最高序号给出确认，因此B发送的确认报文段中的确认号仍然是31，而不能是32或33。<br>现在假定B收到了序号为31的数据，并把序号为31-33的数据交付主机，然后B删除这些数据。接着把接收窗口向前移动3个序号，同时给A发送确认，其中窗口值仍为20，但确认号是34。这表明B已经收到了到序号33为止的数据。我们注意到，B还收到了序号为37，38和40的数据，但这些都没有按序到达，只能先暂存在接收窗口中A收到B的确认后，就可以把发送窗口向前滑动3个序号，但指针P2不动。可以看出，现在A的可用窗口增大了，可发送的序号范围42-53。</p><p><img src="/images/network-basic/TcpAReceive.PNG"></p><p><strong>TCP的缓存与窗口的关系</strong></p><p><img src="/images/network-basic/TcpWinCacheRelation.PNG"></p><p>发送缓存用来暂时存放:</p><ul><li>发送应用程序传送给发送方TCP准备发送的数据;</li><li>TCP已发送出但尚未收到确认的数据。</li></ul><p>接收缓存用来暂时存放:</p><ul><li>按序到达的、但尚未被接收应用程序读取的数据</li><li>未按序到达的数据。</li></ul><p><strong>注意</strong></p><ol><li>在同一时刻，A的发送窗口并不总是和B的接收窗口一样大。因为通过网络传送窗口值需要经历一定的时间滞后；</li><li>对于不按序到达的数据应如何处理，TCP标准并无明确规定。如果接收方一律丢弃，对网络资源的利用不利，因此通常对不按序到达的数据是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程；</li><li>TCP要求接收方必须有累积确认的功能，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。</li></ol><h3 id="5-6-2-超时重传时间的选择"><a href="#5-6-2-超时重传时间的选择" class="headerlink" title="5.6.2. 超时重传时间的选择"></a>5.6.2. 超时重传时间的选择</h3><p>如果把超时重传时间设置得太短，就会引起很多报文段的不必要的重传，使网络负荷增大。但若把超时重传时间设置得过长，则又使网络的空闲时间增大，降低了传输效率。</p><p>TCP采用了一种自适应算法，它记录报文段的往返时间RTT。TCP保留了RTT的一个加权平均往返时间RTTs(这又称为平滑的往返时间）因为进行的是加权平均，因此得出的结果更加平滑)。每当第一次测量到RTT样本时，RTTs值就取为所测量到的RTT样本值。但以后每测量到一个新的RTT样本，就按下式重新计算一次RTTs：</p><p>新的RTTs=(1-α)×(旧的RTTs)+α*(新的RTT样本)</p><p>在上式中，0≤α&lt;1。若α很接近于零，表示新的RTTs值和旧的RTTs值相比变化不大，而对新的RTT样本影响不大(RTT值更新较慢)。若选择α接近于1，则表示新的RTTs值受新的RTT样本的影响较大(RT值更新较快)。</p><p>显然，超时计时器设置的超时重传时间RTO应略大于RTTs。RFC6298建议使用下式计算RTO</p><p>RTO=RTTs+4×RTTD</p><p>而RTTD是RTT的偏差的加权平均值，它与RTTs和新的RTT样本之差有关。</p><p>RFC6298建议这样计算RTTD。当第一次测量时，RTTD值取为测量到的RTT样本值的一半。在以后的测量中，则使用下式计算加权平均的RTT</p><p>新的RTTD=(1-β)×(旧的RTTD+β*|RTTs-新的RTT样本|</p><p>若收到的确认是对重传报文段的确认，但却被源主机当成是对原来的报文段的确认则这样计算出的RTTs和超时重传时间RTO就会偏大。若后面再发送的报文段又是经过重传后才收到确认报文段，则按此方法得出的超时重传时间RTO就越来越长。</p><p>Karn提出了一个算法:在计算加权平均RTTS时，只要报文段重传了，就不采用其往返时间样本，这样得出的加权平均RTTS和RTO就较准确。但是如果报文段的时延突然增大了很多，因<br>此在原来得出的重传时间内，不会收到确认报文段，于是就重传报文段。但根据Karn算<br>法，不考虑重传的报文段的往返时间样本，这样，超时重传时间就无法更新。</p><p>因此要对Karn算法进行修正。方法是:报文段每重传一次，就把超时重传时间RTO增大一些。典型的做法是取新的重传时间为旧的重传时间的2倍。当不再发生报文段的重传时，才根据上面给出的2式计算超时重传时间。实践证明，这种策略较为合理。</p><h3 id="5-6-3-选择确认SACK"><a href="#5-6-3-选择确认SACK" class="headerlink" title="5.6.3. 选择确认SACK"></a>5.6.3. 选择确认SACK</h3><p>若收到的报文段无差错，只是未按序号，中间还缺少一些序号的数据，那么能否设法只传送缺少的数据而不重传已经正确到达接收方的数据?选择确认就是一种可行的处理方法。</p><p><img src="/images/network-basic/SACK.PNG"></p><p>和前后字节不连续的每一个字节块都有两个边界:左边界和右边界。因此在图中用四个指针标记这些边界。左边界指出字节块的第一个字节的序号，但右边界减1才是字节块中的最后一个序号。</p><p>然而，SACK文档并没有指明发送方应当怎样响应SACK。因此大多数的实现还是重传所有未被确认的数据块。</p><h2 id="5-7-TCP的流量控制"><a href="#5-7-TCP的流量控制" class="headerlink" title="5.7. TCP的流量控制"></a>5.7. TCP的流量控制</h2><h3 id="5-7-1-利用滑动窗口实现流量控制"><a href="#5-7-1-利用滑动窗口实现流量控制" class="headerlink" title="5.7.1. 利用滑动窗口实现流量控制"></a>5.7.1. 利用滑动窗口实现流量控制</h3><p>所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</p><p><img src="/images/network-basic/TcpFlowControl.PNG"></p><p>现在我们考虑一种情况。B向A发送了零窗口的报文段后不久，B的接收缓存又有了一些存储空间。于是B向A发送了rwnd=400的报文段。然而这个报文段在传送过程中丢失了。A一直等待收到B发送的非零窗口的通知，而B也一直等待A发送的数据。如果没有其他措施，这种互相等待的死锁局面将一直延续下去。</p><p>为了解决这个问题，TCP为每一个连接设有一个持续计时器。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段(仅携带1字节的数据)，而对方就在确认这个探测报文段时给出了现在的窗口值。如果窗口仍然是零，那么收到这个报文段的一方就重新设置持续计时器。如果窗口不是零，那么死锁的僵局就可以打破了。</p><h3 id="5-7-2-TCP的传输效率"><a href="#5-7-2-TCP的传输效率" class="headerlink" title="5.7.2. TCP的传输效率"></a>5.7.2. TCP的传输效率</h3><p>不同的机制来控制TCP报文段的发送时机</p><ol><li>TCP维持一个变量，它等于最大报文段长度MSS。只要缓存中存放的数据达到MSS字节时，就组装成一个TCP报文段发送出去。</li><li>由发送方的应用进程指明要求发送报文段，即TCP支持的推送(push)操作。第三种机制是</li><li>发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段(但长度不能超过MSS)发送出去。</li></ol><p>在TCP的实现中广泛使用<strong>Nage算法</strong>。</p><p>算法如下:若发送应用进程把要发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。当发送方收到对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存。只有在收到对前一个报文段的确认后才继续发送下一个报文段。当数据到达较快而网络速率较慢时，用这样的方法可明显地减少所用的网络带宽。 Nagle算法还规定，当到达的数据已达到发送窗口大小的半或已达到报文段的最大长度时，就立即发送一个报文段。这样做，就可以有效地提高网络的吞吐量。</p><p><strong>糊涂窗口综合征</strong></p><p>设想一种情况:TCP接收方的缓存已满，而交互式的应用进程一次只从接收缓存中读取1个字节(这样就使接收缓存空间仅腾出1个字节)，然后向发送方发送确认，并把窗口设置为1个字节(但发送的数据报是40字节长)。接着，发送方又发来1个字节的数据(请注意，发送方发送的IP数据报是41字节长)。接收方发回确认，仍然将窗口设置为1个字节。这样进行下去，使网络的效率很低。</p><p>要解决这个问题，可以让接收方等待一段时间，使得或者接收缓存已有足够空间容纳最长的报文段，或者等到接收缓存已有一半空闲的空间。只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小。此外，发送方也不要发送太小的报文段，而是把数据积累成足够大的报文段，或达到接收方缓存的空间的一半大小。</p><h2 id="5-8-TCP的拥塞控制"><a href="#5-8-TCP的拥塞控制" class="headerlink" title="5.8. TCP的拥塞控制"></a>5.8. TCP的拥塞控制</h2><h3 id="5-8-1-拥塞控制的一般原理"><a href="#5-8-1-拥塞控制的一般原理" class="headerlink" title="5.8.1. 拥塞控制的一般原理"></a>5.8.1. 拥塞控制的一般原理</h3><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做<strong>拥塞</strong>。若网络中有许多资源同时呈现供应不足，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。</p><p>网络拥塞往往是由许多因素引起的。简单地扩大缓存的存储空间同样会造成网络资源的严重浪费，因而解决不了网络拥塞的问题。简单地将处理机的速率提高，可能会使上述情况缓解一些，但往往又会将瓶颈转移到其他地方。问题的实质往往是整个系统的各个部分不匹配。只有所有的部分都平衡了，问题才会得到解决。</p><p>拥塞控制与流量控制的关系密切，它们之间也存在着一些差别。所谓拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程。相反，流量控制往往是指点对点通信量的控制，是个端到端的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><p><img src="/images/network-basic/TcpCongestionControl.PNG"></p><p>从控制理论的角度来看有两种方法：</p><ul><li>开环控制：在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。</li><li>闭环控制是基于反馈环路的概念，主要有以下几种措施<ul><li>监测网络系统以便检测到拥塞在何时、何处发生。</li><li>把拥塞发生的信息传送到可采取行动的地方</li><li>调整网络系统的运行以解决出现的问题。</li></ul></li></ul><p>监测网络的拥塞：</p><ul><li>指标：由于缺少缓存空间而被丢弃的分组的百分数、平均队列长度、超时重传的分组数、平均分组时延、分组时延的标准差，等等。上述这些指标的上升都标志着拥塞的增长<br>般在监测到拥塞发生时，要将拥塞发生的信息传送到产生分组的源站。当然，通知<br>拥塞发生的分组同样会使网络更加拥塞</li><li>比特位：在路由器转发的分组中保留一个比特或字段，用该比特或字段的值表示网络没有拥塞或产生了拥塞。也可以由一些主机或路由器周期性地发出探测分组，以询问拥塞是否发生。</li></ul><h3 id="5-8-2-TCP的拥塞控制方法"><a href="#5-8-2-TCP的拥塞控制方法" class="headerlink" title="5.8.2. TCP的拥塞控制方法"></a>5.8.2. TCP的拥塞控制方法</h3><p>TCP进行拥塞控制的算法有四种：慢开始(sow-start)、拥塞避免(congestion avoidance)、快重传(fast retransmit)和快恢复(fast recovery)。</p><h4 id="5-8-2-1-慢开始"><a href="#5-8-2-1-慢开始" class="headerlink" title="5.8.2.1. 慢开始"></a>5.8.2.1. 慢开始</h4><p>发送方维持一个叫做<strong>拥塞窗口</strong>cwnd(congestion window)的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。<strong>发送方让自己的发送窗口等于拥塞窗口。</strong></p><p>发送方控制拥塞窗口的原则是:只要网络没有出现拥塞，拥塞窗口就可以再增大些，以便把更多的分组发送出去。但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些。</p><p>判断网络拥塞的依据就是出现了超时。</p><p>慢开始算法的思路是这样的:当主机开始发送数据时，是先探测一下，由小到大逐渐增大发送窗口，即由小到大逐渐增大拥塞窗口数值。</p><p>慢开始规定，在每收到一个对新的报文段的确认后，可以把拥塞窗口増加最多一个SMSS的数值。</p><p>拥塞窗口cwnd每次的增加量=min(N，SMSS)</p><p>请注意，实际上TCP是用<strong>字节数</strong>作为窗口大小的单位。但为叙述方便起见用报文段的个数作为窗口大小的单位。</p><p><img src="/images/network-basic/TcpSlowStart.PNG"></p><p>发送方每收到一个对新报文段的确认就使发送方的拥塞窗口加1每经过一个传输轮次，拥塞窗口cwnd就加倍。</p><p>一个传输轮次时间其实就是往返时间RTT(请注意，RTT并非是恒定的数值)。强调把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后个字节的确认。</p><p>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。慢开始门限ssthresh的用法如下:</p><p>当cwnd &lt; ssthresh时，使用上述的慢开始算法。<br>当cwnd &gt; ssthresh时，停止使用慢开始算法而改用拥塞避免算法。<br>当cwnd = ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法。</p><h4 id="5-8-2-2-拥塞避免"><a href="#5-8-2-2-拥塞避免" class="headerlink" title="5.8.2.2. 拥塞避免"></a>5.8.2.2. 拥塞避免</h4><p>拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是像慢开始阶段那样加倍增长。因此在拥塞避免阶段就有“加法増大”的特点。这表明在拥塞避免阶段，拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p><p>按线性规律增长。但请注意，“拥塞避免”并非完全能够避免了拥塞。“拥塞避免”是说托拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</p><p><img src="/images/network-basic/TcpCwnd.PNG"></p><p>当拥塞窗口cwnd=24时，网络出现了超时(图中的点2)，发送方判断为网络拥塞。于是调整门限值 ssthresh=cwnd/2=12，同时设置拥塞窗口cwnd=1，进入慢开始阶段</p><p>按照慢开始算法，发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值加1当拥塞窗口cwnd= ssthresh=12时(图中的点3，这是新的 ssthresh值)，改为执行拥塞避免算法，拥塞窗口按线性规律增大。</p><p>当拥塞窗口cwnd=16时(图中的点4)，出现了一个新的情况，就是发送方一连收到3<br>个对同一个报文段的重复确认(图中记为3-ACK)。</p><p>3-ACK解释：</p><p>有时，个别报文段会在网络中丢失，但实际上网络并未发生拥塞。如果发送方迟迟收不到确认，就会产生超时，就会误认为网络发生了拥塞。这就导致发送方错误地启动慢开始，把拥塞窗口cwnd又设置为1，因而降低了传输效率。</p><p>采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。</p><h4 id="5-8-2-3-快重传"><a href="#5-8-2-3-快重传" class="headerlink" title="5.8.2.3. 快重传"></a>5.8.2.3. 快重传</h4><p><img src="/images/network-basic/TcpFastRetransmit.PNG"></p><p>快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。如图5-26所示，接收方收到了M1和M2后都分别及时发出了确认。现假定接收方没有收到M3但却收到了M4本来接收方可以什么都不做。但按照快重传算法，接收方必须立即发送对M2的重复确认，以便让发送方及早知道接收方没有收到报文段M3。发送方接着发送M5和M6。接收方收到后也仍要再次分别发出对M2的重复确认。这样，发送方共收到了接收方的4个对M2的确认，其中后3个都是重复确认。</p><p>快重传算法规定，发送方只要一连收到3个重复确认，就知道接收方确实没有收到报文段M3，因而应当立即进行重传(即“快重传”)，这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。使用快重传可以使整个网络的吞吐量提高约20%。</p><p>因此，在图中的点4，发送方知道现在只是丢失了个别的报文段。于是不启动慢开始，而是执行快恢复算法。这时，发送方调整门限值 ssthresh=cwnd/2=8，同时设置拥塞窗口cwnd=ssthresh=8(图中的点6)，并开始执行拥塞避免算法。</p><h4 id="5-8-2-4-快恢复"><a href="#5-8-2-4-快恢复" class="headerlink" title="5.8.2.4. 快恢复"></a>5.8.2.4. 快恢复</h4><p>也有的快恢复实现是把快恢复开始时的拥塞窗口cwd值再增大一些(增大报文段的长度)，即等于新的 ssthresh+3×MSS。这样做的理由是:既然发送方收到3个重复的确认，就表明有3个分组已经离开了网络。这3个分组不再消耗网络的资源而是停留在接收方的缓存中(接收方发送出3个重复的确认就证明了这个事实)。可见现在网络中并不是堆积了分组而是减少了3个分组。因此可以适当把拥塞窗口扩大些。</p><h4 id="5-8-2-5-总结"><a href="#5-8-2-5-总结" class="headerlink" title="5.8.2.5. 总结"></a>5.8.2.5. 总结</h4><p><img src="/images/network-basic/TcpCongestionControlProcess.PNG"></p><p>在拥塞避免阶段，拥塞窗口是按照线性规律増大的，这常称为加法增大AI，而一旦出现超时或3个重复的确认，就要把门限值设置为当前拥塞窗口值的一半，并大大减小拥塞窗口的数值。这常称为“乘法减小”MD，二者合在一起就是所谓的AIMD算法。</p><p>总之，发送方的窗口的上限值应当取为接收方窗口rwnd和拥塞窗口cwnd这两个变量中较小的：</p><p><strong>发送方窗口的上限值 = Min[ rwnd ， cwnd ]</strong></p><p>当rwnd &lt; cwnd时，是接收方的接收能力限制发送方窗口的最大值</p><p>当cwnd &lt; rwnd时，则是网络的拥塞程度限制发送方窗口的最大值。</p><h3 id="5-8-3-主动队列管理AQM"><a href="#5-8-3-主动队列管理AQM" class="headerlink" title="5.8.3. 主动队列管理AQM"></a>5.8.3. 主动队列管理AQM</h3><p>网络层路由器的队列通常都是按照“先进先出”FIFO的规则处理到来的分组。当队列已满时，以后再到达的所有分组将都被丢弃。这就叫做<strong>尾部丢弃策略</strong>。这会同时影响到很多条TCP连接，结果使这许多TCP连接在同一时间突然都进入到慢开始状态。这在TCP的术语中称为全局同步。全局同步使得全网的通信量突然下降了很多，而在网络恢复正常后，其通<br>信量又突然增大很多。</p><p>为了避免发生网络中的全局同步现象，提出了主动队列管理AQM。AQM可以有不同实现方法，其中曾流行多年的就是随机早期检测RED。</p><p>实现RED时需要使路由器维持两个参数，即队列长度最小门限和最大门限。当每一个分组到达时，RED就按照规定的算法先计算当前的平均队列长度：</p><ol><li>若平均队列长度小于最小门限，则把新到达的分组放入队列进行排队</li><li>若平均队列长度超过最大门限，则把新到达的分组丢弃。</li><li>若平均队列长度在最小门限和最大门限之间，则按照某一丢弃概率p把新到达的分组丢弃(这就体现了丢弃分组的随机性)</li><li>由此可见，RED不是等到已经发生网络拥塞后才把所有在队列尾部的分组全部丢弃，<br>而是在检测到网络拥塞的早期征兆时(即路由器的平均队列长度达到一定数值时)，就以概<br>率p丢弃个别的分组，让拥塞控制只在个别的TCP连接上进行，因而避免发生全局性的拥<br>塞控制。</li></ol><h2 id="5-9-TCP的连接管理"><a href="#5-9-TCP的连接管理" class="headerlink" title="5.9. TCP的连接管理"></a>5.9. TCP的连接管理</h2><h3 id="5-9-1-TCP的连接建立"><a href="#5-9-1-TCP的连接建立" class="headerlink" title="5.9.1. TCP的连接建立"></a>5.9.1. TCP的连接建立</h3><p><img src="/images/network-basic/3handshake.PNG"></p><ol><li><p>开始，B的TCP服务器进程先创建传输控制块TCB，准备接受客户进程的连接请求。然后服务器进程就处于 LISTEN(收听)状态，等待客户的连接请求。如有，即作出响应。</p></li><li><p>A的TCP客户进程也是首先创建传输控制模块TCB。然后，在打算建立TCP连接时，向B发出连接请求报文段，这时首部中的同步位SYN=1，同时选择一个初始序号seq=ⅹ。TCP规定，SYN报文段(即SYN=1的报文段)不能携带数据，但要消耗掉一个序号这时，TCP客户进程进入 SYN-SENT(同步已发送)状态。</p></li><li><p>B收到连接请求报文段后，如同意建立连接，则向A发送确认。在确认报文段中应把SYN位和ACK位都置1，确认号是ack=x+1，同时也为自己选择一个初始序号seq=y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时TCP服务器进程进入 SYN-RCVD(同步收到)状态。</p></li><li><p>TCP客户进程收到B的确认后，还要向B给出确认。确认报文段的ACK置1，确认号ack=y+1，而自己的序号seq=x+1。TCP的标准规定，ACK报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是seq=x。</p></li><li><p>这时，TCP连接已经建立，A进入 ESTABLISHED(已建立连接)状态。当B收到A的确认后，也进入 ESTABLISHED状态</p></li></ol><p>为什么A最后还要发送一次确认呢?这主要是为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误。</p><p>所谓“已失效的连接请求报文段”是这样产生的。考虑一种正常情况，A发出连接请求，但因连接请求报文丢失而未收到确认。于是A再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A共发送了两个连接请求报文段，其中第一个丢失，第二个到达了B，没有“已失效的连接请求报文段”。现假定出现一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达B。本来这是一个早已失效的报文段。但B收到此失效的连接请求报文段后，就误认为是A又发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。假定不采用报文握手，那么只要B发出确认，新的连接就建立了由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据。但B却以为新的运输连接已经建立了，并一直等待A发来数据。B的许多资源就这样白白浪费了。</p><h3 id="5-9-2-TCP的连接释放"><a href="#5-9-2-TCP的连接释放" class="headerlink" title="5.9.2. TCP的连接释放"></a>5.9.2. TCP的连接释放</h3><p><img src="/images/network-basic/4handshake.PNG"></p><ol><li><p>数据传输结束后，通信的双方都可释放连接。现在A和B都处于 ESTABLISHED状态。A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。A把连接释放报文段首部的终止控制位FN置1，其序号seq=u，它等于前面已传送过的数据的最后一个字节的序号加1。这时A进入FⅠ N-WAIT-1(终止等待1)状态，等待B的确认。请注意，TCP规定，FIN报文段即使不携带数据，它也消耗掉序号。</p></li><li><p>B收到连接释放报文段后即发出确认，确认号是ack=u+1，而这个报文段自己的序号是v，等于B前面已传送过的数据的最后一个字节的序号加1。然后B就进入 CLOSEWAT(关闭等待)状态。TCP服务器进程这时应通知高层应用进程，因而从A到B这个方向的连接就释放了，这时的TCP连接处于<strong>半关闭</strong>状态，即A已经没有数据要发送了，但B若发送数据，A仍要接收。也就是说，从B到A这个方向的连接并未关闭，这个状态可能会持续一段时间。</p></li><li><p>A收到来自B的确认后，就进入 FIN-WAIT2(终止等待2)状态，等待B发出的连接释放报文段。</p></li><li><p>若B已经没有要向A发送的数据，其应用进程就通知TCP释放连接。这时B发出的连接释放报文段必须使FIN=1。现假定B的序号为w(在半关闭状态B可能又发送了一些数据)。B还必须重复上次已发送过的确认号ack=u+1。这时B就进入 LAST-ACK(最后确认)状态，等待A的确认。</p></li><li><p>A在收到B的连接释放报文段后，必须对此发出确认。在确认报文段中把ACK置1，确认号ack=w+1，而自己的序号是seq=u+1(根据TCP标准，前面发送过的FIN报文段要消耗一个序号)。然后进入到 TIME-WAIT(时间等待)状态。请注意，现在TCP连接还没有释放掉。必须经过时间等待计时器( TIME-WAIT timer)设置的时间2MSL后，A才进入到 CLOSED状态。</p></li></ol><p>MSL：最长报文段寿命。</p><p>为什么A在 TMME-WAIT状态必须等待2MSL的时间呢?</p><ol><li>为了保证A发送的最后一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而使处在 LAST-ACK状态的B收不到对已发送的FN+ACK报文段的确认。B会超时重传这个FN+ACK报文段，而A就能在2MSL时间内收到这个重传的FIN+ACK报文段。接着A重传一次确认，重新启动2MSL计时器。最后，A和B都正常进入到CLOSED状态。如果A在 TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后立即释放连接，那么就无法收到B重传的FN+ACK报文段，因而也不会再发送一次确认报文段。这样，B就无法按照正常步骤进入 CLOSED状态。1MSL时间留给最后的ACK确认报文段到达服务器端，1MSL时间留给服务器端再次发送的FIN。</li><li>防止上一节提到的“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。B只要收到了A发出的确认，就进入 CLOSED状态。同样，B在撤销相应的传输控制块TCB后，就结束了这次的TCP连接。我们注意到，B结束TCP连接的时间要比A早。</li></ol><p><strong>保活计时器</strong></p><p>设想有这样的情况:客户已主动与服务器建立了TCP连接。但后来客户端的主机突然出故障。显然，服务器以后就不能再收到客户发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就是使用保活计时器。服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两小时。若两小时没有收到客户的数据，服务器就发送一个探测报文段，以后则每隔75秒钟发送一次。若一连发送10个探测报文段后仍无客户的响应，服务器就认为客户端出了故障，接着就关闭这个连接。</p><h3 id="5-9-3-TCP的有限状态机"><a href="#5-9-3-TCP的有限状态机" class="headerlink" title="5.9.3. TCP的有限状态机"></a>5.9.3. TCP的有限状态机</h3><p><img src="/images/network-basic/TcpFiniteState.PNG"></p><h1 id="6-应用层"><a href="#6-应用层" class="headerlink" title="6. 应用层"></a>6. 应用层</h1><h2 id="6-1-域名系统DNS"><a href="#6-1-域名系统DNS" class="headerlink" title="6.1. 域名系统DNS"></a>6.1. 域名系统DNS</h2><p><strong>顶级域名：</strong></p><ul><li>国家顶级域名：.cn .us</li><li>通用顶级域名：.com .org</li><li>基础结构域名：.arpa</li></ul><p><strong>互联网的域名结构：</strong></p><p><img src="/images/network-basic/domin.PNG"></p><p><strong>域名服务器：</strong></p><ul><li>根域名服务器：最高层次的、最重要的域名服务器</li><li>顶级域名服务器：负责管理在该顶级域名服务器下注册的所有二级域名</li><li>权限域名服务器：负责一个区的域名服务器</li><li>本地域名服务器：默认域名服务器</li></ul><p><img src="/images/network-basic/nameServer.PNG"></p><p><strong>解析过程：</strong></p><ol><li>主机向本地域名服务器的查询一般都是采用递归查询。</li></ol><p>所谓递归查询就是:如果主机所询问的本地域名服务器不知道被査询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文(即替该主机继续查询)，而不是让该主机自己进行下一步的查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。</p><ol start="2"><li>本地域名服务器向根域名服务器的查询通常是采用迭代查询</li></ol><p>迭代査询的特点是这样的:当根域名服务器收到本地域名服务器发出的迭代查询请求报文时要么给出所要查询的IP地址，要么告诉本地域名服务器:“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询(而不是替本地域名服务器进行后续的查询)。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地域名服务器下一步应当向哪一个权限域名服务器进行查询，本地域名服务器就这样进行迭代査询。最后，知道了所要解析的域名的IP地址，然后把这个结果返回给发起查询的主机。</p><p><img src="/images/network-basic/nameQuery.PNG"></p><p>为了提高DNS查询效率，并减轻根域名服务器的负荷和减少互联网上的DNs查询报文数量，在域名服务器中广泛地使用了高速缓存(有时也称为高速缓存域名服务器)。由于名字到地址的绑定并不经常改变，为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并处理超过合理时间的项。</p><h2 id="6-2-文件传送协议"><a href="#6-2-文件传送协议" class="headerlink" title="6.2. 文件传送协议"></a>6.2. 文件传送协议</h2><h3 id="6-2-1-FTP"><a href="#6-2-1-FTP" class="headerlink" title="6.2.1. FTP"></a>6.2.1. FTP</h3><p>文件传送协议FTP是互联网上使用得最广泛的文件送协议，提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限，FTP屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件。</p><p>基于TCP的FTP和基于UDP的简单文件传送协议TFTP，它们都是文件共享协议中的一大类，即复制整个文件。而网络文件系统NFS则采用另一种思路，允许应用进程打开一个远地文件，并能在该文件的某一个特定的位置上开始读写数据。在网络上传送的只是少量的修改数据。</p><p>FTP的服务器进程由两大部分组成:一个主进程，负责接受新的请求;另外有若干个从属进程，<br>负责处理单个请求</p><p><strong>主进程的工作步骤</strong></p><ol><li>打开熟知端口(端口号为21)，使客户进程能够连接上</li><li>等待客户进程发出连接请求</li><li>启动从属进程处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程发之()回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并行的</li></ol><p>两个从属进程:控制进程和数据传送进程。为简单起见，服务器端的主进程没有画上</p><p>在进行文件传输时，FTP的客户和服务器之间要建立两个并行的TCP连接:“控制连<br>接（21号端口）”和“数据连接（20号端口）”。控制连接在整个会话期间一直保持打开，FTP客户所发出的传送请求，通过控制连接发送给服务器端的控制进程，但控制连接并不用来传送文件。实际用于传输文件的是“数据连接”。</p><h3 id="6-2-2-TFTP"><a href="#6-2-2-TFTP" class="headerlink" title="6.2.2. TFTP"></a>6.2.2. TFTP</h3><p>简单文件传送协议TFTP，它是个很小且易于实现的文件传送协议。也使用客户服务器方式，但它使用UDP数据报，因此TFTP需要有自己的差错改正措施。TFTP只支持文件传输而不支持交互。TFTP没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。</p><p>每次传送的数据报文中有512字节的数据，但最后一次可不足512字节，这正好可作为文件结束的标志。</p><p><strong>优点：</strong></p><ol><li>TFTP可用于UDP环境</li><li>TFTP代码所占的内存较小</li></ol><h2 id="6-3-超文本传送协议HTTP"><a href="#6-3-超文本传送协议HTTP" class="headerlink" title="6.3. 超文本传送协议HTTP"></a>6.3. 超文本传送协议HTTP</h2><h3 id="6-3-1-HTTP基本过程"><a href="#6-3-1-HTTP基本过程" class="headerlink" title="6.3.1. HTTP基本过程"></a>6.3.1. HTTP基本过程</h3><p>统一资源定位符URL：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/路径&gt;</p><p>URL里面的协议和主机不分大小写，路径有时区分。</p><p>HTTP使用了面向连接的TCP作为运输层协议，保证了数据的可靠传输。但是HTTP协议本身是无连接的。</p><p>HTTP协议是无状态的。也就是说，同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时的相同。</p><p>万维网客户就把HTTP请求报文作为建立TCP连接的三报文握手中的第三个报文的数据，发送给万维网服务器。服务器收到HTTP请求报文后，就把所请求的文档作为响应报文返回给客户。</p><p><img src="/images/network-basic/HTTPtime.PNG"></p><p>所以，请求一个万维网文档所需的时间是该文档的传输时间加上两倍往返时间RTT。</p><p><strong>HTTP/1.0的主要缺点</strong></p><ul><li>每请求一个文档就要有两倍RTT的开销。</li><li>万维网客户和服务器每一次建立新的TCP连接都要分配缓存和变量。特别是同时服务于大量客户的请求，使用并行TCP连接可以缩短响应时间。</li></ul><p><strong>HTTP/1.1协议</strong>较好地解决了这个问题，它使用了持续连接( persistent connection)。所谓持续连接就是万维网服务器在发送响应后仍然在一段时间内保持这条连接，使同一个客户(浏览器)和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。</p><p><strong>持续连接的工作方式：</strong></p><ul><li>非流水线方式：客户在收到前一个响应后才能发出下一个请求。因此客户每访问一次对象都要用去一个往返时间RTT，比1.0少一个。</li><li>流水线方式：客户在收到HTTP的响应报文之前就能够接着发送新的请求报文。因此客户访问所有的对象只需花费一个RTT时间。</li></ul><p><strong>代理服务器</strong></p><p>代理服务器(proxy server)是一种网络实体，它又称为万维网高速缓存( Web cache)。代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这个请求与暂时存放的请求相同，就返回暂存的响应，而不需要按URL的地址再次去互联网<br>访问该资源。代理服务器可在客户端或服务器端工作，也可在中间系统上工作。</p><h3 id="6-3-2-HTTP报文"><a href="#6-3-2-HTTP报文" class="headerlink" title="6.3.2. HTTP报文"></a>6.3.2. HTTP报文</h3><ul><li>请求报文</li><li>响应报文</li></ul><p><img src="/images/network-basic/HTTPmessage.PNG"></p><p>由于HTTP是面向文本的，因此在报文中的每一个字段都是一些ASCI码串，因而各个字段的长度都是不确定的。</p><p>HTTP请求报文和响应报文都是由三个部分组成的，区别仅开始行不同。</p><h4 id="6-3-2-1-HTTP请求报文"><a href="#6-3-2-1-HTTP请求报文" class="headerlink" title="6.3.2.1. HTTP请求报文"></a>6.3.2.1. HTTP请求报文</h4><p>请求报文的第一行有方法，请求资源的URL，以及HTTP的版本。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Get</td><td>请求资源</td></tr><tr><td>Post</td><td>向服务端发送资源</td></tr><tr><td>Delete</td><td>用于删除资源</td></tr><tr><td>Put</td><td>用于资源的更新，若资源不存在则新建一个</td></tr><tr><td>Option</td><td>请求一些选项信息</td></tr><tr><td>Head</td><td>只请求资源的头部，该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载， 以此可以节约带宽资源</td></tr><tr><td>Trace</td><td>用于环回测试的请求报文</td></tr><tr><td>Connect</td><td>用于代理服务器</td></tr></tbody></table><p><strong>Get/Post的区别</strong></p><ul><li>Get请求的参数放在URL里，有长度限制；Post请求的参数放在实体里，没有限制。</li><li>Get请求比起Post请求更加不安全，因为参数放在URL中，不能用来传递敏感信息。</li><li>GET用于信息获取，而且应该是安全和幂等的（对同一URL的多个请求应该返回同样的结果）；POST请求表示可能修改服务器上资源的请求</li></ul><h4 id="6-3-2-2-HTTP响应报文报文"><a href="#6-3-2-2-HTTP响应报文报文" class="headerlink" title="6.3.2.2. HTTP响应报文报文"></a>6.3.2.2. HTTP响应报文报文</h4><p>状态行包括三项内容，即HTTP的版本，状态码，以及解释状态码的简单短语</p><p>状态码都是三位数字的，分为5大类：</p><ul><li>1xx：通知信息</li><li>2xx：成功</li><li>3xx：重定向，中间态，如要完成请求还必须采取进一步的行动</li><li>4xx：客户的差错，如请求中有错误的语法或不能完成。</li><li>5xx：服务器错误，这些状态代码表示服务器在尝试处理请求时发生内部错误。</li></ul><p>具体的：</p><ul><li><p>200 OK：表示从客户端发送给服务器的请求被正常处理并返回；</p></li><li><p>204 No Content：表示客户端发送给客户端的请求得到了成功处理，但在返回的响应报文中没有资源可以返回；</p></li><li><p>206 Patial Content：表示客户端进行了范围请求，并且服务器成功执行了这部分的GET请求。</p></li><li><p>301 Moved Permanently：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL；</p></li><li><p>302 Found：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL；</p></li></ul><blockquote><p>永久是指原来访问的资源已经永久删除啦，客户端应该根据新的URI访问重定向。<br>临时是指访问的资源可能暂时先用location的URI访问，但旧资源还在的，下次你再来访问的时候可能就不用重定向了。</p></blockquote><ul><li>303 See Other：表示请求的资源被分配了新的URL，客户端应使用GET方法定向获取请求的资源；</li><li>304 Not Modified：该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但是从缓存获取资源</li></ul><blockquote><p>该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但是从缓存获取资源客户端在请求一个文件的时候，发现自己有该请求之前的缓存的文件，并且记录了 Last Modified ，那么在请求头中会包含 If Modified Since ，这个时间就是缓存文件的 Last Modified 。因此，如果请求中包含 If Modified Since，就说明已经有缓存在客户端。服务端只要判断这个时间和当前请求的文件的修改时间就可以确定是返回 304 还是 200 。在服务端的返回的响应头中通常有Last Modified 如果此值与请求头中的If Modified Since时间一致那么返回就是304，否则就是200。<br>对于静态文件，例如：CSS、图片，服务器会自动完成 Last Modified 和 If Modified Since 的比较，完成缓存或者更新。但是对于动态页面，就是动态产生的页面，往往没有包含 Last Modified 信息，这样浏览器、网关等都不会做缓存，也就是在每次请求的时候都完成一个 200 的请求。<br>因此，对于动态页面做缓存加速，首先要在 Response 的 HTTP Header 中增加 Last Modified 定义，其次根据 Request 中的 If Modified Since 和被请求内容的更新时间来返回 200 或者 304 。虽然在返回 304 的时候已经做了一次数据库查询，但是可以避免接下来更多的数据库查询，并且没有返回页面内容而只是一个 HTTP Header，从而大大的降低带宽的消耗，对于用户的感觉也是提高。</p></blockquote><ul><li><p>307 Temporary Redirect：临时重定向，与303有着相同的含义，307会遵照浏览器标准不会从POST变成GET；（不同浏览器可能会出现不同的情况）；</p></li><li><p>400 Bad Request：表示请求报文中存在语法错误；</p></li><li><p>401 Unauthorized：未经许可，需要通过HTTP认证；</p></li><li><p>403 Forbidden：服务器拒绝该次访问（访问权限出现问题）；</p></li><li><p>404 Not Found：表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；</p></li><li><p>500 Inter Server Error：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时；</p></li><li><p>503 Server Unavailable：表示服务器暂时处于超负载或正在进行停机维护，无法处理请求；</p></li></ul><p><strong>重定向</strong></p><p>所谓重定向就是，当浏览器向服务端发送url 请求的时候返回状态码为30x时表示请求被重定向了，例如请求时<a href="http://www.a.com/">http://www.a.com</a> 返回的请求头中location:<a href="https://www.a.com/">https://www.a.com</a> 那么客户端就要重新根据location 提供的信息重新发起新的请求。例如在外网的ingress  配置http 强制跳转https 的时候就是通过配置301强制跳转的。</p><p>请求报文：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/pet-products.txt</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.joes-hardware.com</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*</span><br></pre></td></tr></table></figure><p>服务端响应报文重定向到另一个地址：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">301</span> OK</span><br><span class="line"><span class="attribute">Location</span><span class="punctuation">: </span>http://www.gentle-grooming.com/</span><br><span class="line"><span class="attribute">Content-length</span><span class="punctuation">: </span>56</span><br><span class="line"><span class="attribute">Content-type</span><span class="punctuation">: </span>text/plain</span><br></pre></td></tr></table></figure><p>客户端浏览器收到重定向响应报文后，将发起一个向新地址的请求：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1  </span><br><span class="line">Host: www.gentle-grooming.com</span><br><span class="line">Accept: *</span><br></pre></td></tr></table></figure><p>新地址的响应报文：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-type</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Content-length</span><span class="punctuation">: </span>3307</span><br></pre></td></tr></table></figure><h3 id="6-3-3-HTTP协议的区别"><a href="#6-3-3-HTTP协议的区别" class="headerlink" title="6.3.3. HTTP协议的区别"></a>6.3.3. HTTP协议的区别</h3><p><strong>HTTP1.1比起1.0</strong></p><ol><li>缓存处理。在HTTP1.0中主要使用header里的If-Modified-Since、Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since， If-Match， If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li>带宽优化及网络连接的使用。HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li>错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li>Host头处理，为虚拟化准备。在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li><li>长连接。HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li></ol><p><strong>HTTP2.0比起1.1</strong></p><ol><li>新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li><li>多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的id将request再归属到各自不同的服务端请求里面。</li><li>header压缩、缓存。如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li><li>服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。</li></ol><p><img src="/images/network-basic/HTTPdiff.jpg"></p><h3 id="6-3-4-HTTPS"><a href="#6-3-4-HTTPS" class="headerlink" title="6.3.4. HTTPS"></a>6.3.4. HTTPS</h3><p>HTTPS：是以安全为目标的HTTP通道，简单讲：HTTPS = HTTP + TLS/SSL（TLS的前身是SSL）。</p><p>HTTPS协议的主要作用：</p><ul><li>加密数据，建立一个信息安全通道，来保证数据传输的安全；另一种就是</li><li>对网站服务器进行真实身份认证。</li></ul><h4 id="6-3-4-1-HTTPS的工作原理"><a href="#6-3-4-1-HTTPS的工作原理" class="headerlink" title="6.3.4.1. HTTPS的工作原理"></a>6.3.4.1. HTTPS的工作原理</h4><p><img src="/images/network-basic/HTTPS.png"></p><ol><li>Client发起一个HTTPS的请求，并将自己支持的加密规则发给Server。</li><li>Server从中选出一资加密算法和HASH算法，把自己的身份信息以公钥证书形式返回给客户端。</li><li>Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。</li><li>Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥。</li><li>Client使用约定好的HASH算法计算握手消息，并用生成的随机数对消息加密，发给Server。</li><li>Server使用自己的私钥解密，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。使用密码解析Client发来的握手消息，并验证HASH是否一致。</li><li>Server使用对称密钥加密一段内容，发送给Client。</li><li>Client使用对称密钥解密响应的密文，并计算HASH，得到明文内容。</li></ol><p>Server与Client互相发送加密的握手消息并验证，目的是保证双方获得一致的密码，并且可以正常地加解密，做一次测试。</p><p>非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据加密，HASH算法用于验证数据完整性。</p><p>SSL握手过程中有任何错误都会是加密连接断开，从而阻止隐私信息的传输，非常安全。攻击者常采用假证书欺骗客户端。</p><h4 id="6-3-4-2-HTTPS和HTTP的区别"><a href="#6-3-4-2-HTTPS和HTTP的区别" class="headerlink" title="6.3.4.2. HTTPS和HTTP的区别"></a>6.3.4.2. HTTPS和HTTP的区别</h4><ol><li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li><li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</li></ol><h3 id="6-3-5-HTTP缓存机制"><a href="#6-3-5-HTTP缓存机制" class="headerlink" title="6.3.5. HTTP缓存机制"></a>6.3.5. HTTP缓存机制</h3><p>浏览器的缓存机制也就是我们说的HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的，所以在分析浏览器缓存机制之前，我们先使用图文简单介绍一下HTTP报文，HTTP报文分为两种：</p><ul><li>HTTP请求(Request)报文，报文格式为：请求行 – HTTP头(通用信息头，请求头，实体头) – 请求报文主体(只有POST才有报文主体)</li></ul><p><img src="/images/network-basic/HttpRequestHead.png"></p><ul><li>HTTP响应(Response)报文，报文格式为：状态行 – HTTP头(通用信息头，响应头，实体头) – 响应报文主体</li></ul><p><img src="/images/network-basic/HttpResponseHead.png"></p><p>通用信息头指的是请求和响应报文都支持的头域，分别为Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via；</p><p>实体头则是实体信息的实体头域，分别为Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。</p><p>浏览器与服务器通信的方式为应答模式，即：浏览器发起HTTP请求 – 服务器响应该请求。</p><p><img src="/images/network-basic/HttpFirstRequest.png"></p><ol><li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li><li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li></ol><p>根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强制缓存和协商缓存。</p><h4 id="6-3-5-1-强制缓存"><a href="#6-3-5-1-强制缓存" class="headerlink" title="6.3.5.1. 强制缓存"></a>6.3.5.1. 强制缓存</h4><p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种：</p><ol><li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）：</li></ol><p><img src="/images/network-basic/HttpForceCache1.png"></p><ol start="2"><li>存在该缓存结果和缓存标识，但是结果已经失效，强制缓存失效，则使用协商缓存：</li></ol><p><img src="/images/network-basic/HttpForceCache2.png"></p><p>（3）存在该缓存结果和缓存标识，且该结果没有还没有失效，强制缓存生效，直接返回该结果：</p><p><img src="/images/network-basic/HttpForceCache3.png"></p><p><strong>强制缓存的缓存规则</strong></p><p>当浏览器向服务器发送请求的时候，服务器会将缓存规则（放入HTTP响应的报文的HTTP头中和请求结果一起）返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Conctrol的优先级比Expires高。</p><ol><li>Expires</li></ol><p>Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求的结果缓存的到期时间（绝对时间），即再次发送请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。</p><p>到了HTTP/1.1，Expires已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，如果客户端与服务端的时间由于某些原因（时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存直接失效，那么强制缓存存在的意义就毫无意义。</p><ol><li>Cache-Control</li></ol><p>取值为：</p><ul><li>public：所有内容都将被缓存（客户端和代理服务器都可缓存）</li><li>private：所有内容只有客户端可以缓存，Cache-Control的默认取值</li><li>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li><li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li><li>max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效（相对时间）</li></ul><p><strong>浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？</strong></p><p>内存缓存(from memory cache)和硬盘缓存(from disk cache):</p><ol><li>内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性：</li></ol><ul><li>快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。</li><li>时效性：一旦该进程关闭，则该进程的内存则会清空。</li></ul><ol start="2"><li>硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。</li></ol><p>在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。</p><p>行为分析：</p><p>访问某个网站 –&gt; 200 –&gt; 关闭博客的标签页 –&gt; 重新打开网站（渲染） –&gt; 200(from disk cache) –&gt; 刷新 –&gt; 200(from memory cache)。ctrl+F5 强制刷新就会200 发起新的请求而忽略缓存。</p><h4 id="6-3-5-2-协商缓存"><a href="#6-3-5-2-协商缓存" class="headerlink" title="6.3.5.2. 协商缓存"></a>6.3.5.2. 协商缓存</h4><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p><ol><li>协商缓存生效，返回304：</li></ol><p><img src="/images/network-basic/HttpConsultCacheSucc.png"></p><ol start="2"><li>协商缓存失败，返回200和请求结果：</li></ol><p><img src="/images/network-basic/HttpConsultCacheFail.png"></p><p>同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：</p><ul><li>Last-Modified / If-Modified-Since</li><li>Etag / If-None-Match</li></ul><p>其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。</p><p><strong>Last-Modified / If-Modified-Since</strong></p><ol><li>Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间，时间值。</li><li>If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，告诉服务器上次请求该资源时返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比：</li></ol><ul><li>若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；</li><li>否则则返回304，代表资源无更新，可继续使用缓存文件。</li></ul><p><strong>Etag / If-None-Match</strong></p><ol><li>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)</li><li>If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比：</li></ol><ul><li>一致则返回304，代表资源无更新，继续使用缓存文件；</li><li>不一致则重新返回资源文件，状态码为200。</li></ul><h4 id="6-3-5-3-总结"><a href="#6-3-5-3-总结" class="headerlink" title="6.3.5.3. 总结"></a>6.3.5.3. 总结</h4><p>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)</p><p>协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存，主要过程如下：</p><p><img src="/images/network-basic/HttpCache.png"></p><h3 id="6-3-6-session和cookie"><a href="#6-3-6-session和cookie" class="headerlink" title="6.3.6. session和cookie"></a>6.3.6. session和cookie</h3><p><strong>session与cookie的区别</strong></p><p>session：Session 是存放在服务器端的，类似于Session结构来存放用户数据，当浏览器 第一次发送请求时，服务器自动生成了一个Session和一个Session ID用来唯一标识这个Session，并将其通过响应发送到浏览器。当浏览器第二次发送请求，会将前一次服务器响应中的Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户对应的Session。由于Session存放在服务器端，所以随着时间的推移或者用户访问的增多，会给服务器增加负担。使用的时候要考虑下服务器的性能。</p><p>cookie：Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端会把Cookie保存起来。由于Cookie是存放在客户端，是可见的，安全性就会很低。因此不建议将一些重要的信息放在cookie中。</p><p><strong>区别</strong></p><ul><li>cookie存放在客户端，session存放在服务器端</li><li>cookie不是很安全，别人可以分析你本地的cookie信息进行cookie欺骗，因此重要信息应考虑保存在服务器端</li><li>session一定时间内回报存在服务器端，当访问量增大时，会影响服务器性能，从性能方面考虑应使用cookie</li><li>不同浏览器对cookie的数据大小限制不同，个数限制也不同</li><li>可以考虑将登陆信息等重要信息存放为session，不重要的信息可以放在cookie中</li></ul><p><strong>联系</strong></p><ul><li>都是用来记录用户的信息，以便让服务器分辨不同的用户</li><li>可以搭配使用，但都有自己的使用局限，要考虑到安全和性能的问题</li></ul><p><strong>如果客户端禁止 cookie，session 还能用吗？</strong></p><p>如果浏览器禁止cookie，那么客户端访问服务端时无法携带sessionid，服务端无法识别用户身份，便无法进行会话控制，session失效。但可以通过以下几种方法：</p><ul><li>URL重写：URL重写要求将站点中的所有超链接都进行改造，在超链接后用一个特殊的参数JSESSIONID保存当前浏览器对应session的编号，这样一来，当用户点击超链接访问服务器时，服务器可以从URL后的参数中分析出JSESSIONID，从而找到对应的sesison使用.</li><li>用文件、数据库等形式保存Session ID，在跨页过程中手动调用</li></ul><h2 id="6-4-输入URL之后会发生什么"><a href="#6-4-输入URL之后会发生什么" class="headerlink" title="6.4. 输入URL之后会发生什么"></a>6.4. 输入URL之后会发生什么</h2><h3 id="6-4-1-大纲"><a href="#6-4-1-大纲" class="headerlink" title="6.4.1. 大纲"></a>6.4.1. 大纲</h3><ol><li>浏览器解析URL</li><li>查找资源缓存</li><li>DNS解析</li><li>建立TCP连接（三次握手）</li><li>HTTP/HTTPS发起请求</li><li>对TCP报文打包，加入源IP地址和目标IP地址</li><li>网络层查询下一跳路由，ARP查询下一跳路由的MAC地址</li><li>数据链路层对IP报文打包并附上MAC地址</li><li>物理层发送数据</li><li>服务器处理请求，响应，浏览器接收HTTP响应</li><li>选择关闭TCP连接（四次挥手）</li><li>编码、解析构建规则树</li><li>渲染树</li></ol><h3 id="6-4-2-具体过程"><a href="#6-4-2-具体过程" class="headerlink" title="6.4.2. 具体过程"></a>6.4.2. 具体过程</h3><ul><li>浏览器解析URL获取协议、域名、端口、路径；</li><li>查看浏览器是否有资源的缓存<ul><li>有。判断是否过期<ul><li>没过期。直接读取缓存</li><li>过期。<ul><li>Etag和If-None-Match</li><li>Last-Modify和lf-Modified-Since</li><li>文件修改了则把新资源发给浏览器（状态码200），没修改则告诉浏览器读取缓存（状态码304）</li></ul></li></ul></li><li>没有则进行下一步</li></ul></li><li>DNS解析<ul><li>寻找浏览器是否存在缓存，若没有</li><li>寻找操作系统是否存在缓存，若没有</li><li>寻找hosts文件中是否有域名和ip的对应关系，若没有</li><li>查找路由器中是否有缓存</li><li>寻找DNS服务器是否没缓存，若没有</li><li>向本地域名服务器递归查询</li><li>本地域名服务器想根域名服务器迭代查询</li></ul></li><li>生成HTTP请求</li><li>建立TCP连接，三次握手<ul><li>客户端发送SYN=1，Seq=X</li><li>服务端发回SYN=1，ACK=X+1，Seq=Y</li><li>客户端发送ACK=Y+1，Seq=Y + 1</li></ul></li><li>如果是HTTP请求，对HTTP报文进行报文分割并标记序号和端口号</li><li>如果是HTTPS请求<ul><li>Client发起一个HTTPS的请求，并将自己支持的加密规则发给Server。</li><li>Server从中选出一资加密算法和HASH算法，把自己的身份信息以公钥证书形式返回给客户端。</li><li>Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。</li><li>Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥。</li><li>Client使用约定好的HASH算法计算握手消息，并用生成的随机数对消息加密，发给Server。</li><li>Server使用自己的私钥解密，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。使用密码解析Client发来的握手消息，并验证HASH是否一致。</li><li>Server使用对称密钥加密一段内容，发送给Client。</li><li>Client使用对称密钥解密响应的密文，并计算HASH，得到明文内容。</li></ul></li><li>对TCP报文打包，加入源IP地址和目标IP地址。</li><li>网络层根据目标IP地址和路由表，查询下一跳路由。使用ARP查询下一跳路由的MAC地址。</li><li> 数据链路层对IP报文打包并附上MAC地址。</li><li> 物理层发送数据。</li><li> 服务器在收到浏览器发送的HTTP请求之后，会将收到的HTTP报文封装成HTTP的Request对象，并通过不同的Web服务器进行处理，处理完的结果以HTTP的Response对象返回，主要包括状态码，响应头，响应报文三个部分。</li><li> 浏览器接收到HTTP响应，关闭TCP连接或保持复用，四次握手。</li><li> 如果说响应的内容是HTML文档的话，就需要浏览器进行解析渲染呈现给用户。</li><li> 根据响应头的字符集进行解码如果响应头没有字符集，则浏览器会默认用一套解码规则，当解析html解析到meta标签中的编码规则时，则替换成新的解码方式重新解码。</li><li> 浏览器通过解析HTML，生成DOM树，解析CSS，生成CSS规则树。</li><li> 然后通过DOM树和CSS规则树生成渲染树。渲染树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。repaint（重画颜色等，不影响布局）和reflow（组件的几何尺寸变了，重新验证并计算渲染树）。</li></ul><h1 id="7-参考链接"><a href="#7-参考链接" class="headerlink" title="7. 参考链接"></a>7. 参考链接</h1><ul><li>《计算机网络（第7版）》谢希仁，电子工业出版社</li><li><a href="https://www.cnblogs.com/maybe2030/p/4781555.html">计算机网络基础知识总结</a></li><li><a href="https://blog.csdn.net/yaopeng_2005/article/details/7064869">OSI七层模型详解</a></li><li><a href="https://www.cnblogs.com/zhengshiqiang47/p/8673559.html">HTTP协议以及HTTP2.0/1.1/1.0区别</a></li><li><a href="https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A">HTTP1.0、HTTP1.1 和 HTTP2.0 的区别</a></li><li><a href="https://blog.csdn.net/banana960531/article/details/85621865">HTTP常见状态码（14种）</a></li><li><a href="https://messiahhh.github.io/blog/frontend">菜鸟向前端指南</a></li><li><a href="https://www.cnblogs.com/wqhwe/p/5407468.html">HTTP与HTTPS的区别</a></li><li><a href="https://www.cnblogs.com/wuwuyong/p/12198928.html">计算机网络常见面试题</a></li><li><a href="https://www.cnblogs.com/inception6-lxc/p/9152691.html">计算机网络常见面试题</a></li><li><a href="https://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html">计算机网络之面试常考</a></li><li><a href="https://blog.csdn.net/weixin_41969587/article/details/88836161">HTTP请求和响应3：状态码（status）</a></li><li><a href="https://www.cnblogs.com/fanggege/p/13207204.html">http 状态码之3xx</a></li><li><a href="https://www.cnblogs.com/chengxs/p/10396066.html">彻底理解浏览器的缓存机制(htp绶存机制)</a></li><li><a href="https://mp.weixin.qq.com/s/DId9NRXF0SaMyCo27vmojg">这样看 B 站，可以更快！</a></li><li><a href="https://www.cnblogs.com/jxxblogs/p/12088924.html">session与cookie的区别？ 如果客户端禁止 cookie session 还能用吗？</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;概述、物理层、数据链路层、网络层、运输层、应用层。&lt;/p&gt;
&lt;p&gt;70页、5万字，超长总结。&lt;/p&gt;</summary>
    
    
    
    <category term="Study" scheme="https://memorykk.cn/categories/Study/"/>
    
    
    <category term="Network" scheme="https://memorykk.cn/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>网络爬虫基础</title>
    <link href="https://memorykk.cn/webCrawler-basic.html"/>
    <id>https://memorykk.cn/webCrawler-basic.html</id>
    <published>2021-03-13T04:48:16.000Z</published>
    <updated>2021-03-16T07:31:13.155Z</updated>
    
    <content type="html"><![CDATA[<p>待写</p><span id="more"></span><p>正文</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;待写&lt;/p&gt;</summary>
    
    
    
    <category term="Tool" scheme="https://memorykk.cn/categories/Tool/"/>
    
    
  </entry>
  
  <entry>
    <title>蓝桥杯Java</title>
    <link href="https://memorykk.cn/lanqiao-P11.html"/>
    <id>https://memorykk.cn/lanqiao-P11.html</id>
    <published>2021-03-10T12:50:02.000Z</published>
    <updated>2021-03-16T06:09:24.414Z</updated>
    
    <content type="html"><![CDATA[<p>第十一届蓝桥杯大赛软件类省赛Java大学B组第一场 &amp; 第一次校内模拟  &amp; 第三次校内模拟<br>详解及总结</p><span id="more"></span><hr><p><strong>目录</strong></p><ul><li><a href="#%E7%9C%81%E8%B5%9B">省赛</a><ul><li><a href="#A%E8%A7%A3%E5%AF%86">A解密</a></li><li><a href="#B%E7%BA%AA%E5%BF%B5%E6%97%A5">B纪念日</a></li><li><a href="#C%E5%90%88%E5%B9%B6%E6%A3%80%E6%B5%8B">C合并检测</a></li><li><a href="#D%E5%88%86%E9%85%8D%E5%8F%A3%E7%BD%A9">D分配口罩</a></li><li><a href="#E%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0">E斐波那契数列最大公约数</a></li><li><a href="#F%E5%88%86%E7%B1%BB%E8%AE%A1%E6%95%B0">F分类计数</a></li><li><a href="#G%E5%85%AB%E6%AC%A1%E6%B1%82%E5%92%8C">G八次求和</a></li><li><a href="#H%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81">H字符串编码</a></li><li><a href="#I%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9">I二叉搜索树插入节点</a></li></ul></li><li><a href="#%E6%A0%A1%E5%86%85%E6%A8%A1%E6%8B%9F%E8%B5%9B%E4%B8%80">校内模拟赛一</a><ul><li><a href="#A%E8%AE%A1%E7%AE%97">A计算</a></li><li><a href="#B%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0">B约数个数</a></li><li><a href="#C%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0">C叶节点数</a></li><li><a href="#D%E5%8C%85%E5%90%AB%E6%95%B0%E5%AD%979">D包含数字9</a></li><li><a href="#E%E6%95%B0%E4%BD%8D%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0">E数位递增的数</a></li><li><a href="#F%E9%80%92%E5%A2%9E%E4%B8%89%E5%85%83%E7%BB%84">F递增三元组</a></li><li><a href="#G%E9%9F%B3%E8%8A%82%E5%88%A4%E6%96%AD">G音节判断</a></li><li><a href="#H%E9%95%BF%E8%8D%89">H长草</a></li></ul></li><li><a href="#%E6%A0%A1%E5%86%85%E6%A8%A1%E6%8B%9F%E8%B5%9B%E4%B8%89">校内模拟赛三</a><ul><li><a href="#A">A</a></li><li><a href="#B">B</a></li><li><a href="#C">C</a></li><li><a href="#D">D</a></li><li><a href="#E">E</a></li><li><a href="#F">F</a></li><li><a href="#G">G</a></li><li><a href="#H">H</a></li><li><a href="#I">I</a></li><li><a href="#J">J</a></li></ul></li><li><a href="#%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%8D%A2">字符转换</a></li></ul><hr><h1 id="省赛"><a href="#省赛" class="headerlink" title="省赛"></a>省赛</h1><h2 id="A解密"><a href="#A解密" class="headerlink" title="A解密"></a>A解密</h2><p><img src="/images/lanqiao-P11/P11A1.png" alt="P11A1.png"><br><img src="/images/lanqiao-P11/P11A2.png" alt="P11A2.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String tc = <span class="string">&quot;yxmdacikntjhqlgoufszpwbrev&quot;</span>;</span><br><span class="line">        String str = <span class="string">&quot;EaFnjISplhFviDhwFbEjRjfIBBkRyY&quot;</span>;</span><br><span class="line">        String result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> xi;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (temp &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                temp += <span class="string">&#x27;a&#x27;</span> - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">                xi = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                xi = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result += (<span class="keyword">char</span>) (xi + tc.indexOf(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YeRikGSunlRzgDlvRwYkXkrGWWhXaA</span><br></pre></td></tr></table></figure><h2 id="B纪念日"><a href="#B纪念日" class="headerlink" title="B纪念日"></a>B纪念日</h2><p><img src="/images/lanqiao-P11/P11B.png" alt="P11B.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r=<span class="number">0</span>,p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1921</span>;i&lt;<span class="number">2020</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">100</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">400</span>==<span class="number">0</span>) &#123;</span><br><span class="line">                    r++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    p++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">4</span>==<span class="number">0</span>) &#123;</span><br><span class="line">                    r++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    p++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println((r*<span class="number">366</span>+p*<span class="number">365</span>-<span class="number">21</span>)*<span class="number">24</span>*<span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">52038720</span><br></pre></td></tr></table></figure><h2 id="C合并检测"><a href="#C合并检测" class="headerlink" title="C合并检测"></a>C合并检测</h2><p><img src="/images/lanqiao-P11/P11C.png" alt="P11C.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minK =<span class="number">0</span>,min=<span class="number">99999999</span>,temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">100</span> %i != <span class="number">0</span>)&#123;</span><br><span class="line">                temp =(<span class="number">100</span>/i)+i+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp=(<span class="number">100</span>/i)+i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp&lt;min)&#123;</span><br><span class="line">                min=temp;</span><br><span class="line">                minK=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(minK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="D分配口罩"><a href="#D分配口罩" class="headerlink" title="D分配口罩"></a>D分配口罩</h2><p><img src="/images/lanqiao-P11/P11D.png" alt="P11D.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *当要求在长度为n的大序列中取出长度为0-n的小序列时用DFS，一次性可求出，</span></span><br><span class="line"><span class="comment"> *如n=5,要求排列组合中求出A(1,5)、A(2,5)、...A(5,5)，跟穷举一样。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main4</span> </span>&#123;</span><br><span class="line"><span class="comment">//    public static int[] arr = &#123;9090400, 8499400, 5926800, 8547000, 4958200, 4422600, 5751200,4175600,</span></span><br><span class="line"><span class="comment">//    6309600, 5865200, 6604400, 4635000, 10663400, 8087200, 4554000&#125;;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">16</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[arr.length];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; arr.length; x++) &#123;</span><br><span class="line">            sum += arr[x];</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        System.out.println(min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= sum / <span class="number">2</span>) &#123;</span><br><span class="line">            min = Math.min(min, Math.abs(sum - index * <span class="number">2</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;___________________________________&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; arr.length; x++) &#123;</span><br><span class="line">            <span class="comment">//若未访问过</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[x]) &#123;</span><br><span class="line">                visited[x] = <span class="keyword">true</span>;</span><br><span class="line">                res[x]=arr[x];</span><br><span class="line">                dfs(index + arr[x]);</span><br><span class="line">                visited[x] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(index==<span class="number">0</span>||index==<span class="number">1</span>)</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+index+<span class="string">&quot;层--第&quot;</span>+x+<span class="string">&quot;个--&quot;</span>+Arrays.toString(res)+<span class="string">&quot;--结果：&quot;</span>+min);</span><br><span class="line">            res[x]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2400</span><br></pre></td></tr></table></figure><h2 id="E斐波那契数列最大公约数"><a href="#E斐波那契数列最大公约数" class="headerlink" title="E斐波那契数列最大公约数"></a>E斐波那契数列最大公约数</h2><p><img src="/images/lanqiao-P11/P11E.png" alt="P11E.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BigInteger arr[] = <span class="keyword">new</span> BigInteger[<span class="number">2025</span>]; <span class="comment">// int long型数据均会爆数组</span></span><br><span class="line">        arr[<span class="number">0</span>] = BigInteger.ZERO;</span><br><span class="line">        arr[<span class="number">1</span>] = arr[<span class="number">2</span>] = BigInteger.ONE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">2020</span>; i++) &#123;</span><br><span class="line">            arr[i] = arr[i - <span class="number">1</span>].add(arr[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(gcd(arr[<span class="number">2020</span>],arr[<span class="number">520</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigInteger <span class="title">gcd</span><span class="params">(BigInteger  a,BigInteger  b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.equals(BigInteger.ZERO)?a:gcd(b,a.mod(b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6765</span><br></pre></td></tr></table></figure><h2 id="F分类计数"><a href="#F分类计数" class="headerlink" title="F分类计数"></a>F分类计数</h2><p><img src="/images/lanqiao-P11/P11F.png" alt="P11F.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> H=<span class="number">0</span>,L=<span class="number">0</span>,D=<span class="number">0</span>;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = input.next();</span><br><span class="line">        <span class="keyword">char</span>[] arr = str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; arr[i]&lt;=<span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">                H++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i]&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; arr[i]&lt;=<span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">                L++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; arr[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                D++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(H);</span><br><span class="line">        System.out.println(L);</span><br><span class="line">        System.out.println(D);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G八次求和"><a href="#G八次求和" class="headerlink" title="G八次求和"></a>G八次求和</h2><p><img src="/images/lanqiao-P11/P11G.png" alt="P11G.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BigInteger base = <span class="keyword">new</span> BigInteger(<span class="keyword">new</span> Scanner(System.in).next());</span><br><span class="line">        BigInteger result = BigInteger.ZERO;</span><br><span class="line">        <span class="keyword">for</span>(BigInteger i=BigInteger.ONE;i.compareTo(base)&lt;<span class="number">1</span>;i=i.add(BigInteger.ONE))&#123;</span><br><span class="line">            result = result.add(i.pow(<span class="number">8</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result.mod(<span class="keyword">new</span> BigInteger(<span class="string">&quot;123456789&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H字符串编码"><a href="#H字符串编码" class="headerlink" title="H字符串编码"></a>H字符串编码</h2><p><img src="/images/lanqiao-P11/P11H.png" alt="P11H.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">char</span>[] arrC = <span class="keyword">new</span> Scanner(System.in).next().toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[arrC.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arrC.length;i++)&#123;</span><br><span class="line">            arr[i] = arrC[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;<span class="number">2</span>)&#123;</span><br><span class="line">                res += (<span class="keyword">char</span>)(arr[i]+<span class="string">&#x27;A&#x27;</span>-<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i]*<span class="number">10</span>+arr[i+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (temp &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    res += (<span class="keyword">char</span>)(temp+<span class="string">&#x27;A&#x27;</span>-<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    res += (<span class="keyword">char</span>)(arr[i] + <span class="string">&#x27;A&#x27;</span>-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="I二叉搜索树插入节点"><a href="#I二叉搜索树插入节点" class="headerlink" title="I二叉搜索树插入节点"></a>I二叉搜索树插入节点</h2><p><img src="/images/lanqiao-P11/P11I1.png" alt="P11I1.png"><br><img src="/images/lanqiao-P11/P11I2.png" alt="P11I2.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main9</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">        <span class="keyword">int</span> k = input.nextInt();</span><br><span class="line">        <span class="keyword">long</span> w[] = <span class="keyword">new</span> <span class="keyword">long</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> p[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="comment">//第i个节点权值w[i]，其父节点编号p[i],权值pw[i]</span></span><br><span class="line">            p[i] = input.nextInt();</span><br><span class="line">            w[i] = input.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> parentW=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> cntW=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;w.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i]==k)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                parentW=w[p[i]];</span><br><span class="line">                cntW=w[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==<span class="number">2</span>)&#123;</span><br><span class="line">            System.out.println(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//插入右子树</span></span><br><span class="line">            <span class="keyword">if</span>(cntW&lt;parentW)&#123;</span><br><span class="line">                <span class="comment">//K是其父的左子树</span></span><br><span class="line">                <span class="keyword">if</span>(w[k]&lt;w[p[k]])&#123;</span><br><span class="line">                    System.out.println(w[k]-w[p[k]]-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//K是其父的右子树</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.println(-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//插入左子树</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//K是其父的左子树</span></span><br><span class="line">                <span class="keyword">if</span>(w[k]&lt;w[p[k]])&#123;</span><br><span class="line">                    System.out.println(-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//K是其父的右子树</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.println(w[k]-w[p[k]]-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="校内模拟赛一"><a href="#校内模拟赛一" class="headerlink" title="校内模拟赛一"></a>校内模拟赛一</h1><h2 id="A计算"><a href="#A计算" class="headerlink" title="A计算"></a>A计算</h2><blockquote><p>在计算机存储中，15.125GB是多少MB？</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">1024</span>*<span class="number">15.125</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15488</span><br></pre></td></tr></table></figure><h2 id="B约数个数"><a href="#B约数个数" class="headerlink" title="B约数个数"></a>B约数个数</h2><blockquote><p>1200000有多少个约数（只计算正约数）。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1200000</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">1200000</span>%i==<span class="number">0</span>)&#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">96</span><br></pre></td></tr></table></figure><h2 id="C叶节点数"><a href="#C叶节点数" class="headerlink" title="C叶节点数"></a>C叶节点数</h2><blockquote><p>一棵包含有2019个结点的二叉树，最多包含多少个叶结点？</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n0&#x3D;n2+1</span><br><span class="line">n0+n1+n2&#x3D;2019</span><br><span class="line"></span><br><span class="line">max(n0)&#x3D;1010</span><br></pre></td></tr></table></figure><h2 id="D包含数字9"><a href="#D包含数字9" class="headerlink" title="D包含数字9"></a>D包含数字9</h2><blockquote><p>在1至2019中，有多少个数的数位中包含数字9？<br>注意，有的数中的数位中包含多个9，这个数只算一次。例如，1999这个数包含数字9，在计算只是算一个数。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2019</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] arr=(String.valueOf(i)).toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]==<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">544</span><br></pre></td></tr></table></figure><h2 id="E数位递增的数"><a href="#E数位递增的数" class="headerlink" title="E数位递增的数"></a>E数位递增的数</h2><blockquote><p>【问题描述】<br>一个正整数如果任何一个数位不大于右边相邻的数位，则称为一个数位递增的数，例如1135是一个数位递增的数，而1024不是一个数位递增的数。<br>给定正整数 n，请问在整数 1 至 n 中有多少个数位递增的数？<br>【输入格式】<br>输入的第一行包含一个整数 n。<br>【输出格式】<br>输出一行包含一个整数，表示答案。<br>【样例输入】<br>30<br>【样例输出】<br>26<br>【评测用例规模与约定】<br>对于 40% 的评测用例，1 &lt;= n &lt;= 1000。<br>对于 80% 的评测用例，1 &lt;= n &lt;= 100000。<br>对于所有评测用例，1 &lt;= n &lt;= 1000000。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> n = <span class="keyword">new</span> Scanner(System.in).nextLong();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] arr=(<span class="string">&quot;&quot;</span>+i).toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;arr.length-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j==arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F递增三元组"><a href="#F递增三元组" class="headerlink" title="F递增三元组"></a>F递增三元组</h2><blockquote><p>【问题描述】<br>在数列 a[1], a[2], …, a[n] 中，如果对于下标 i, j, k 满足 0&lt;i&lt;j&lt;k&lt;n+1 且 a[i]&lt;a[j]&lt;a[k]，则称 a[i], a[j], a[k] 为一组递增三元组，a[j]为递增三元组的中心。<br>给定一个数列，请问数列中有多少个元素可能是递增三元组的中心。<br>【输入格式】<br>输入的第一行包含一个整数 n。<br>第二行包含 n 个整数 a[1], a[2], …, a[n]，相邻的整数间用空格分隔，表示给定的数列。<br>【输出格式】<br>输出一行包含一个整数，表示答案。<br>【样例输入】<br>5<br>1 2 5 3 5<br>【样例输出】<br>2<br>【样例说明】<br>a[2] 和 a[4] 可能是三元组的中心。<br>【评测用例规模与约定】<br>对于 50% 的评测用例，2 &lt;= n &lt;= 100，0 &lt;= 数列中的数 &lt;= 1000。<br>对于所有评测用例，2 &lt;= n &lt;= 1000，0 &lt;= 数列中的数 &lt;= 10000。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> index = input.nextInt() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">        <span class="keyword">boolean</span>[] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[index];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = input.nextInt();</span><br><span class="line">            flag[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; arr.length; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (arr[j] &lt; arr[k] &amp;&amp; !flag[j]) &#123;</span><br><span class="line">                            flag[j] = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[i])&#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G音节判断"><a href="#G音节判断" class="headerlink" title="G音节判断"></a>G音节判断</h2><blockquote><p>【问题描述】<br>小明对类似于 hello 这种单词非常感兴趣，这种单词可以正好分为四段，第一段&gt; 由一个或多个辅音字母组成，第二段由一个或多个元音字母组成，第三段由一个或多个辅音字母组成，第四段由一个或多个元音字母组成。<br>给定一个单词，请判断这个单词是否也是这种单词，如果是请输出yes，否则请输出no。<br>元音字母包括 a, e, i, o, u，共五个，其他均为辅音字母。<br>【输入格式】<br>输入一行，包含一个单词，单词中只包含小写英文字母。<br>【输出格式】<br>输出答案，或者为yes，或者为no。<br>【样例输入】<br>lanqiao<br>【样例输出】<br>yes<br>【样例输入】<br>world<br>【样例输出】<br>no<br>【评测用例规模与约定】<br>对于所有评测用例，单词中的字母个数不超过100。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//public class Main7 &#123;</span></span><br><span class="line"><span class="comment">//    public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">//        int ex=0;</span></span><br><span class="line"><span class="comment">//        char[] arr=new Scanner(System.in).nextLine().toCharArray();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        if(isYuan(arr[0]))&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;no&quot;);</span></span><br><span class="line"><span class="comment">//            return;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        if(!isYuan(arr[arr.length-1]))&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;no&quot;);</span></span><br><span class="line"><span class="comment">//            return;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        for(int i=0;i&lt;arr.length-1;i++)&#123;</span></span><br><span class="line"><span class="comment">//            if(!isYuan(arr[i]))&#123;</span></span><br><span class="line"><span class="comment">//                if(isYuan(arr[i+1])) &#123;</span></span><br><span class="line"><span class="comment">//                    ex++;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;else&#123;</span></span><br><span class="line"><span class="comment">//                if(!isYuan(arr[i+1])) &#123;</span></span><br><span class="line"><span class="comment">//                    ex++;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        if(ex==3)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;yes&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;else&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;no&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    public static boolean isYuan(char c)&#123;</span></span><br><span class="line"><span class="comment">//        if(c==&#x27;a&#x27;||c==&#x27;e&#x27;||c==&#x27;i&#x27;||c==&#x27;o&#x27;||c==&#x27;u&#x27;)&#123;</span></span><br><span class="line"><span class="comment">//            return true;</span></span><br><span class="line"><span class="comment">//        &#125;else&#123;</span></span><br><span class="line"><span class="comment">//            return false;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正则表达式解法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">&quot;[^aeiou]+[aeiou]+[^aeiou]+[aeiou]+&quot;</span>);</span><br><span class="line">        Matcher m = p.matcher(<span class="keyword">new</span> Scanner(System.in).nextLine());</span><br><span class="line">        <span class="keyword">if</span> (m.matches()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H长草"><a href="#H长草" class="headerlink" title="H长草"></a>H长草</h2><blockquote><p>【问题描述】<br>小明有一块空地，他将这块空地划分为 n 行 m 列的小块，每行和每列的长度都为 1。<br>小明选了其中的一些小块空地，种上了草，其他小块仍然保持是空地。<br>这些草长得很快，每个月，草都会向外长出一些，如果一个小块种了草，则它将向自己的上、下、左、右四小块空地扩展，这四小块空地都将变为有草的小块。<br>请告诉小明，k 个月后空地上哪些地方有草。<br>【输入格式】<br>输入的第一行包含两个整数 n, m。<br>接下来 n 行，每行包含 m 个字母，表示初始的空地状态，字母之间没有空格。如果为小数点，表示为空地，如果字母为 g，表示种了草。<br>接下来包含一个整数 k。<br>【输出格式】<br>输出 n 行，每行包含 m 个字母，表示 k 个月后空地的状态。如果为小数点，表示为空地，如果字母为 g，表示长了草。<br>【样例输入】<br>4 5<br>.g…<br>…..<br>..g..<br>…..<br>2<br>【样例输出】<br>gggg.<br>gggg.<br>ggggg<br>.ggg.<br>【评测用例规模与约定】<br>对于 30% 的评测用例，2 &lt;= n, m &lt;= 20。<br>对于 70% 的评测用例，2 &lt;= n, m &lt;= 100。<br>对于所有评测用例，2 &lt;= n, m &lt;= 1000，1 &lt;= k &lt;= 1000。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n=input.nextInt();</span><br><span class="line">        <span class="keyword">int</span> m=input.nextInt();</span><br><span class="line">        <span class="keyword">char</span>[][] arr = <span class="keyword">new</span> <span class="keyword">char</span>[n][m];</span><br><span class="line">        <span class="keyword">boolean</span>[][] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][m];</span><br><span class="line">        input.nextLine();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            String temp = input.nextLine();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                arr[i][j]=temp.charAt(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = input.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//刷新标记</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[i][j]==<span class="string">&#x27;g&#x27;</span>)&#123;</span><br><span class="line">                        flag[i][j]=<span class="keyword">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        flag[i][j]=<span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[i][j]==<span class="string">&#x27;g&#x27;</span> &amp;&amp; flag[i][j]) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(i-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; arr[i-<span class="number">1</span>][j]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                            arr[i-<span class="number">1</span>][j]=<span class="string">&#x27;g&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n &amp;&amp; arr[i+<span class="number">1</span>][j]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                            arr[i+<span class="number">1</span>][j]=<span class="string">&#x27;g&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(j-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; arr[i][j-<span class="number">1</span>]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                            arr[i][j-<span class="number">1</span>]=<span class="string">&#x27;g&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(j+<span class="number">1</span>&lt;m &amp;&amp; arr[i][j+<span class="number">1</span>]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                            arr[i][j+<span class="number">1</span>]=<span class="string">&#x27;g&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                System.out.print((arr[i][j]));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="校内模拟赛三"><a href="#校内模拟赛三" class="headerlink" title="校内模拟赛三"></a>校内模拟赛三</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><blockquote><p>请问在 1 到 2020 中，有多少个数与 2020 互质，即有多少个数与 2020 的最大公约数为 1。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2020</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(gcd(<span class="number">2020</span>,i)==<span class="number">1</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i%j==<span class="number">0</span>)?j:gcd(j,i%j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">800</span><br></pre></td></tr></table></figure><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><blockquote><p>ASCII 码将每个字符对应到一个数值（编码），用于信息的表示和传输。在 ASCII 码中，英文字母是按从小到大的顺序依次编码的，例如：字母 A 编码是 65, 字母 B 编码是 66，字母 C 编码是 67，请问字母 Q 编码是多少？</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println((<span class="keyword">int</span>)<span class="string">&#x27;Q&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">81</span><br></pre></td></tr></table></figure><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote><p>有一棵二叉树，一个由2021个结点，其中有1000个结点有两个子结点，其他的结点有一个或者0个子结点。<br>请问，这棵二叉树有多少个叶结点？</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n0&#x3D;n2+1</span><br><span class="line">n2&#x3D;1000</span><br><span class="line"></span><br><span class="line">n0&#x3D;1001</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1001</span><br></pre></td></tr></table></figure><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote><p>对于整数 v 和 p，定义 Pierce 序列为：<br>　　a[1] = v<br>　　a[i] = p % a[i-1]<br>　　例如，当 v = 8, p = 21 时，对应的 Pierce 序列为<br>　　a[1] = 8<br>　　a[2] = 5<br>　　a[3] = 1<br>　　再往后计算，值变为 0，不在我们考虑的范围内。因此当 v = 8, p = 21 时， Pierce 序列的长度为 3。<br>　　当 p 一定时，对于不同的 v 值，Pierce 序列的长度可能不同。<br>　　当 p=2021 时，最长的 Pierce 序列出现在 v=1160 时，请问这个序列有多长？</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v=<span class="number">1160</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">1</span>,p=<span class="number">2021</span>;</span><br><span class="line">        <span class="keyword">while</span>(v!=<span class="number">1</span>)&#123;</span><br><span class="line">            v = p%v;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote><p>在 Excel 中，第 1 列到第 26 列的列名依次为 A 到 Z，从第 27 列开始，列名有两个字母组成，第 27 列到第 702 列的列名依次为 AA 到 ZZ。之后的列再用 3 个字母、4 个字母表示。<br>请问，第 2021 列的列名是什么？</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">2021</span>;</span><br><span class="line">        <span class="keyword">int</span> i=p/(<span class="number">26</span>*<span class="number">26</span>);</span><br><span class="line">        <span class="keyword">int</span> j=(p%(<span class="number">26</span>*<span class="number">26</span>))/<span class="number">26</span>;</span><br><span class="line">        <span class="keyword">int</span> k=p-i*<span class="number">26</span>*<span class="number">26</span>-j*<span class="number">26</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>) (<span class="string">&#x27;A&#x27;</span> + i - <span class="number">1</span>) + <span class="string">&quot;&quot;</span> + (<span class="keyword">char</span>) (<span class="string">&#x27;A&#x27;</span> + j - <span class="number">1</span>) + <span class="string">&quot;&quot;</span> + (<span class="keyword">char</span>) (<span class="string">&#x27;A&#x27;</span> + k - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>) (<span class="string">&#x27;A&#x27;</span> + j - <span class="number">1</span>) + <span class="string">&quot;&quot;</span> + (<span class="keyword">char</span>) (<span class="string">&#x27;A&#x27;</span> + k - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>) ((<span class="keyword">char</span>) (<span class="string">&#x27;A&#x27;</span> + k - <span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BYS</span><br></pre></td></tr></table></figure><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote><p>【问题描述】<br>斐波那契数列是这样一个数列：它的第一项和第二项都是1，从第三项开始每一项都是前两项的和。<br>根据以上定义，我们容易计算出斐波那契数列的前几项依次是：1, 1, 2, 3, 5, 8, 13, 21, 34, 55 ……<br>现在请你计算斐波那契数列第N项是奇数还是偶数？</p><p>【输入格式】<br>输入的包含一个整数N。</p><p>【输出格式】<br>如果是奇数输出1，是偶数输出0。</p><p>【样例输入】<br>10</p><p>【样例输出】<br>1</p><p>【提示】<br>找规律。</p><p>【评测用例规模与约定】<br>对于所有评测用例，1 &lt;= N &lt;= 1000000000。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="keyword">new</span> Scanner(System.in).nextInt();</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><blockquote><p>【问题描述】<br>在书写一个较大的整数时，为了方便看清数位，通常会在数位之间加上逗号来分割数位，具体的，从右向左，每三位分成一段，相邻的段之间加一个逗号。<br>例如，1234567 写成 1,234,567。<br>例如，17179869184 写成 17,179,869,184。<br>给定一个整数，请将这个整数增加分割符后输出。</p><p>【输入格式】<br>输入一行包含一个整数 v。</p><p>【输出格式】<br>输出增加分割符后的整数。</p><p>【样例输入】<br>1234567</p><p>【样例输出】<br>1,234,567</p><p>【样例输入】<br>17179869184</p><p>【样例输出】<br>17,179,869,184</p><p>【评测用例规模与约定】<br>对于 50% 的评测用例，0 &lt;= v &lt; 10^9 (10的9次方)。<br>对于所有评测用例，0 &lt;= v &lt; 10^18 (10的18次方)。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String temp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">char</span>[] arr=<span class="keyword">new</span> Scanner(System.in).next().toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] tempArr=<span class="keyword">new</span> <span class="keyword">char</span>[arr.length*<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=arr.length;i++)&#123;</span><br><span class="line">            temp += arr[arr.length-i];</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span> &amp;&amp; i!=arr.length)&#123;</span><br><span class="line">                temp += <span class="string">&quot;,&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tempArr = temp.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= tempArr.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            System.out.print(tempArr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><blockquote><p>【问题描述】<br>给定一个矩阵 M，由 n 行 m 列组成，第 i 行第 j 列值为 M[i][j]。<br>定义矩阵 M 的重量为矩阵中所有元素的和，几位weight(M)<br>请找到矩阵左上角的一个子矩阵S（矩阵的前 r 行中的前 c 列组成），使得这个子矩阵的重量的两倍最接近矩阵 M 重量。即 |2 weight(S)-weight(M)| 最小。<br>如果有多个子矩阵满足条件，请找出面积 r * c 最小的一个。<br>如果仍然有多个子矩阵满足条件，请找出其中 r 最小的一个。</p><p>【输入格式】<br>输入第一行包含两个整数 n, m，表示矩阵的大小。<br>接下来 n 行，每行 m 个整数，表示给定的矩阵M。</p><p>【输出格式】<br>输出一行，包含两个整数 r, c，表示子矩阵为矩阵 M 的前 r 行中的前 c 列。</p><p>【样例输入】<br>3 4<br>3 0 1 1<br>1 0 1 1<br>1 1 -2 4</p><p>【样例输出】<br>2 3</p><p>【评测用例规模与约定】<br>对于 30% 的评测用例，1 &lt;= n, m &lt;= 20, -10 &lt;= M[i][j] &lt;= 10。<br>对于 50% 的评测用例，1 &lt;= n, m &lt;= 100, -100 &lt;= M[i][j] &lt;= 100。<br>对于所有评测用例，1 &lt;= n, m &lt;= 1000, -1000 &lt;= M[i][j] &lt;= 1000。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">        <span class="keyword">int</span> m = input.nextInt();</span><br><span class="line">        <span class="keyword">int</span> weight=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span> [n*m];</span><br><span class="line">        <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span> [n*m];</span><br><span class="line">        <span class="comment">//权值</span></span><br><span class="line">        <span class="keyword">int</span> arr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="comment">//权值和</span></span><br><span class="line">        <span class="keyword">int</span> weightArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="comment">//差值</span></span><br><span class="line">        <span class="keyword">int</span> diffArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                arr[i][j] = input.nextInt();</span><br><span class="line">                weight += arr[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        weight /= <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//遍历计算第一行的权值和</span></span><br><span class="line">        <span class="keyword">int</span> tempWeight=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            tempWeight += arr[i][<span class="number">0</span>];</span><br><span class="line">            weightArr[i][<span class="number">0</span>] = tempWeight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历计算第一列的权值和</span></span><br><span class="line">        tempWeight=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            tempWeight += arr[<span class="number">0</span>][j];</span><br><span class="line">            weightArr[<span class="number">0</span>][j] = tempWeight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出计算所有项对应的权值和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">                weightArr[i][j] = arr[i][j] + weightArr[i-<span class="number">1</span>][j] + weightArr[i][j-<span class="number">1</span>] - weightArr[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找出最小差值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                diffArr[i][j] = Math.abs(weightArr[i][j]-weight);</span><br><span class="line">                <span class="keyword">if</span>(diffArr[i][j]&lt;min)&#123;</span><br><span class="line">                    min = diffArr[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(min);</span><br><span class="line">        <span class="comment">//统计最小值的个数cnt，并将下标记录在数组r[]c[]</span></span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(diffArr[i][j]==min)&#123;</span><br><span class="line">                    r[cnt]=i;</span><br><span class="line">                    c[cnt]=j;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//差值唯一</span></span><br><span class="line">        <span class="keyword">int</span>[] diffRC = <span class="keyword">new</span> <span class="keyword">int</span>[cnt];</span><br><span class="line">        <span class="keyword">int</span> minRC = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(cnt==<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="string">&quot;A:&quot;</span>+r[<span class="number">0</span>]+<span class="number">1</span>)+<span class="string">&quot; &quot;</span>+(c[<span class="number">0</span>]+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有多个相等的差值，判断r*c</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">                diffRC[i] = (r[i]+<span class="number">1</span>)*(c[i]+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(diffRC[i]&lt;minRC)&#123;</span><br><span class="line">                    minRC=diffRC[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计最小的R*C，个数cntRC</span></span><br><span class="line">        <span class="keyword">int</span> cntRC=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] diffR = <span class="keyword">new</span> <span class="keyword">int</span>[cnt];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(diffRC[i]==minRC)&#123;</span><br><span class="line">                diffR[cntRC]=i;</span><br><span class="line">                System.out.println(<span class="string">&quot;diffR[cntRC]：&quot;</span>+(r[diffR[cntRC]]+<span class="number">1</span>)+<span class="string">&quot; &quot;</span>+(c[diffR[cntRC]]+<span class="number">1</span>));</span><br><span class="line">                System.out.println(minRC);</span><br><span class="line">                cntRC++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;cntRC:&quot;</span>+cntRC);</span><br><span class="line">        <span class="keyword">int</span> minR = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> minRi = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//只有一个最小的R*C</span></span><br><span class="line">        <span class="keyword">if</span>(cntRC==<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="string">&quot;B:&quot;</span>+r[diffR[<span class="number">0</span>]]+<span class="number">1</span>)+<span class="string">&quot; &quot;</span>+(c[diffR[<span class="number">0</span>]]+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有多个最小的R*C，输出最小的R minR</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cntRC;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(r[diffR[i]]&lt;minR)&#123;</span><br><span class="line">                    minR=r[diffR[i]];</span><br><span class="line">                    minRi=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println((<span class="string">&quot;C:&quot;</span>+(r[diffR[minRi]]+<span class="number">1</span>))+<span class="string">&quot; &quot;</span>+(c[diffR[minRi]]+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">2 4 -2</span></span><br><span class="line"><span class="comment">6 0 2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">-----</span></span><br><span class="line"><span class="comment">12:6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2 6 4</span></span><br><span class="line"><span class="comment">8 12 12</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4 0 2</span></span><br><span class="line"><span class="comment">2 6 6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">3 0 1 1</span></span><br><span class="line"><span class="comment">1 0 1 1</span></span><br><span class="line"><span class="comment">1 1 -2 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">1 -1 1</span></span><br><span class="line"><span class="comment">-1 1 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><blockquote><p>【问题描述】<br>杂货铺老板一共有N件物品，每件物品具有ABC三种属性中的一种或多种。从杂货铺老板处购得一件物品需要支付相应的代价。<br>现在你需要计算出如何购买物品，可以使得ABC三种属性中的每一种都在至少一件购买的物品中出现，并且支付的总代价最小。</p><p>【输入格式】<br>输入第一行包含一个整数N。<br>以下N行，每行包含一个整数C和一个只包含”ABC”的字符串，代表购得该物品的代价和其具有的属性。</p><p>【输出格式】<br>输出一个整数，代表最小的代价。如果无论如何凑不齐ABC三种属性，输出-1。</p><p>【样例输入】<br>5<br>10 A<br>9 BC<br>11 CA<br>4 A<br>5 B</p><p>【样例输出】<br>13</p><p>【评测用例规模与约定】<br>对于50%的评测用例，1 &lt;= N &lt;= 20<br>对于所有评测用例，1 &lt;= N &lt;= 1000， 1 &lt;= C &lt;= 100000</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main91</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n=input.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] flag = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        Arrays.fill(flag,Integer.MAX_VALUE);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> w = input.nextInt();</span><br><span class="line">            v=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">char</span>[] str = input.next().toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;str.length;j++)&#123;</span><br><span class="line">                v |= <span class="number">1</span>&lt;&lt;(str[j]-<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;flag.length;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((k&amp;v)!=v &amp;&amp; flag[k]!=Integer.MAX_VALUE &amp;&amp; w+flag[k]&lt;flag[k|v])&#123;</span><br><span class="line">                    flag[k|v] = w+flag[k];</span><br><span class="line">                &#125;</span><br><span class="line">                flag[v]=Math.min(flag[v],w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(flag[<span class="number">7</span>]==Integer.MAX_VALUE?-<span class="number">1</span>:flag[<span class="number">7</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="J"><a href="#J" class="headerlink" title="J"></a>J</h2><blockquote><p>记不清了，之后补吧。<br>大意是：<br>输入一个n*m的数组，求出每个元素与它周围一圈的元素中最大的元素，输出数组</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 当时考试没想到，就“硬”写出来的暴力，不推荐</span></span><br><span class="line"><span class="comment"> * 更好的方法是读入矩阵并将其放置在比它大一圈的数组中，保持数据在中央，边缘置为</span></span><br><span class="line"><span class="comment"> * 这样就不用考虑4、6个的情况，只需要比较9个数的函数就可以</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">        <span class="keyword">int</span> m = input.nextInt();</span><br><span class="line">        <span class="keyword">int</span> arr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="keyword">int</span> res[][] = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                arr[i][j] = input.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>) &#123;</span><br><span class="line">        res[<span class="number">0</span>][i]=max4(arr[<span class="number">0</span>][<span class="number">0</span>],arr[<span class="number">0</span>][<span class="number">1</span>],arr[<span class="number">1</span>][<span class="number">0</span>],arr[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i==m-<span class="number">1</span>) &#123;</span><br><span class="line">        res[<span class="number">0</span>][i]=max4(arr[<span class="number">0</span>][m-<span class="number">1</span>],arr[<span class="number">0</span>][m-<span class="number">2</span>],arr[<span class="number">1</span>][m-<span class="number">1</span>],arr[<span class="number">1</span>][m-<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        res[<span class="number">0</span>][i]=max6(arr[<span class="number">0</span>][i-<span class="number">1</span>],arr[<span class="number">0</span>][i],arr[<span class="number">0</span>][i+<span class="number">1</span>],arr[<span class="number">1</span>][i-<span class="number">1</span>],arr[<span class="number">1</span>][i],arr[<span class="number">1</span>][i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>) &#123;</span><br><span class="line">        res[n-<span class="number">1</span>][i]=max4(arr[n-<span class="number">1</span>][<span class="number">0</span>],arr[n-<span class="number">1</span>][<span class="number">1</span>],arr[n-<span class="number">2</span>][<span class="number">0</span>],arr[n-<span class="number">2</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i==m-<span class="number">1</span>) &#123;</span><br><span class="line">        res[n-<span class="number">1</span>][i]=max4(arr[n-<span class="number">1</span>][m-<span class="number">1</span>],arr[n-<span class="number">1</span>][m-<span class="number">2</span>],arr[n-<span class="number">2</span>][m-<span class="number">1</span>],arr[n-<span class="number">2</span>][m-<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        res[n-<span class="number">1</span>][i]=max6(arr[n-<span class="number">1</span>][i-<span class="number">1</span>],arr[n-<span class="number">1</span>][i],arr[n-<span class="number">1</span>][i+<span class="number">1</span>],arr[n-<span class="number">2</span>][i-<span class="number">1</span>],arr[n-<span class="number">2</span>][i],arr[n-<span class="number">2</span>][i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n-<span class="number">1</span>;i++) &#123;</span><br><span class="line">        res[i][<span class="number">0</span>]=max6(arr[i-<span class="number">1</span>][<span class="number">0</span>],arr[i][<span class="number">0</span>],arr[i+<span class="number">1</span>][<span class="number">0</span>],arr[i-<span class="number">1</span>][<span class="number">1</span>],arr[i][<span class="number">1</span>],arr[i+<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n-<span class="number">1</span>;i++) &#123;</span><br><span class="line">        res[i][m-<span class="number">1</span>]=max6(arr[i-<span class="number">1</span>][m-<span class="number">1</span>],arr[i][m-<span class="number">1</span>],arr[i+<span class="number">1</span>][m-<span class="number">1</span>],arr[i-<span class="number">1</span>][m-<span class="number">2</span>],arr[i][m-<span class="number">2</span>],arr[i+<span class="number">1</span>][m-<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//中间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n-<span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m-<span class="number">1</span>;j++) &#123;</span><br><span class="line">        res[i][j]=max9(arr[i-<span class="number">1</span>][j-<span class="number">1</span>],arr[i-<span class="number">1</span>][j],arr[i-<span class="number">1</span>][j+<span class="number">1</span>],arr[i][j-<span class="number">1</span>],arr[i][j],arr[i][j+<span class="number">1</span>],arr[i+<span class="number">1</span>][j-<span class="number">1</span>],arr[i+<span class="number">1</span>][j],arr[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==m-<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print(res[i][j]);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.print(res[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max4</span><span class="params">(<span class="keyword">int</span> a0,<span class="keyword">int</span> a1,<span class="keyword">int</span> a2,<span class="keyword">int</span> a3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">    a[<span class="number">0</span>] = a0;</span><br><span class="line">    a[<span class="number">1</span>] = a1;</span><br><span class="line">    a[<span class="number">2</span>] = a2;</span><br><span class="line">    a[<span class="number">3</span>] = a3;</span><br><span class="line">    <span class="keyword">int</span> temp = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]&gt;temp) &#123;</span><br><span class="line">    temp = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max6</span><span class="params">(<span class="keyword">int</span> a0,<span class="keyword">int</span> a1,<span class="keyword">int</span> a2,<span class="keyword">int</span> a3,<span class="keyword">int</span> a4,<span class="keyword">int</span> a5)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>];</span><br><span class="line">    a[<span class="number">0</span>] = a0;</span><br><span class="line">    a[<span class="number">1</span>] = a1;</span><br><span class="line">    a[<span class="number">2</span>] = a2;</span><br><span class="line">    a[<span class="number">3</span>] = a3;</span><br><span class="line">    a[<span class="number">4</span>] = a4;</span><br><span class="line">    a[<span class="number">5</span>] = a5;</span><br><span class="line">    <span class="keyword">int</span> temp = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]&gt;temp) &#123;</span><br><span class="line">    temp = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max9</span><span class="params">(<span class="keyword">int</span> a0,<span class="keyword">int</span> a1,<span class="keyword">int</span> a2,<span class="keyword">int</span> a3,<span class="keyword">int</span> a4,<span class="keyword">int</span> a5,<span class="keyword">int</span> a6,<span class="keyword">int</span> a7,<span class="keyword">int</span> a8)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>];</span><br><span class="line">    a[<span class="number">0</span>] = a0;</span><br><span class="line">    a[<span class="number">1</span>] = a1;</span><br><span class="line">    a[<span class="number">2</span>] = a2;</span><br><span class="line">    a[<span class="number">3</span>] = a3;</span><br><span class="line">    a[<span class="number">4</span>] = a4;</span><br><span class="line">    a[<span class="number">5</span>] = a5;</span><br><span class="line">    a[<span class="number">6</span>] = a6;</span><br><span class="line">    a[<span class="number">7</span>] = a7;</span><br><span class="line">    a[<span class="number">8</span>] = a8;</span><br><span class="line">    <span class="keyword">int</span> temp = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]&gt;temp) &#123;</span><br><span class="line">    temp = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="K"><a href="#K" class="headerlink" title="K"></a>K</h2><blockquote><p>给定一个序列 (a_1, a_2, …, a_n), 它的一个上升子序列是指从序列中取出一些元素，按照原来的顺序排列后，是单调递增的序列。<br> 例如，对于序列 (3, 2, 7, 6, 7)，取出下标为 2, 4, 5 的元素 a_2, a_4, a_5，即 2, 6, 7，是一个上升子序列。<br> 在这个序列中，有 7 个长度为 2 的上升子序列，例如</p><p>   下标 1, 3 对应的 3, 7；<br>　　1. 下标 1, 4 对应的 3, 6；<br>　　2. 下标 1, 5 对应的 3, 7；<br>　　3. 下标 2, 3 对应的 2, 7；<br>　　4. 下标 2, 4 对应的 2, 6；<br>　　5. 下标 2, 5 对应的 2, 7；<br>　　6. 下标 4, 5 对应的 6, 7。<br>注意，可能有下标不同但对应数值相同的上升子序列，他们应当算成不同的上升子序列。<br>　　给定序列，请问序列中一共有多少个长度为 k 的上升子序列。<br>输入格式<br>　　输入第一行包含两个整数 n, k，表示序列的长度和上升子序列的长度。<br>　　第二行包含 n 个整数 a_1, a_2, …, a_n，表示给定的序列。<br>输出格式<br>　　输出一行，包含一个整数，表示长度为 k 的上升子序列的数量，答案可能很大，请输出答案除以 1000007 的余数。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> res;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = input.nextInt();</span><br><span class="line">        k = input.nextInt();</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            arr[i] = input.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        res = DFS(i,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res%<span class="number">1000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> kk)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(kk==k) &#123;</span><br><span class="line">    res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[j]&gt;arr[i]) &#123;</span><br><span class="line">        res++;</span><br><span class="line">        DFS(j,kk+<span class="number">1</span>);</span><br><span class="line">        res--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符转换"><a href="#字符转换" class="headerlink" title="字符转换"></a>字符转换</h1><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>String -&gt; char</td><td>toCharArray();<br>charAt();</td></tr><tr><td>char -&gt; String</td><td>String.valueOf(‘’);<br>“”+’’</td></tr><tr><td>String -&gt; int</td><td>int=Integer.parseInt(“”);<br>int=Integer.valueOf(“”).intValue();</td></tr><tr><td>int -&gt; String</td><td>String.valueOf()；<br>Integer.toString()；<br>String=””+int;</td></tr><tr><td>char -&gt; int(ascii)</td><td>int=char;</td></tr><tr><td>int(ascii) -&gt; char</td><td>char=(char)int;</td></tr><tr><td>char -&gt; int</td><td>int=’’-‘0’;</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;第十一届蓝桥杯大赛软件类省赛Java大学B组第一场 &amp;amp; 第一次校内模拟  &amp;amp; 第三次校内模拟&lt;br&gt;详解及总结&lt;/p&gt;</summary>
    
    
    
    <category term="Study" scheme="https://memorykk.cn/categories/Study/"/>
    
    
    <category term="lanqiao" scheme="https://memorykk.cn/tags/lanqiao/"/>
    
  </entry>
  
  <entry>
    <title>《鸟哥的Linux私房菜》第0-3章</title>
    <link href="https://memorykk.cn/linux-vbird-0-3.html"/>
    <id>https://memorykk.cn/linux-vbird-0-3.html</id>
    <published>2021-02-20T06:08:11.000Z</published>
    <updated>2021-03-11T14:58:40.926Z</updated>
    
    <content type="html"><![CDATA[<p>基础篇第 0-3 章学习笔记</p><span id="more"></span><hr><p><strong>目录</strong></p><ul><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%AE%BA">计算机概论</a><ul><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6">计算机硬件</a></li><li><a href="#CPU">CPU</a></li><li><a href="#%E5%86%85%E5%AD%98">内存</a></li><li><a href="#%E6%98%BE%E5%8D%A1">显卡</a></li><li><a href="#%E7%A1%AC%E7%9B%98%E4%B8%8E%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87">硬盘与存储设备</a></li><li><a href="#PCI%E9%80%82%E9%85%8D%E5%8D%A1">PCI 适配卡</a></li><li><a href="#%E4%B8%BB%E6%9D%BF">主板</a></li><li><a href="#%E7%94%B5%E6%BA%90">电源</a></li><li><a href="#%E6%96%87%E5%AD%97%E7%BC%96%E7%A0%81%E7%B3%BB%E7%BB%9F">文字编码系统</a></li><li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a></li><li><a href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">应用程序</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></li><li><a href="#Linux%E6%98%AF%E4%BB%80%E4%B9%88">Linux是什么</a><ul><li><a href="#%E5%8E%86%E5%8F%B2">历史</a></li><li><a href="#Linux%E7%9A%84%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC">Linux的内核版本</a></li><li><a href="#Linux-distribution">Linux distribution</a></li><li><a href="#Linux%E7%9A%84%E7%89%B9%E8%89%B2">Linux的特色</a></li></ul></li><li><a href="#%E4%B8%BB%E6%9C%BA%E8%A7%84%E5%88%92%E4%B8%8E%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA">主机规划与磁盘分区</a><ul><li><a href="#%E7%A3%81%E7%9B%98%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E5%90%8D%E7%9A%84%E5%85%B3%E7%B3%BB">磁盘连接的方式与设备文件名的关系</a><ul><li><a href="#IDE%E8%AE%BE%E5%A4%87">IDE设备</a></li><li><a href="#SATA%E8%AE%BE%E5%A4%87">SATA设备</a></li></ul></li><li><a href="#%E7%A3%81%E7%9B%98%E7%9A%84%E7%BB%84%E6%88%90">磁盘的组成</a></li><li><a href="#%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E8%A1%A8">磁盘分区表</a></li><li><a href="#%E5%BC%80%E6%9C%BA%E6%B5%81%E7%A8%8B%E4%B8%8E%E4%B8%BB%E5%BC%95%E5%AF%BC%E5%88%86%E5%8C%BAMBR">开机流程与主引导分区MBR</a><ul><li><a href="#%E5%BC%80%E6%9C%BA%E6%B5%81%E7%A8%8B">开机流程</a></li><li><a href="#BootLoader%E7%9A%84%E5%8A%9F%E8%83%BD">BootLoader的功能</a></li></ul></li><li><a href="#%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E7%9A%84%E9%80%89%E6%8B%A9">磁盘分区的选择</a></li><li><a href="#%E4%B8%BB%E6%9C%BA%E7%A1%AC%E7%9B%98%E7%9A%84%E4%B8%BB%E8%A6%81%E8%A7%84%E5%88%92">主机硬盘的主要规划</a></li></ul></li><li><a href="#%E5%AE%89%E8%A3%85CentOS-5-x%E4%B8%8E%E5%A4%9A%E9%87%8D%E5%BC%95%E5%AF%BC">安装CentOS 5.x与多重引导</a><ul><li><a href="#%E5%AE%89%E8%A3%85%E8%A7%84%E5%88%92">安装规划</a></li><li><a href="#%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4">安装步骤</a></li></ul></li></ul><hr><h1 id="计算机概论"><a href="#计算机概论" class="headerlink" title="计算机概论"></a>计算机概论</h1><h2 id="计算机硬件"><a href="#计算机硬件" class="headerlink" title="计算机硬件"></a>计算机硬件</h2><p><img src="/images/linux-vbird-0-3/computer.png" alt="computer.png"></p><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>CPU 的架构：</p><ul><li>精简指令集 RISC：单指令工作简单，执行快。arm</li><li>复杂指令集 CISC。单指令工作复杂，执行慢。intel(x86)、amd(x86_64)<br>1Byte=8bit</li></ul><p><img src="/images/linux-vbird-0-3/problem_memory.png" alt="problem_memory.png"></p><p>原本的单核 CPU 仅有一个运算单元,所谓的多核则是在一个 CPU 封装当中嵌入了两个以上的运算内核,简单地说,就是一个实际的 CPU 外壳中含有两个以上的 CPU 单元。<br>amd 内存与 cpu 直连，intel 内存通过北桥与 cpu 连接</p><p><strong>CPU 频率=外频*倍频</strong></p><ul><li>外频：cpu 与外部传输速率</li><li>倍频：cpu 内部运算的加速功能（出厂固定）</li></ul><p>超频：通过主板的设定功能更改成较高频率的一种方式。因为频率并非正常速度,故可能会造成死机等。</p><p>总线宽度：32/64<br>CPU 有向下兼容的能力</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>个人计算机的内存主要组件为动态随机访问内存 DRAM，挥发性</p><ul><li>SDRAM</li><li>DDR SDRAM：双倍数据传输速度 - DDR - DDRⅡ - DDRⅢ<br>双通道设计：两根 64 位总线宽度-&gt;128 位<br> CPU 外频=内存外频<br> 第二层缓存：常用的数据或程序放置在 CPU 内部，不在通过北桥从内存加载<br> DRAM 频率速度无法达到 L2=CPU 外频，因此使用静态随机访问内存 SRAM<br> <strong>只读存储器 ROM</strong><br>主板上组件参数存储在 CMOS 中，BIOS 是一套写死在 ROM 上的程序，非挥发性，系统开机时首先读取 BIOS；固件很多采用 ROM 进行软件写入；ROM 无法改写，因此 BIOS 通常写入 Flash Memory 或 EEPROM 中，以更新。</li></ul><h2 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h2><p>一般对于图形影像的显示重点在于分辨率与色彩深度，因为每个图像显示的颜色会占用内存，因此显卡上面会有一个内存的容量，这个显存容量将会影响到最终你的屏幕分辨率与色彩深度。越大越好。<br> 在显卡上嵌入 3D 加速芯片提升运算能力，即 GPU。<br> 北桥通信<br> 规格：AGP-&gt;PCI-&gt;PCIe</p><h2 id="硬盘与存储设备"><a href="#硬盘与存储设备" class="headerlink" title="硬盘与存储设备"></a>硬盘与存储设备</h2><p>硬盘：盘片、机械手臂、磁头、主轴马达。<br> 盘片上的数据：<br>磁盘上最小存储单位：扇区 512bytes；扇区组成圆：磁道；所有片上面的同一磁道：柱面（分割硬盘的最小单位）。<br>磁盘容量=header 数量<em>每个 header 负责的柱面数量</em>每个柱面所含有的扇区数量*扇区的容量<br>传输接口： - IDE 接口：连接两个设备，理论 133MB/s - SATA 接口：PC，一个设备，利于散热，理论 300MB/s</p><p>缓冲存储器：加速读取<br> 转速：主轴马达转动盘片<br> 运转：正常关机使机械手臂归回原位；避免移动主机使硬盘抖动</p><h2 id="PCI适配卡"><a href="#PCI适配卡" class="headerlink" title="PCI适配卡"></a>PCI适配卡</h2><p>用户额外的功能卡安插在 PCI 插槽上，很多组件（声卡、网卡）采用 PCI 接口传输，现多 PCIe</p><h2 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h2><p>主板上面负责通信各个组件的就是芯片组，芯片组一般分为北桥与南桥，需要散热。北桥负责 CPU/RAM/VGA 等的连接,南桥则负责 PCI 接口与速度较慢的 I/O 设备。<br> 芯片组：集成（显卡、网卡）型、独立型<br> I/O 地址：标识不同的设备；IRQ 中断信道：告知 CPU 该设备工作情况方便分配工作。sharing IRQ 技术。<br> CMOS 与 BIOS</p><h2 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h2><p>能源转换率<br> 接口</p><h2 id="文字编码系统"><a href="#文字编码系统" class="headerlink" title="文字编码系统"></a>文字编码系统</h2><p>英文：ASCII，一个字符占用 1B<br> 中文：big5（简体 gb2312），占用 2B<br> ISO/IEC 制订了 Unicode 编码系统，即 UTF8</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>内核、接口以及相关应用<br> 操作系统内核（kernel）：管理计算机的所有活动及驱动系统中的所有硬件，分配资源。内核所放置到内存中的区块受保护，开机后常驻内存。参考硬件规格，硬件不同则内核不同。<br> 系统调用（System Call）：一套开发接口，开发软件参考内核功能相关的开发接口。</p><p>内核功能：</p><ol><li>系统调用接口：与内核通信，软件开发</li><li>程序管理：多任务环境下有效分配资源</li><li>内存管理：虚拟内存功能提供在内存不足时的内存交换 swap</li><li>文件系统管理</li><li>设备驱动</li></ol><p>操作系统与驱动程序：OS 提供开发接口，让硬件开发商制作驱动，安装。</p><h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2><p>程序与 OS 有关系</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>计算机的定义为：”接受用户输入指令与数据，经由中央处理器的数据与逻辑单元运算处理后，以产生或存储成有用的信息“。<br> 计算机的五大单元包括输入单元、输出单元、CP∪ 内部的控制单元、算术逻辑单元与内存五大部分。<br> 数据会流进流出内存是 CPU 所发布的控制命令，而 CPU 实际要处理的数据则完全来自于内存。<br> CPU 依设计理念主要分为精简指令集(RSC)与复杂指令集(CSC)系统。<br> 关于 CPU 的频率部分，外频指的是 cPU 与外部组件进行数据传输时的速度,倍频则是 CPU 内部用来加速工作性能的一个倍数，两者相乘才是 cPU 的频率速度。<br> 一般主板芯片组分为北桥与南桥，北桥的总线称为系统总线,因为是内存传输的主要信道所以速度较快。南桥就是所谓的输入/输出(I/O)总线,主要在于连系硬盘、USB、网卡等接口设备。<br> 北桥所支持的频率我们称为前端总线速度( Front Side Bus,FSB),而每次传送的位数则是总线宽度。<br> CPU 每次能够处理的数据量称为字组大小( word size),字组大小依据 cPU 的设计而有 32 位与 64 位之分。我们现在所称的计算机是 32 或 64 位主要是依据这个 CPU 解析的字组大小而来的!<br> 个人计算机的内存主要组件为动态随机访问内存( Dynamic Random Access Memory,DRAM），至于 CPU 内部的第二层缓存则使用静态随机访问内存（Static Random Access Memory, SRAM）。<br> BIOS(Basic Input Output System)是一套程序,这套程序是写死到主板上面的一个内存芯片中,这个内存芯片在没有通电时也能够将数据记录下来,那就是只读存储器(Read Only Memory,ROM)。<br> 显卡的规格有 PCI/AGP/PCe,目前的主流为 Pcle 接口。<br> 硬盘是由盘片、机械手臂、磁头与主轴马达所组成的,其中盘片的组成为扇区、磁道与柱面。<br> 操作系统( Operating System,Os)其实也是一组程序,这组程序的重点在于管理计算机的所有活动以及驱动系统中的所有硬件。<br> 计算机主要以二进制作为单位,常用的磁盘容量单位为 Byte,其单位换算为 1Byte=8bt<br> 操作系统仅在于驱动与管理硬件,而要使用硬件时,就得需要通过应用软件或者是 she 的功能,来调用操作系统操纵硬件工作。目前,操作系统除了上述功能外,通常已经包含了日常工作所需要的应用软件在内了。</p><h1 id="Linux是什么"><a href="#Linux是什么" class="headerlink" title="Linux是什么"></a>Linux是什么</h1><p>Linux 是 OS 内核，包含内核及工具，沿袭 Unix，提供了一个完整的 OS 中最底层的硬件控制与资源管理的完整架构。</p><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><ul><li>Bell 实验室开发 Multics 分时系统无果，Ken Thompson 用汇编语言编写内核程序 Unics，之后为了移植，改用 C 语言编写内核发性 UNIX 正式版本，强调多用户多任务的兼容分时系统。后来 AT&amp;T 收回 UNIX 源码版权，谭宁邦自主编写 Minix，用于教学，公开源码，付费发行。</li><li>史托曼为了创建一个自由开放的 UNIX 操作系统，开始 GNU 项目，成立自由软件基金会 FSF，合作之下完成 GNU C Compiler，撰写通用公共许可证 GPL（CopyLeft），1991 年，芬兰大学生 Linus Torvalds 宣称 LInux 内核程序可以在 Intel 386 上运行。</li><li>GNU：发布软件的同时公布源码。</li><li>GNU GPL：GPL 代表具有自由度的软件，用户可以自由执行、复制、再发行、学习、修改与强化，但不能取消 GPL 授权，软件是自由的，但软件相关的“服务”是可以商业的。Open Source 的好处即修改程序代码去适合的工作环境。</li></ul><h2 id="Linux的内核版本"><a href="#Linux的内核版本" class="headerlink" title="Linux的内核版本"></a>Linux的内核版本</h2><p><strong>主版本.次版本.释出版本-修改版本</strong></p><ul><li>次版本为奇数：开发中版本，内核工程师使用；</li><li>次版本为偶数：稳定版本，家庭计算机以及企业版本。</li><li>释出版本：主次版本不变情况下，新增功能累积到一定程度之后释出。</li><li>Linux 内核版本与 distibution 版本并不相同</li></ul><h2 id="Linux-distribution"><a href="#Linux-distribution" class="headerlink" title="Linux distribution"></a>Linux distribution</h2><p>Linux 是 kernel，GNU GPL 授权模式，参考 POSIX 设计规范（POSIX 即可携式操作系统接口，重点在于规范内核与应用程序之间的接口），兼容 UNIX 操作系统，即 UNIX Like。</p><ul><li>为了让用户能够接触到 Linux，于是很多的商业公司或非营利团体就将 Kernel+ Softwares+ Tools 集成起来，加上自己具有创意的工具程序,这个工具程序可以让用户以光盘、DvD 或者通过网络直接安装管理 Lnux 系统。称为 dLinux distribution。</li></ul><p><img src="/images/linux-vbird-0-3/linux_distribution.png" alt="linux_distribution.png"></p><ul><li>Linux standard Base(LsSB)等标准来规范开发者,以及目录架构的 Fle system Hierarchy Standard(FHS)标准规范，它们的唯一差别可能就是该开发者自家所开发出来的管理工具以及套件管理的模式。所以说，基本上，每个 Linux distributions 除了架构的严谨度与选择的套件内容外，其实差异并不太大，最大的差异在于软件的安装模式。</li><li>团队版适合个人（更新快），商业版适合服务器（稳定）。</li><li>事实上鸟哥认为 distributions 主要分为两大系统，一种是使用 RPM 方式安装软件的系统,包括 Red Hat， Fedora，SusE，Centos 等都是这类；一种则是使用 Debian 的 dpkg 方式安装软件的系统，包括 Debian，Ubuntu，B2D 等。</li></ul><h2 id="Linux的特色"><a href="#Linux的特色" class="headerlink" title="Linux的特色"></a>Linux的特色</h2><ul><li>稳定的系统</li><li>免费或少许费用</li><li>安全性、漏洞的快速修补</li><li>多任务、多用户</li><li>用户、用户组</li><li>相对不耗资源</li><li>需要小内核的嵌入式系统</li><li>整合度佳且多样的用户界面（GUI）</li></ul><h1 id="主机规划与磁盘分区"><a href="#主机规划与磁盘分区" class="headerlink" title="主机规划与磁盘分区"></a>主机规划与磁盘分区</h1><p>各个硬件设备在 linux 中当成一个文件来对待，几乎所有的硬件设备文件在/dev 目录里。<br>Windows 下不管有多少个 IDE 设备都是顺序地分配盘符，而在 Linux 下是认真区分对待每一个硬盘的。<br><em>（来自<a href="https://blog.csdn.net/weixin_32482133/article/details/112946362">https://blog.csdn.net/weixin_32482133/article/details/112946362</a>）</em></p><h2 id="磁盘连接的方式与设备文件名的关系"><a href="#磁盘连接的方式与设备文件名的关系" class="headerlink" title="磁盘连接的方式与设备文件名的关系"></a>磁盘连接的方式与设备文件名的关系</h2><table><thead><tr><th>接口</th><th>命名</th></tr></thead><tbody><tr><td>IDE 设备</td><td>/dev/hd[a-d]</td></tr><tr><td>SCSI/SATA/USB 硬盘</td><td>/dev/sd[a-p]</td></tr></tbody></table><h3 id="IDE设备"><a href="#IDE设备" class="headerlink" title="IDE设备"></a>IDE设备</h3><p>一个 IDE 扁平线缆可以连接两个 IDE 设备，通常主机会提供两个接口 IDE1（primary）和 IDE2（secondary），故可以连接四个 IDE 设备，每个扁平线缆上的 IDE 设备分为 Master/Slave。</p><table><thead><tr><th>IDE</th><th>Master</th><th>Slave</th></tr></thead><tbody><tr><td>IDE1（primary）</td><td>/dev/hda</td><td>/dev/hdb</td></tr><tr><td>IDE2（secondary）</td><td>/dev/hdc</td><td>/dev/hdd</td></tr></tbody></table><h3 id="SATA设备"><a href="#SATA设备" class="headerlink" title="SATA设备"></a>SATA设备</h3><p>SATA/SCSI/USB 等磁盘接口使用 SCSI 模块驱动，使用/dev/sd[a-p]格式，SATA/USB 接口的磁盘根本没有顺序，文件名由 Linux 内核检测到磁盘的顺序排列。</p><h2 id="磁盘的组成"><a href="#磁盘的组成" class="headerlink" title="磁盘的组成"></a>磁盘的组成</h2><p>磁盘的第一个扇区（512bytes）记录重要信息：</p><ul><li>主引导分区 MBR（446bytes）：安装引导加载程序的地方。系统开机时主动读取，系统知道程序存放位置和如何开机。</li><li>分区表（64bytes）：记录整块硬盘分区的状态。硬盘必须切割才能使用。</li></ul><p><img src="/images/linux-vbird-0-3/disk_constitute.png" alt="disk_constitute.png"></p><h2 id="磁盘分区表"><a href="#磁盘分区表" class="headerlink" title="磁盘分区表"></a>磁盘分区表</h2><p>分区的最小单位是柱面，参考柱面号码切割硬盘，在分区表所在的 64bytes 容量中，分为四组记录区，每组记录区记录了该区段的起始与结束的柱面号码。这四个分区称为主或扩展分区。</p><p><img src="/images/linux-vbird-0-3/disk_separate1.png" alt="disk_separate1.png"></p><p>系统写入磁盘时，一定会参考分区表。分区的目的：安全性与性能。<br>利用额外的（第一个扇区之外的）扇区记录更多的分区信息，扩展分区本身不能被格式化，主分区与逻辑分区可以。</p><p><img src="/images/linux-vbird-0-3/disk_separate2.png" alt="disk_separate2.png"></p><p>这五个由扩展分区切割的分区成为逻辑分区（5个），设备名从主分区保留之后开始。<br>    主分区+扩展分区≤4（硬盘限制）；<br>    扩展分区≤1（操作系统限制）。<br>    P主分区、E扩展分区、L逻辑分区。主分区和扩展分区之外的空间将被浪费。考虑到连续性，E分配在最后。分区&gt;4时，一定要有E。<br>    例如：在第二块SATA硬盘下分6个分区，有方法：</p><p><img src="/images/linux-vbird-0-3/disk_separate3.png" alt="disk_separate3.png"><br><img src="/images/linux-vbird-0-3/disk_separate4.png" alt="disk_separate4.png"></p><h2 id="开机流程与主引导分区MBR"><a href="#开机流程与主引导分区MBR" class="headerlink" title="开机流程与主引导分区MBR"></a>开机流程与主引导分区MBR</h2><h3 id="开机流程"><a href="#开机流程" class="headerlink" title="开机流程"></a>开机流程</h3><ol><li>BIOS：开机主动执行韧体 BIOS，寻找开机设备（根据用户设置的能开机的硬盘）</li><li>MBR：分析存储设备（如硬盘）第一个扇区的 MBR 位置，内置引导加载程序</li><li>引导加载程序 Boot Loader：加载内核</li><li>内核文件：OS 工作。</li></ol><p>BIOS 和 MBR 由硬件支持，BootLoader 由 OS 支持。</p><h3 id="BootLoader的功能"><a href="#BootLoader的功能" class="headerlink" title="BootLoader的功能"></a>BootLoader的功能</h3><ul><li><p>提供菜单：多重引导</p></li><li><p>载入内核：指向可开机的程序区段</p></li><li><p>转交其他 Loader（一个硬盘上包含多个系统，如双系统）</p><p>硬盘的每个分区都有自己的启动扇区，内核文件实际放置在各分区内，Loader 只认识自己分区的内核以及其他 Loader。</p></li></ul><p><img src="/images/linux-vbird-0-3/mbr.png" alt="mbr.png"></p><h2 id="磁盘分区的选择"><a href="#磁盘分区的选择" class="headerlink" title="磁盘分区的选择"></a>磁盘分区的选择</h2><p>Linux 所有数据以文件形态呈现，使用目录树结构，实际存放在磁盘分区中。</p><p>挂载：文件系统与目录树的关系</p><ul><li>将一个目录当作磁盘的入口，进入目录即可读取分区。即“挂载”与“挂载点”，最重要的根目录一定需要挂载到某分区。<br>（磁盘上有/file，挂载到/mnt 下，即访问路径/mnt/file）</li><li>安装 distribution，自定义安装 Custom 模式，建议仅区分主分区/和交换分区 swap（补充内存）。更详细的分区方案参考网络。</li></ul><h2 id="主机硬盘的主要规划"><a href="#主机硬盘的主要规划" class="headerlink" title="主机硬盘的主要规划"></a>主机硬盘的主要规划</h2><p>  主机硬盘的需求和主机开放的服务有关，还需要注意数据分类和安全。</p><p>  最简单的的分区方法<br>  / &amp; swap &amp; 未分区</p><p>  根据用途：</p><p>  容量大且读写频繁的目录：/ /usr /home /var swap<br>  大硬盘配合旧主机造成无法开机的问题<br>  旧主板找不到大容量磁盘，导致误判，但是 Linux 内核顺利开机后会重新检测硬盘而不例会 BIOS，所以 Linux 能够安装。<br>  但是安装完毕无法开机，BIOS 不能正确识别硬盘，开机错误。BIOS 只能读取前面的扇区，故将启动扇区所在分区规范在 ≤1024 个柱面以内。<br>  分区/boot &amp; / &amp; swap，/boot 100MB 左右，放在硬盘最前面。</p><h1 id="安装CentOS-5-x与多重引导"><a href="#安装CentOS-5-x与多重引导" class="headerlink" title="安装CentOS 5.x与多重引导"></a>安装CentOS 5.x与多重引导</h1><h2 id="安装规划"><a href="#安装规划" class="headerlink" title="安装规划"></a>安装规划</h2><ul><li>Linux主机的角色定位</li><li>选择distribution</li><li>计算机硬件配置</li><li>磁盘分区配置：/boot&amp;/&amp;/home&amp;swap  PPPL</li><li>引导装载程序BootLoader：安装到MBR</li><li>选择软件：默认/最小/全部/自定义</li></ul><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol><li>调整启动媒体(BIOS):使用Linux安装光盘，调整BIOS的开机启动顺序为光盘；（无法以DVD开机时很可能是由于计算机硬件不支持、光驱会挑片、光盘问题、硬件超频等）</li><li>选择安装结构与开机:包括图形界面命令行界面等，也可加入特殊参数（硬件检测、安装媒体、内存测试）来开机进入安装界面；</li><li>选择语系数据:由于不同地区的键盘按键不同，此时需要调整语系/键盘/鼠标等配置；</li><li>磁盘分区:最重要的项目之一。提前规划。</li></ol><p>四种分区结构：</p><ul><li>整块硬盘：删除所有分区并创建默认分区结构</li><li>Linux分区：删除Linux分区并创建默认分区</li><li>选定驱动器的空闲空间：未分区空间</li><li>建立自定义分区结构</li></ul><p>Linux支持的文件系统类型：<br><em>（二三版书上介绍有差别）</em><br>ext2/ext3：Linux使用的文件系统类型，ext3/ext4比ext2多日志记录，恢复系统较为迅速</p><ol start="5"><li>引导装载程序、网络、时区设置与root密码:一些需要的系统基础设置!</li><li>软件选择:需要什么样的软件?全部安装还是默认安装即可?</li><li>安装后的首次设置:安装完毕后还有一些事项要处理,包括用户、 SELinux与防火墙等</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;基础篇第 0-3 章学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="Study" scheme="https://memorykk.cn/categories/Study/"/>
    
    
    <category term="linux" scheme="https://memorykk.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>记一次使用Github登录Gitalk跳至首页的解决过程</title>
    <link href="https://memorykk.cn/gitalk-405.html"/>
    <id>https://memorykk.cn/gitalk-405.html</id>
    <published>2021-02-19T08:45:48.000Z</published>
    <updated>2021-02-19T11:41:54.450Z</updated>
    
    <content type="html"><![CDATA[<p>使用自定义域名之后的 Github page 在使用 Github 登录 Github 时跳转首页，无限循环</p><span id="more"></span><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>博客使用的是Hexo+Github+Gitalk，使用 Github 登录 Gitalk 之后跳转至首页，无限循环，地址栏URL显示为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;memorykk.cn&#x2F;?error&#x3D;redirect_uri_mismatch&amp;error_description&#x3D;The+redirect_uri+MUST+match+the+registered+callback+URL+for+this+application.&amp;error_uri&#x3D;https%3A%2F%2Fdocs.github.com%2Fapps%2Fmanaging-oauth-apps%2Ftroubleshooting-authorization-request-errors%2F%23redirect-uri-mismatch</span><br></pre></td></tr></table></figure><h1 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h1><p>为了更清楚地检查，将此 URL 中的 Unicode 转为中文：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;memorykk.cn&#x2F;?</span><br><span class="line">error&#x3D;redirect_uri_mismatch&amp;</span><br><span class="line">error_description&#x3D;The+redirect_uri+MUST+match+the+registered+callback+URL+for+this+application.&amp;</span><br><span class="line">error_uri&#x3D;https:&#x2F;&#x2F;docs.github.com&#x2F;apps&#x2F;managing-oauth-apps&#x2F;troubleshooting-authorization-request-errors&#x2F;#redirect-uri-mismatch</span><br></pre></td></tr></table></figure><p>根据描述，<kbd>redirect error</kbd> <kbd>registered callback URL</kbd>不匹配。</p><p>打开<kbd>F12</kbd>查看<kbd>Network</kbd>：</p><p><img src="/images/gitalk-405/reirect_uri.png" alt="reirect_uri.png"></p><p><kbd>this application</kbd>我使用的是<kbd>OAuth Apps</kbd>，查看其Authorization callback URL，果不其然：</p><p><img src="/images/gitalk-405/Auth_callback_URL.png" alt="Auth_callback_URL.png"></p><p><code>http</code>和<code>https</code>的差别还是很大的！修改Authorization callback URL为<code>https</code>之后成功了。</p><p>点击<kbd>使用GitHub登录</kbd>之后，又出现 405 问题，<br><img src="/images/gitalk-405/405.png" alt="405.png"><br>打开<kbd>F12</kbd>查看<kbd>Network</kbd>：<br><img src="/images/gitalk-405/url1.png" alt="url1.png"><br>转换为中文：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Request URL: https:&#x2F;&#x2F;memorykk.cn&#x2F;TeamSpeak&#x2F;%7B%7B%20theme.gitalk.proxy%20%7D%7D</span><br><span class="line"></span><br><span class="line">Request URL: https:&#x2F;&#x2F;memorykk.cn&#x2F;TeamSpeak&#x2F;&#123;&#123; theme.gitalk.proxy &#125;&#125;</span><br></pre></td></tr></table></figure><p>好家伙，这还是源代码形式啊，坑定是后台有什么问题！<br>检查<kbd>theme\layout\components\comment.ejs</kbd>，这行代码果然是从这里出来的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var gitalk &#x3D; new Gitalk(&#123;</span><br><span class="line">clientID: &#39;&lt;%&#x3D; theme.gitalk_client_id %&gt;&#39;,</span><br><span class="line">clientSecret: &#39;&lt;%&#x3D; theme.gitalk_client_secret %&gt;&#39;,</span><br><span class="line">repo: &#39;&lt;%&#x3D; theme.gitalk_repo %&gt;&#39;,</span><br><span class="line">owner: &#39;&lt;%&#x3D; theme.gitalk_owner %&gt;&#39;,</span><br><span class="line">admin: [&#39;&lt;%- theme.gitalk_admin.join(&quot;&#39;, &#39;&quot;) %&gt;&#39;],</span><br><span class="line">id: location.pathname,</span><br><span class="line">distractionFreeMode: false,</span><br><span class="line">createIssueManually: true,</span><br><span class="line">proxy: &#39;&#123;&#123; theme.gitalk.proxy &#125;&#125;&#39;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>之前对node.js也不了解（虽然现在也一样，允悲），没注意格式。仿照上面几行代码改成：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy: &#39;&lt;%&#x3D; theme.gitalk.proxy %&gt;&#39;,</span><br></pre></td></tr></table></figure><p>还是报 405 错误，打开<kbd>F12</kbd>查看：<br><img src="/images/gitalk-405/405_2.png" alt="405_2.png"></p><p>总感觉之前白嫖的 CorsAnywhere Proxy 链接压根没有传递过去，直接手动写死在里面：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy: &#39;https:&#x2F;&#x2F;netnr-proxy.cloudno.de&#x2F;https:&#x2F;&#x2F;github.com&#x2F;login&#x2F;oauth&#x2F;access_token&#39;,</span><br></pre></td></tr></table></figure><p>好家伙，成功了，ohhhhhhhhhhh，虽然这种做法极不优雅！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>网页出错先用<kbd>F12</kbd>看看哪部分的问题，顺藤摸瓜，缩小范围。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用自定义域名之后的 Github page 在使用 Github 登录 Github 时跳转首页，无限循环&lt;/p&gt;</summary>
    
    
    
    <category term="Log" scheme="https://memorykk.cn/categories/Log/"/>
    
    
    <category term="Gitalk" scheme="https://memorykk.cn/tags/Gitalk/"/>
    
  </entry>
  
  <entry>
    <title>TeamSpeak</title>
    <link href="https://memorykk.cn/TeamSpeak.html"/>
    <id>https://memorykk.cn/TeamSpeak.html</id>
    <published>2021-02-19T06:22:14.000Z</published>
    <updated>2021-03-18T14:51:03.417Z</updated>
    
    <content type="html"><![CDATA[<p>一个简易的TeamSpeak使用教程</p><span id="more"></span><p>更新于2021-02-19 14:22:14：<br>旧地址<del>memorykk.cn</del>已不可用，为了您后续的正常使用，请使用新地址<text style="color:white;background-color:red">ts.memorykk.cn</text></p><p><img src="/images/TeamSpeak/address.png" alt="address.png"></p><hr><p>更新于2020/5/22 15:30：</p><p>根据 @洛杉矶湖人名宿孙悦 ​的提醒，<text style="color:red">不推荐下载ts1.cn的盗版客户端，也不推荐俱乐部或者各位玩家租用ts1.cn的盗版服务器。</text>具体可<a href="https://bbs.hupu.com/32525047.html">查看原帖</a>，所以希望大家去官网下载正版软件，如果官网或github下载太慢，可以点正文中转存的链接，都是一样的。</p><hr><p>去年自己搭建了一个TeamSpeak服务器，闲着也是闲着，分享出来给大家使用，市面上的服务器要么收费、要么音质权限不给，本服务器免费共享，合法合规，不涉及隐私信息等，请放心使用！</p><h1 id="什么是TeamSpeak"><a href="#什么是TeamSpeak" class="headerlink" title="什么是TeamSpeak"></a>什么是TeamSpeak</h1><blockquote><p>TeamSpeak (简称TS) 是一套专有的VoIP软件，使用者可以用耳机和麦克风，通过客户端软件连线到指定的服务器，与在服务器内频道的其他使用者进行通话。是一种很像电话会议的方式。 通常 TeamSpeak 的使用者大多为多人连线游戏的玩家，与同队伍的玩家进行通讯。在游戏的对战方面，语音对话通讯具有竞争优势。</p></blockquote><p>简言之，TeamSpeak是一款非常优秀的语音软件，类似于国内的YY语音、TT语音等，PUBG、CSGO等项目职业选手都在使用，在和小伙伴激情上分时，你该不会还在使用QQ微信电话吧？那么TS优点在哪里呢？有几点：</p><ul><li>界面简洁，没有广告，没有花里胡哨的付费内容；</li><li>极高的音乐级音质，超低的延迟；</li><li>独有的麦克风降噪、键盘声衰减、回声消除；</li><li>自动感应麦真的很好用。</li></ul><h1 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h1><ol><li>下载TeamSpeak客户端（最新版本为3.5.6）</li></ol><ul><li><a href="https://teamspeak.com/zh-CN/downloads/#client">官网下载</a></li><li>转存下载：（文件和官网一样，解决下载过慢问题）<ul><li><a href="https://wwa.lanzous.com/izgdukunldc">WINDOWS CLIENT 32-BIT 3.5.6</a></li><li><a href="https://wwa.lanzous.com/iQ78Wkun8ab">WINDOWS CLIENT 64-BIT 3.5.6</a></li><li><a href="https://memorykk.cn/src/TeamSpeak3-Client-macosx-3.5.6.dmg">MACOS CLIENT UNIVERSAL BINARY 3.5.6</a></li><li><a href="https://memorykk.cn/src/TeamSpeak3-Client-linux_x86-3.5.6.run">LINUX CLIENT 32-BIT 3.5.6</a></li><li><a href="https://memorykk.cn/src/TeamSpeak3-Client-linux_amd64-3.5.6.run">LINUX CLIENT 64-BIT 3.5.6</a></li></ul></li><li><a href="https://wwa.lanzous.com/icw5xgd">下载中文语音包&amp;语言包</a></li></ul><ol start="2"><li>安装客户端和中文包</li></ol><p>默认“下一步”就完事了，打开如下：</p><p><img src="/images/TeamSpeak/2-1.png" alt="2-1.png"><br><img src="/images/TeamSpeak/2-2.png" alt="2-2.png"></p><ol start="3"><li>注册登录你的TS账号（跳过这一步也可以）</li></ol><p>安装软件后会弹出来，没弹出来可以依次点击 <kbd>工具</kbd>-&gt;<kbd>选项</kbd>-&gt;<kbd>myTeamSpeak​</kbd> 继续操作。</p><p><img src="/images/TeamSpeak/3.png" alt="3.png"></p><ol start="4"><li>设置语音输入方式</li></ol><p>依次点击 <kbd>工具</kbd>-&gt;<kbd>选项</kbd>-&gt;<kbd>输入</kbd> 建议设置如下：</p><p><img src="/images/TeamSpeak/4.png" alt="4.png"></p><p>语音输入方式：</p><ul><li>Automatic：自动感应麦</li><li>Volume Gate：自定义麦克风的收音敏感度，点“开始测试”，比最高的分贝低一点就可以了</li><li>Hybrid：不懂，没用过</li></ul><ol start="5"><li>连接服务器</li></ol><p>依次点击左上角 <kbd>连接</kbd>-&gt;<kbd>连接</kbd>-&gt;输入服务器地址（<strong>ts.memorykk.cn</strong>）和昵称，无密码，直接点击连接，自动进入大厅。</p><p><img src="/images/TeamSpeak/5.png" alt="5.png"></p><ol start="6"><li>开房间</li></ol><p>空白处右键单击“创建频道”，设置房间名，有需要的可以设置密码，点击确定，房间开好了，双击房间名即可进入，这时候你就可以让你的小伙伴直接进入你的房间就完事了。</p><p><img src="/images/TeamSpeak/6-1.png" alt="6-1.png"><br><img src="/images/TeamSpeak/6-2.png" alt="6-2.png"></p><p><strong>注意</strong></p><ol><li>创建频道如果选择临时，当频道最后一人离开时，频道会自动消失。</li><li>可以设置频道音质，右键单击频道-&gt;声音-&gt;拖到质量条。</li><li>不推荐设置密码，方便大家组队。</li><li>频道可以设置图标，标注自己玩的游戏，有需要的下方留言哦。</li></ol><p>最后，有问题到下方留言或是查看<a href="https://memorykk.cn/about/">联系方式</a>，希望大家玩得开心。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个简易的TeamSpeak使用教程&lt;/p&gt;</summary>
    
    
    
    <category term="Tool" scheme="https://memorykk.cn/categories/Tool/"/>
    
    
    <category term="TeamSpeak" scheme="https://memorykk.cn/tags/TeamSpeak/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="https://memorykk.cn/Git.html"/>
    <id>https://memorykk.cn/Git.html</id>
    <published>2021-02-15T02:49:13.000Z</published>
    <updated>2021-03-30T07:35:12.130Z</updated>
    
    <content type="html"><![CDATA[<p>Git是目前世界上最先进的分布式版本控制系统（没有之一）。</p><span id="more"></span><hr><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#1-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6">1. 版本控制</a></li><li><a href="#2-%E5%AE%89%E8%A3%85GIT">2. 安装GIT</a><ul><li><a href="#2-1-LINUX">2.1. LINUX</a></li><li><a href="#2-2-LINUX">2.2. LINUX</a><ul><li><a href="#2-2-1-DEBIANUBUNTU">2.2.1. DEBIAN/UBUNTU</a></li><li><a href="#2-2-2-CENTOSREDHAT">2.2.2. CENTOS/REDHAT</a></li></ul></li><li><a href="#2-3-WINDOWS">2.3. WINDOWS</a></li></ul></li><li><a href="#3-%E9%85%8D%E7%BD%AEGIT">3. 配置GIT</a><ul><li><a href="#3-1-%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8CEMAIL">3.1. 配置用户名和EMAIL</a></li><li><a href="#3-2-%E5%A2%9E%E5%88%A0%E9%85%8D%E7%BD%AE%E9%A1%B9">3.2. 增删配置项</a><ul><li><a href="#3-2-1-%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE%E9%A1%B9">3.2.1. 添加配置项</a></li><li><a href="#3-2-2-%E5%88%A0%E9%99%A4%E9%85%8D%E7%BD%AE%E9%A1%B9">3.2.2. 删除配置项</a></li></ul></li><li><a href="#3-3-%E6%9B%B4%E5%A4%9A%E9%85%8D%E7%BD%AE%E9%A1%B9">3.3. 更多配置项</a></li></ul></li><li><a href="#4-GIT%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">4. GIT基本概念</a></li><li><a href="#5-GIT%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">5. GIT工作流程</a></li><li><a href="#6-GIT%E6%93%8D%E4%BD%9C">6. GIT操作</a><ul><li><a href="#6-1-GIT%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93">6.1. GIT创建版本库</a><ul><li><a href="#6-1-1-%E5%9C%A8%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%96">6.1.1. 在工作目录中初始化</a></li><li><a href="#6-1-2-%E4%BB%8E%E7%8E%B0%E6%9C%89%E4%BB%93%E5%BA%93%E5%85%8B%E9%9A%86">6.1.2. 从现有仓库克隆</a></li></ul></li><li><a href="#6-2-%E6%96%87%E4%BB%B6%E6%9B%B4%E6%96%B0">6.2. 文件更新</a><ul><li><a href="#6-2-1-%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81">6.2.1. 文件状态</a></li><li><a href="#6-2-2-%E6%A3%80%E6%9F%A5%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81">6.2.2. 检查文件状态</a></li><li><a href="#6-2-3-%E8%B7%9F%E8%B8%AA%E6%96%87%E4%BB%B6">6.2.3. 跟踪文件</a></li><li><a href="#6-2-4-%E6%9A%82%E5%AD%98%E5%B7%B2%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6">6.2.4. 暂存已修改文件</a></li><li><a href="#6-2-5-%E5%BF%BD%E7%95%A5%E6%9F%90%E4%BA%9B%E6%96%87%E4%BB%B6">6.2.5. 忽略某些文件</a></li><li><a href="#6-2-6-%E6%9F%A5%E7%9C%8B%E6%9C%AA%E6%9A%82%E5%AD%98%E7%9A%84%E6%9B%B4%E6%96%B0">6.2.6. 查看未暂存的更新</a></li><li><a href="#6-2-7-%E6%9F%A5%E7%9C%8B%E5%B7%B2%E6%9A%82%E5%AD%98%E7%9A%84%E6%9B%B4%E6%96%B0">6.2.7. 查看已暂存的更新</a></li><li><a href="#6-2-8-%E6%8F%90%E4%BA%A4%E6%9B%B4%E6%96%B0">6.2.8. 提交更新</a></li><li><a href="#6-2-9-%E8%B7%B3%E8%BF%87%E4%BD%BF%E7%94%A8%E6%9A%82%E5%AD%98%E5%8C%BA%E5%9F%9F">6.2.9. 跳过使用暂存区域</a></li><li><a href="#6-2-10-%E7%A7%BB%E9%99%A4%E6%96%87%E4%BB%B6">6.2.10. 移除文件</a></li><li><a href="#6-2-11-%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6">6.2.11. 移动文件</a></li></ul></li><li><a href="#6-3-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2">6.3. 查看提交历史</a><ul><li><a href="#6-3-1-%E9%99%90%E5%88%B6%E8%BE%93%E5%87%BA%E9%95%BF%E5%BA%A6">6.3.1. 限制输出长度</a></li><li><a href="#6-3-2-%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%B7%A5%E5%85%B7%E6%9F%A5%E9%98%85%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2">6.3.2. 使用图形化工具查阅提交历史</a></li></ul></li><li><a href="#6-4-%E6%92%A4%E9%94%80">6.4. 撤销</a><ul><li><a href="#6-4-1-%E4%BF%AE%E6%94%B9%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E6%8F%90%E4%BA%A4">6.4.1. 修改最后一次提交</a></li><li><a href="#6-4-2-%E5%8F%96%E6%B6%88%E5%B7%B2%E7%BB%8F%E6%9A%82%E5%AD%98%E7%9A%84%E6%96%87%E4%BB%B6">6.4.2. 取消已经暂存的文件</a></li><li><a href="#6-4-3-%E5%8F%96%E6%B6%88%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%AE%E6%94%B9">6.4.3. 取消对文件的修改</a></li><li><a href="#6-4-4-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93">6.4.4. 文件操作总结</a></li></ul></li></ul></li><li><a href="#7-GIT%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">7. GIT远程仓库</a><ul><li><a href="#7-1-%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">7.1. 查看远程仓库</a></li><li><a href="#7-2-%E6%B7%BB%E5%8A%A0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">7.2. 添加远程仓库</a></li><li><a href="#7-3-%E4%BB%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E6%8A%93%E5%8F%96%E6%95%B0%E6%8D%AE">7.3. 从远程仓库抓取数据</a></li><li><a href="#7-4-%E6%8E%A8%E9%80%81%E6%95%B0%E6%8D%AE%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">7.4. 推送数据到远程仓库</a></li><li><a href="#7-5-%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%BF%A1%E6%81%AF">7.5. 查看远程仓库信息</a></li><li><a href="#7-6-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E5%88%A0%E9%99%A4%E5%92%8C%E9%87%8D%E5%91%BD%E5%90%8D">7.6. 远程仓库的删除和重命名</a><ul><li><a href="#7-6-1-%E9%87%8D%E5%91%BD%E5%90%8D">7.6.1. 重命名</a></li><li><a href="#7-6-2-%E5%88%A0%E9%99%A4">7.6.2. 删除</a></li></ul></li></ul></li><li><a href="#8-%E7%89%88%E6%9C%AC%E6%A0%87%E7%AD%BE">8. 版本标签</a><ul><li><a href="#8-1-%E6%98%BE%E7%A4%BA%E5%B7%B2%E6%9C%89%E6%A0%87%E7%AD%BE">8.1. 显示已有标签</a></li><li><a href="#8-2-%E6%96%B0%E5%BB%BA%E6%A0%87%E7%AD%BE">8.2. 新建标签</a><ul><li><a href="#8-2-1-%E5%90%AB%E9%99%84%E6%B3%A8%E7%9A%84%E6%A0%87%E7%AD%BE">8.2.1. 含附注的标签</a></li><li><a href="#8-2-2-%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%A0%87%E7%AD%BE">8.2.2. 轻量级标签</a></li><li><a href="#8-2-3-%E7%AD%BE%E7%BD%B2%E6%A0%87%E7%AD%BE">8.2.3. 签署标签</a></li><li><a href="#8-2-4-%E9%AA%8C%E8%AF%81%E6%A0%87%E7%AD%BE">8.2.4. 验证标签</a></li></ul></li><li><a href="#8-3-%E5%90%8E%E6%9C%9F%E5%8A%A0%E6%B3%A8%E6%A0%87%E7%AD%BE">8.3. 后期加注标签</a></li><li><a href="#8-4-%E5%88%86%E4%BA%AB%E6%A0%87%E7%AD%BE">8.4. 分享标签</a></li></ul></li><li><a href="#9-GIT%E5%88%86%E6%94%AF">9. GIT分支</a><ul><li><a href="#9-1-%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B">9.1. 分支简介</a></li><li><a href="#9-2-%E6%96%B0%E5%BB%BA%E5%88%86%E6%94%AF">9.2. 新建分支</a></li><li><a href="#9-3-HEAD">9.3. HEAD</a></li><li><a href="#9-4-%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF">9.4. 切换分支</a></li><li><a href="#9-5-%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF">9.5. 合并分支</a></li><li><a href="#9-6-%E9%81%87%E5%88%B0%E5%86%B2%E7%AA%81%E6%97%B6%E7%9A%84%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6">9.6. 遇到冲突时的分支合并</a></li><li><a href="#9-7-%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF">9.7. 删除分支</a></li><li><a href="#9-8-%E6%A1%88%E4%BE%8B">9.8. 案例</a></li><li><a href="#9-9-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86">9.9. 分支管理</a></li><li><a href="#9-10-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">9.10. 远程分支</a></li><li><a href="#9-11-%E6%8E%A8%E9%80%81%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF">9.11. 推送本地分支</a></li><li><a href="#9-12-%E8%B7%9F%E8%B8%AA%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">9.12. 跟踪远程分支</a></li><li><a href="#9-13-%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">9.13. 删除远程分支</a></li><li><a href="#9-14-%E5%88%86%E6%94%AF%E8%A1%8D%E5%90%88">9.14. 分支衍合</a></li></ul></li><li><a href="#1-0-%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">10. 参考链接</a></li></ul><!-- /TOC --><hr><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。最初由 Linus Torvalds 为了帮助管理 Linux 内核开发而花了两周时间自己用C写出来的。（理那厮·掏袜子真的太绝了⊙ｏ⊙）</p><h1 id="1-版本控制"><a href="#1-版本控制" class="headerlink" title="1. 版本控制"></a>1. 版本控制</h1><p>版本控制系统分为本地式、集中式和分布式。</p><ul><li><p>本地式：适合个人使用，用于记录文件更新。代表：RCS</p><img src="/images/Git/local.png" class=""></li><li><p>集中式：必须联网，断网后可编辑无法commit和回滚。版本库都存在中央服务器上，用户的本地只有自己以前所同步的版本，没有完整的版本库。代表：SVN、CVS、VSS。<br>假设SVN服务器没了，那你丢掉了所有历史信息，因为你的本地只有当前版本以及部分历史信息。</p><img src="/images/Git/centralization.png" class=""></li><li><p>分布式：只有在push、pull时需要联网，断网后可正常commit。中央服务器只为了修改起来方便，可有可无，每个用户本地都是一个完整的版本库。代表：Git。<br>每个人都同时对同一版本修改，commit操作提交到本地，多人协作时需要push操作和别人同步，但是团队人数多会导致非常麻烦，所以出现所谓的（便于修改的）中央服务器。<br>假设GitHub服务器没了，你不会丢掉任何git历史信息，因为你的本地有完整的版本库信息，你可以把本地的git库重新上传到另外的git服务商。 </p><img src="/images/Git/distributed.png" class=""></li></ul><p><strong>Git的特点</strong></p><ul><li><p>直接记录快照，而非差异比较<br>Git 只关心文件数据的<strong>整体</strong>是否发生变化，而大多数其他系统则只关心文件内容的具体差异。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。有变化则保存，无则链接。</p></li><li><p>近乎所有操作都是本地执行</p></li><li><p>时刻保持数据完整性<br>保存在 Git 数据库中的东西都是用此哈希值来作索引的，而不是靠文件名。</p></li><li><p>多数操作仅添加数据</p></li></ul><h1 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2. 安装Git"></a>2. 安装Git</h1><h2 id="2-1-Linux"><a href="#2-1-Linux" class="headerlink" title="2.1. Linux"></a>2.1. Linux</h2><p>Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。<br><code>yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel</code><br>或<br><code>$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev</code><br>下载源码：<a href="http://git-scm.com/download">http://git-scm.com/download</a><br>编译安装<br><code>$ tar -zxf git-1.7.2.2.tar.gz</code><br><code>$ cd git-1.7.2.2</code><br><code>$ make prefix=/usr/local all</code><br><code>$ sudo make prefix=/usr/local install</code></p><h2 id="2-2-Linux"><a href="#2-2-Linux" class="headerlink" title="2.2. Linux"></a>2.2. Linux</h2><h3 id="2-2-1-Debian-Ubuntu"><a href="#2-2-1-Debian-Ubuntu" class="headerlink" title="2.2.1. Debian/Ubuntu"></a>2.2.1. Debian/Ubuntu</h3><p><code>$ sudo apt-get install git</code></p><h3 id="2-2-2-Centos-RedHat"><a href="#2-2-2-Centos-RedHat" class="headerlink" title="2.2.2. Centos/RedHat"></a>2.2.2. Centos/RedHat</h3><p><code>$ yum install git-core</code></p><h2 id="2-3-Windows"><a href="#2-3-Windows" class="headerlink" title="2.3. Windows"></a>2.3. Windows</h2><p><a href="https://git-scm.com/downloads">官网下载</a><br><a href="https://npm.taobao.org/mirrors/git-for-windows/">镜像下载</a><br>默认安装。</p><img src="/images/Git/winGit.PNG" class=""><ul><li><kbd>Git Bash</kbd>：Unix与Linux风格的命令行（<strong>推荐</strong>）</li><li><kbd>Git CMD</kbd>：DOS风格的命令</li><li><kbd>Git GUI</kbd>：图形界面（<strong>新手不推荐</strong>）  </li></ul><p>打开<kbd>Git Bash</kbd>检查一下：  </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git --version</span></span><br><span class="line">git version 2.29.2.windows.2</span><br></pre></td></tr></table></figure><h1 id="3-配置Git"><a href="#3-配置Git" class="headerlink" title="3. 配置Git"></a>3. 配置Git</h1><h2 id="3-1-配置用户名和Email"><a href="#3-1-配置用户名和Email" class="headerlink" title="3.1. 配置用户名和Email"></a>3.1. 配置用户名和Email</h2><p>信息将会嵌入你的每次提交中。</p><p><strong>配置级别</strong>  </p><ul><li>系统级<kbd>--system</kbd>：系统中所有用户适用的配置<ul><li>Linux：/etc/gitconfig</li><li>Windows：Git/mingw64/etc/gitconfig</li></ul></li><li>用户级<kbd>--global</kbd>：当前用户适用的配置<ul><li>Linux：~/.gitconfig</li><li>Windows：C:/Users/Administrator/.gitconfig</li></ul></li><li>项目级<kbd>--local</kbd>：特定项目适用的配置<ul><li>Linux：gitProject/.gitconfig</li><li>Windows：gitProject/.gitconfig</li></ul></li></ul><p>低级覆盖高级：<strong>local&lt;globall&lt;system</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">&quot;Your Name&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">&quot;Your Email&quot;</span></span></span><br></pre></td></tr></table></figure><p>如果用了<kbd>--global</kbd>选项，所有项目都会默认使用这个全局配置，不加则为某个特定的项目信息。</p><h2 id="3-2-增删配置项"><a href="#3-2-增删配置项" class="headerlink" title="3.2. 增删配置项"></a>3.2. 增删配置项</h2><h3 id="3-2-1-添加配置项"><a href="#3-2-1-添加配置项" class="headerlink" title="3.2.1. 添加配置项"></a>3.2.1. 添加配置项</h3><p><code>git config [--local|--global|--system]  section.key value</code></p><p>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">51139@DESKTOP MINGW64 /e/blog</span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global Student.number 2018000001</span></span><br><span class="line">51139@DESKTOP MINGW64 /e/blog</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat C:/Users/51139/.gitconfig</span></span><br><span class="line">[user]</span><br><span class="line">        name = memorykkk</span><br><span class="line">        email = 511390937@qq.com</span><br><span class="line">[Student]</span><br><span class="line">        number = 2018000001</span><br></pre></td></tr></table></figure><h3 id="3-2-2-删除配置项"><a href="#3-2-2-删除配置项" class="headerlink" title="3.2.2. 删除配置项"></a>3.2.2. 删除配置项</h3><p><code>git config [--local|--global|--system] --unset section.key</code></p><h2 id="3-3-更多配置项"><a href="#3-3-更多配置项" class="headerlink" title="3.3. 更多配置项"></a>3.3. 更多配置项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config -l, --list     #list all    列出所有</span><br><span class="line">git config -e, --edit     #open an editor    打开一个编辑器</span><br><span class="line">git config --global color.ui true   #打开所有的默认终端着色</span><br><span class="line">git config --global alias.ci commit   #别名 ci 是commit的别名</span><br><span class="line">user.name  #用户名</span><br><span class="line">user.email  #邮箱</span><br><span class="line">core.editor  #文本编辑器  </span><br><span class="line">merge.tool  #差异分析工具  </span><br><span class="line">core.paper &quot;less -N&quot;  #配置显示方式  </span><br><span class="line">color.diff true  #diff颜色配置  </span><br><span class="line">alias.co checkout  #设置别名</span><br><span class="line">git config user.name  #获得用户名</span><br><span class="line">git config core.filemode false  #忽略修改权限的文件 </span><br></pre></td></tr></table></figure><p>学习<kbd>config</kbd>命令，运行  <code>$ git help config</code></p><p>查看手册 <a href="https://git-scm.com/docs/git-config">git config</a></p><h1 id="4-Git基本概念"><a href="#4-Git基本概念" class="headerlink" title="4. Git基本概念"></a>4. Git基本概念</h1><ol><li>Git本地有三个工作区域：<strong>工作区</strong>（Workspace）、<strong>暂存区</strong>（Index/Stage）、<strong>仓库</strong>（Repository），加上<strong>远程仓库</strong>（Remote）共四个工作区域。</li></ol><p>Git 各个命令可以理解为在各个仓库间转移数据，各个命令对应对每个仓库输入输出。</p><ul><li>Workspace：工作区，平时能看到的存放项目代码的地方</li><li>Index / Stage：暂存区，临时存放改动，保存即将提交到文件列表信息的文件，有时也叫作索引</li><li>Repository：仓库区（或本地仓库），安全存放数据的位置，含所有版本的数据，HEAD指向最新版本</li><li>Remote：远程仓库，托管代码的服务器，用于远程数据交换</li></ul><ol start="2"><li>对于本地三个区域的关系如下：<br><img src="/images/Git/local_relation.png" alt="local_relation"></li></ol><ul><li><p>Directory：使用Git管理的仓库，包含我们的工作空间和Git的管理空间</p></li><li><p>WorkSpace：需要通过Git进行版本控制的目录和文件组成工作空间</p></li><li><p>.git：存放Git管理信息的目录，初始化仓库的时候自动创建</p></li><li><p>Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前存放所有的更新</p></li><li><p>Local Repo：本地仓库，HEAD会只是当前的开发分支（branch）。</p></li><li><p>Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。<br>观察命令对各区域的影响：<br><img src="/images/Git/git_theory.jpg" alt="git_theory"></p></li><li><p>master 是 master 分支所代表的目录树，此时 HEAD 实际是指向 master 分支的一个”游标”，objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。</p></li><li><p>当对工作区修改（或新增）的文件执行 <kbd>git add</kbd> 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</p></li><li><p>当执行提交操作 <kbd>git commit</kbd>时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</p></li><li><p>当执行 <kbd>git reset HEAD</kbd> 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</p></li><li><p>当执行 <kbd>git rm --cached &lt;file></kbd> 命令时，会直接从暂存区删除文件，工作区则不做出改变。</p></li><li><p>当执行 <kbd>git checkout .</kbd> 或者 <kbd>git checkout -- &lt;file></kbd> 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</p></li><li><p>当执行 <kbd>git checkout HEAD .</kbd> 或者 <kbd>git checkout HEAD &lt;file></kbd> 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</p></li></ul><ol start="3"><li>若对四个区域分级：workspace &lt; index &lt; repository &lt; remote，基本的转移如下表，参数和选项决定数据来源。</li></ol><table><thead><tr><th></th><th>低等级输入</th><th>高等级输入</th></tr></thead><tbody><tr><td>workspace</td><td>手动</td><td>git checkout/git stash</td></tr><tr><td>index/stage</td><td>git add</td><td>git reset</td></tr><tr><td>repository</td><td>git commit</td><td>git pull</td></tr><tr><td>remote</td><td>git push</td><td>-</td></tr></tbody></table><p>四个区域转换关系如下：<br><img src="/images/Git/git_transition.png" alt="git_transition"></p><h1 id="5-Git工作流程"><a href="#5-Git工作流程" class="headerlink" title="5. Git工作流程"></a>5. Git工作流程</h1><p>一般工作流程如下：</p><ul><li>在工作目录中修改某些文件。</li><li>对修改后的文件进行快照，然后保存到暂存区域。</li><li>提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。</li></ul><p><img src="/images/Git/git-process-img.png" alt="git-process"></p><h1 id="6-Git操作"><a href="#6-Git操作" class="headerlink" title="6. Git操作"></a>6. Git操作</h1><h2 id="6-1-Git创建版本库"><a href="#6-1-Git创建版本库" class="headerlink" title="6.1. Git创建版本库"></a>6.1. Git创建版本库</h2><ul><li>在工作目录中初始化新仓库</li><li>从现有仓库克隆</li></ul><h3 id="6-1-1-在工作目录中初始化"><a href="#6-1-1-在工作目录中初始化" class="headerlink" title="6.1.1. 在工作目录中初始化"></a>6.1.1. 在工作目录中初始化</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure><p>在新建空目录或已有目录中，使用命令 <code>git init</code> 初始化一个新仓库。初始化后该目录下自动生成<kbd>.git</kbd>目录，用于生成所有 Git 需要的数据和资源。</p><p><strong>文件加入版本库</strong><br>将文件添加到仓库（workspace -&gt; stage）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add &lt;file&gt;</span></span><br></pre></td></tr></table></figure><p>执行后没有任何信息则代表执行成功。</p><p>将文件提交到仓库（stage -&gt; repository）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m &lt;message&gt;</span></span><br></pre></td></tr></table></figure><p>多次<kbd>add</kbd>不同的文件，但只需一次<kbd>commit</kbd>就可以提交。</p><h3 id="6-1-2-从现有仓库克隆"><a href="#6-1-2-从现有仓库克隆" class="headerlink" title="6.1.2. 从现有仓库克隆"></a>6.1.2. 从现有仓库克隆</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> &lt;url&gt; &lt;newName&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Git 收取的是项目历史的完整数据（每一个文件的每一个版本），而不是某个特定版本，服务器上有的数据克隆之后本地也都有了。  </li><li><kbd>url</kbd> 支持 git 协议或 SSH 传输协议。通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。  </li><li>克隆之后的目录名为 url 中 .git 前的名称，通过 <kbd>&lt;newName></kbd> 可以自定义。目录中包含<kbd>.git</kbd>目录，用于保存下载下来的所有版本记录，然后从中取出最新版本的文件拷贝。</li></ul><h2 id="6-2-文件更新"><a href="#6-2-文件更新" class="headerlink" title="6.2. 文件更新"></a>6.2. 文件更新</h2><h3 id="6-2-1-文件状态"><a href="#6-2-1-文件状态" class="headerlink" title="6.2.1. 文件状态"></a>6.2.1. 文件状态</h3><p>文件状态主要分两种，已跟踪（tracked）即本来就被纳入版本控制管理的文件，其它文件即未跟踪（untracked）。</p><ul><li>Untracked：未跟踪，此文件没有加入到git库，不参与版本控制。通过 <code>git add</code> 状态变为staged</li><li>Unmodify：文件已经入库，未修改，即版本库中的文件快照内容与文件夹中完全一致。这种文件被修改成为Modified，通过<code>git rm</code>移出版本库成为Untracked</li><li>Modified：文件已修改。这种文件通过<code>git add</code>可变成staged，通过<code>git checkout</code>则丢弃修改回到unmodify</li><li>Staged：暂存状态。通过<code>git commit</code>则将修改同步到库中，这时库中的文件和本地文件又变为一致，变为Unmodify状态。执行<code>git reset HEAD &lt;filename&gt;</code>取消暂存，变为Modified</li></ul><p>初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改（unmodified）。<br>文件状态变化周期：<br><img src="/images/Git/file-status.png" alt="file-status"></p><p>修改后的文件状态是 modified，逐步放在暂存区域，最后一次性提交。</p><h3 id="6-2-2-检查文件状态"><a href="#6-2-2-检查文件状态" class="headerlink" title="6.2.2. 检查文件状态"></a>6.2.2. 检查文件状态</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看指定文件状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status &lt;filename&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看所有文件状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br></pre></td></tr></table></figure><p>例如创建README之后：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim README</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Untracked files:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># README</span></span></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><p>表示当前处在<kbd>master</kbd>分支，未跟踪文件里包含 README，即 Git 之前的快照中没有这个文件，未纳入管理。</p><h3 id="6-2-3-跟踪文件"><a href="#6-2-3-跟踪文件" class="headerlink" title="6.2.3. 跟踪文件"></a>6.2.3. 跟踪文件</h3><p>（workspace -&gt; stage；untracked -&gt; staged）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加指定文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add &lt;file1&gt; &lt;file2&gt; ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加指定目录到暂存区，包括子目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add &lt;dir&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加当前目录的所有文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add README</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">    # On branch master</span><br><span class="line">    # Changes to be committed:</span><br><span class="line">    # (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">    #</span><br><span class="line">    # new file: README</span><br><span class="line">    #</span><br></pre></td></tr></table></figure><p>“Changes to be committed:” 表示其下的文件处于暂存区</p><h3 id="6-2-4-暂存已修改文件"><a href="#6-2-4-暂存已修改文件" class="headerlink" title="6.2.4. 暂存已修改文件"></a>6.2.4. 暂存已修改文件</h3><p>（untracked -&gt; staged）<br>修改一个已跟踪的文件后</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">    # On branch master</span><br><span class="line">    # Changes not staged for commit:</span><br><span class="line">    # (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">    #</span><br><span class="line">    # modified: benchmarks.rb</span><br><span class="line">    #</span><br></pre></td></tr></table></figure><p>“Changes not staged for commit:” 表示该文件内容发生变化但还未放到暂存区，需要重新运行 <code>git add</code> 命令。<br>也就是说，文件修改之后必须再次 <code>git add</code>，否则 <code>git commit</code> 提交的是修改前版本。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add benchmarks.rb</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># new file: README</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> modified: benchmarks.rb</span></span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure><p><code>git add</code> 根据目标文件的状态产生不同的效果：</p><ul><li>开始跟踪新文件</li><li>把已跟踪的文件放到暂存区</li><li>合并时把有冲突的文件标记为已解决状态</li></ul><h3 id="6-2-5-忽略某些文件"><a href="#6-2-5-忽略某些文件" class="headerlink" title="6.2.5. 忽略某些文件"></a>6.2.5. 忽略某些文件</h3><p>有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。有以下三种方式：</p><ol><li><p>创建<kbd>.gitignore</kbd>文件</p></li><li><p>项目设置中指定排除文件<br>临时指定。需要编辑当前项目中的 .git/info/exclude 文件</p></li><li><p>定义Git全局的 .gitignore 文件<br>设置全局的.gitignore文件来管理所有Git项目的行为。创建.gitignore文件，存放在任意位置，然后使用命令 <code># git config --global core.excludesfile ~/.gitignore</code> 配置。</p></li></ol><p>格式规范如下：</p><ul><li>每行一个，空格不匹配任意文件，可作为分隔符，可用反斜杠转义</li><li>所有空行或者以注释符号 <kbd>＃</kbd> 开头的行都会被 Git 忽略</li><li>可以使用标准的 glob 模式匹配：shell 所使用的简化了的正则表达式</li><li>匹配模式最后跟反斜杠<kbd>/</kbd>说明要忽略的是目录下所有文件</li><li>使用两个星号”**” 表示匹配任意中间目录</li><li><kbd>/</kbd>结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件；<kbd>/</kbd>开始的模式匹配项目根目录</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号<kbd>!</kbd>取反。</li><li>关于优先级等更多语法查看<a href="https://www.cnblogs.com/kevingrace/p/5690241.html">Git忽略提交规则 - .gitignore配置运维总结</a></li></ul><p>一般来说每个Git项目中都需要一个“.gitignore”文件，告诉Git哪些文件不需要添加到版本管理中，实际项目中很多文件都是不需要版本管理的，例如日志、缩略图、敏感信息等。</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span></span><br><span class="line">    doc/*.txt</span><br></pre></td></tr></table></figure><h3 id="6-2-6-查看未暂存的更新"><a href="#6-2-6-查看未暂存的更新" class="headerlink" title="6.2.6. 查看未暂存的更新"></a>6.2.6. 查看未暂存的更新</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br></pre></td></tr></table></figure><p>查看工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。<br>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br><span class="line">    diff --git a/benchmarks.rb b/benchmarks.rb</span><br><span class="line">    index 3cb747f..da65585 100644</span><br><span class="line">    --- a/benchmarks.rb</span><br><span class="line">    +++ b/benchmarks.rb</span><br><span class="line">    @@ -36,6 +36,10 @@ def main</span><br><span class="line">    @commit.parents[0].parents[0].parents[0]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    + run_code(x, &#x27;commits 1&#x27;) do</span><br><span class="line">    + git.commits.size</span><br><span class="line">    + end</span><br><span class="line">    +</span><br><span class="line">    run_code(x, &#x27;commits 2&#x27;) do</span><br><span class="line">    log = git.commits(&#x27;master&#x27;, 15)</span><br><span class="line">    log.size</span><br></pre></td></tr></table></figure><h3 id="6-2-7-查看已暂存的更新"><a href="#6-2-7-查看已暂存的更新" class="headerlink" title="6.2.7. 查看已暂存的更新"></a>6.2.7. 查看已暂存的更新</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached</span></span><br></pre></td></tr></table></figure><p>查看已经暂存起来的文件和上次提交时的快照之间的差异</p><h3 id="6-2-8-提交更新"><a href="#6-2-8-提交更新" class="headerlink" title="6.2.8. 提交更新"></a>6.2.8. 提交更新</h3><p>（staged -&gt; commited；stage -&gt; repository）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m &lt;file&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区的指定文件到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit &lt;file1&gt; &lt;file2&gt; ... -m &lt;message&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交工作区自上次commit之后的变化，直接到仓库区，跳过add,对新文件无效</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交时显示所有diff信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -v</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果我们提交后发现有个文件改错了，将修改过的文件通过<span class="string">&quot;git add&quot;</span>后执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m &lt;message&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend &lt;file1&gt; &lt;file2&gt; ...</span> </span><br></pre></td></tr></table></figure><p>使用 <code>git status</code> 查看暂存区域状态，准备妥当之后就可以提交了。<br>这样看来暂存区的意义在于<strong>精心准备</strong>每次提交。  </p><ul><li>直接使用不加 <kbd>-m</kbd> 的 <code>git commit</code> 提交会打开编辑器（通过 <code>$ git config --global core.editor emacs</code> 配置）以便输入本次提交的说明。</li><li>使用<kbd>-m</kbd>选项比较方便。</li></ul><p>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;Story 182: Fix benchmarks for speed&quot;</span></span></span><br><span class="line">    [master]: created 463dc4f: &quot;Fix benchmarks for speed&quot;</span><br><span class="line">    2 files changed, 3 insertions(+), 0 deletions(-)</span><br><span class="line">    create mode 100644 README</span><br></pre></td></tr></table></figure><p>显示了提交的分支（master）、SHA-1校验和（463dc4f）、修改过的文件数（2）和增（3）删<strong>行数</strong>。  </p><p>因为修改后但未暂存的处于已修改态（modified），只能纳入下一次版本。  </p><p><strong>每次提交都是对项目的一次快照，以后可以回退</strong></p><h3 id="6-2-9-跳过使用暂存区域"><a href="#6-2-9-跳过使用暂存区域" class="headerlink" title="6.2.9. 跳过使用暂存区域"></a>6.2.9. 跳过使用暂存区域</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -a -m &lt;message&gt;</span></span><br></pre></td></tr></table></figure><p>Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤，对新文件无效</p><h3 id="6-2-10-移除文件"><a href="#6-2-10-移除文件" class="headerlink" title="6.2.10. 移除文件"></a>6.2.10. 移除文件</h3><ol><li>从 Git 中移除文件</li></ol><p>未跟踪文件对 Git 来说不存在，手动<code>rm</code>即可，已跟踪文件就必须要从已跟踪文件清单（stage）中移除，然后提交。可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm &lt;file&gt;</span></span><br></pre></td></tr></table></figure><p>如果只是简单地从工作目录中手工删除文件，运行 <code>git status</code> 时就会在 “Changes not staged for commit” 部分（未暂存清单）看到。（判断为“修改”操作？）</p><ol start="2"><li>从 Git 中移除，但仍然希望保留在当前工作目录<br>（stage -&gt; workspace；tracked:staged -&gt; untracked）<br>即不小心纳入仓库后，想要移除跟踪但不删除文件。</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm --cached &lt;file&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-2-11-移动文件"><a href="#6-2-11-移动文件" class="headerlink" title="6.2.11. 移动文件"></a>6.2.11. 移动文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git mv &lt;oldfileName&gt; &lt;newFileName&gt;</span></span><br></pre></td></tr></table></figure><p>Git 并不跟踪文件移动操作。如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。要在 Git 中对文件改名，执行<code>git mv</code>实际上相当于</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mv old new</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm old</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add new</span></span><br></pre></td></tr></table></figure><h2 id="6-3-查看提交历史"><a href="#6-3-查看提交历史" class="headerlink" title="6.3. 查看提交历史"></a>6.3. 查看提交历史</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br></pre></td></tr></table></figure><p>默认不用任何参数，<code>git log</code> 会按提交时间列出所有的更新信息。<br>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">    commit ca82a6dff817ec66f44342007202690a93763949   #SHA-1校验和</span><br><span class="line">    Author: Scott Chacon &lt;schacon@gee-mail.com&gt;       #作者&lt;邮箱&gt;</span><br><span class="line">    Date: Mon Mar 17 21:52:11 2008 -0700              #时间</span><br><span class="line"></span><br><span class="line">    changed the version number                        #提交说明</span><br></pre></td></tr></table></figure><p><strong>选项</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> &lt;option&gt;</span></span><br><span class="line">  -p    #开显示每次提交的内容差异</span><br><span class="line">  --stat  #仅显示简要的增改行数统计</span><br><span class="line">  --shortstat #只显示 --stat 中最后的行数修改添加移除统计。</span><br><span class="line">  --name-only #仅在提交信息后显示已修改的文件清单。</span><br><span class="line">  --name-status #显示新增、修改、删除的文件清单。</span><br><span class="line">  --abbrev-commit #仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</span><br><span class="line">  --relative-date #使用较短的相对时间显示（比如，“2 weeks ago”）。</span><br><span class="line">  --graph 显示 ASCII #图形表示的分支合并历史。</span><br><span class="line">  --pretty #使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</span><br></pre></td></tr></table></figure><h3 id="6-3-1-限制输出长度"><a href="#6-3-1-限制输出长度" class="headerlink" title="6.3.1. 限制输出长度"></a>6.3.1. 限制输出长度</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> &lt;option&gt;</span></span><br><span class="line">  -(n) #仅显示最近的 n 条提交</span><br><span class="line">  --since, --after #仅显示指定时间之后的提交。</span><br><span class="line">  --until, --before #仅显示指定时间之前的提交。</span><br><span class="line">  --author #仅显示指定作者相关的提交。</span><br><span class="line">  --committer #仅显示指定提交者相关的提交。</span><br></pre></td></tr></table></figure><h3 id="6-3-2-使用图形化工具查阅提交历史"><a href="#6-3-2-使用图形化工具查阅提交历史" class="headerlink" title="6.3.2. 使用图形化工具查阅提交历史"></a>6.3.2. 使用图形化工具查阅提交历史</h3><p>随 Git 一同发布的 gitk 相当于 git log 命令的可视化版本。</p><h2 id="6-4-撤销"><a href="#6-4-撤销" class="headerlink" title="6.4. 撤销"></a>6.4. 撤销</h2><p>任何已经提交到 Git 的都可以被恢复。你可能失去的数据，仅限于没有提交过的，对 Git 来说它们就像从未存在过一样。</p><h3 id="6-4-1-修改最后一次提交"><a href="#6-4-1-修改最后一次提交" class="headerlink" title="6.4.1. 修改最后一次提交"></a>6.4.1. 修改最后一次提交</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果我们提交后发现有个文件改错或没有加，将修改过的文件通过<span class="string">&quot;git add&quot;</span>后执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改上一次commit的提交信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m &lt;message&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend &lt;file1&gt; &lt;file2&gt; ...</span> </span><br></pre></td></tr></table></figure><p>也就是说，在执行<code>git commit</code>之后暂存区为空，此时若再次执行<code>git commit --amend</code>判断为修改上次的提交信息；此时若<code>git add</code>新文件到暂存区，执行此命令相当于添加到上次提交。</p><h3 id="6-4-2-取消已经暂存的文件"><a href="#6-4-2-取消已经暂存的文件" class="headerlink" title="6.4.2. 取消已经暂存的文件"></a>6.4.2. 取消已经暂存的文件</h3><p>（staged -&gt; modified）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset HEAD &lt;file&gt;</span></span><br></pre></td></tr></table></figure><p>文件从暂存区回到已修改未暂存状态。</p><h3 id="6-4-3-取消对文件的修改"><a href="#6-4-3-取消对文件的修改" class="headerlink" title="6.4.3. 取消对文件的修改"></a>6.4.3. 取消对文件的修改</h3><p>（modified -&gt; unmodified）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- &lt;file&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-4-4-文件操作总结"><a href="#6-4-4-文件操作总结" class="headerlink" title="6.4.4. 文件操作总结"></a>6.4.4. 文件操作总结</h3><p><img src="/images/Git/file-summary.png" alt="file-summary.png"></p><h1 id="7-Git远程仓库"><a href="#7-Git远程仓库" class="headerlink" title="7. Git远程仓库"></a>7. Git远程仓库</h1><p>Git 要求每个远程主机都必须指定一个主机名。</p><h2 id="7-1-查看远程仓库"><a href="#7-1-查看远程仓库" class="headerlink" title="7.1. 查看远程仓库"></a>7.1. 查看远程仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote</span></span><br></pre></td></tr></table></figure><p>查看每个远程库的简短名字。Git 默认使用“origin”这个名字来标识你所克隆的原始仓库。  </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br></pre></td></tr></table></figure><p>加上<kbd>-v</kbd>选项，显示对应的克隆地址。</p><h2 id="7-2-添加远程仓库"><a href="#7-2-添加远程仓库" class="headerlink" title="7.2. 添加远程仓库"></a>7.2. 添加远程仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add &lt;shortname&gt; &lt;url&gt;</span></span><br></pre></td></tr></table></figure><p><kbd>&lt;shortname></kbd>即自定义远程主机名<remote-name>，在<code>git remote</code>中显示，</p><h2 id="7-3-从远程仓库抓取数据"><a href="#7-3-从远程仓库抓取数据" class="headerlink" title="7.3. 从远程仓库抓取数据"></a>7.3. 从远程仓库抓取数据</h2><p><strong>git fetch</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch add &lt;remote-name&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch add &lt;remote-name&gt; &lt;branch-name&gt;  <span class="comment">#指定分支</span></span></span><br></pre></td></tr></table></figure><ul><li>抓取所有本地仓库没有的数据。但只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支。  </li><li>通常用来查看其他人的进程，因为它取回的代码对本地代码没有影响。  </li><li>指定分支所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。  </li><li>类似的，<code>git fetch origin</code>会抓取上次<code>clone</code>以来的别人提交的更新。  </li><li>如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。</li></ul><p><strong>git pull</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull &lt;remote-name&gt; &lt;remote-branch-name&gt;:&lt;local-branch-name&gt;</span></span><br></pre></td></tr></table></figure><ul><li>取回远程主机某个分支的更新，再与本地的指定分支合并。  </li><li>如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。  </li><li>如果是与当前分支合并，则冒号后面的部分可以省略。  </li><li>等同于先<code>git fetch</code>再<code>git merge</code>。  </li><li>如果远程主机删除了某个分支，默认情况下，<code>git pull</code> 不会在拉取远程分支的时删除对应的本地分支。这是为了防止由于其他人操作了远程主机，导致<code>git pull</code>不知不觉删除了本地分支。除非加上参数 <kbd>-p</kbd> 就会在本地删除远程已经删除的分支。</li></ul><h2 id="7-4-推送数据到远程仓库"><a href="#7-4-推送数据到远程仓库" class="headerlink" title="7.4. 推送数据到远程仓库"></a>7.4. 推送数据到远程仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;remote-name&gt; &lt;local-branch-name&gt;:&lt;remote-branch-name&gt;</span></span><br></pre></td></tr></table></figure><ul><li>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。  </li><li>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。<br>将本地仓库中的数据推送到远程仓库，只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。</li><li>如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</li><li>如果是新建分支第一次<code>git push</code>，会提示：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fatal: The current branch dev1 has no upstream branch.</span><br><span class="line">　　To push the current branch and set the remote as upstream, use</span><br><span class="line">　　git push --set-upstream origin dev1</span><br></pre></td></tr></table></figure><p>输入这行命令，然后输入用户名和密码就成功了，以后的push就只需要输入<code>git push origin</code>。</p><ul><li>如果当前分支只有一个追踪分支，那么主机名都可以省略。</li><li>如果当前分支与多个主机存在追踪关系，则可以使用<kbd>-u</kbd>选项指定一个默认主机，这样后面就可以不加任何参数使用<code>git push</code>。</li><li>如果不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用<kbd>--all</kbd>选项。</li><li>如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做<code>git pull</code>合并差异，然后再推送到远程主机。这时如果你一定要推送，可以使用<kbd>--force</kbd>选项。<br>结果导致远程主机上更新的版本被覆盖。</li></ul><h2 id="7-5-查看远程仓库信息"><a href="#7-5-查看远程仓库信息" class="headerlink" title="7.5. 查看远程仓库信息"></a>7.5. 查看远程仓库信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote show &lt;remote-name&gt;</span></span><br></pre></td></tr></table></figure><p>例如：  </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote show origin</span></span><br><span class="line">    * remote origin</span><br><span class="line">    URL: git@github.com:defunkt/github.git</span><br><span class="line">    Remote branch merged with &#x27;git pull&#x27; while on branch issues     # git pull 时将自动合并的分支</span><br><span class="line">    issues</span><br><span class="line">    Remote branch merged with &#x27;git pull&#x27; while on branch master     # git pull 时将自动合并的分支</span><br><span class="line">    master</span><br><span class="line">    New remote branches (next fetch will store in remotes/origin)   # 还没有同步到本地的远端分支</span><br><span class="line">    caching               </span><br><span class="line">    Stale tracking branches (use &#x27;git remote prune&#x27;)    #已同步到本地的远端分支在远端服务器上已被删除</span><br><span class="line">    libwalker</span><br><span class="line">    walker2</span><br><span class="line">    Tracked remote branches</span><br><span class="line">    acl</span><br><span class="line">    apiv2</span><br><span class="line">    dashboard2</span><br><span class="line">    issues</span><br><span class="line">    master</span><br><span class="line">    postgres</span><br><span class="line">    Local branch pushed with &#x27;git push&#x27;     # git push 缺省推送的分支</span><br><span class="line">    master:master         </span><br></pre></td></tr></table></figure><h2 id="7-6-远程仓库的删除和重命名"><a href="#7-6-远程仓库的删除和重命名" class="headerlink" title="7.6. 远程仓库的删除和重命名"></a>7.6. 远程仓库的删除和重命名</h2><h3 id="7-6-1-重命名"><a href="#7-6-1-重命名" class="headerlink" title="7.6.1. 重命名"></a>7.6.1. 重命名</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote rename pb paul</span></span><br></pre></td></tr></table></figure><p>修改的是某个远程仓库在本地的简称，分支名也会发生变化。</p><h3 id="7-6-2-删除"><a href="#7-6-2-删除" class="headerlink" title="7.6.2. 删除"></a>7.6.2. 删除</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote rm &lt;remote-name&gt;</span></span><br></pre></td></tr></table></figure><h1 id="8-版本标签"><a href="#8-版本标签" class="headerlink" title="8. 版本标签"></a>8. 版本标签</h1><h2 id="8-1-显示已有标签"><a href="#8-1-显示已有标签" class="headerlink" title="8.1. 显示已有标签"></a>8.1. 显示已有标签</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> $ git tag -l <span class="string">&#x27;&lt;tag-name&gt;&#x27;</span>    <span class="comment">#显示指定版本</span></span></span><br></pre></td></tr></table></figure><p>按照字母顺序排列。</p><h2 id="8-2-新建标签"><a href="#8-2-新建标签" class="headerlink" title="8.2. 新建标签"></a>8.2. 新建标签</h2><p>Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用；而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息。</p><p>建议一般使用含附注型的标签，临时性加注标签用轻量级标签。</p><h3 id="8-2-1-含附注的标签"><a href="#8-2-1-含附注的标签" class="headerlink" title="8.2.1. 含附注的标签"></a>8.2.1. 含附注的标签</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -a &lt;tag-name&gt; -m &lt;message&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show <span class="string">&#x27;&lt;tag-name&gt;&#x27;</span>    <span class="comment">#查看相应标签的版本信息</span></span></span><br></pre></td></tr></table></figure><p><kbd>-a</kbd>指定标签名，<kbd>-m</kbd>指定对应的标签说明，<code>git show</code>可以显示出。</p><h3 id="8-2-2-轻量级标签"><a href="#8-2-2-轻量级标签" class="headerlink" title="8.2.2. 轻量级标签"></a>8.2.2. 轻量级标签</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag &lt;tag-name&gt;</span></span><br></pre></td></tr></table></figure><p>没有选项。</p><h3 id="8-2-3-签署标签"><a href="#8-2-3-签署标签" class="headerlink" title="8.2.3. 签署标签"></a>8.2.3. 签署标签</h3><p>如果你有自己的私钥，还可以用 GPG 来签署标签，只需要把之前的 <kbd>-a</kbd> 改为 <kbd>-s</kbd> 即可。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -s &lt;tag-name&gt; -m &lt;message&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-2-4-验证标签"><a href="#8-2-4-验证标签" class="headerlink" title="8.2.4. 验证标签"></a>8.2.4. 验证标签</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -v &lt;tag-name&gt;</span></span><br></pre></td></tr></table></figure><p>验证已经签署的标签，会调用 GPG 来验证签名，所以需要有签署者的公钥，存放在 keyring 中，才能验证，否则报错<code>gpg: Can&#39;t check signature: public key not found</code>。</p><h2 id="8-3-后期加注标签"><a href="#8-3-后期加注标签" class="headerlink" title="8.3. 后期加注标签"></a>8.3. 后期加注标签</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -a &lt;tag-name&gt; &lt;SHA-1&gt;</span></span><br></pre></td></tr></table></figure><p>只要在打标签的时候跟上对应提交对象的校验和（或前几位字符）即可。<br>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v1.2 9fceb02</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show v1.2</span></span><br><span class="line">  version 1.2</span><br><span class="line">    commit 9fceb02d0ae598e95dc970b74767f19372d61af8</span><br><span class="line">    Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt;</span><br><span class="line">    Date: Sun Apr 27 20:43:35 2008 -0700</span><br><span class="line"></span><br><span class="line">    updated rakefile</span><br></pre></td></tr></table></figure><h2 id="8-4-分享标签"><a href="#8-4-分享标签" class="headerlink" title="8.4. 分享标签"></a>8.4. 分享标签</h2><p>默认情况下，<code>git push</code> 并不会把标签传送到远端服务器上</p><ul><li>使用<kbd>--tags</kbd>选项一次推送所有本地新增的标签上去</li><li>通过显式命令才能分享标签到远端仓库。  </li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin --tags</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin [tag-name]</span></span><br></pre></td></tr></table></figure><h1 id="9-Git分支"><a href="#9-Git分支" class="headerlink" title="9. Git分支"></a>9. Git分支</h1><p>使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。</p><h2 id="9-1-分支简介"><a href="#9-1-分支简介" class="headerlink" title="9.1. 分支简介"></a>9.1. 分支简介</h2><p>在 Git 中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针、作者等附属信息、零个或多个指向该提交对象的父对象指针。首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。</p><p>举例：对于三个文件暂存后，Git 嫁给你当前版本的快照（blob类型）连同每个文件的额SHA-1保存至仓库。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add README test.rb LICENSE</span></span><br><span class="line">    $ git commit -m &#x27;initial commit of my project&#x27;</span><br></pre></td></tr></table></figure><p>现在仓库中有五个对象：</p><ul><li>三个 blob 对象：表示文件快照内容</li><li>tree 对象：记录着目录树内容及其中各个文件对应的 blob 对象索引的</li><li>commit 对象：指向 tree 对象（根目录）的索引和其他提交信息元数据。在需要的时候重现此次快照。<br><img src="/images/Git/singleObj.png" alt="singleObj.png"></li></ul><p>作些修改后再次提交，那么这次的提交对象会包含一个指向上次提交对象的指针（parent 对象）。两次提交后：<br><img src="images/Git/multiObj.png" alt="multiObj.png"></p><p>Git 中的分支，其实本质上仅仅是个指向 commit 对象的可变指针。Git 会使用 <kbd>master</kbd> 作为分支的默认名字。在若干次提交后，你其实已经有了一个指向最后一次提交对象的 <kbd>master</kbd> 分支，它在每次提交的时候都会自动向前移动。<br><img src="images/Git/masterHistory.png" alt="masterHistory.png"></p><h2 id="9-2-新建分支"><a href="#9-2-新建分支" class="headerlink" title="9.2. 新建分支"></a>9.2. 新建分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch &lt;branch-name&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>git branch testing</code>在当前 commit 对象上新建一个分支指针<kbd>testing</kbd>：<br><img src="images/Git/newBranch.png" alt="newBranch.png"></p><h2 id="9-3-HEAD"><a href="#9-3-HEAD" class="headerlink" title="9.3. HEAD"></a>9.3. HEAD</h2><p>HEAD 是一个指向你正在工作中的本地分支的指针，即当前分支。</p><p>运行 <code>git branch</code> 命令，仅仅是建立了一个新的分支，但不会自动切换到这个分支中去，所以依然还在 <kbd>master</kbd> 分支里工作：</p><p><img src="images/Git/headMaster.png" alt="headMaster.png"></p><h2 id="9-4-切换分支"><a href="#9-4-切换分支" class="headerlink" title="9.4. 切换分支"></a>9.4. 切换分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout &lt;branch-name&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b &lt;branch-name&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>git checkout testing</code>切换分支<kbd>testing</kbd>：<br><img src="images/Git/checkout.png" alt="checkout.png"></p><p>或者运行 <code>git checkout</code> 并加上 <kbd>-b</kbd> 参数，新建并切换到该分支。</p><p>提交之后：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim test.rb</span></span><br><span class="line">    $ git commit -a -m &#x27;made a change&#x27;</span><br></pre></td></tr></table></figure><p><img src="images/Git/headTesting.png" alt="headTesting.png"><br>提交后 HEAD 随<kbd>testing</kbd>分支一起向前移动，，而 <kbd>master</kbd> 分支仍然指向原先 <code>git checkout</code> 时所在的 commit 对象。</p><p>如果此时执行<code>git checkout master</code>，切回<kbd>master</kbd>分支：</p><p><img src="images/Git/masterHistory.png" alt="masterHistory.png"><br>做了两件事：</p><ul><li>HEAD 指针移回到 <kbd>master</kbd> 分支</li><li>工作目录中的文件换成了 master 分支所指向的快照内容（较旧的进度）<br>它的主要作用是将 testing 分支里作出的修改暂时取消，这样你就可以向另一个方向进行开发。</li></ul><p>此时如果提交新文件，即：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim test.rb</span></span><br><span class="line">    $ git commit -a -m &#x27;made other changes&#x27;</span><br></pre></td></tr></table></figure><p><img src="images/Git/branchHistory.png" alt="branchHistory.png"></p><p><strong>Git 中的分支实际上仅是一个包含所指对象校验和（40 个字符长度 SHA-1 字串）的文件，Git 的实现与项目复杂度无关，并且每次提交都记录了 parent 对象，所以 Git 分支操作非常廉价。</strong></p><blockquote><p>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：<br>你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！<br>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：<br>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：<br>所以Git合并分支也很快！就改改指针，工作区内容也不变！<br>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支。</p></blockquote><h2 id="9-5-合并分支"><a href="#9-5-合并分支" class="headerlink" title="9.5. 合并分支"></a>9.5. 合并分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge iss53</span></span><br></pre></td></tr></table></figure><p>回到 <kbd>master</kbd> 分支，运行 <code>git merge</code> 命令指定要合并进来的分支<kbd>iss53</kbd></p><h2 id="9-6-遇到冲突时的分支合并"><a href="#9-6-遇到冲突时的分支合并" class="headerlink" title="9.6. 遇到冲突时的分支合并"></a>9.6. 遇到冲突时的分支合并</h2><p>如果在不同的分支中都修改了同一个文件的同一部分，Git 就无法干净地把两者合到一起（逻辑上说，这种问题只能由人来裁决）。结果如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge iss53</span></span><br><span class="line">    Auto-merging index.html</span><br><span class="line">    CONFLICT (content): Merge conflict in index.html</span><br><span class="line">    Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>Git 做了合并但没有提交，等待解决冲突。可以用 <code>git status</code> 查看合并时发生冲突的文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash"> unmerged: index.html</span></span><br></pre></td></tr></table></figure><p>任何包含未解决冲突的文件都会以未合并<strong>unmerged</strong>的状态列出。Git 会在有冲突的文件里加入标准的冲突解决标记：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line">    &lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class="line">    =======</span><br><span class="line">    &lt;div id=&quot;footer&quot;&gt;</span><br><span class="line">    please contact us at support@github.com</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></pre></td></tr></table></figure><p>可以看到 <kbd>=======</kbd> 隔开的上半部分，是 HEAD（当前分支）中的内容，下半部分是在 <kbd>iss53</kbd> 分支中的内容。</p><p>解决办法是删除上面的内容（包括’=’’&lt;’’&gt;’），自行决定怎么写。之后运行<code>git add</code>和<code>git status</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash"> modified: index.html</span></span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure><p>确认冲突已解决，标记为<strong>modified</strong>，再<code>git commit</code>提交。</p><p>也可以使用相关可视化工具解决冲突，运行<code>git mergetool</code>。</p><h2 id="9-7-删除分支"><a href="#9-7-删除分支" class="headerlink" title="9.7. 删除分支"></a>9.7. 删除分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d &lt;branch-name&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">强制删除</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -D &lt;branch-name&gt;</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程分支，分支必须完全合并在其上游分支，或者在HEAD上没有设置上游</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete &lt;branch-name&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -dr &lt;remote-name/branch-name&gt;</span></span><br></pre></td></tr></table></figure><h2 id="9-8-案例"><a href="#9-8-案例" class="headerlink" title="9.8. 案例"></a>9.8. 案例</h2><p><strong>工作流程</strong></p><ol><li>开发某个网站为</li><li>实现某个新的需求，创建一个分支。</li><li>在这个分支上开展工作。</li></ol><p>假设此时突然有个很严重的问题需要紧急修补，那么：</p><ol><li>返回到原先已经发布到生产服务器上的分支。</li><li>为这次紧急修补建立一个新分支，并在其中修复问题。</li><li>通过测试后，回到生产服务器所在的分支，将修补分支合并进来，然后再推送到生产服务器上。</li><li>切换到之前实现新需求的分支，继续工作。</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建iss53并切换</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b iss53</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 遇问题切回master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时工作区和之前 master 提交时完全一样</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建紧急修补分支 hotfix</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b <span class="string">&#x27;hotfix&#x27;</span></span></span><br></pre></td></tr></table></figure><p>Git 的好处：  </p><ul><li>不需要同时发布这个补丁和 iss53 里作出的修改</li><li>不需要在创建和发布该补丁到服务器之前花费大力气来复原这些修改</li></ul><p>切换分支时需要留心你的暂存区或者工作目录里<strong>还没有提交的修改</strong>，它会产生冲突从而阻止切换，最好保持一个清洁的工作区域（也可以通过 stashing 和 commit amending 绕过这种问题）。</p><p><img src="images/Git/hotfixSuccess.png" alt="hotfixSuccess.png.png"></p><p>修改、测试之后回到 <kbd>master</kbd> 分支并把 <kbd>hotfix</kbd> 合并：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge hotfix</span></span><br></pre></td></tr></table></figure><p>请注意，合并时出现了“Fast forward”的提示。由于当前 <kbd>master</kbd> 分支所在的提交对象是要并入的 <kbd>hotfix</kbd> 分支的直接上游，Git 只需把 <kbd>master</kbd> 分支指针直接右移。换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为<strong>快进</strong>（Fast forward）。</p><p><kbd>hotfix</kbd>分支完成历史使命之后可以删掉，回到正常的 iss53 正常工作：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d hotfix</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout iss53</span></span><br></pre></td></tr></table></figure><p><img src="images/Git/normalWork.png" alt="normalWork.png"></p><p>需求#53开发完之后，合并<kbd>master</kbd>和<kbd>iss53</kbd>分支：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge iss53</span></span><br></pre></td></tr></table></figure><p>这次合并操作的底层实现，并不同于之前 <kbd>hotfix</kbd> 的并入方式。因为这次你的开发历史是从更早的地方开始分叉的。由于当前 <kbd>master</kbd> 分支所指向的提交对象（C4）并不是 <kbd>iss53</kbd> 分支的直接祖先，Git 不得不进行一些额外处理。就此例而言，Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算：</p><p><img src="images/Git/merge3.png" alt="merge3.png"></p><p>这次，Git 没有简单地把分支指针右移，而是对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（C6）（见图 3-17）。这个提交对象比较特殊，它有两个祖先（C4 和 C5）。</p><p>值得一提的是 Git 可以自己裁决哪个共同祖先才是最佳合并基础；这和 CVS 或 Subversion（1.5 以后的版本）不同，它们需要开发者手工指定合并基础。所以此特性让 Git 的合并操作比其他系统都要简单不少。</p><p><img src="images/Git/mergeAutoCommit.png" alt="mergeAutoCommit.png"></p><p>此时<kbd>iss53</kbd>没用了，可以删除。</p><h2 id="9-9-分支管理"><a href="#9-9-分支管理" class="headerlink" title="9.9. 分支管理"></a>9.9. 分支管理</h2><p><strong>查看所有分支</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">    iss53</span><br><span class="line">    * master</span><br><span class="line">    testing</span><br></pre></td></tr></table></figure><p><code>git branch</code> 命令不加参数列出所有分支。 <kbd>master</kbd> 分支前的 <kbd>*</kbd> 字符表示当前所在的分支。也就是说如果现在提交更新，<kbd>master</kbd> 分支将随着开发进度前移。</p><p><strong>查看各分支最后一个 commit 对象的信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -v</span></span><br></pre></td></tr></table></figure><p><strong>查看与HEAD已合并/或未合并分支</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看已并入当前分支的==哪些分支是当前分支的直接上游</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --merged</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看尚未合并的</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --no-merged</span></span><br></pre></td></tr></table></figure><p>对于已合并的，可以用<code>git branch -d</code>直接删除，不会有损失。<br>对于已合并的，用<code>git branch -d</code>删除会报错，因为这样做会丢失数据，除非<kbd>-D</kbd>强制删除。</p><h2 id="9-10-远程分支"><a href="#9-10-远程分支" class="headerlink" title="9.10. 远程分支"></a>9.10. 远程分支</h2><p>用<kbd>remote-name/remote-branch-name</kbd>描述远程分支，区别于本地分支。</p><p>在第一次<code>git clone</code>之后，下载的数据命名为<kbd>origin/master</kbd>，无法修改。之后 Git 创建属于本地的 <kbd>master</kbd> 分支，二者都指向远程<kbd>origin</kbd>的<kbd>master</kbd>分支。<br><img src="images/Git/remoteBranch1.png" alt="remoteBranch1.png"></p><p>如果在本地 <kbd>master</kbd> 分支做了些改动，在本地的提交历史正朝向不同方向发展，与此同时，其他人向 git.ourcompany.com 推送了他们的更新，服务器上的 <kbd>master</kbd> 分支就会向前推进。不过只要不和服务器通讯，本地的 <kbd>origin/master</kbd> 指针仍然保持原位不会移动。<br><img src="images/Git/remoteBranch2.png" alt="remoteBranch2.png"></p><p>可以运行 <code>git fetch origin</code> 来同步远程服务器上的数据到本地。从 origin 上获取尚未拥有的数据，更新你本地的数据库，然后把 <kbd>origin/master</kbd> 的指针移到最新位置。<br><img src="images/Git/remoteBranch3.png" alt="remoteBranch3.png"></p><p>假设，还有另一个仅供你的敏捷开发小组使用的内部服务器 git.team1.ourcompany.com。加为当前项目的远程分支之一，并命名为 teamone。</p><p>现在可以用 <code>git fetch teamone</code> 来获取小组服务器上你还没有的数据了。由于当前该服务器上的内容是你 <kbd>origin</kbd> 服务器上的子集，Git 不会下载任何数据，而只是简单地创建一个名为 <kbd>teamone/master</kbd> 的远程分支，指向 teamone 服务器上 <kbd>master</kbd> 分支所在的提交对象 <kbd>31b8e</kbd>。<br><img src="images/Git/remoteBranch4.png" alt="remoteBranch4.png"></p><p><kbd>master</kbd>并不是多么神秘复杂的东西，分清楚远程的别人的<kbd>origin/master</kbd>、本地的别人的<kbd>origin/master</kbd>、本地的自己的<kbd>master</kbd>就可以了。</p><h2 id="9-11-推送本地分支"><a href="#9-11-推送本地分支" class="headerlink" title="9.11. 推送本地分支"></a>9.11. 推送本地分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;remote-name&gt; &lt;branch-name&gt;</span></span><br></pre></td></tr></table></figure><p>要想和其他人分享某个本地分支，你需要把它推送到一个你拥有<strong>写权限</strong>的远程仓库。你创建的本地分支不会因为你的写入操作而被自动同步到你引入的远程服务器上，你需要明确地执行推送分支的操作。</p><p><code>git push origin serverfix:serverfix</code>意思是“上传我本地的 <kbd>serverfix</kbd> 分支到远程仓库中去，仍旧称它为 <kbd>serverfix</kbd> 分支”。通过此语法，你可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫作 <kbd>awesomebranch</kbd>，可以用 <code>git push origin serverfix:awesomebranch</code> 来推送数据。</p><h2 id="9-12-跟踪远程分支"><a href="#9-12-跟踪远程分支" class="headerlink" title="9.12. 跟踪远程分支"></a>9.12. 跟踪远程分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b &lt;branch-name&gt; &lt;remote-name/branch-name&gt;</span></span><br></pre></td></tr></table></figure><p>从远程分支 <code>checkout</code> 出来的本地分支，称为<strong>跟踪分支</strong> (tracking branch)。跟踪分支是一种和某个远程分支有直接联系的本地分支。在跟踪分支里输入 <code>git push</code>，Git 会自行推断应该向哪个服务器的哪个分支推送数据。</p><h2 id="9-13-删除远程分支"><a href="#9-13-删除远程分支" class="headerlink" title="9.13. 删除远程分支"></a>9.13. 删除远程分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;remote-name&gt; :&lt;branch-name&gt;</span></span><br></pre></td></tr></table></figure><p>对于<code>git push &lt;remote-name&gt; &lt;local-branch-name&gt;:&lt;remote-branch-name&gt;</code> 语法，如果省略 <local-branch-name>，那就等于是在说“在这里提取空白然后把它变成<remote-branch-name>”。</p><h2 id="9-14-分支衍合"><a href="#9-14-分支衍合" class="headerlink" title="9.14. 分支衍合"></a>9.14. 分支衍合</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout &lt;rebase-branch-name&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rebase &lt;master-branch-name&gt;</span></span><br></pre></td></tr></table></figure><p>把一个分支中的修改整合到另一个分支有两种办法：<code>merge</code> 和 <code>rebase</code>。<br><strong>merge</strong><br><img src="images/Git/merge.png" alt="merge.png"></p><p><strong>rebase</strong><br>还有可以把在 C3 里产生的变化补丁在 C4 的基础上重新打一遍，这种操作叫做衍合（rebase）。即把在一个分支里提交的改变移到另一个分支里重放一遍。</p><p>原理是回到两个分支最近的共同祖先，根据当前分支（也就是要进行衍合的分支 <kbd>experiment</kbd>）后续的历次提交对象（这里只有一个 C3），生成一系列文件补丁，然后以基底分支（也就是主干分支 <kbd>master</kbd>）最后一个提交对象（C4）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（C3’），从而改写 <kbd>experiment</kbd> 的提交历史，使它成为 <kbd>master</kbd> 分支的直接下游：<br><img src="images/Git/rebase.png" alt="rebase.png"></p><p>再进行快进合并：<br><img src="images/Git/speedMerge.png" alt="speedMerge.png"></p><p>现在的 C3’ 对应的快照，其实和普通的三方合并，即 C5 对应的快照内容一模一样，结果没有任何区别，只不过提交历史不同。但衍合能产生一个更为整洁的提交历史，仿佛所有修改都是在一根线上先后进行的。</p><p>一般我们使用衍合的目的，是想要得到一个能在远程分支上干净应用的补丁。项目志愿开发者通过衍合提交，维护者就不需要做任何整合工作。实际上是把解决分支补丁同最新主干代码之间冲突的责任，化转为由提交补丁的人来解决。</p><p>衍合是按照每行的修改次序重演一遍修改，而合并是把最终结果合在一起。</p><h1 id="10-参考链接"><a href="#10-参考链接" class="headerlink" title="10. 参考链接"></a>10. 参考链接</h1><ul><li><a href="https://git-scm.com/docs">Git官方参考文档</a></li><li><a href="http://git.oschina.net/progit/">Pro Git（中文版）</a></li><li><a href="https://www.cnblogs.com/syp172654682/p/7689328.html">深入浅出Git教程</a></li><li><a href="https://www.cnblogs.com/yaozhongxiao/p/3811130.html">Git图解剖析</a></li><li><a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的官方网站</a></li><li><a href="https://www.runoob.com/git/">菜鸟教程</a></li><li><a href="https://www.cnblogs.com/kevingrace/p/5690241.html">Git忽略提交规则 - .gitignore配置运维总结</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Git是目前世界上最先进的分布式版本控制系统（没有之一）。&lt;/p&gt;</summary>
    
    
    
    <category term="Tool" scheme="https://memorykk.cn/categories/Tool/"/>
    
    
    <category term="Git" scheme="https://memorykk.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>记一次博客接入Gitalk出现403问题的解决过程</title>
    <link href="https://memorykk.cn/gitalk-403.html"/>
    <id>https://memorykk.cn/gitalk-403.html</id>
    <published>2021-02-14T01:44:16.000Z</published>
    <updated>2021-02-19T08:45:30.462Z</updated>
    
    <content type="html"><![CDATA[<p>小站的评论系统始终无法接入 Gitalk，提示 403 Error</p><span id="more"></span><hr><p><strong>目录</strong></p><ul><li><a href="#%E9%97%AE%E9%A2%98">问题</a></li><li><a href="#%E6%88%91%E7%9A%84%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B">我的解决过程</a></li><li><a href="#%E5%85%B6%E4%BB%96%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B">其他解决过程</a><ul><li><a href="#%E8%B5%B7%E5%9B%A0">起因</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E7%BB%8F%E9%AA%8C">经验</a></li></ul></li><li><a href="#%E9%83%A8%E7%BD%B2%E8%87%AA%E5%B7%B1%E7%9A%84CORSproxy">部署自己的 CORSproxy</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li></ul><hr><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>最近博客接入 Gitalk 评论系统时，始终报错 403，不知所以，无奈转至 LeanCloud 的 valine comment，但 valine 的风格总让人感觉不够优雅 ╯︿╰。</p><p>报错界面：<img src="/images/gitalk-403/no-issue.PNG" class="" title="no-issue" alt="no-issue"></p><p>点击 <kbd>使用 GitHub 登录</kbd> 之后，显示 Error：<img src="/images/gitalk-403/403.PNG" class="" title="403" alt="403"></p><h1 id="我的解决过程"><a href="#我的解决过程" class="headerlink" title="我的解决过程"></a>我的解决过程</h1><ol><li><p>打开 <kbd>F12</kbd> 控制台，刷新页面，查看出错的 Header：<img src="/images/gitalk-403/f12.PNG" class="" title="f12" alt="f12"></p></li><li><p>触及到知识盲区了。这个 URL 尽管没见过，但两个地址套起来的形式很有特点，习惯性地打开前面的<a href="https://cors-anywhere.herokuapp.com/">链接</a>，展示如下：<img src="/images/gitalk-403/core.PNG" class="" title="core" alt="core"></p></li></ol><p>大意是：CORS Anywhere 这是个实现跨域请求的 Demo，单击按钮临时解锁对演示的访问。</p><p>So，我被加锁了？</p><ol start="3"><li>打开<a href="https://github.com/Rob--W/cors-anywhere/issues/301">提示的参考链接</a>，这个 CORS Anywhere 的作者说：</li></ol><blockquote><p>Public demo server (cors-anywhere.herokuapp.com) will be very limited by January 2021, 31st #301<br>The user (developer) must visit a page at cors-anywhere.herokuapp.com to temporarily unlock the demo for their browser. This allows developers to try out the functionality, to help with deciding on self-hosting or looking for alternatives.</p></blockquote><p>意思是 CORS Anywhere 这个 Demo 被滥用，从 2021/1/31 开始限制，用户必须访问<a href="cors-anywhere.herokuapp.com">页面</a><strong>临时</strong>解锁。</p><ol start="4"><li><p>虽然这只是个临时解决方案，但当时没想太多，能用就行。<img src="/images/gitalk-403/requestTemp.PNG" class="" title="requestTemp" alt="requestTemp"></p></li><li><p>Gitalk 也确实正常工作了。</p></li></ol><h1 id="其他解决过程"><a href="#其他解决过程" class="headerlink" title="其他解决过程"></a>其他解决过程</h1><p>在 GitHub 上寻找相关 Issues 时看见这位大神的解决过程，自愧不如，经原作者同意之后搬运过来，特别是解决思路让我很受启发。以下是原文：</p><hr><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>我的博客最近刚换上了 hexo 框架，于是评论功能就换成了 Gitalk。但最近发现登录功能不好用了，点击使用 GitHub 登录总是失败。</p><p>就点击这个按钮的时候，始终登录不上去：</p><p><img src="https://qiniu.cuiqingcai.com/n79m6.png" alt="image-20210212223917778"></p><p>于是我就想着手解决一下这个问题。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里就记录一下我在排查过程中碰到的一些坑和解决思路。</p><p>首先，登录失败的问题，第一时间应该去排查的就是网络请求，打开控制台，查看 Network 面板，出现类似的结果：</p><p><img src="https://qiniu.cuiqingcai.com/4d8sw.png" alt="image-20210212224407613"></p><p>网络请求直接 403 了，拿不到 token 了，于是就登录不上了。</p><p>观察下，这个链接 cors-anywhere 似乎是用来解决跨域限制的，后面还跟了一个 GitHub 的 Access Token 获取地址，那没跑了，前面这个就是一个反向代理，后面是真实的请求 URL。</p><p>OK，看着这个也没啥思路啊，然后接着怎么办？</p><p>那就接着去搜这个 cors-anywhere.herokuapp.com，因为 herokuapp 很眼熟嘛，就是一个公用的网址 Host 平台，类似于 AWS、Azure 之类的，那么前面这个可能包含某些信息。万一是开源的那就好办了。</p><p>接着搜，cors-anywhere，然后就搜到了这个：<a href="https://github.com/Rob--W/cors-anywhere">https://github.com/Rob–W/cors-anywhere</a></p><p>介绍如下：</p><blockquote><p><strong>CORS Anywhere</strong> is a NodeJS proxy which adds CORS headers to the proxied request.</p><p>The url to proxy is literally taken from the path, validated and proxied. The protocol part of the proxied URI is optional, and defaults to “http”. If port 443 is specified, the protocol defaults to “https”.</p><p>This package does not put any restrictions on the http methods or headers, except for cookies. Requesting <a href="http://www.w3.org/TR/cors/#user-credentials">user credentials</a> is disallowed. The app can be configured to require a header for proxying a request, for example to avoid a direct visit from the browser.</p></blockquote><p>真是一个开源框架，和我猜的一样，就是一个解决跨域问题而生的反向代理。</p><p>然后我就在它的 README 中看到了这个：</p><p><img src="https://qiniu.cuiqingcai.com/e9xla.png" alt="image-20210212224946845"></p><p>好家伙，这不就是我刚才用到的链接吗？</p><p>那肯定是这个玩意出了什么毛病。</p><p>咋看呢？这个果断就是找 Issue 了：</p><p><img src="https://qiniu.cuiqingcai.com/yyu6t.png" alt="image-20210212225114466"></p><p>一看，太明显了：</p><blockquote><p>PSA: Public demo server (cors-anywhere.herokuapp.com) will be very limited by January 2021, 31st</p></blockquote><p>意思就是从今年 1.31 开始这个网站的访问会受限，点进去看看：</p><blockquote><p>The demo server of CORS Anywhere (cors-anywhere.herokuapp.com) is meant to be a demo of this project. But abuse has become so common that the platform where the demo is hosted (Heroku) has asked me to shut down the server, despite efforts to counter the abuse (rate limits in <a href="https://github.com/Rob--W/cors-anywhere/issues/45">#45</a> and <a href="https://github.com/Rob--W/cors-anywhere/issues/164">#164</a>, and blocking other forms of requests). Downtime becomes increasingly frequent (e.g. recently <a href="https://github.com/Rob--W/cors-anywhere/issues/300">#300</a>, <a href="https://github.com/Rob--W/cors-anywhere/issues/299">#299</a>, <a href="https://github.com/Rob--W/cors-anywhere/issues/295">#295</a>, <a href="https://github.com/Rob--W/cors-anywhere/issues/294">#294</a>, <a href="https://github.com/Rob--W/cors-anywhere/issues/287">#287</a>) due to abuse and its popularity.</p><p>To counter this, I will make the following changes:</p><ol><li> The rate limit will decrease from 200 (<a href="https://github.com/Rob--W/cors-anywhere/issues/164">#164</a>) per hour to 50 per hour.</li><li> By January 31st, 2021, cors-anywhere.herokuapp.com will stop serving as an open proxy.</li><li> From February 1st. 2021, cors-anywhere.herokuapp.com will only serve requests after the visitor has completed a challenge: The user (developer) must visit a page at cors-anywhere.herokuapp.com to temporarily unlock the demo for their browser. This allows developers to try out the functionality, to help with deciding on self-hosting or looking for alternatives.</li></ol></blockquote><p>好吧，意思就是说这个网站本来是演示用的，但是现在已经被滥用了，然后从 1.31 开始用户手动必须手动先访问这个网站获取临时的访问权限，然后才能使用。另外推荐开发者自己来维护一个网站。</p><p>接着下面的评论第一个就更滑稽了：</p><p><img src="https://qiniu.cuiqingcai.com/7d55t.png" alt="image-20210212225414735"></p><p>这个人直接艾特了 gitalk，哈哈哈，因为 Gitalk 就如刚才所说的那样，也用了这个。</p><p>那就顺便去 Gitalk <a href="https://github.com/gitalk/gitalk%EF%BC%8C%E9%80%9B%E4%B8%80%E4%B8%8B">https://github.com/gitalk/gitalk，逛一下</a> issue，看看是不是也有人遇到了同样的问题，果不其然了：</p><p><img src="https://qiniu.cuiqingcai.com/s7bn5.png" alt="image-20210212225919986"></p><p>最近几个 issue 都是关于 403 的，真热闹。</p><p>点进去看看，有个大收获，里面有个好心人说：</p><blockquote><p>这次直接去嫖了一个 CORS proxy,把 gitalk.js 的 6794 行改为 proxy: ‘<a href="https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access_token">https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access_token</a>‘, 就可以了。具体能用多久我也没普，且用且珍惜。</p></blockquote><p>真是得来全不费功夫，本来还想着自己部署着，这次那就换了就行了。</p><p>然而，这样不行，得需要改 gitalk.js 的源码，并不太好吧。</p><p>好，这时候就遇到了一个问题，要修改某些开源软件的源码应该怎么办？</p><p>首选的思路当然不是硬改，改了之后还要自己 host 一个新的 js 文件，那显然是很费精力的。</p><p>其实一半程序在编写的时候应该是预留一些接口和配置的，我们应该能很轻易地通过某些配置就能实现某些配置的复写。</p><p>那就接着看看吧，既然要改，那就得先看看 Gitalk 是怎么用的吧。</p><p>看文档，Gitalk 调用方式如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">const gitalk = new Gitalk(&#123;  </span><br><span class="line"> clientID: &#x27;GitHub Application Client ID&#x27;,  </span><br><span class="line"> clientSecret: &#x27;GitHub Application Client Secret&#x27;,  </span><br><span class="line"> repo: &#x27;GitHub repo&#x27;, // The repository of store comments,  </span><br><span class="line"> owner: &#x27;GitHub repo owner&#x27;,  </span><br><span class="line"> admin: \[&#x27;GitHub repo owner and collaborators, only these guys can initialize github issues&#x27;\],  </span><br><span class="line"> id: location.pathname, // Ensure uniqueness and length less than 50  </span><br><span class="line"> distractionFreeMode: false // Facebook-like distraction free mode  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gitalk.render(&#x27;gitalk-container&#x27;)</span><br></pre></td></tr></table></figure><p>看来这个在声明的时候是有参数的，那刚才 URL 配置没看到在哪里配啊，既然如此，那就看看 Gitalk 这个对象支持多少参数吧。</p><p>接着就去找 Gitalk 的构造参数说明，找到这么一个：</p><ul><li>proxy：<code>String</code></li></ul><p>Default: <code>https://cors-anywhere.herokuapp.com/https://github.com/login/oauth/access_token</code>.</p><p>果然找到了，所以这里如果我们要修改，那就改 proxy 参数就行了，初始化 Gitalk 的时候复写掉 proxy 就行。</p><p>OK，基本思路有了，那我怎么改到我的源码里呢？</p><p>我的博客是基于 Hexo 的 Next 主题的，根据经验，Gitalk 是 Next 主题自带的，所以 Gitalk 的声明应该就在 Next 主题源码里面。</p><p>那怎么找呢？</p><p>这时候就需要借助于一些搜索技巧了，搜什么？既然要用 Gitalk，那一定有刚才初始化的调用，那就搜 Gitalk 这个关键字就行了。另外还需要缩小一下搜索范围。</p><p>于是我就把范围限定到了 next 主题目录，搜索 Gitalk。</p><p><img src="https://qiniu.cuiqingcai.com/ey8tq.png" alt="image-20210212230931998"></p><p>简直不要太舒服，一搜就有了，文件是 themes/next/layout/_third-party/comments/gitalk.swig。</p><p>这里我们只需要把 proxy 参数加上不就行了，值是什么呢？仿照写就行了，配置风格保持统一，那就加一条：</p><p>1</p><p>proxy : ‘‘,</p><p>OK，那这个配置的值很明显是主题配置文件，那就把配置文件里面加上 proxy 这个参数就好了。</p><p>找到 themes/next/_config.yml，添加行：</p><p>1</p><p>proxy: <a href="https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access/_token">https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access\_token</a></p><p>结果如下：</p><p><img src="https://qiniu.cuiqingcai.com/nnb1f.png" alt="image-20210212231224403"></p><p>好了，大功告成！</p><p>重新部署 Hexo，现在评论又能重新使用了，问题就解决了！</p><p>测试地址：<a href="https://cuiqingcai.com/message/%EF%BC%8C%E5%A4%A7%E5%AE%B6%E6%9D%A5%E7%BB%99%E6%88%91%E7%95%99%E8%A8%80%E5%90%A7%EF%BD%9E">https://cuiqingcai.com/message/，大家来给我留言吧～</a></p><p>好了，这就是我排查问题的整个过程，做一下记录。</p><h2 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h2><p>另外，其实这篇文章的用意不仅仅是单纯解决这个问题，因为这个问题大家可能并没有遇到过，因此这个解决方案仅仅是给极少数遇到这个问题的朋友提供的。</p><p>但是，这并不代表这篇文章没有价值，因为其中有的思路是通用的，在这里稍微做一下总结，希望对大家有帮助：</p><ul><li>当遇到网页功能异常的时候，排查问题就主要看两个——控制台、网络请求，这里面往往能找到主要问题。</li><li>结合一些基本知识进行合理的推断，比如刚才我就推断了 cors- anywhere 的作用并结合 herokuapp 推断这个可能还会是个公用的服务。</li><li>当碰到没有思路或者不确定的时候，去谷歌它！不要百度，另外还可以在 GitHub 或者 Gitee 上搜。</li><li>如果找到对应的 GitHub 仓库，Issue 区往往能找到一些有效答案，比如刚才我就在 Issue 区找到了一个可替代的 cors 网站。</li><li>修改代码功能的时候要想着尽量复写，也就是 overwrite，而不是直接改，前者更具有灵活性，而且某些情况下会省去一些麻烦。</li><li>复写的时候去找一些参数配置，比如找一些初始化参数、默认参数配置，看看能否实现改写的需求。</li><li>找不到入口的时候善用全局搜索功能，比如刚才 Gitalk 找哪里调用的时候，就直接全局搜索。</li><li>根据功能限制某些搜索范围，比如刚才我就知道 Gitalk 这个功能是 Next 主题提供的，所以我就直接限制搜索范围是 Next 主题的源码。</li><li>以上步骤多尝试，熟能生巧。</li></ul><hr><h1 id="部署自己的-CORSproxy"><a href="#部署自己的-CORSproxy" class="headerlink" title="部署自己的 CORSproxy"></a>部署自己的 CORSproxy</h1><p>就在我以为一切都要结束的时候，我看到了这个评论，兴趣来了！</p><img src="/images/gitalk-403/baipiao.PNG" class="" title="baipiao" alt="baipiao"><p>参考步骤：</p><ol><li><a href="https://dash.cloudflare.com/">注册 CloudFlare 账号</a></li><li><a href="https://workers.cloudflare.com/">building Worker</a></li><li><a href="https://github.com/Zibri/cloudflare-cors-anywhere">上传代码</a></li></ol><p>然而我卡在了第一步，DNS 设置 CF 的名称服务器一直验证不通过。。。</p><img src="/images/gitalk-403/cfCheck.PNG" class="" width="50" height="50" title="cfCheck" alt="cfCheck"><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://cuiqingcai.com/30010.html">Gitalk 评论登录 403 问题解决</a> 精觅-崔庆才的个人站点.</li><li><a href="https://github.com/Rob--W/cors-anywhere/issues/301">PSA: Public demo server (cors-anywhere.herokuapp.com) will be very limited by January 2021, 31st #301</a></li><li><a href="https://github.com/gitalk/gitalk/issues/428">使用 Github 登录后，提示 403 错误 #428</a></li><li><a href="https://github.com/Zibri/cloudflare-cors-anywhere">cloudflare-cors-anywhere</a></li><li><a href="https://blog.csdn.net/u012424449/article/details/103068412">一分钟教程：利用 cloudflare worker 搭建在线代理—-jsproxy</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;小站的评论系统始终无法接入 Gitalk，提示 403 Error&lt;/p&gt;</summary>
    
    
    
    <category term="Log" scheme="https://memorykk.cn/categories/Log/"/>
    
    
    <category term="Gitalk" scheme="https://memorykk.cn/tags/Gitalk/"/>
    
  </entry>
  
  <entry>
    <title>Hexo中Markdown语法失效问题</title>
    <link href="https://memorykk.cn/Hexo-Markdown-nonsupport.html"/>
    <id>https://memorykk.cn/Hexo-Markdown-nonsupport.html</id>
    <published>2021-02-13T06:20:06.000Z</published>
    <updated>2021-02-19T06:11:39.188Z</updated>
    
    <content type="html"><![CDATA[<p>在Hexo站上用Markdown写博时发现好多语法失效问题，记录一下</p><span id="more"></span><hr><p><strong>目录</strong></p><ul><li><a href="#1-%E8%A1%A8%E6%A0%BC%E7%9B%B4%E6%8E%A5%E4%BB%A5%E6%BA%90%E7%A0%81%E6%98%BE%E7%A4%BA%E6%97%A0%E6%B8%B2%E6%9F%93">1.表格直接以源码显示无渲染</a></li><li><a href="#2-lt-kbd-gt-%E6%97%A0%E6%A0%B7%E5%BC%8F">2.&lt;kbd&gt;无样式</a></li><li><a href="#3-%E6%8F%92%E5%85%A5-lt-table-gt-%E4%B8%8D%E6%B8%B2%E6%9F%93">3.插入&lt;table&gt;不渲染</a></li><li><a href="#4-%E6%8F%92%E5%85%A5HTML%E6%A0%87%E7%AD%BE%E4%BA%A7%E7%94%9F%E5%A4%A7%E9%87%8F%E6%8D%A2%E8%A1%8C">4.插入HTML标签产生大量换行</a></li><li><a href="#5-%E7%9B%AE%E5%BD%95%E8%B7%B3%E8%BD%AC%E6%97%A0%E5%8F%8D%E5%BA%94">5.目录跳转无反应</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul><hr><h2 id="1-表格直接以源码显示无渲染"><a href="#1-表格直接以源码显示无渲染" class="headerlink" title="1.表格直接以源码显示无渲染"></a>1.表格直接以源码显示无渲染</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>| 左对齐 | 右对齐 | 居中对齐 |<br>| :—-| —-: | :——: |<br>| 单元格aaaaaaaaaa | 单aaaaaaaaaaaaaa元格 | 单元aaaaaaaaaaa格 |<br>| 单元格 | 单元格 | 单元格 |<br>| 单 | 单 | 单 |  </p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul><li>表格和正文之间空两行。  </li><li>Markdown中生成的表格十分简洁，这倒也符合快速的特点，如果想自定义样式，通过嵌入css实现，例如本例。  </li><li>我使用的Hacker主题，通用样式文件存放在themes\Hacker\source\css\base\normalize.css，对这种通用性的追加即可，其他主题同理。</li></ul><table><thead><tr><th align="left">居中对齐</th><th align="right">对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单</td><td align="right">单</td><td align="center">单</td></tr></tbody></table><h3 id="待解决"><a href="#待解决" class="headerlink" title="待解决"></a>待解决</h3><p>  表格正常显示之后，对齐方式却不生效，网上没找到和我一样问题的，不过这个需求也不大，或许只能通过css解决。</p><h2 id="2-lt-kbd-gt-无样式"><a href="#2-lt-kbd-gt-无样式" class="headerlink" title="2.&lt;kbd&gt;无样式"></a>2.&lt;kbd&gt;无样式</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>比如这个kbd标签，Ctrl ，看起来很不明显有没有，大概率本来就这样，但是我一开始希望它是这样：<block style="display:inline-block;"><img src="/images/Hexo-Markdown-nonsupport/ctrl.PNG" class="" width="50" height="50" title="ctrl" alt="ctrl"></block></p><blockquote><p>提示: &lt;kbd&gt; 标签已废弃，不推荐使用，但是可以通过CSS实现丰富的效果。<br>——<a href="https://www.runoob.com/tags/tag-kbd.html">HTML&lt;kbd&gt;标签</a></p></blockquote><h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><p>因为我感觉这个会很常用，但我给它加了css样式，还不错。<kbd>Ctrl</kbd></p><h2 id="3-插入-lt-table-gt-不渲染"><a href="#3-插入-lt-table-gt-不渲染" class="headerlink" title="3.插入&lt;table&gt;不渲染"></a>3.插入&lt;table&gt;不渲染</h2><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>我在HTML里面测试好table，再将整个&lt;table&gt;&lt;/table&gt;粘贴到VSC的md文件中，但是这时HTML标签不渲染，直接以源码显示。</p><h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><ul><li>先在md中手写&lt;table&gt;&lt;/table&gt;这两个标签，再将table里面的内容粘过去，不要开始和结束标签。</li><li>或者可能是HTML代码中有空行！</li></ul><h2 id="4-插入HTML标签产生大量换行"><a href="#4-插入HTML标签产生大量换行" class="headerlink" title="4.插入HTML标签产生大量换行"></a>4.插入HTML标签产生大量换行</h2><h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><p>插入HTML标签产生大量换行</p><h3 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h3><p>将HTML标签之间的空格删除，也就是写到一行中。</p><h2 id="5-目录跳转无反应"><a href="#5-目录跳转无反应" class="headerlink" title="5.目录跳转无反应"></a>5.目录跳转无反应</h2><h3 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h3><p>因为本主题（或是别的问题）不会生成文章目录结构，所以我一般写完后用MarkdownAllinOne生成目录，但是点击无反应，不跳转。</p><h3 id="解决-4"><a href="#解决-4" class="headerlink" title="解决"></a>解决</h3><ul><li><p>首先标题里不能有符号<br>如果标题为”&amp;总结”，但MarkdownAllinOne生成目录自动链接到”#总结”，Hexo渲染出的HTML源码却是：</p><p><code>&lt;h2 id=&quot;amp-总结&quot;&gt;&lt;a href=&quot;#amp-总结&quot; class=&quot;headerlink&quot; title=&quot;&amp;amp;总结&quot;&gt;&lt;/a&gt;&amp;amp;总结&lt;/h2&gt;</code></p><p>这样看来，”#amp-总结”才是正确跳转。</p></li><li><p>若大小写原因，关闭MarkdownAllinOne扩展的自动转换小写选项<br>去<kbd>扩展设置</kbd>里关闭。  </p><p><img src="/images/Hexo-Markdown-nonsupport/mdPlugin1.PNG" alt="mdPlugin2.PNG"></p><p><em><strong>（！这不是必须的，只是为了方便，顺便关闭自动更新目录）</strong></em></p><p><img src="/images/Hexo-Markdown-nonsupport/mdPlugin2.PNG" alt="mdPlugin1.PNG"></p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关键还得搞清楚Hexo生成的是静态页面这个大方向，然后根据自己想法发挥。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Hexo站上用Markdown写博时发现好多语法失效问题，记录一下&lt;/p&gt;</summary>
    
    
    
    <category term="Log" scheme="https://memorykk.cn/categories/Log/"/>
    
    
    <category term="Markdown" scheme="https://memorykk.cn/tags/Markdown/"/>
    
    <category term="Hexo" scheme="https://memorykk.cn/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Markdown</title>
    <link href="https://memorykk.cn/Markdown.html"/>
    <id>https://memorykk.cn/Markdown.html</id>
    <published>2021-02-13T02:52:04.000Z</published>
    <updated>2021-02-13T11:47:47.155Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown是一种轻量级标记语言，以纯文本格式快速编写文档。</p><span id="more"></span><ul><li>Markdown编写的文档后缀为 .md、.markdown，可以导出HTML、Word、图像、PDF、Epub等多种格式的文档。  </li><li>Hexo、github等支持使用markdown编辑器编写文章，刚好边学边练。</li><li>可以通过css的方式，美化Hexo元素，嵌入style 标签，在生成html时，style标签也随之写入到html页面中，产生自定义效果。</li></ul><hr><p><strong>目录</strong></p><ul><li><a href="#markdown%E8%AF%AD%E6%B3%95">Markdown语法</a><ul><li><a href="#%E6%A0%87%E9%A2%98">标题</a></li><li><a href="#%E5%AD%97%E4%BD%93">字体</a></li><li><a href="#%E6%8D%A2%E8%A1%8C">换行</a></li><li><a href="#%E5%88%86%E9%9A%94%E7%BA%BF">分隔线</a></li><li><a href="#%E8%84%9A%E6%B3%A8">脚注</a></li><li><a href="#%E5%88%97%E8%A1%A8">列表</a></li><li><a href="#%E5%8C%BA%E5%9D%97">区块</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li><li><a href="#%E9%93%BE%E6%8E%A5">链接</a></li><li><a href="#%E5%9B%BE%E7%89%87">图片</a></li><li><a href="#%E8%A1%A8%E6%A0%BC">表格</a></li><li><a href="#%E6%94%AF%E6%8C%81%E7%9A%84html%E5%85%83%E7%B4%A0">支持的HTML元素</a></li><li><a href="#%E8%BD%AC%E4%B9%89">转义</a></li><li><a href="#%E5%85%AC%E5%BC%8F">公式</a></li><li><a href="#%E7%94%BB%E5%9B%BE">画图</a></li></ul></li><li><a href="#markdown%E5%B7%A5%E5%85%B7">Markdown工具</a></li><li><a href="#%E6%8E%A8%E8%8D%90">推荐</a></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><hr><h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用<kbd>#</kbd>标记标题，1-6个<kbd>#</kbd>标识1-6级标题。<br><em>（markdown语法中的关键字之后一般要加一个空格）</em><br>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><ul><li>斜体<br>使用一个<kbd>*</kbd>包起来</li><li>加粗<br>使用两个<kbd>*</kbd>包起来</li><li>斜体加粗<br>使用三个<kbd>*</kbd>包起来</li><li>删除线<br>使用两个<kbd>~</kbd>包起来</li><li>下划线<br>使用HTML的<kbd>&lt;u>&lt;/u></kbd>包起来</li></ul><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*这是倾斜的文字*</span></span><br><span class="line"><span class="strong">**这是加粗的文字**</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*这是斜体加粗的文字<span class="strong">**<span class="emphasis">*</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">~~这是加删除线的文字~~</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>这是加下划线的文字<span class="xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span></span></span></span></span><br></pre></td></tr></table></figure><p>效果如下：<br><em>这是倾斜的文字</em><br><strong>这是加粗的文字</strong><br><em><strong>这是斜体加粗的文字</strong></em><br><del>这是加删除线的文字</del><br><u>这是加下划线的文字</u></p><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>markdown源文件中的回车不会换行，必须使用<kbd>两个空格+回车</kbd>或者<kbd>两个回车</kbd>。</p><p>示例 <em>（注意第一段之后的空格）</em>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一段  </span><br><span class="line">第二段</span><br><span class="line"></span><br><span class="line">第三段</span><br></pre></td></tr></table></figure><p>效果如下：</p><p>第一段<br>第二段</p><p>第三段</p><h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p>在一行中用三个以上的<kbd>*</kbd>、<kbd>-</kbd>、<kbd>_</kbd>来建分隔线，显示效果一致，行内不能有其他东西，但可以在行内插入空格。</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="strong"><span class="emphasis">---</span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong">__<span class="emphasis">_</span></span></span></span></span><br></pre></td></tr></table></figure><p>效果如下：</p><hr><hr><hr><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a><del>脚注</del></h2><p><strong>！貌似无法使用</strong><br>脚注是对文本的补充说明，鼠标悬停即可查看，使用<kbd>[^要注明的文本]</kbd>，在之后任意位置重复<kbd>[^要注明的文本]:补充内容</kbd>。</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Welcome To [^Memorykk&#x27;s Blog]</span><br><span class="line">[<span class="symbol">^Memorykk&#x27;s Blog</span>]: <span class="link">https://memorykk.cn</span></span><br></pre></td></tr></table></figure><p>效果如下：<br>Welcome To [^ Memorykk ]<br>[^ Memorykk ]: <a href="https://memorykk.cn/">https://memorykk.cn</a><br>参考：<img src="https://www.runoob.com/wp-content/uploads/2019/03/md5.gif" alt="参考示例"></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表使用<kbd>*</kbd>、<kbd>+</kbd>、<kbd>-</kbd>标记，追加列表内容，三者无差异。</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> 第一项</span><br><span class="line"><span class="bullet">+</span> 第二项</span><br><span class="line"><span class="bullet">-</span> 第三项</span><br></pre></td></tr></table></figure><p>效果如下：  </p><ul><li>第一项</li></ul><ul><li>第二项</li></ul><ul><li>第三项</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表使用数字+<kbd>.</kbd>标记。</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一项</span><br><span class="line"><span class="bullet">2.</span> 第二项</span><br></pre></td></tr></table></figure><p>效果如下：  </p><ol><li>第一项</li><li>第二项</li></ol><h3 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h3><p>子列表的选项前加四个空格即可。</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一项</span><br><span class="line"><span class="bullet">    *</span> 元素1</span><br><span class="line"><span class="bullet">    *</span> 元素2</span><br><span class="line"><span class="bullet">2.</span> 第二项</span><br><span class="line"><span class="bullet">    -</span> 元素3</span><br><span class="line"><span class="bullet">    -</span> 元素4</span><br></pre></td></tr></table></figure><p>效果如下：  </p><blockquote><ol><li>第一项<ul><li>元素1</li><li>元素2</li></ul></li><li>第二项<ul><li>元素3</li><li>元素4</li></ul></li></ol></blockquote><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>区块使用<kbd>></kbd>标记，追加区块内容。<br>区块支持嵌套，一个<kbd>></kbd>为最外层，两个<kbd>></kbd>为第一层嵌套，以此类推。<br>另外，区块可与列表等随意嵌套。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 1. 第一项</span></span><br><span class="line"><span class="quote">&gt;     <span class="emphasis">* 元素1</span></span></span><br><span class="line"><span class="quote"><span class="emphasis">&gt;     *</span> 元素2</span></span><br><span class="line"><span class="bullet">2.</span> 第二项</span><br><span class="line"><span class="code">    &gt; - 元素3</span></span><br><span class="line"><span class="code">    &gt; - 元素4</span></span><br></pre></td></tr></table></figure><p>效果如下：  </p><blockquote><ol><li>第一项<ul><li>元素1</li><li>元素2</li></ul></li><li>第二项<ul><li>元素3</li><li>元素4</li></ul></li></ol></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="单行代码"><a href="#单行代码" class="headerlink" title="单行代码"></a>单行代码</h3><p>使用一个<kbd>`</kbd>将代码包起来。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">`System.out.println(&quot;Hello World!&quot;);`</span></span><br></pre></td></tr></table></figure><p>效果如下：<br><code>System.out.println(&quot;Hello World!&quot;);</code></p><h3 id="多行代码"><a href="#多行代码" class="headerlink" title="多行代码"></a>多行代码</h3><p>使用六个<kbd>`</kbd>将代码包起来，前三个<kbd>`</kbd>接代码语言，也可不指定。</p><p>示例：<em>（为了防止编辑器转义，在前后加了前后括号，实际使用中不能写哦~）</em></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">（<span class="code">```java</span></span><br><span class="line"><span class="code">System.out.println(&quot;Hello&quot;);</span></span><br><span class="line"><span class="code">System.out.println(&quot;World&quot;);</span></span><br><span class="line"><span class="code">System.out.println(&quot;!&quot;);</span></span><br><span class="line"><span class="code">```）</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;!&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="普通链接"><a href="#普通链接" class="headerlink" title="普通链接"></a>普通链接</h3><p>使用<kbd>[链接名称]</kbd><kbd>(链接地址)</kbd>或者直接<kbd><链接地址></kbd>标记。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">Memorykk&#x27;s Blog</span>](<span class="link">https://memorykk.cn</span>)  </span><br><span class="line"><span class="xml">&lt;https://www.memorykkk.cn&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：<br><a href="https://memorykk.cn/">Memorykk’s Blog</a><br><a href="https://www.memorykkk.cn/">https://www.memorykkk.cn</a></p><h3 id="高级链接"><a href="#高级链接" class="headerlink" title="高级链接"></a>高级链接</h3><p>通过变量来设置一个链接，变量赋值在文档末尾。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这个链接赋给变量1：[<span class="string">Memorykk&#x27;s Blog</span>][<span class="symbol">1</span>]</span><br><span class="line">这个链接赋给变量google：[<span class="string">GOOGLE</span>][<span class="symbol">google</span>]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">1</span>]: <span class="link">https://memorykk.cn</span></span><br><span class="line">[<span class="symbol">google</span>]: <span class="link">https://www.google.com</span></span><br></pre></td></tr></table></figure><p>效果如下：<br>这个链接赋给变量1：<a href="https://memorykk.cn/">Memorykk’s Blog</a><br>这个链接赋给变量google：<a href="https://www.google.com/">GOOGLE</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>使用<kbd>![alt文本]</kbd><kbd>(图片链接 "可选标题")</kbd>标记。<br>markdown不支持指定宽高，可使用HTML &lt;img&gt;标签标记。<br>可以制作图片链接</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">Github.ico</span>](<span class="link">https://github.githubassets.com/favicons/favicon.svg</span>)</span><br></pre></td></tr></table></figure><p>效果如下：<br><img src="https://github.githubassets.com/favicons/favicon.svg" alt="Github.ico"></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>使用<kbd>|</kbd>标记单元格，使用<kbd>-</kbd>分隔表头和其他行，还可设置对其方式：</p><ul><li><kbd>-:</kbd>设置内容和标题栏居右对齐。</li><li><kbd>:-</kbd>设置内容和标题栏居左对齐。</li><li><kbd>:-:</kbd>设置内容和标题栏居中对齐。  </li></ul><hr><ul><li>:之间多余的空格会被忽略</li><li>的数量至少一个</li><li>内容和|之间多余的空格会被忽略</li></ul><p>示例：<em>（但是本页并未生效，Hexo的问题？）</em></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :------| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单 | 单 | 单 |</span><br></pre></td></tr></table></figure><p>效果如下：  </p><p><img src="/images/Markdown/table.PNG" alt="table.PNG"></p><h2 id="支持的HTML元素"><a href="#支持的HTML元素" class="headerlink" title="支持的HTML元素"></a>支持的HTML元素</h2><p>直接在文档里面用 HTML 撰写。<br>目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等。</p><h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符反斜杠<kbd>\</kbd>。<br>目前支持的特殊字符：<br><kbd>\</kbd>、<kbd>`</kbd>、<kbd>*</kbd>、<kbd>_</kbd>、<kbd>{}</kbd>、<kbd>[]</kbd>、<kbd>()</kbd>、<kbd>#</kbd>、<kbd>+</kbd>、<kbd>-</kbd>、<kbd>.</kbd>、<kbd>!</kbd>、<kbd>HTML元素</kbd>。</p><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>使用两个<kbd>$</kbd>包裹 TeX 或 LaTeX 格式的数学公式。<br>提交后会根据需要加载 Mathjax 对数学公式进行渲染。</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\lim<span class="emphasis">_&#123;x \to 0&#125; \frac&#123;3x^2 +7x^3&#125;&#123;x^2 +5x^4&#125; = 3</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><p>效果如下：<br>$$<br>\lim_{x \to 0} \frac{3x^2 +7x^3}{x^2 +5x^4} = 3<br>$$</p><h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><p>参考 <a href="https://www.runoob.com/markdown/md-advance.html">菜鸟教程</a></p><h1 id="Markdown工具"><a href="#Markdown工具" class="headerlink" title="Markdown工具"></a>Markdown工具</h1><p>目前我使用的是Visual Studio Code，默认支持markdown编辑以及即时预览，配合插件十分好用：  </p><ul><li><a href="https://marketplace.visualstudio.com/items?itemName=bierner.markdown-preview-github-styles">Markdown Preview Github Styling</a>：预览您的Markdown在Github上呈现的样子</li><li><a href="https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one">Markdown All in One</a>Markdown所需的全部功能（键盘快捷键、目录、自动预览等）</li></ul><h1 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h1><p>  <a href="Hexo-Markdown-nonsupport.html">Hexo中Markdown语法失效问题</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.runoob.com/markdown">Markdown教程</a></li><li><a href="https://www.jianshu.com/p/191d1e21f7ed">Markdown基本语法</a></li><li><a href="https://javahikers.github.io/2019/05/04/markdown-simple-to-use/">markdown简明使用方法</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Markdown是一种轻量级标记语言，以纯文本格式快速编写文档。&lt;/p&gt;</summary>
    
    
    
    <category term="Tool" scheme="https://memorykk.cn/categories/Tool/"/>
    
    
    <category term="Markdown" scheme="https://memorykk.cn/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://memorykk.cn/hello-world.html"/>
    <id>https://memorykk.cn/hello-world.html</id>
    <published>2021-02-11T15:59:59.000Z</published>
    <updated>2021-02-12T12:09:08.216Z</updated>
    
    <content type="html"><![CDATA[<p>照例写个HelloWorld占好位置。</p><span id="more"></span><p>这里是正文。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;照例写个HelloWorld占好位置。&lt;/p&gt;</summary>
    
    
    
    <category term="Fragment" scheme="https://memorykk.cn/categories/Fragment/"/>
    
    
    <category term="Hexo" scheme="https://memorykk.cn/tags/Hexo/"/>
    
  </entry>
  
</feed>
