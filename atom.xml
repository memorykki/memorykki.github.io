<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Memorykk</title>
  
  <subtitle>never too late to learn</subtitle>
  <link href="https://memorykk.cn/atom.xml" rel="self"/>
  
  <link href="https://memorykk.cn/"/>
  <updated>2021-03-16T07:17:42.382Z</updated>
  <id>https://memorykk.cn/</id>
  
  <author>
    <name>Memorykk</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://memorykk.cn/network-basic.html"/>
    <id>https://memorykk.cn/network-basic.html</id>
    <published>2021-03-14T03:39:36.000Z</published>
    <updated>2021-03-16T07:17:42.382Z</updated>
    
    <content type="html"><![CDATA[<p>概述、物理层、数据链路层、网络层、运输层、应用层。</p><p>70页、5万字，超长总结。</p><span id="more"></span><hr><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#1-%E6%A6%82%E8%BF%B0">1. 概述</a><ul><li><a href="#1-1-%E4%BA%92%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0">1.1. 互联网概述</a></li><li><a href="#1-2-%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E7%BB%84%E6%88%90">1.2. 互联网的组成</a><ul><li><a href="#1-2-1-%E8%BE%B9%E7%BC%98%E9%83%A8%E5%88%86">1.2.1. 边缘部分</a><ul><li><a href="#1-2-1-1-%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%B9%E5%BC%8F">1.2.1.1. 客户-服务器方式</a></li><li><a href="#1-2-1-2-%E5%AF%B9%E7%AD%89%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F">1.2.1.2. 对等连接方式</a></li></ul></li><li><a href="#1-2-2-%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86">1.2.2. 核心部分</a><ul><li><a href="#1-2-2-1-%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2">1.2.2.1. 电路交换</a></li><li><a href="#1-2-2-2-%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2">1.2.2.2. 分组交换</a></li><li><a href="#1-2-2-3-%E6%8A%A5%E6%96%87%E4%BA%A4%E6%8D%A2">1.2.2.3. 报文交换</a></li></ul></li></ul></li><li><a href="#1-3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87">1.3. 计算机网络的性能指标</a><ul><li><a href="#1-3-1-%E9%80%9F%E7%8E%87">1.3.1. 速率</a></li><li><a href="#1-3-2-%E5%B8%A6%E5%AE%BD">1.3.2. 带宽</a></li><li><a href="#1-3-3-%E5%90%9E%E5%90%90%E9%87%8F">1.3.3. 吞吐量</a></li><li><a href="#1-3-4-%E6%97%B6%E5%BB%B6">1.3.4. 时延</a></li><li><a href="#1-3-5-%E6%97%B6%E5%BB%B6%E5%B8%A6%E5%AE%BD%E7%A7%AF">1.3.5. 时延带宽积</a></li><li><a href="#1-3-6-%E5%BE%80%E8%BF%94%E6%97%B6%E9%97%B4RTT">1.3.6. 往返时间RTT</a></li><li><a href="#1-3-7-%E5%88%A9%E7%94%A8%E7%8E%87">1.3.7. 利用率</a></li></ul></li><li><a href="#1-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">1.4. 计算机网络体系结构</a><ul><li><a href="#1-4-1-OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B">1.4.1. OSI七层模型</a><ul><li><a href="#1-4-1-1-%E7%89%A9%E7%90%86%E5%B1%82">1.4.1.1. 物理层</a></li><li><a href="#1-4-1-2-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">1.4.1.2. 数据链路层</a></li><li><a href="#1-4-1-3-%E7%BD%91%E7%BB%9C%E5%B1%82">1.4.1.3. 网络层</a></li><li><a href="#1-4-1-4-%E4%BC%A0%E8%BE%93%E5%B1%82">1.4.1.4. 传输层</a></li><li><a href="#1-4-1-5-%E4%BC%9A%E8%AF%9D%E5%B1%82">1.4.1.5. 会话层</a></li><li><a href="#1-4-1-6-%E8%A1%A8%E7%A4%BA%E5%B1%82">1.4.1.6. 表示层</a></li><li><a href="#1-4-1-7-%E5%BA%94%E7%94%A8%E5%B1%82">1.4.1.7. 应用层</a></li></ul></li><li><a href="#1-4-2-%E6%80%BB%E7%BB%93">1.4.2. 总结</a></li></ul></li></ul></li><li><a href="#2-%E7%89%A9%E7%90%86%E5%B1%82">2. 物理层</a><ul><li><a href="#2-1-%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1">2.1. 数据通信</a><ul><li><a href="#2-1-1-%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F">2.1.1. 数据通信系统</a></li><li><a href="#2-1-2-%E4%BF%A1%E9%81%93">2.1.2. 信道</a></li><li><a href="#2-1-3-%E4%BF%A1%E9%81%93%E7%9A%84%E6%9E%81%E9%99%90%E5%AE%B9%E9%87%8F">2.1.3. 信道的极限容量</a></li></ul></li><li><a href="#2-2-%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B%E7%9A%84%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93">2.2. 物理层下的传输媒体</a></li><li><a href="#2-3-%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF">2.3. 信道复用技术</a></li><li><a href="#2-4-%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF">2.4. 宽带接入技术</a></li></ul></li><li><a href="#3-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">3. 数据链路层</a><ul><li><a href="#3-1-%E4%BD%BF%E7%94%A8%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93">3.1. 使用点对点信道</a><ul><li><a href="#3-1-1-%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98">3.1.1. 三个基本问题</a><ul><li><a href="#3-1-1-1-%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7">3.1.1.1. 封装成帧</a></li><li><a href="#3-1-1-2-%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93">3.1.1.2. 透明传输</a></li><li><a href="#3-1-1-3-%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B">3.1.1.3. 差错检测</a></li></ul></li><li><a href="#3-1-2-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP">3.1.2. 点对点协议PPP</a><ul><li><a href="#3-1-2-1-%E5%8D%8F%E8%AE%AE%E7%BB%84%E6%88%90">3.1.2.1. 协议组成</a></li><li><a href="#3-1-2-2-PPP%E5%B8%A7%E6%A0%BC%E5%BC%8F">3.1.2.2. PPP帧格式</a></li><li><a href="#3-1-2-3-PPP%E5%8D%8F%E8%AE%AE%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81">3.1.2.3. PPP协议工作状态</a></li></ul></li></ul></li><li><a href="#3-2-%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93">3.2. 使用广播信道</a><ul><li><a href="#3-2-1-%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">3.2.1. 局域网的数据链路层</a><ul><li><a href="#3-2-1-1-%E4%BB%A5%E5%A4%AA%E7%BD%91%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%A0%87%E5%87%86">3.2.1.1. 以太网的两个标准</a></li><li><a href="#3-2-1-2-%E9%80%82%E9%85%8D%E5%99%A8">3.2.1.2. 适配器</a></li></ul></li><li><a href="#3-2-2-CSMACD%E5%8D%8F%E8%AE%AE">3.2.2. CSMA/CD协议</a></li><li><a href="#3-2-3-%E4%BD%BF%E7%94%A8%E9%9B%86%E7%BA%BF%E5%99%A8%E7%9A%84%E6%98%9F%E5%BD%A2%E6%8B%93%E6%89%91">3.2.3. 使用集线器的星形拓扑</a></li><li><a href="#3-2-4-%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87">3.2.4. 信道利用率</a></li><li><a href="#3-2-5-MAC%E5%B1%82">3.2.5. MAC层</a><ul><li><a href="#3-2-5-1-MAC%E5%9C%B0%E5%9D%80">3.2.5.1. MAC地址</a></li><li><a href="#3-2-5-2-MAC%E5%B8%A7%E7%9A%84%E6%A0%BC%E5%BC%8F">3.2.5.2. MAC帧的格式</a></li></ul></li><li><a href="#3-2-6-%E6%89%A9%E5%B1%95%E7%9A%84%E4%BB%A5%E5%A4%AA%E7%BD%91">3.2.6. 扩展的以太网</a><ul><li><a href="#3-2-6-1-%E7%89%A9%E7%90%86%E5%B1%82%E6%89%A9%E5%B1%95">3.2.6.1. 物理层扩展</a></li><li><a href="#3-2-6-2-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%89%A9%E5%B1%95">3.2.6.2. 数据链路层扩展</a><ul><li><a href="#3-2-6-2-1-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%89%B9%E7%82%B9">3.2.6.2.1. 交换机特点</a></li><li><a href="#3-2-6-2-2-%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB">3.2.6.2.2. 路由器与交换机的主要区别</a></li><li><a href="#3-2-6-2-3-%E4%BB%A5%E5%A4%AA%E7%BD%91%E7%9A%84%E8%87%AA%E5%AD%A6%E4%B9%A0%E5%8A%9F%E8%83%BD">3.2.6.2.3. 以太网的自学习功能</a></li></ul></li></ul></li></ul></li></ul></li><li><a href="#4-%E7%BD%91%E7%BB%9C%E5%B1%82">4. 网络层</a><ul><li><a href="#4-1-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1">4.1. 网络层提供的两种服务</a></li><li><a href="#4-2-%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AEIP">4.2. 网际协议IP</a><ul><li><a href="#4-2-1-%E5%88%86%E7%B1%BB%E7%9A%84IP%E5%9C%B0%E5%9D%80">4.2.1. 分类的IP地址</a><ul><li><a href="#4-2-1-1-IP%E5%9C%B0%E5%9D%80%E7%9A%84%E8%A1%A8%E7%A4%BA">4.2.1.1. IP地址的表示</a></li><li><a href="#4-2-1-2-%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%89%E7%B1%BBIP%E5%9C%B0%E5%9D%80">4.2.1.2. 常见的三类IP地址</a></li></ul></li><li><a href="#4-2-2-%E7%A7%81%E6%9C%89%E5%9C%B0%E5%9D%80">4.2.2. 私有地址</a></li><li><a href="#4-2-3-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2NAT">4.2.3. 网络地址转换NAT</a></li><li><a href="#4-2-4-DHCP%E5%8D%8F%E8%AE%AE">4.2.4. DHCP协议</a></li><li><a href="#4-2-5-IP%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%9C%B0%E5%9D%80">4.2.5. IP地址与硬件地址</a></li><li><a href="#4-2-6-%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AEARP">4.2.6. 地址解析协议ARP</a><ul><li><a href="#4-2-6-1-%E5%90%8C%E4%B8%80%E5%B1%80%E5%9F%9F%E7%BD%91">4.2.6.1. 同一局域网</a></li><li><a href="#4-2-6-2-%E4%B8%8D%E5%9C%A8%E5%90%8C%E4%B8%80%E5%B1%80%E5%9F%9F%E7%BD%91">4.2.6.2. 不在同一局域网</a></li></ul></li><li><a href="#4-2-7-%E9%80%86%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AERARP">4.2.7. 逆地址解析协议RARP</a></li><li><a href="#4-2-8-IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E6%A0%BC%E5%BC%8F">4.2.8. IP数据报的格式</a></li><li><a href="#4-2-9-IP%E5%B1%82%E8%BD%AC%E5%8F%91%E5%88%86%E7%BB%84%E7%9A%84%E6%B5%81%E7%A8%8B">4.2.9. IP层转发分组的流程</a></li></ul></li><li><a href="#4-3-%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91%E5%92%8C%E6%9E%84%E9%80%A0%E8%B6%85%E7%BD%91">4.3. 划分子网和构造超网</a><ul><li><a href="#4-3-1-%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91">4.3.1. 划分子网</a><ul><li><a href="#4-3-1-1-%E4%B8%89%E7%BA%A7IP%E5%9C%B0%E5%9D%80">4.3.1.1. 三级IP地址</a></li><li><a href="#4-3-1-2-%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81">4.3.1.2. 子网掩码</a></li><li><a href="#4-3-1-3-%E4%BD%BF%E7%94%A8%E5%AD%90%E7%BD%91%E7%9A%84%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91">4.3.1.3. 使用子网的分组转发</a></li></ul></li><li><a href="#4-3-2-%E6%9E%84%E9%80%A0%E8%B6%85%E7%BD%91">4.3.2. 构造超网</a><ul><li><a href="#4-3-2-1-%E7%BD%91%E7%BB%9C%E5%89%8D%E7%BC%80">4.3.2.1. 网络前缀</a></li></ul></li></ul></li><li><a href="#4-4-ICMP%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE">4.4. ICMP网际控制报文协议</a></li><li><a href="#4-5-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE">4.5. 路由选择协议</a><ul><li><a href="#4-5-1-%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AERIP">4.5.1. 内部网关协议RIP</a><ul><li><a href="#4-5-1-1-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">4.5.1.1. 工作原理</a></li><li><a href="#4-5-1-2-%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E7%AE%97%E6%B3%95">4.5.1.2. 距离向量算法</a></li></ul></li><li><a href="#4-5-2-%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AEOSPF">4.5.2. 内部网关协议OSPF</a></li><li><a href="#4-5-3-%E5%A4%96%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AEBGP">4.5.3. 外部网关协议BGP</a></li></ul></li></ul></li><li><a href="#5-%E8%BF%90%E8%BE%93%E5%B1%82">5. 运输层</a><ul><li><a href="#5-1-%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0">5.1. 协议概述</a><ul><li><a href="#5-1-1-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1">5.1.1. 进程之间的通信</a></li><li><a href="#5-1-2-%E4%B8%A4%E4%B8%AA%E4%B8%BB%E8%A6%81%E5%8D%8F%E8%AE%AE">5.1.2. 两个主要协议</a></li><li><a href="#5-1-3-%E7%AB%AF%E5%8F%A3">5.1.3. 端口</a></li></ul></li><li><a href="#5-2-%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AEUDP">5.2. 用户数据报协议UDP</a></li><li><a href="#5-3-%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AETCP%E6%A6%82%E8%BF%B0">5.3. 传输控制协议TCP概述</a><ul><li><a href="#5-3-1-TCP%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9">5.3.1. TCP的主要特点</a></li><li><a href="#5-3-2-TCP%E7%9A%84%E8%BF%9E%E6%8E%A5">5.3.2. TCP的连接</a></li></ul></li><li><a href="#5-4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">5.4. 可靠传输的工作原理</a><ul><li><a href="#5-4-1-%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE">5.4.1. 停止等待协议</a><ul><li><a href="#5-4-1-1-%E6%97%A0%E5%B7%AE%E9%94%99%E6%83%85%E5%86%B5">5.4.1.1. 无差错情况</a></li><li><a href="#5-4-1-2-%E5%87%BA%E7%8E%B0%E5%B7%AE%E9%94%99">5.4.1.2. 出现差错</a></li><li><a href="#5-4-1-3-%E7%A1%AE%E8%AE%A4%E4%B8%A2%E5%A4%B1%E5%92%8C%E7%A1%AE%E8%AE%A4%E8%BF%9F%E5%88%B0">5.4.1.3. 确认丢失和确认迟到</a></li><li><a href="#5-4-1-4-%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87">5.4.1.4. 信道利用率</a></li></ul></li><li><a href="#5-4-2-%E8%BF%9E%E7%BB%ADARQ%E5%8D%8F%E8%AE%AE">5.4.2. 连续ARQ协议</a></li></ul></li><li><a href="#5-5-TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E6%A0%BC%E5%BC%8F">5.5. TCP报文段格式</a></li><li><a href="#5-6-TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0">5.6. TCP可靠传输的实现</a><ul><li><a href="#5-6-1-%E4%BB%A5%E5%AD%97%E8%8A%82%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">5.6.1. 以字节为单位的滑动窗口</a></li><li><a href="#5-6-2-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E7%9A%84%E9%80%89%E6%8B%A9">5.6.2. 超时重传时间的选择</a></li><li><a href="#5-6-3-%E9%80%89%E6%8B%A9%E7%A1%AE%E8%AE%A4SACK">5.6.3. 选择确认SACK</a></li></ul></li><li><a href="#5-7-TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">5.7. TCP的流量控制</a><ul><li><a href="#5-7-1-%E5%88%A9%E7%94%A8%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">5.7.1. 利用滑动窗口实现流量控制</a></li><li><a href="#5-7-2-TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E6%95%88%E7%8E%87">5.7.2. TCP的传输效率</a></li></ul></li><li><a href="#5-8-TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">5.8. TCP的拥塞控制</a><ul><li><a href="#5-8-1-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E4%B8%80%E8%88%AC%E5%8E%9F%E7%90%86">5.8.1. 拥塞控制的一般原理</a></li><li><a href="#5-8-2-TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95">5.8.2. TCP的拥塞控制方法</a><ul><li><a href="#5-8-2-1-%E6%85%A2%E5%BC%80%E5%A7%8B">5.8.2.1. 慢开始</a></li><li><a href="#5-8-2-2-%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D">5.8.2.2. 拥塞避免</a></li><li><a href="#5-8-2-3-%E5%BF%AB%E9%87%8D%E4%BC%A0">5.8.2.3. 快重传</a></li><li><a href="#5-8-2-4-%E5%BF%AB%E6%81%A2%E5%A4%8D">5.8.2.4. 快恢复</a></li><li><a href="#5-8-2-5-%E6%80%BB%E7%BB%93">5.8.2.5. 总结</a></li></ul></li><li><a href="#5-8-3-%E4%B8%BB%E5%8A%A8%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86AQM">5.8.3. 主动队列管理AQM</a></li></ul></li><li><a href="#5-9-TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86">5.9. TCP的连接管理</a><ul><li><a href="#5-9-1-TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B">5.9.1. TCP的连接建立</a></li><li><a href="#5-9-2-TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE">5.9.2. TCP的连接释放</a></li><li><a href="#5-9-3-TCP%E7%9A%84%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA">5.9.3. TCP的有限状态机</a></li></ul></li></ul></li><li><a href="#6-%E5%BA%94%E7%94%A8%E5%B1%82">6. 应用层</a><ul><li><a href="#6-1-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS">6.1. 域名系统DNS</a></li><li><a href="#6-2-%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AE">6.2. 文件传送协议</a><ul><li><a href="#6-2-1-FTP">6.2.1. FTP</a></li><li><a href="#6-2-2-TFTP">6.2.2. TFTP</a></li></ul></li><li><a href="#6-3-%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AEHTTP">6.3. 超文本传送协议HTTP</a><ul><li><a href="#6-3-1-HTTP%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B">6.3.1. HTTP基本过程</a></li><li><a href="#6-3-2-HTTP%E6%8A%A5%E6%96%87">6.3.2. HTTP报文</a><ul><li><a href="#6-3-2-1-HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87">6.3.2.1. HTTP请求报文</a></li><li><a href="#6-3-2-2-HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E6%8A%A5%E6%96%87">6.3.2.2. HTTP响应报文报文</a></li></ul></li><li><a href="#6-3-3-HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB">6.3.3. HTTP协议的区别</a></li><li><a href="#6-3-4-HTTPS">6.3.4. HTTPS</a><ul><li><a href="#6-3-4-1-HTTPS%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">6.3.4.1. HTTPS的工作原理</a></li><li><a href="#6-3-4-2-HTTPS%E5%92%8CHTTP%E7%9A%84%E5%8C%BA%E5%88%AB">6.3.4.2. HTTPS和HTTP的区别</a></li></ul></li><li><a href="#6-3-5-HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6">6.3.5. HTTP缓存机制</a><ul><li><a href="#6-3-5-1-%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98">6.3.5.1. 强制缓存</a></li><li><a href="#6-3-5-2-%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98">6.3.5.2. 协商缓存</a></li><li><a href="#6-3-5-3-%E6%80%BB%E7%BB%93">6.3.5.3. 总结</a></li></ul></li><li><a href="#6-3-6-SESSION%E5%92%8CCOOKIE">6.3.6. SESSION和COOKIE</a></li></ul></li><li><a href="#6-4-%E8%BE%93%E5%85%A5URL%E4%B9%8B%E5%90%8E%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88">6.4. 输入URL之后会发生什么</a><ul><li><a href="#6-4-1-%E5%A4%A7%E7%BA%B2">6.4.1. 大纲</a></li><li><a href="#6-4-2-%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B">6.4.2. 具体过程</a></li></ul></li></ul></li><li><a href="#7-%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">7. 参考链接</a><!-- /TOC --></li></ul><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><h2 id="1-1-互联网概述"><a href="#1-1-互联网概述" class="headerlink" title="1.1. 互联网概述"></a>1.1. 互联网概述</h2><ul><li>三大网：电信网、有线电视网、计算机网络。</li><li>计算机网络：简称为“网络”，由若干结点和连接这些节点的链路组成。</li><li>互连网（internet）：网络通过路由器互连起来构成更大的计算机网络，即“网络的网络”。</li><li>主机：与网络相连的计算机。</li><li>互联网（Internet）：当前全球最大的、开放的、众多网络互连而成的特定互连网，采用TCP/IP协议族作为通信规则。</li><li>互联网服务提供者ISP：商业公司ISP共同拥有整个互联网。</li><li>互联网的多层次ISP结构：主干ISP、地区ISP、本地ISP。</li></ul><p><img src="/images/network-basic/multi-isp.png" alt="multi-isp.png"></p><ul><li>互联网交换点IXP：允许两个网络直接相连并交换分组，而不再需要通过更高层的ISP转发分组，从而加快效率。IXP常采用工作在数据链路层的网络交换机，用局域网连接起来。</li></ul><h2 id="1-2-互联网的组成"><a href="#1-2-互联网的组成" class="headerlink" title="1.2. 互联网的组成"></a>1.2. 互联网的组成</h2><p>从工作方式上看，分为：</p><ul><li>边缘部分：由所有来凝结在互联网上的主机组成，用户直接使用，用来进行通信和资源共享，即资源子网。</li><li>核心部分：由大量网络和连接这些网络的路由器组成，为边缘部分提供连通性和交换，即通信子网。</li></ul><h3 id="1-2-1-边缘部分"><a href="#1-2-1-边缘部分" class="headerlink" title="1.2.1. 边缘部分"></a>1.2.1. 边缘部分</h3><p>连接在互联网上的所有主机又称为“端系统”。端系统之间的通信实质是进程之间的通信。<br>通信方式有两类：客户服务器方式（C/S）、对等方式（P2P）。</p><h4 id="1-2-1-1-客户-服务器方式"><a href="#1-2-1-1-客户-服务器方式" class="headerlink" title="1.2.1.1. 客户-服务器方式"></a>1.2.1.1. 客户-服务器方式</h4><p>描述的是两个应用进程之间服务与被服务的关系。<br>客户是服务请求方，服务器是服务提供方。</p><p><img src="/images/network-basic/cs.png" alt="cs.png"></p><p><strong>客户程序</strong></p><ul><li>被用户调用后运行，通信时主动想S发起请求，C必须知道S的地址；</li><li>不需要特殊的硬件和复杂的OS。</li></ul><p><strong>服务器程序</strong></p><ul><li>系统启动后自动调用并不断运行，被动地等待并接受C请求，可同时处理多个请求；</li><li>一般需要强大的硬件和复杂的OS支持。</li></ul><h4 id="1-2-1-2-对等连接方式"><a href="#1-2-1-2-对等连接方式" class="headerlink" title="1.2.1.2. 对等连接方式"></a>1.2.1.2. 对等连接方式</h4><p>两台主机在通信时不区分哪个是C或S，运行P2P软件即可平等通信，本质上看认识C/S方式。</p><p><img src="/images/network-basic/p2p.png" alt="p2p.png"></p><h3 id="1-2-2-核心部分"><a href="#1-2-2-核心部分" class="headerlink" title="1.2.2. 核心部分"></a>1.2.2. 核心部分</h3><p>起特殊作用的是<strong>路由器</strong>，实现分组交换。<br>三种交换方式：电路交换、报文交换、分组交换。</p><h4 id="1-2-2-1-电路交换"><a href="#1-2-2-1-电路交换" class="headerlink" title="1.2.2.1. 电路交换"></a>1.2.2.1. 电路交换</h4><p>从通信资源的分配角度来看，交换就是按照某种方式动态地分配传输线路的资源。</p><p>在通话之前，必须先拨号请求建立连接，也就是一条专用的物理通路。挂机后，交换机释放刚才使用的这条专用的物理通路。这种必须经过“建立连接（占用通信资源）→通话（一直占用通信资源）→释放连接（归还通信资源）”的交换方式即“电路交换”。</p><p>在通话的全部时间内，通话的两个用户始终占用端到端的通信资源。</p><p><img src="/images/network-basic/circuitSwitch.png" alt="circuitSwitch.png"></p><p>使用电路交换的线路的传输效率十分低。</p><h4 id="1-2-2-2-分组交换"><a href="#1-2-2-2-分组交换" class="headerlink" title="1.2.2.2. 分组交换"></a>1.2.2.2. 分组交换</h4><p>采用存储转发技术，待发送的在整个数据块称为报文，发送之前将报文划分成等长的数据段，再加上必要的控制信息组成的首部构成分组，又称为“包”。</p><p><img src="/images/network-basic/message.png" alt="message.png"></p><p>主机H1向主机H5发送数据。主机H1先将分组逐个地发往与它直接相连的路由器A。此时，除链路H1-A外，其他通信链路并不被目前通信的双方所占用。需要注意的是，即使是链路H1-A，也只是当分组正在此链路上传送时才被占用。在各分组传送之间的空闲时间，链路H1-A仍可为其他主机发送的分组使用。</p><p><img src="/images/network-basic/packetSwitch.png" alt="packetSwitch.png"></p><table><thead><tr><th>优点</th><th>所采用的手段</th></tr></thead><tbody><tr><td>高效</td><td>在分组传输的过程中动态分配传输带宽，对通信链路是逐段占用</td></tr><tr><td>灵活</td><td>为每一个分组独立地选择最合适的转发路由</td></tr><tr><td>迅速</td><td>以分组作为传送单位，可以不先建立连接就能向其他主机发送分组</td></tr><tr><td>可靠</td><td>保证可靠性的网络协议:分布式多路由的分组交换网，使网络有很好的生存性</td></tr></tbody></table><p>问题：</p><ul><li>分组在各路由器存储转发时需要排队，造成时延；</li><li>各分组携带的控制信息造成开销</li></ul><h4 id="1-2-2-3-报文交换"><a href="#1-2-2-3-报文交换" class="headerlink" title="1.2.2.3. 报文交换"></a>1.2.2.3. 报文交换</h4><p>采用存储转发原理，但每次交换整个报文。</p><p>三种交换方式的比较：</p><p><img src="/images/network-basic/switch.png"></p><h2 id="1-3-计算机网络的性能指标"><a href="#1-3-计算机网络的性能指标" class="headerlink" title="1.3. 计算机网络的性能指标"></a>1.3. 计算机网络的性能指标</h2><h3 id="1-3-1-速率"><a href="#1-3-1-速率" class="headerlink" title="1.3.1. 速率"></a>1.3.1. 速率</h3><p>用的信息量的单位。网络技术中的速率指的是数据的传送速率，它也称为数据率或比特率( bit rate)。速率是计算机网络中最重要的一个性能指标。速率的单位是bit/s。</p><p>当提到网络的速率时，往往指的是额定速率或标称速率，而并非网络实际上运行的</p><h3 id="1-3-2-带宽"><a href="#1-3-2-带宽" class="headerlink" title="1.3.2. 带宽"></a>1.3.2. 带宽</h3><p>带宽本来是指某个信号具有的频带宽度。在计算机网络中，带宽用来表示网络中某通道传送数据的能力，因此网络带宽表示在单位时间内网络中的某信道所能通过的“最高数据率”，单位bit/s。</p><p>前者为频域称谓，而后者为时域称谓，其本质是相同的。</p><h3 id="1-3-3-吞吐量"><a href="#1-3-3-吞吐量" class="headerlink" title="1.3.3. 吞吐量"></a>1.3.3. 吞吐量</h3><p>吞吐量表示在单位时间内通过某个网络(或信道、接口)的实际的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。显然，吞吐量受网络的带宽或网络的额定速率的限制。</p><h3 id="1-3-4-时延"><a href="#1-3-4-时延" class="headerlink" title="1.3.4. 时延"></a>1.3.4. 时延</h3><p>时延包括以下几个部分：</p><ul><li>发送时延：主机或路由器发送数据帧所需要的时间</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">发送时延&#x3D;数据帧长度bit&#x2F;发送速率bit&#x2F;s</span><br></pre></td></tr></table></figure><ul><li>传播时延 电磁波在信道中传播一定的距离需要花费的时间。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">传播时延&#x3D;信道长度m&#x2F;电磁波在信道上的传播速率m&#x2F;s</span><br></pre></td></tr></table></figure><p>发送时延与传输信道的长度没有关系，传播时延与信号的发送速率无关。</p><ul><li><p>处理时延：主机或路由器在收到分组时要花费一定的时间进行处理，例如分析分<br>组的首部、从分组中提取数据部分、进行差错检验或査找适当的路由等。</p></li><li><p>排队时延 分组在经过网络传输时，要经过许多路由器。但分组在进入路由器后<br>要先在输入队列中排队等待处理。排队时延的长短往往取决于网络当时的通信量。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总时延&#x3D;发送时延+传播时延+处理时延+排队时延</span><br></pre></td></tr></table></figure><p><img src="/images/network-basic/delay.png"></p></li></ul><p>对于高速链路，提高的仅仅是数据的发送速率而非比特在链路上的传播速率，减小了数据的发送时延，所以比特不会传送得更快。</p><h3 id="1-3-5-时延带宽积"><a href="#1-3-5-时延带宽积" class="headerlink" title="1.3.5. 时延带宽积"></a>1.3.5. 时延带宽积</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">时延带宽积&#x3D;传播时延*带宽</span><br></pre></td></tr></table></figure><p>管道中的比特数表示发送端发出的但未到达接收端的比特。</p><h3 id="1-3-6-往返时间RTT"><a href="#1-3-6-往返时间RTT" class="headerlink" title="1.3.6. 往返时间RTT"></a>1.3.6. 往返时间RTT</h3><p>信息双向交互一次所需的时间。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有效数据率&#x3D;数据长度&#x2F;发送时间+RTT</span><br></pre></td></tr></table></figure><h3 id="1-3-7-利用率"><a href="#1-3-7-利用率" class="headerlink" title="1.3.7. 利用率"></a>1.3.7. 利用率</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前时延&#x3D;网络空闲时的时延&#x2F;1-利用率</span><br></pre></td></tr></table></figure><p>这里U是网络的利用率，数值在0到1之间。当网络的利用率达到其容量的1/2时<br>时延就要加倍。</p><p>当网络的利用率接近最大值1时，网络的时延就趋于无穷大。因此我们必须有这样的概念:信道或网络的利用率过高会产生非常大的时延。</p><p><img src="/images/network-basic/delay-U.png"></p><h2 id="1-4-计算机网络体系结构"><a href="#1-4-计算机网络体系结构" class="headerlink" title="1.4. 计算机网络体系结构"></a>1.4. 计算机网络体系结构</h2><p>法律上的国际标准：OSI<br>事实上的国籍标准：TCP/IP</p><p>网络协议：未进行网络中的数据交换而建立的规则、标准或约定。包括：</p><ul><li>语法：即数据与控制信息的结构或格式</li><li>语义：即需要发出何种控制信息，完成何种动作以及做出何种响应，例如重传或丢弃的时间</li><li>同步：即事件实现顺序的详细说明</li></ul><p><img src="/images/network-basic/OSI.png"></p><h3 id="1-4-1-OSI七层模型"><a href="#1-4-1-OSI七层模型" class="headerlink" title="1.4.1. OSI七层模型"></a>1.4.1. OSI七层模型</h3><p>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><p>下4层完成通信子网的功能，上3层完成资源子网的功能。</p><p><img src="/images/network-basic/osi7.png"></p><h4 id="1-4-1-1-物理层"><a href="#1-4-1-1-物理层" class="headerlink" title="1.4.1.1. 物理层"></a>1.4.1.1. 物理层</h4><p>利用传输介质为数据链路层提供物理连接，实现比特流的透明传输，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。</p><p>考虑多大的电压代表“1”“0”，接收方应如何识别，电缆的插头应有多少根引脚、如何连接等。</p><h4 id="1-4-1-2-数据链路层"><a href="#1-4-1-2-数据链路层" class="headerlink" title="1.4.1.2. 数据链路层"></a>1.4.1.2. 数据链路层</h4><p>在物理层提供的比特流的基础上，通过差错控制、封装成帧、流量控制提供可靠的通过物理介质传输数据的方法。</p><p>该层通常又被分为介质访问控制（MAC）和逻辑链路控制（LLC）两个子层。</p><p>数据链路层的具体工作是接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层；并且，还负责处理接收端发回的确认帧的信息，以便提供可靠的数据传输。</p><h4 id="1-4-1-3-网络层"><a href="#1-4-1-3-网络层" class="headerlink" title="1.4.1.3. 网络层"></a>1.4.1.3. 网络层</h4><p>将上层的报文段或用户数据报封装成分组，也叫IP数据报。</p><p>另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。</p><p>数据链路层是解决同一网络内节点之间的通信，而网络层主要解决不同子网间的通信。</p><ul><li>寻址：数据链路层中使用的物理地址（如MAC地址）仅解决网络内部的寻址问题。在不同子网之间通信时，为了识别和找到网络中的设备，每一子网中的设备都会被分配一个唯一的地址。由于各子网使用的物理技术可能不同，因此这个地址应当是逻辑地址（如IP地址）。</li><li>交换：规定不同的信息交换方式。常见的交换技术有：线路交换技术和存储转发技术，后者又包括报文交换技术和分组交换技术。</li><li>路由算法：当源节点和目的节点之间存在多条路径时，本层可以根据路由算法，通过网络为数据分组选择最佳路径，并将信息从最合适的路径由发送端传送到接收端。</li><li>连接服务：与数据链路层流量控制不同的是，前者控制的是网络相邻节点间的流量，后者控制的是从源节点到目的节点间的流量。其目的在于防止阻塞，并进行差错检测。</li></ul><h4 id="1-4-1-4-传输层"><a href="#1-4-1-4-传输层" class="headerlink" title="1.4.1.4. 传输层"></a>1.4.1.4. 传输层</h4><p>OSI下3层的主要任务是数据通信，上3层的任务是数据处理。而传输层是通信子网和资源子网的接口和桥梁，起到承上启下的作用。</p><ul><li>传输连接管理：提供建立、维护和拆除传输连接的功能。传输层在网络层的基础上为高层提供“面向连接”和“面向无接连”的两种服务。</li><li>处理传输差错：提供可靠的“面向连接”和不太可靠的“面向无连接”的数据传输服务、差错控制和流量控制。在提供“面向连接”服务时，通过这一层传输的数据将由目标设备确认，如果在指定的时间内未收到确认信息，数据将被重发。</li></ul><h4 id="1-4-1-5-会话层"><a href="#1-4-1-5-会话层" class="headerlink" title="1.4.1.5. 会话层"></a>1.4.1.5. 会话层</h4><p>向两个实体的表示层提供建立和使用连接的方法。将不同实体之间的表示层的连接称为会话。因此会话层的任务就是组织和协调两个会话进程之间的通信，并对数据交换进行管理。</p><ul><li>会话管理：允许用户在两个实体设备之间建立、维持和终止会话，并支持它们之间的数据交换。例如提供单方向会话或双向同时会话，并管理会话中的发送顺序，以及会话所占用时间的长短。</li><li>会话流量控制：提供会话流量控制和交叉会话功能。</li><li>寻址：使用远程地址建立会话连接。l</li><li>出错控制：从逻辑上讲会话层主要负责数据交换的建立、保持和终止，但实际的工作却是接收来自传输层的数据，并负责纠正错误。会话控制和远程过程调用RPC均属于这一层的功能。但应注意，此层检查的错误不是通信介质的错误，而是磁盘空间、打印机缺纸等类型的高级错误。</li></ul><h4 id="1-4-1-6-表示层"><a href="#1-4-1-6-表示层" class="headerlink" title="1.4.1.6. 表示层"></a>1.4.1.6. 表示层</h4><p>对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。</p><p>其主要功能是“处理用户信息的表示问题，如编码、数据格式转换和加密解密”等。</p><ul><li>数据格式处理：协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异。</li><li>数据的编码：处理字符集和数字的转换。例如由于用户程序中的数据类型（整型或实型、有符号或无符号等）、用户标识等都可以有不同的表示方式，因此，在设备之间需要具有在不同字符集或格式之间转换的功能。</li><li>压缩和解压缩：为了减少数据的传输量，这一层还负责数据的压缩与恢复。</li><li>数据的加密和解密：可以提高网络的安全性。</li></ul><h4 id="1-4-1-7-应用层"><a href="#1-4-1-7-应用层" class="headerlink" title="1.4.1.7. 应用层"></a>1.4.1.7. 应用层</h4><p>计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，通过应用进程间的交互完成特定的网络应用。</p><ul><li>用户接口：应用层是用户与网络，以及应用程序与网络间的直接接口，使得用户能够与网络进行交互式联系。</li><li>实现各种服务：该层具有的各种应用程序可以完成和实现用户请求的各种服务。</li></ul><h3 id="1-4-2-总结"><a href="#1-4-2-总结" class="headerlink" title="1.4.2. 总结"></a>1.4.2. 总结</h3><p>OSI七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br>TCP/IP四层：网络接口层、 网际层、运输层、 应用层。<br>五层协议：物理层、数据链路层、网络层、运输层、 应用层。</p><p><strong>协议</strong><br>物理层：RJ45、CLOCK、IEEE802.3（网卡，网线，集线器，中继器，调制解调器）<br>数据链路：PPP、FR、HDLC、VLAN、MAC（网桥，交换机）<br>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器、网关）<br>传输层：TCP、UDP、SPX<br>会话层：NFS、SQL、NETBIOS、RPC<br>表示层：JPEG、MPEG、ASII<br>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</p><p><img src="/images/network-basic/protocolFamily.png"></p><p><strong>作用</strong><br>物理层：通过媒介传输比特，确定机械及电气规范（比特Bit）<br>数据链路层：将比特组装成帧和点到点的传递（帧Frame）<br>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）<br>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）<br>会话层：建立、管理和终止会话（会话协议数据单元SPDU）<br>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）<br>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）  </p><p><img src="/images/network-basic/data.png"></p><p>协议数据单元PDU：对等层次之间传送的数据单位。<br>服务数据单元SDU：层间交换的数据单位。<br>服务访问点SAP：同意系统中相邻两层的实体交换信息的地方。</p><p><img src="/images/network-basic/service-relation.png"></p><p>协议是水平的，服务是垂直的。</p><p><strong>交换机、路由器、网关</strong></p><ul><li><p>交换机<br>在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背 部总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部 交换矩阵迅速将数据包传送到目的端口。目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表中。<br>交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张 ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不 能划分网络层广播，即广播域。<br>交换机被广泛应用于二层网络交换，俗称“二层交换机”。<br>交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在OSI七层模型中的第二层、第三层、第四层盒第七层，并因此而得名。</p></li><li><p>路由器<br>路由器（Router）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。<br>路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。</p></li><li><p>网关<br>网关（Gateway），网关顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP/IP 的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家 庭中或者小型企业网络中使用，用于连接局域网和Internet。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。<br>在传统TCP/IP术语中，网络设备只分成两种，一种为网关（gateway），另一种为主机（host）。网关能在网络间转递数据包，但主机不能 转送数据包。在主机（又称终端系统，end system）中，数据包需经过TCP/IP四层协议处理，但是在网关（又称中介系 统，intermediate system）只需要到达网际层（Internet layer），决定路径之后就可以转送。在当时，网关 （gateway）与路由器（router）还没有区别。<br>在现代网络术语中，网关（gateway）与路由器（router）的定义不同。网关（gateway）能在不同协议间移动数据，而路由器（router）是在不同网络间移动数据，相当于传统所说的IP网关（IP gateway）。<br>网关是连接两个网络的设备，对于语音网关来说，他可以连接PSTN网络和以太网，这就相当于VOIP，把不同电话中的模拟信号通过网关而转换成数字信号，而且加入协议再去传输。在到了接收端的时候再通过网关还原成模拟的电话信号，最后才能在电话机上听到。<br>对于以太网中的网关只能转发三层以上数据包，这一点和路由是一样的。而不同的是网关中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。</p></li></ul><h1 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2. 物理层"></a>2. 物理层</h1><p>首先要强调指岀，物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而通信手段也有许多不同方式。物理层的作用正是要尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异。</p><p>可以将物理层的主要任务描述为确定与传输媒体的接口有关的一些特性，即</p><ol><li>机械特性指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置，等。平时常见的各种规格的接插件都有严格的标准化的规定。</li><li>电气特性指明在接口电缆的各条线上出现的电压的范围。</li><li>功能特性指明某条线上出现的某一电平的电压的意义。</li><li>过程特性指明对于不同功能的各种可能事件的出现顺序</li></ol><p>物理层还要完成串行-&gt;并行传输的转换。</p><h2 id="2-1-数据通信"><a href="#2-1-数据通信" class="headerlink" title="2.1. 数据通信"></a>2.1. 数据通信</h2><h3 id="2-1-1-数据通信系统"><a href="#2-1-1-数据通信系统" class="headerlink" title="2.1.1. 数据通信系统"></a>2.1.1. 数据通信系统</h3><p>可划分为三大部分，即源系统(或发送端、发送方)、传输系统(或传输网络)和目的系统(或接收端、接收方)。</p><p><img src="/images/network-basic/DataCommunication.png"></p><ul><li>模拟信号，或连续信号：代表消息的参数的取值是连续的。</li><li>数字信号，或离散信号：代表消息的参数的取值是离散的。代表不同离散数值的基本波形就称为码元。</li></ul><h3 id="2-1-2-信道"><a href="#2-1-2-信道" class="headerlink" title="2.1.2. 信道"></a>2.1.2. 信道</h3><p>从通信的双方信息交互的方式来看，可以有以下三种基本方式：</p><ul><li>单向通信：称为单工通信，即只能有一个方向的通信而没有反方向的交互。无<br>线电广播或有线电广播以及电视广播就属于这种类型</li><li>双向交替通信：又称为半双工通信，即通信的双方都可以发送信息，但不能双方<br>同时发送(当然也就不能同时接收)。</li><li>双向同时通信：又称为全双工通信，即通信的双方可以同时发送和接收信息<br>单向通信只需要一条信道，而双向交替通信或双向同时通信则都需要两条信道(每个<br>方向各一条)。</li></ul><p>显然，双向同时通信的传输效率最高。</p><p>来自信源的基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。所以必须对基带信号进行调制，分为两大类：</p><ul><li>基带调制：对基带信号的波形进行变换，使它能够与信道特性相适应，变换后的信号仍然是基带信号，也称为编码。<ul><li>不归零制</li><li>归零制</li><li>曼彻斯特编码</li><li>差分曼彻斯特编码</li></ul></li><li>带通调制：使用载波把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，经过载波调制后的信号称为带通信号，即仅在一段频率范围内能够通过信道。<ul><li>调幅（AM）</li><li>调频（FM）</li><li>调相（PM）</li></ul></li></ul><h3 id="2-1-3-信道的极限容量"><a href="#2-1-3-信道的极限容量" class="headerlink" title="2.1.3. 信道的极限容量"></a>2.1.3. 信道的极限容量</h3><p>码间串扰：接收端收到的信号波形就失去了码元之间的清晰界限。<br>严重的码间串扰使得本来分得很清楚的一串码元变得模糊而无法识别。</p><p>奈氏准则：在任何信道中，码元传输的速率是有上限的，传输速率超过此上限，就会出现严重的码间串扰的问题。</p><p>信噪比：所谓信噪比就是信号的平均功率和噪声的平均功率之比，常记为S/N，并用分贝(dB)作为度量单位。</p><p><img src="/images/network-basic/SNR.png"></p><p>香农公式：信道的极限信息传输速率C是</p><p><img src="/images/network-basic/shannon.png"></p><p>式中，W为信道的带宽(Hz);S为信道内所传信号的平均功率;N为信道内<br>部的高斯噪声功率。</p><p>香农公式的意义在于:只要信息传输速率低于信道的极限信息传输速率，就一定存在某种办法来实现无差错的传输。</p><p>从以上所讲的不难看出，对于频带宽度已确定的信道，可以用编码的方法让每一个码元携带更多比特的信息量。</p><h2 id="2-2-物理层下的传输媒体"><a href="#2-2-物理层下的传输媒体" class="headerlink" title="2.2. 物理层下的传输媒体"></a>2.2. 物理层下的传输媒体</h2><ul><li>导引型<ul><li>双绞线</li><li>同轴线缆</li><li>光缆</li></ul></li><li>非导引型<ul><li>短波通信</li><li>无线电微波通信</li><li>卫星通信</li></ul></li></ul><h2 id="2-3-信道复用技术"><a href="#2-3-信道复用技术" class="headerlink" title="2.3. 信道复用技术"></a>2.3. 信道复用技术</h2><p><img src="/images/network-basic/multiplexing.png"></p><ul><li>频分复用（FDM）：所有用户在同样的时间占用不同的带宽资源。</li><li>时分复用（TDM）：所有用户在不同的时间占用同样的频带宽度，又称为同步时分复用。</li></ul><p><img src="/images/network-basic/FDM-TDM.png"></p><ul><li>统计时分复用（STDM）：改进的时分复用，缓存用户数据放入STDM帧，又称为异步时分复用</li><li>波分复用（WDM）：光的频分复用。</li><li>码分复用（CDM）：共享信道。</li></ul><h2 id="2-4-宽带接入技术"><a href="#2-4-宽带接入技术" class="headerlink" title="2.4. 宽带接入技术"></a>2.4. 宽带接入技术</h2><ul><li>ADSL技术：改造电话用户线；</li><li>光纤同轴混合网（HFC网）：改造有线电视网；</li><li>光纤到户（FTTx）：光信号转电信号。</li></ul><h1 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3. 数据链路层"></a>3. 数据链路层</h1><p>数据链路层使用的信道：</p><ul><li>点对点信道。这种信道使用一对一的点对点通信方式。</li><li>广播信道。这种信道使用一对多的广播通信方式。</li></ul><h2 id="3-1-使用点对点信道"><a href="#3-1-使用点对点信道" class="headerlink" title="3.1. 使用点对点信道"></a>3.1. 使用点对点信道</h2><h3 id="3-1-1-三个基本问题"><a href="#3-1-1-三个基本问题" class="headerlink" title="3.1.1. 三个基本问题"></a>3.1.1. 三个基本问题</h3><p>封装成帧。透明传输、差错检测</p><h4 id="3-1-1-1-封装成帧"><a href="#3-1-1-1-封装成帧" class="headerlink" title="3.1.1.1. 封装成帧"></a>3.1.1.1. 封装成帧</h4><p>封装成帧就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧，</p><p>首部和尾部的一个重要作用就是进行帧定界(即确定帧的界限)。此外，首部和尾部还包括许多必要的控制信息。应当使帧的数据部分长度尽可能地大于首部和尾部的长度。每一种链路层协议都规定了所能传送的帧的数据部分长度上限—最大传送<br>单元MTU。</p><p><img src="/images/network-basic/MTU.PNG"></p><p>帧定界符SOH和EOT标识真的开始与结束，用以判断一个完整的帧。</p><h4 id="3-1-1-2-透明传输"><a href="#3-1-1-2-透明传输" class="headerlink" title="3.1.1.2. 透明传输"></a>3.1.1.2. 透明传输</h4><p>当传送的用文本组成的帧时，不管从键盘上输入什么字符都可以放在这样的帧中传输过去，因此这样的传输就是透明传输。</p><p>但当数据部分是非ASCI码的文本文件时(如二进制代码的计算机程序或图像等)，情<br>况就不同了。如果数据中的某个字节的二进制代码恰好和SOH或EOT这种控制字符一样<br>，数据链路层就会错误地“找到帧的边界”，把部分帧收下(误认为是个完整的<br>帧)，而把剩下的那部分数据丢弃(这部分找不到帧定界控制字符SOH)。</p><p><img src="/images/network-basic/EOT.PNG"></p><p><strong>字符填充</strong></p><p>为了解决透明传输问题，发送端的数据链路层在数据中出现控制字符<br>SOH”或“EOT”的前面插入一个转义字符“ESC”。而在接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符。</p><h4 id="3-1-1-3-差错检测"><a href="#3-1-1-3-差错检测" class="headerlink" title="3.1.1.3. 差错检测"></a>3.1.1.3. 差错检测</h4><p>比特差错：比特在传输过程中可能会产生差错：1可能会变成0，而0也可能变成1。</p><p>误码率BER：在一段时间内，传输错误的比特占所传输比特总数的比率。</p><p><strong>循环冗余检验CRC</strong></p><p><img src="/images/network-basic/CRC1.PNG"><br><img src="/images/network-basic/CRC2.PNG"></p><p>判定这个帧有差错，但无法确定究竟是哪一位或哪几位出现了差错。</p><p>在数据链路层若仅仅使用循环冗余检验CRC差错检测技术，则只能做到对帧的无差错接受</p><p>即:“凡是接收端数据链路层接受的帧，我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错”。接收端丢弃的帧虽然曾收到了，但最终还是因为有差错被丢弃，即没有被接受。</p><p>传输差错：帧丢失、帧重复或帧失序。</p><p>过去oSI的观点是:必须让数据链路层向上提供可靠传输。因此在CRC检错的基础上，增加了帧编号、确认和重传机制。</p><h3 id="3-1-2-点对点协议PPP"><a href="#3-1-2-点对点协议PPP" class="headerlink" title="3.1.2. 点对点协议PPP"></a>3.1.2. 点对点协议PPP</h3><p>在TCP/P协议族中，可靠传输由运输层的TCP协议负责，因此数据链路层的PPP协<br>议不需要进行纠错，不需要设置序号，也不需要进行流量控制。PPP协议不支持多点线路，只支持点对点的链路通信。此外，PPP协议只支持全双工链路。</p><h4 id="3-1-2-1-协议组成"><a href="#3-1-2-1-协议组成" class="headerlink" title="3.1.2.1. 协议组成"></a>3.1.2.1. 协议组成</h4><p>PPP协议有三个组成部分：</p><ol><li>将P数据报封装到串行链路的方法。PP既支持异步链路(无奇偶检验的8比<br>特数据)，也支持面向比特的同步链路。IP数据报在PPP帧中就是其信息部分。这个信息部分的长度受最大传送单元MTU的限制。</li><li>用来建立、配置和测试数据链路连接的链路控制协议LCP( Link Cont<br>Protoco)。通信的双方可协商一些选项。在RFC1661中定义了11种类型的LCP分组</li><li>一套网络控制协议 NCP(Network Control Protocol)°，其中的每一个协议支持不同的网络层协议，如IP、OSI的网络层、 DECnet，以及 AppleTalk等</li></ol><h4 id="3-1-2-2-PPP帧格式"><a href="#3-1-2-2-PPP帧格式" class="headerlink" title="3.1.2.2. PPP帧格式"></a>3.1.2.2. PPP帧格式</h4><p><img src="/images/network-basic/PPP.PNG"></p><ul><li>F：0x7E 01111110，标志字段，标识帧的开始或结束</li><li>A、C：无意义</li><li>协议：表示信息部分使用的协议类型</li><li>FCS：检验序列</li></ul><p><strong>字节填充</strong><br>使用异步传输时，它把转义符定义为0xD(即ol11101)，并使用字节填充<br>RFC1662规定了如下所述的填充方法</p><ol><li>把信息字段中出现的每一个0x7E字节转变成为2字节序列(0x7D，0x5E)</li><li>若信息字段中出现一个0x7D的字节(即出现了和转义字符一样的比特组合)，则<br>把0x7D转变成为2字节序列(0x7D，0x5D)</li><li>若信息字段中出现ASCI码的控制字符(即数值小于0x20的字符)，则在该字符前<br>面要加入一个αx⑦D字节，同时将该字符的编码加以改变。例如，出现0x03(在控制字符中是“传输结束”ETX)就要把它转变为2字节序列(0x7D，Ox23)。</li></ol><p><strong>零比特填充</strong><br>使用同步传输时，在发送端，只要发现有5个连续1，则立即填入一个0。因此经过这种填充后的数据，就可以保证在信息字段中不会出现6个连续1。接收端在收到一个帧<br>时，先找到标志字段F以确定一个帧的边界，接着再用硬件对其中的比特流进行扫描。每当发现5个连续1时，就把这5个连续1后的一个0删除，以还原成原来的信息比特流。</p><h4 id="3-1-2-3-PPP协议工作状态"><a href="#3-1-2-3-PPP协议工作状态" class="headerlink" title="3.1.2.3. PPP协议工作状态"></a>3.1.2.3. PPP协议工作状态</h4><p><img src="/images/network-basic/PPPstatus.PNG"></p><p>当用户拨号接入ISP后，就建立了一条从用户个人电脑到IsP的物理连接。这时，用户个人电脑向ISSP发送一系列的链路控制协议LCP分组(封装成多个PPP帧)，以便建立LCP连接。这些分组及其响应选择了将要使用的一些PPP参数。接着还要进行网络层配置，网络控制协议NCP给新接入的用户个人电脑分配一个临时的IP地址。这样，用户个人电脑就成为互联网上的一个有IP地址的主机</p><p>当用户通信完毕时，NCP释放网络层连接，收回原来分配出去的IP地址。接着，LCP释放数据链路层连接。最后释放的是物理层的连接。</p><p>在“网络层协议”状态，PPP链路的两端的网络控制协议NCP根据网络层的不同协议互相交换网络层特定的网络控制分组。这个步骤是很重要的，因为现在的路由器都能够同时支持多种网络层协议。总之，PPP协议两端的网络层可以运行不同的网络层协议，但仍然可使用同一个PP协议进行通信<br>如果在PPP链路上运行的是IP协议，则对PP链路的每一端配置IP协议模块(如分配IP地址)时就要使用NCP中支持IP的协议——IP控制协议IPCP( IP ControlProtoco)IPCP分组也封装成PPP帧(其中的协议字段为0x8021)在PP链路上传送。在低速链路上运行时，双方还可以协商使用压缩的TCP和P首部，以减少在链路上发送的比特数。</p><p>PPP协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。</p><h2 id="3-2-使用广播信道"><a href="#3-2-使用广播信道" class="headerlink" title="3.2. 使用广播信道"></a>3.2. 使用广播信道</h2><h3 id="3-2-1-局域网的数据链路层"><a href="#3-2-1-局域网的数据链路层" class="headerlink" title="3.2.1. 局域网的数据链路层"></a>3.2.1. 局域网的数据链路层</h3><p>局域网使用的就是广播信道。按照网络拓扑分为星形网、环形网、总线网。总线网以传统以太网最为著名，之后出现的快速以太网、吉比特以太网在市场中占据绝对优势，以太网成为局域网的同义词。</p><p>共享信道技术：</p><ul><li>静态划分信道：复用分用技术；</li><li>动态媒体接入控制：又称多点接入<ul><li>随机接入：用户随机发送信息，需要解决碰撞；</li><li>受控接入：用户发送信息需要服从控制。轮询。</li></ul></li></ul><h4 id="3-2-1-1-以太网的两个标准"><a href="#3-2-1-1-以太网的两个标准" class="headerlink" title="3.2.1.1. 以太网的两个标准"></a>3.2.1.1. 以太网的两个标准</h4><ul><li>DIX Ethernet V2</li><li>IEEE 802.3</li></ul><p>二者差别很小。后来IEEE 802将数据链路层拆分为逻辑链路控制LLC( Logical Link Contro)子层和媒体接入控制MAC( Medium Access Control)子层。与接入到传输媒体有关的内容都放在MAC子层，而LLC子层则与传输媒体无关。</p><p>后来市场稳定，LLC子层的作用消失，DIX Ethernet V2市场更大。</p><h4 id="3-2-1-2-适配器"><a href="#3-2-1-2-适配器" class="headerlink" title="3.2.1.2. 适配器"></a>3.2.1.2. 适配器</h4><p>计算机与外界局域网的连接时通过通信适配器进行的，又称为网络接口卡NIC。装有处理器和存储器（包括RAM和ROM）</p><p>作用：</p><ul><li>串并行的转换</li><li>缓存</li><li>实现以太网协议</li></ul><p>工作：</p><p>适配器在接收和发送时不使用计算机的CPU。当适配器收到有差错的帧时，就把这个帧直接丢弃而不必通知计算机。收到正确的帧时，它就使用中断来通知该计算机，并交付协议栈中的网络层。</p><p>当计算机要发送IP数据报时，就由协议栈把IP数据报向下交给适配器，组装成帧后发送到局域网。</p><p>计算机的硬件地址就在适配器的ROM中，而计算机的软件地址（IP地址）则在计算机的存储器中。</p><h3 id="3-2-2-CSMA-CD协议"><a href="#3-2-2-CSMA-CD协议" class="headerlink" title="3.2.2. CSMA/CD协议"></a>3.2.2. CSMA/CD协议</h3><p>总线使用。</p><p>为了通信简便，采用两个措施：</p><ol><li>采用较为灵活的无连接的工作方式，即不必先建立连接就可以直接发送数据<br>适配器对发送的数据帧不进行编号，也不要求对方发回确认。以太网提供的服务是尽最大努力的交付，即不可靠的交付。</li></ol><p>当目的站收到有差错的数据帧时，就把帧丢弃，其他什么也不做。对有差错帧是否需要重传则由高层来决定。</p><p>总线上在同一时间只能允许一台计算机发送数据，否则各计算机之间就会互相干扰，因此以太网使用CSMA/CD协议。</p><ol start="2"><li>以太网发送的数据都使用曼彻斯特( Manchester)编码的信号。</li></ol><p><strong>要点</strong></p><ul><li>先听后发<br>在发送前检测信道，是为了获得发送权。如果检测出已经有其他站在发送，则自己就暂时不许发送数据，必须要等到信道变为空闲时才能发送。</li><li>边听边发<br>在发送中检测信道，是为了及时发现有没有其他站的发送和本站发送的碰撞。</li><li>冲突停止<br>当适配器检测到的信号电压变化幅度超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。适配器就要立即停止发送，免得继续进行无效的<br>发送，白白浪费网络资源，然后等待一段随机时间后再次发送。</li><li>延迟重发<br>使用截断二进制指数退避算法确定延迟重发时机。</li></ul><p>因为传播时延的存在导致先听后发之后人有可能发生碰撞。发送数据后，最迟要经过多长时间才能知道自己发送的数据和其他站发送的数据有没有发生碰撞?这个时间最多是两倍的总线端到端的传播时延(2r)，称为争用期，又叫碰撞窗口。，即经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><p>因此局域网必须按最坏情况设计，即取总线两端的两个站之间的传播时延(这两个站之间的距离最大)为端到端传播时延。</p><p><img src="/images/network-basic/crash.PNG"></p><p>显然，在使用 CSMA/CD协议时，一个站不可能同时进行发送和接收(但必须边发送<br>边监听信道)。因此使用 CSMA/CD协议的以太网不可能进行全双工通信而只能进行双向交替通信(半双工通信)。</p><p>凡长度小于64字节的帧都是由于冲突而中止的无效帧。</p><p><strong>强化碰撞</strong><br>当发送数据的站一旦发现发生了碰撞时，除了立即停止发送数据外，还要再继续发送3比特或48比特的人为干扰信号，以便让所有用户都知道现在已经发生了碰撞。</p><p><strong>帧间最小间隔</strong><br>以太网还规定了帧间最小间隔为96μs，相当于96比特时间。这样做是为了使刚刚收<br>到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。</p><h3 id="3-2-3-使用集线器的星形拓扑"><a href="#3-2-3-使用集线器的星形拓扑" class="headerlink" title="3.2.3. 使用集线器的星形拓扑"></a>3.2.3. 使用集线器的星形拓扑</h3><p>集线器和每个站之间使用两对双绞线，用于发送和接收。<br>IEEE制定了10BASE-T星形以太网标准802.3i。“10”代表10Mbit/s的数据率，BASE表示连接线上的信号是基带信号，T代表双绞线。每个站到集线器的距离不超过100m。</p><p><strong>特点</strong></p><ul><li>用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是<br>CSMA/CD协议。</li><li>一个集线器有许多接口，每个接口通过RJ-45插头用两对双绞线与一台计算机上的适配器相连。因此，一个集线器很像一个多接口的转发器。</li><li>集线器工作在物理层，它的每个接口仅仅简单地转发比特，收到1就转发1，收<br>到0就转发0，不进行碰撞检测。</li></ul><h3 id="3-2-4-信道利用率"><a href="#3-2-4-信道利用率" class="headerlink" title="3.2.4. 信道利用率"></a>3.2.4. 信道利用率</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">信道利用率a&#x3D;\frac&#123;单程端到端时延r&#125;&#123;帧的发送时间T&#125;</span><br></pre></td></tr></table></figure><p>因此，以太网的连线的长度受到限制(否则r数值会太大)，同时以太网的帧长不能太短(否则T的值会太小，使a值太大)。</p><h3 id="3-2-5-MAC层"><a href="#3-2-5-MAC层" class="headerlink" title="3.2.5. MAC层"></a>3.2.5. MAC层</h3><h4 id="3-2-5-1-MAC地址"><a href="#3-2-5-1-MAC地址" class="headerlink" title="3.2.5.1. MAC地址"></a>3.2.5.1. MAC地址</h4><p>规定了一种48位的全球地址，是指局域网上的每一台计算机中固化在适配器的ROM中的地址。</p><p>适配器从网络上每收到一个MAC帧就先用硬件检査MAC帧中的目的地址。如果是发往本站的帧则收下，然后再进行其他的处理。否则就将此帧丢弃，不再进行其他的处理。</p><p>“发往本站的帧”包括以下三种帧：</p><ul><li>单播(unicast)帧(一对一)，即收到的帧的MAC地址与本站的硬件地址相同。</li><li>广播(broadcast帧(一对全体)，即发送给本局域网上所有站点的帧(全1地址)。</li><li>多播(multicas帧(一对多)，即发送给本局域网上一部分站点的帧</li></ul><p>所有的适配器都至少应当能够识别前两种帧，即能够识别单播和广播地址。显然，只有目的地址才能使用广播地址和多播地址。</p><h4 id="3-2-5-2-MAC帧的格式"><a href="#3-2-5-2-MAC帧的格式" class="headerlink" title="3.2.5.2. MAC帧的格式"></a>3.2.5.2. MAC帧的格式</h4><ol><li>DIX Ethernet V2</li></ol><p><img src="/images/network-basic/MAC.PNG"></p><p>类型：标注上一层是什么协议。</p><p><strong>帧长度</strong><br>在曼彻斯特编码的每一个码元(不管码元是1或0)的正中间一定有次电压的转换(从高到低或从低到高)。当发送方把一个以太网帧发送完毕后，就不再发送其他码元了(既不发送1，也不发送0)。因此，发送方网络适配器的接口上的电压也就不再变化了。这样，接收方就可以很容易地找到以太网帧的结束位置。在这个位置往前数4字节<br>(FCS字段长度是4字节)，就能确定数据字段的结束位置。</p><p><strong>8字节</strong><br>第一个字段是7个字节的前同步码(1和0交替码)，它的作用是使接收端的适配器在接收MAC帧时能够迅速调整其时钟频率，使它和发送端的时钟同步<br>也就是“实现位同步”(位同步就是比特同步的意思)。第二个字段是帧开始定界符，定义为10101011。</p><p><strong>定界</strong><br>以太网在传送帧时，各帧之间还必须有一定的间隙。因此，接收端只要找到帧开始定界符，其后面的连续到达的比特流就都属于同一个MAC帧。可见以太网不需要使用帧结束定界符，也不需要使用字节插入来保证透明传输。</p><ol start="2"><li>IEEE802.3</li></ol><ul><li>IEEE8023规定的MAC帧的第三个字段是“长度/类型”。当这个字段值大于<br>0x0600时(相当于十进制的1536)，就表示“类型”。这样的帧和以太网V2 MAC帧完全<br>样。只有当这个字段值小于0x0600时才表示“长度”，即MAC帧的数据部分长度。实际上，前面我们已经讲过，由于以太网采用了曼彻斯特编码，长度字段并无实际意义。</li><li>当“长度/类型”字段值小于0x0600时，数据字段必须装入上面的逻辑链路控制<br>JC子层的LLC帧。</li></ul><h3 id="3-2-6-扩展的以太网"><a href="#3-2-6-扩展的以太网" class="headerlink" title="3.2.6. 扩展的以太网"></a>3.2.6. 扩展的以太网</h3><p>扩展的以太网在网络层看来仍是一个网络。</p><h4 id="3-2-6-1-物理层扩展"><a href="#3-2-6-1-物理层扩展" class="headerlink" title="3.2.6.1. 物理层扩展"></a>3.2.6.1. 物理层扩展</h4><p>使用多级结构的集线器。</p><p><img src="/images/network-basic/physical-ex.PNG"></p><p><strong>缺点</strong></p><ol><li>通过集线器互连起来后就把三个碰撞域变成一个碰撞域，而这时的最大吞吐量没有变化。</li><li>如果不同的系使用不同的以太网技术，那么就不可能用集线器将们互连起来。</li></ol><h4 id="3-2-6-2-数据链路层扩展"><a href="#3-2-6-2-数据链路层扩展" class="headerlink" title="3.2.6.2. 数据链路层扩展"></a>3.2.6.2. 数据链路层扩展</h4><p>以太网交换机的出现代替了网桥转发帧。</p><h5 id="3-2-6-2-1-交换机特点"><a href="#3-2-6-2-1-交换机特点" class="headerlink" title="3.2.6.2.1. 交换机特点"></a>3.2.6.2.1. 交换机特点</h5><ul><li>实质是一个多接口的网桥，全双工工作，具有并行性，即同时连通多对接口使之同时通信。主机独占传输媒体，无碰撞地传输数据；</li><li>接口有存储器帮助缓存；</li><li>即插即用，内部的交换表通过自学习算法自动建立；</li><li>用户独享带宽，增加了总吞吐量；</li><li>多种速率的接口</li></ul><h5 id="3-2-6-2-2-路由器与交换机的主要区别"><a href="#3-2-6-2-2-路由器与交换机的主要区别" class="headerlink" title="3.2.6.2.2. 路由器与交换机的主要区别"></a>3.2.6.2.2. 路由器与交换机的主要区别</h5><ol><li>工作层次不同 <br>最初的的交换机是工作在数据链路层，而路由器一开始就设计工作在网络层。由于交换机工作在数据链路层，所以它的工作原理比较简单，而路由器工作在网络层，可以得到更多的协议信息，路由器可以做出更加智能的转发决策。 </li><li>数据转发所依据的对象不同 <br>交换机是利用物理地址或者说MAC地址来确定转发数据的目的地址。而路由器则是利用IP地址来确定数据转发的地址。IP地址是在软件中实现的，描述的是设备所在的网络。MAC地址通常是硬件自带的，由网卡生产商来分配的，而且已经固化到了网卡中去，一般来说是不可更改的。而IP地址则通常由网络管理员或系统自动分配。 </li><li>传统的交换机只能分割冲突域，不能分割广播域；而路由器可以分割广播域 <br>由交换机连接的网段仍属于同一个广播域，广播数据包会在交换机连接的所有网段上传播，在某些情况下会导致通信拥挤和安全漏洞。连接到路由器上的网段会被分配成不同的广播域，广播数据不会穿过路由器。虽然第三层以上交换机具有VLAN功能，也可以分割广播域，但是各子广播域之间是不能通信交流的，它们之间的交流仍然需要路由器。 </li><li>路由器提供了防火墙的服务 <br>路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴。</li></ol><h5 id="3-2-6-2-3-以太网的自学习功能"><a href="#3-2-6-2-3-以太网的自学习功能" class="headerlink" title="3.2.6.2.3. 以太网的自学习功能"></a>3.2.6.2.3. 以太网的自学习功能</h5><p><img src="/images/network-basic/self-learn.PNG"></p><p>A先向B发送一帧，从接口1进入到交换机。交换机收到帧后，先查找交换表，没有<br>查到应从哪个接口转发这个帧(在MAC地址这一列中，找不到目的地址为B的项目)。接<br>着，交换机把这个帧的源地址A和接口1写入交换表中，并向除接口1以外的所有接口<br>播这个帧(这个帧就是从接口1进来的，当然不应当把它再从接口1转发出去)。<br>C和D将丢弃这个帧，因为目的地址不对。只B才收下这个目的地址正确的帧。这也<br>称为过滤。<br>从新写入交换表的项目(A，1)可以看出，以后不管从哪一个接口收到帧，只要其目的地<br>址是A，就应当把收到的帧从接口1转发出去。这样做的依据是:既然A发出的帧是从接<br>口1进入到交换机的，那么从交换机的接口1转发出的帧也应当可以到达A。<br>假定接下来B通过接口3向A发送一帧。交换机查找交换表，发现交换表中的MAC地址有A。表明要发送给A的帧(即目的地址为A的帧)应从接口1转发。于是就把这个帧传送到接口1转发给A。显然，现在已经没有必要再广播收到的帧。交换表这时新增加的项目(B，3)，表明今后如有发送给B的帧，就应当从接口3转发出去。<br>经过一段时间后，只要主机C和D也向其他主机发送帧，以太网交换机中的交换表就会把转发到C或D应当经过的接口号(2或4)写入到交换表中。这样，交换表中的项目就齐全了。要转发给任何一台主机的帧，都能够很快地在交换表中找到相应的转发接口考虑到有时可能要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更改交换表中的项目。为此，在交换表中每个项目都设有一定的有效时间。过期的项目就<br>自动被删除。用这样的方法保证交换表中的数据都符合当前网络的实际状况。<br>以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置。</p><p><strong>生成树协议STP</strong></p><p><img src="/images/network-basic/STP.PNG"></p><p>假定一开始主机A通过接口交换机#1向主机B发送一帧。交换机#1收到这个帧后就向所有其他接口进行广播发送。现观察其中一个帧的走向:离开交换机#1的<br>接口3→交换机#2的接口1→接口2→交换机#1的接口4→接口3→交换机#的接口这样就无限制地循环兜圈子下去，白白消耗了网络资源<br>为了解决这种兜圈子问题，IEE的8021D标准制定了一个生成树协议STP( Spanning<br>Tree Protocol)。其要点就是不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从台主机到所有其他主机的路径是无环路的树状结构，从而消除了兜圈子现象。</p><h1 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4. 网络层"></a>4. 网络层</h1><h2 id="4-1-网络层提供的两种服务"><a href="#4-1-网络层提供的两种服务" class="headerlink" title="4.1. 网络层提供的两种服务"></a>4.1. 网络层提供的两种服务</h2><ul><li>面向连接：虚电路</li><li>无连接的</li></ul><p>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服。<br>网络在发送分组时不需要先建立连接。每一个分组(也就是IP数据报)独立发送，与其前后的分组无关(不进行编号)。网络层不提供服务质量的承诺。</p><p>虚电路服务与数据报服务的对比：</p><table><thead><tr><th>对比的方面</th><th>虚电路服务</th><th>数据报服务</th></tr></thead><tbody><tr><td>思路</td><td>靠通信应当由网络来保证</td><td>可靠通信应当由用户主机来保证</td></tr><tr><td>连接的建立</td><td>必须有</td><td>不需要</td></tr><tr><td>终点地址</td><td>仅在连接建立阶段使用，每个分组使用短</td><td>每个分组都有终点的完整地址</td></tr><tr><td>的虚电路号</td><td></td><td></td></tr><tr><td>分组的转发</td><td>属于同一条虚电路的分组均按照同一路由进行转发</td><td>每个分组独立选择路由进行转发</td></tr><tr><td>当结点出故障时</td><td>所有通过出故障的结点的虚电路均不能工作</td><td>出故障的结点可能会丢失分组</td></tr><tr><td>分组的顺序</td><td>总是按发送顺序到达终点</td><td>到达终点的时间不一定按发送顺序</td></tr><tr><td>端到端的差错处理和流量控制</td><td>可以由网络负责，也可以由用户主机负责</td><td>由用户主机负责</td></tr></tbody></table><h2 id="4-2-网际协议IP"><a href="#4-2-网际协议IP" class="headerlink" title="4.2. 网际协议IP"></a>4.2. 网际协议IP</h2><p>与IP协议配套使用的还有三个协议：</p><ul><li>地址解析协议ARP</li><li>网际控制报文协议ICMP</li><li>网际组管理协议IGMP</li><li><del>逆地址解析协议RARP</del>：使只知道自己硬件地址的主机能够通过RARP协议找出其IP地址。现在的DHCP协议已经包含RARP协议的功能。</li></ul><h3 id="4-2-1-分类的IP地址"><a href="#4-2-1-分类的IP地址" class="headerlink" title="4.2.1. 分类的IP地址"></a>4.2.1. 分类的IP地址</h3><p>IP编址经历的三个历史阶段：</p><ol><li>分类的IP地址</li><li>划分子网</li><li>构造超网</li></ol><h4 id="4-2-1-1-IP地址的表示"><a href="#4-2-1-1-IP地址的表示" class="headerlink" title="4.2.1.1. IP地址的表示"></a>4.2.1.1. IP地址的表示</h4><p>一个网络号在整个互联网范围内必须是唯一的，一台主机号在它前面的网络号所指明的网络范围内必须是唯一的，一个IP地址在整个互联网范围内是唯一的。</p><p>两级的IP地址可以记为:<br>IP地址:={&lt;网络号&gt;，&lt;主机号&gt;}</p><p><img src="/images/network-basic/divideClassIP.PNG"></p><h4 id="4-2-1-2-常见的三类IP地址"><a href="#4-2-1-2-常见的三类IP地址" class="headerlink" title="4.2.1.2. 常见的三类IP地址"></a>4.2.1.2. 常见的三类IP地址</h4><p>A类地址的网络号字段占1个字节，只有7位可供使用(该字段的第一位已固定为0)，但可指派的网络号是126个(即27-2)。减2的原因是:第一，IP地址中的全0表示“这个this”。网络号字段为全0的IP地址是个保留地址，意思是“本网络”;第二，网络号为127(即01111111作为本地软件环回测试( loopback test)本主机的进程之间的通信之用。目的地址为环回地址的IP数据报永远不会出现在任何网络上，因为网络号为127的地址根本不是一个网络地址。</p><p>A类地址的主机号占3个字节，因此每一个A类网络中的最大主机数是24-2，即6770214。这里减2的原因是:全0的主机号字段表示该IP地址是“本主机”所连接到的单个网络地址(例如，一主机的IP地址为567.8，则该主机所在的网络地址就是567.0.0.0)而全1表示“所有的(a)”，因此全1的主机号字段表示该网络上的所有主机</p><p>B类地址的网络号字段有2个字节，但前面两位(10)已经固定了，只剩下14位可以进行分配。因为网络号字段后面的14位无论怎样取值也不可能出现使整个2字节的网络号字段成为全0或全1，因此这里不存在网络总数减2的问题。</p><p>C类地址有3个字节的网络号字段，最前面的3位是(110)，还有21位可以进行分配。C类网络地址1920.0.0也是不指派的，可以指派的C类最小网络地址是92010</p><p><strong>IP地址的指派范围</strong></p><table><thead><tr><th>网络类别</th><th>最大可指派的网络数</th><th>第一个可指派的网络号</th><th>最后一个可指派的网络号</th><th>每个网络中的最大主机数</th></tr></thead><tbody><tr><td>A</td><td>2{7}-2</td><td>1</td><td>126</td><td>16777214</td></tr><tr><td>B</td><td>2{14}-2</td><td>128.1</td><td>191.255</td><td>65534</td></tr><tr><td>C</td><td>2{21}-2</td><td>192.0.1</td><td>223.255.255</td><td>254</td></tr></tbody></table><p><strong>一般不使用的特殊IP地址</strong></p><table><thead><tr><th>网络号</th><th>主机号</th><th>源地址使用</th><th>目的地址使用</th><th>代表的意思</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>可以</td><td>不可</td><td>在本网络上的本主机(DHCP)</td></tr><tr><td>0</td><td>host-id</td><td>可以</td><td>不可</td><td>在本网络上的某台主机 host-id</td></tr><tr><td>全1</td><td>全1</td><td>不可</td><td>可以</td><td>只在本网络上进行广播(各路由器均不转发)</td></tr><tr><td>net-id</td><td>全1</td><td>不可</td><td>可以</td><td>对net-id上的所有主机进行广播</td></tr><tr><td>127</td><td>非全0或全1的任何数</td><td>可以</td><td>可以</td><td>用于本地软件环回测试</td></tr></tbody></table><p><strong>特点</strong></p><ul><li>每一个IP地址都由网络号和主机号两部分组成。所以IP地址是一种<br>分等级的地址结构。分两个等级的好处是:<ul><li>IP地址管理机构在分配I地址时只分配网络号(第一级)，而剩下的主机号(第二级)则由得到该网络号的单位自行分配。</li><li>路由器仅根据目的主机所连接的网络号来转发分组(而不考虑目的主机号)，这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间以及查找路由表的时间。</li></ul></li><li>实际上IP地址是标志一台主机(或路由器)和一条链路的接口。当一台主机同时连<br>接到两个网络上时，该主机就必须同时具有两个相应的IP地址，其网络号必须是不同的<br>这种主机称为多归属主机。</li><li>用转发器或网桥连接起来的若干个局域网仍为一个网络，因为这些局域网都具有同样的网络号。具有不同网络号的局域网必须使用路由器进行互连。</li><li>所有分配到网络号的网络(不管是范围很小的局域网，还是可能覆盖很大地理范围的广域网)都是平等的。所谓平等，是指互联网同等对待每一个IP地址。</li></ul><p><img src="/images/network-basic/IPofInternet.PNG"></p><h3 id="4-2-2-私有地址"><a href="#4-2-2-私有地址" class="headerlink" title="4.2.2. 私有地址"></a>4.2.2. 私有地址</h3><p>由于IP地址的紧缺，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机数。考虑到互联网并不很安全，一个机构内也并不需要把所有的主机接入到外部的互联网.实际上，在许多情况下，很多主机主要还是和本机构内的其他主机进行通信。假定在一个机构内部的计算机通信也是采用 TCP/IP协议，那么从原则上讲，对于这些仅在机构内部使用的计算机就可以由本机构自行分配其IP地址。这就是说，让这些计算机使用仅在本机构有效的酽地址(这种地址称为私有地址)，而不需要向互联网的管理机构申请全球唯一的IP地址(这种地址称为公有地址)。这样就可以大大节约宝贵的全球IP地址资源。</p><p>为了解决这一问题，RFC1918指明了一些专用地址( private address)这些地址只能用<br>于一个机构的内部通信，而不能用于和互联网上的主机通信。在互联网中的所有路由器，对目的地址是专用地址的数据报<br>律不进行转发，即</p><ul><li>10.0.0.0到10.255.255.255(或记为10.0.0.0/8，它又称为24位块)</li><li>172.16.0.0到172.16.255.255(或记为172.16.0.0/12，它又称为20位块)</li><li>192.168.0.0到192.168.255.255(或记为192.168.0.0/16，它又称为16位块)</li></ul><p>采用这样的专用IP地址的互连网络就叫做专用网。专用IP地址也叫做可重用地址。</p><h3 id="4-2-3-网络地址转换NAT"><a href="#4-2-3-网络地址转换NAT" class="headerlink" title="4.2.3. 网络地址转换NAT"></a>4.2.3. 网络地址转换NAT</h3><p>下面讨论另一种情况，就是在专用网内部的一些主机本来已经分配到了本地IP地址，即仅在本专用网内使用的专用地址)，但现在又想和互联网上的主机通信(并不需要加密)，那么应当采取什么措施呢?</p><p>网络地址转换NAT需要在专用网连接到互联网的路由器上安装NAT软件。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。这样，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和互联网连接。</p><h3 id="4-2-4-DHCP协议"><a href="#4-2-4-DHCP协议" class="headerlink" title="4.2.4. DHCP协议"></a>4.2.4. DHCP协议</h3><p>DHCP动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p><h3 id="4-2-5-IP地址与硬件地址"><a href="#4-2-5-IP地址与硬件地址" class="headerlink" title="4.2.5. IP地址与硬件地址"></a>4.2.5. IP地址与硬件地址</h3><p>从层次的角度看，物理地址是数据链路层和物理层使用的地址，而IP地址是网络层和以上各层使用的地址，是一种逻辑地址(用软件实现的)。</p><p>IP地址放在IP数据报的首部，而硬件地址则放在MAC帧的首部。在网络层和网络层以上使用的是IP地址，而数据链路层及以下使用的是硬件地址。当IP数据报放入数据链路层的MAC帧中以后，整个的IP数据报就成为MAC帧的数据，因而在数据链路层看不见数据报的IP地址。</p><p><img src="/images/network-basic/ip-dl.PNG"></p><p><strong>要点</strong></p><ol><li>在IP层抽象的互联网上只能看到IP数据报。</li><li>虽然在P数据报首部有源站IP地址，但路由器只根据目的站的I地址的网络号进行路由选择</li><li>在局域网的链路层，只能看见MAC帧。<br>IP数据报被封装在MAC帧中。MAC帧在不同网络上传送时，其MAC帧首部中的源地址和目的地址要发生变化。开始在H1到R1间传送时，MAC帧首部中写的是从硬件地址HA1发送到硬件地址HA3，路由器R1收到此MAC帧后，在数据链路层，要丢弃原来的MAC帧的首部和尾部。在转发时在数据链路层，要重新添加上MAC帧的首部和尾部。这时首部中的源地址和目的地址分别便成为HA4和HA5。路由器R2收到此帧后，再次更换MAC帧的首部和尾部，首部中的源地址和目的地址分别变成为HA6和HA2。MAC帧的首部的这种变化，在上面的IP层上是看不见的。</li><li>尽管互连在一起的网络的硬件地址体系各不相同，但IP层抽象的互联网却屏蔽了<br>下层这些很复杂的细节。只要我们在网络层上讨论问题，就能够使用统一的、抽象的IP地址研究主机和主机或路由器之间的通信。</li></ol><p>既然在网络链路上传送的帧最终是按照硬件地址找到目的主机的，那么为什么我们还要使用抽象的IP地址，而不直接使用硬件地址进行通信?</p><p>由于全世界存在着各式各样的网络，它们使用不同的硬件地址。要使这些异构网络能<br>够互相通信就必须进行非常复杂的硬件地址转换工作，因此由用户或用户主机来完成这项作几乎是不可能的事。但IP编址把这个复杂问题解决了。连接到互联网的主机只需各自拥有一个唯一的IP地址，它们之间的通信就像连接在同一个网络上那样简单方便，因为上述的调用ARP的复杂过程都是由计算机软件自动进行的，对用户来说是看不见这种调用过程的。</p><h3 id="4-2-6-地址解析协议ARP"><a href="#4-2-6-地址解析协议ARP" class="headerlink" title="4.2.6. 地址解析协议ARP"></a>4.2.6. 地址解析协议ARP</h3><p>网络层使用的是IP地址，但在实际网络的链路上传送数据帧时还是必须使用该网络的硬件地址。但IP地址和下面的网络的硬件地址之间由于格式不同而不存在简单的映射关系。此外，IP或MAC地址可能会改变。地址解析协议ARP解决这个问题的方法是在主机ARP高速缓存中存放一个从IP地址到硬件地址的映射表，并且这个映射表还经常动态更新(新增或超时删除)。<br>每一台主机都设有一个ARP高速缓存( ARP cache)，里面有本局域网上的各主机和路由器的IP地址到硬件地址的映射表，这些都是该主机目前知道的一些地址。</p><h5 id="4-2-6-1-同一局域网"><a href="#4-2-6-1-同一局域网" class="headerlink" title="4.2.6.1. 同一局域网"></a>4.2.6.1. 同一局域网</h5><p>当主机A要向本局域网上的某台主机B发送IP数据报时，就先在其ARP高速缓存中<br>查看有无主机B的IP地址。</p><p>若有，就在ARP高速缓存中查出其对应的硬件地址，再把这硬件地址写入MAC帧，然后通过局域网把该MAC帧发往此硬件地址；<br>若没有，主机A就自动运行ARP，然后按以下步骤找出主机B的硬件地址。</p><ol><li>ARP进程在本局域网上广播发送一个ARP请求分组；</li><li>在本局域网上的所有主机上运行的ARP进程都收到此ARP请求分组</li><li>主机B的IP地址与ARP请求分组中要查询的P地址一致，就收下这个ARP请求分组，并向主机A发送ARP响应分组，同时在这个ARP响应分组中写入自己的硬件地址。由于其余的所有主机的IP地址都与ARP请求分组中要查询的IP地址不一致，因此都不理睬这个ARP请求分组。<br>ARP请求分组是广播发送的，但ARP响应分组是普通的单播。</li><li>主机A收到主机B的ARP响应分组后，就在其ARP高速缓存中写入主机B的IP地址到硬件地址的映射。同时主机B记录主机A的映射。</li></ol><p>ARP对保存在高速缓存中的每一个映射地址项目都设置生存时间凡超过生存时间的项目就从高速缓存中删除掉。</p><h5 id="4-2-6-2-不在同一局域网"><a href="#4-2-6-2-不在同一局域网" class="headerlink" title="4.2.6.2. 不在同一局域网"></a>4.2.6.2. 不在同一局域网</h5><p>四种情况：</p><p><img src="/images/network-basic/ARPfour.PNG"></p><ol><li>发送方是主机(如H1)，要把IP数据报发送到同一个网络上的另一台主机(如H2)。这时H发送ARP请求分组(在网1上广播)，找到目的主机H2的硬件地址。</li><li>发送方是主机(如H1)，要把IP数据报发送到另一个网络上的一台主机(如H3或H4)。这时H1发送ARP请求分组(在网1上广播)，找到网1上的一个路由器R1的硬件地址。剩下的工作由路由器R1来完成。R1要做的事情是下面的(3)或(4)。</li><li>发送方是路由器(如R1)，要把P数据报转发到与R1连接在同一个网络(网2)上的主机(如H3)。这时R1发送ARP请求分组(在网2上广播)，找到目的主机H3的硬件地址</li><li>发送方是路由器(如R1)，要把IP数据报转发到网3上的一台主机(如H4)。H4与不是连接在同一个网络上。这时R1发送ARP请求分组(在网2上广播)，找到连接在网2上的一个路由器R2的硬件地址。剩下的工作由这个路由器R2来完成</li></ol><h3 id="4-2-7-逆地址解析协议RARP"><a href="#4-2-7-逆地址解析协议RARP" class="headerlink" title="4.2.7. 逆地址解析协议RARP"></a>4.2.7. 逆地址解析协议RARP</h3><p>功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址，比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。</p><p><strong>工作流程</strong></p><ol><li>给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；</li><li>本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；</li><li>如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；</li><li>如果不存在，RARP服务器对此不做任何的响应；</li><li>源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。</li></ol><h3 id="4-2-8-IP数据报的格式"><a href="#4-2-8-IP数据报的格式" class="headerlink" title="4.2.8. IP数据报的格式"></a>4.2.8. IP数据报的格式</h3><p><img src="/images/network-basic/ip.PNG"></p><ul><li>版本：占4位，指P协议的版本。通信双方使用的P协议的版本必须一致。</li><li>首部长度：占4位，可表示的最大十进制数值是15。</li></ul><p>首部长度字段所表示数的单位是32位字(4字节)，因此首部长度字段的最小值是5，最大值15。当IP分组的首部长度不是4字节的整数倍时，必须利用最后的填充字段加以填充。因此IP数据报的数据部分永远在4字节的整数倍时开始，这样在实现IP协议时较为方便。</p><ul><li>区分服务：占8位，用来获得更好的服务。旧标准中叫做服务类型，但实际上一直没有被使用过。</li><li>总长度：总长度指首部和数据之和的长度，单位为字节。</li></ul><p>最常用的以太网规定其MTU值是1500字节。若所传送的数据报长度超过数据链路层的MTU值，就必须把过长的数据报进行分片处理。</p><p>虽然使用尽可能长的PP数据报会使传输效率得到提高，但每一个IP数据报越短，路由<br>转发的速度就越快。为此，IP协议规定，在互联网中所有的主机和路由器，必须能够接<br>受长度不超过576字节的数据报。这是假定上层交下来的数据长度有512字节，加上最长的IP首部60字节，再加上4字节的富余量，就得到576字节。当主机需要发送长度超过576字节的数据报时，应当先了解一下，目的主机能否接受所要发送的数据报长度。否则，就要进行分片。</p><p>在进行分片时(见后面的“片偏移”字段)，数据报首部中的“总长度”字段是指分片<br>后的每一个分片的首部长度与该分片的数据长度的总和。</p><ul><li>标识：占16位。IP软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。</li></ul><p>但这个“标识”并不是序号，因为IP是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的MTU而必须分片时，这个标识字段的值就被复制到所有的数据报片的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。</p><ul><li>标志：占3位，但目前只有两位有意义<ul><li>标志字段中的最低位记为MF(More Fragment)。MF=1即表示后面“还有分片”的数据报。MF=0表示这已是若干数据报片中的最后一个。</li><li>标志字段中间的一位记为DF(Don’ t Fragment)，意思是“不能分片”。只有当DF<br>0时才允许分片。</li></ul></li><li>片偏移：占13位。片偏移指出:较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对于用户数据字段的起点，该片从何处开始。片偏移以8个字节为偏移单位。这就是说，每个分片的长度一定是8字节(64位)的整数倍。</li></ul><p><img src="/images/network-basic/ip-shard.PNG"></p><ul><li>生存时间：占8位，生存时间字段常用的英文缩写是TTL( Time To live)，表明<br>这是数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在互联网中兜圈子。</li></ul><p>然而随着技术的进步，路由器处理数据报所需的时间不断在缩短，一般都远远小于1秒，后来就把TTL字段的功能改为“跳数限制”(但名称不变)。路由器在每次转发数据报之前就把TTL值减1。若TTL值减小到零，就丢弃这个数据报，不再转发。因此，现在TTL的单位不再是秒，而是跳数。TTL的意义是指明数据报在互联网中至多可经过多少路由器。显然，数据报能在互联网中经过的路由器的最大数值是255。若把TTL的初始值设置为1，就表示这个数据报只能在本局域网中传送。因为这个数据报一传送到局域网上的某个路由器，在被转发之前TIL值就减小到零，因而就会被这个路由器丢弃。</p><ul><li>协议：占8位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的<br>主机的IP层知道应将数据部分上交给哪个协议进行处理。</li><li>首部检验和占16位。这个字段只检验数据报的首部，但不包括数据部分。非CRC。</li><li>源地址：占32位。</li><li>目的地址：占32位。</li></ul><h3 id="4-2-9-IP层转发分组的流程"><a href="#4-2-9-IP层转发分组的流程" class="headerlink" title="4.2.9. IP层转发分组的流程"></a>4.2.9. IP层转发分组的流程</h3><p>在路由表中，对每一条路由最主要的是以下两个信息：</p><p><strong>(目的网络地址，下一跳地址)</strong></p><ol><li>从数据报的首部提取目的主机的IP地址D，得出目的网络地址为N；</li><li>若N就是与此路由器直接相连的某个网络地址，则进行直接交付，不需要再经过其<br>他的路由器，直接把数据报交付目的主机(这里包括把目的主机地址D转换为具体的硬件地址，把数据报封装为MAC帧，再发送此帧);否则就是间接交付，执行3；</li><li>若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的<br>下一跳路由器;否则，执行4；</li><li>若路由表中有到达网络N的路由，则把数据报传送给路由表中所指明的下一跳路由<br>器;否则，执行5；</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器;否<br>则，执行6；</li><li>报告转发分组出错。</li></ol><p>当路由器收到一个待转发的数据报，在从路由表得出下一跳路由器的IP地址后，不是<br>把这个地址填入IP数据报，而是送交数据链路层的网络接口软件。网络接口软件负责把下跳路由器的IP地址转换成硬件地址(必须使用ARP)，并将此硬件地址放在链路层的<br>MAC帧的首部，然后根据这个硬件地址找到下一跳路由器。由此可见，当发送一连串的数据报时，上述的这种查找路由表、用ARP得到硬件地址、把硬件地址写入MAC帧的首部等过程，将不断地重复进行，造成了一定的开销。</p><h2 id="4-3-划分子网和构造超网"><a href="#4-3-划分子网和构造超网" class="headerlink" title="4.3. 划分子网和构造超网"></a>4.3. 划分子网和构造超网</h2><h3 id="4-3-1-划分子网"><a href="#4-3-1-划分子网" class="headerlink" title="4.3.1. 划分子网"></a>4.3.1. 划分子网</h3><h4 id="4-3-1-1-三级IP地址"><a href="#4-3-1-1-三级IP地址" class="headerlink" title="4.3.1.1. 三级IP地址"></a>4.3.1.1. 三级IP地址</h4><p><strong>两级IP地址的缺点</strong></p><ul><li>IP地址空间的利用率有时很低。</li><li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。</li><li>两级IP地址不够灵活。</li></ul><p><strong>基本思路</strong></p><ul><li>一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个子网( subne划分子网纯属一个单位内部的事情。本单位以外的网络看不见这个网络是由多少个子网组成，因为这个单位对外仍然表现为一个网络。</li><li>划分子网的方法是从网络的主机号借用若干位作为子网号 ibnet-id，当然主机号<br>也就相应减少了同样的位数。于是两级IP地址在本单位内部就变为三级IP地址:网络号子网号和主机号。也可以用以下记法来表示</li></ul><p><strong>IP地址:={&lt;网络号&gt;，&lt;子网号&gt;，&lt;主机号&gt;}</strong></p><ul><li>凡是从其他网络发送给本单位某台主机的IP数据报，路由器在收到IP数据报后，再按目的网络号和子网号找到目的子网，把IP数据报交付目的主机。</li></ul><h4 id="4-3-1-2-子网掩码"><a href="#4-3-1-2-子网掩码" class="headerlink" title="4.3.1.2. 子网掩码"></a>4.3.1.2. 子网掩码</h4><p>使用子网掩码的好处:不管网络有没有划分子网，只要把子网掩码和IP地址进行<br>逐位的“与”运算(AND)，就立即得出网络地址来。这样在路由器处理到来的分组时就可采用同样的算法。</p><p><img src="/images/network-basic/subnetMask.PNG"></p><p>所有的网络都必须使用子网掩码，同时在路由器的路由表中也必须有子网掩码这一栏。如果一个网络不划分子网，那么该网络的子网掩码就使用默认子网掩码。默认子网掩码中1的位置和I地址中的网络号字段net-id正好相对应。因此，若用默认子网掩码和某个不划分子网的IP地址逐位相“与”(AND)，就应当能够得出该IP地址的网络地址来。这样做可以不用査找该地址的类别位就能知道这是哪一类的IP地址。显然，</p><p>A类地址的默认子网掩码是255.0.0.0，或0xFF000000<br>B类地址的默认子网掩码是255.255.0.0，或0 XFFFF0000。<br>C类地址的默认子网掩码是255.255.255.0，或0 XFFFFFF00。</p><p>B类地址的子网划分选择(使用固定长度子网)：</p><table><thead><tr><th>子网号的位数</th><th>子网掩码</th><th>子网数</th><th>每个子网的主机数</th></tr></thead><tbody><tr><td>2</td><td>255.255.192.0</td><td>2{2次方}-2</td><td>2{14次方}-2</td></tr><tr><td>2</td><td>255.255.224.0</td><td>2{3次方}-2</td><td>2{13次方}-2</td></tr><tr><td>2</td><td>255.255.240.0</td><td>2{4次方}-2</td><td>2{12次方}-2</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><p>子网号的位数中没有0，1，15和16这四种情况，因为这没有意义。</p><p>划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数。</p><h4 id="4-3-1-3-使用子网的分组转发"><a href="#4-3-1-3-使用子网的分组转发" class="headerlink" title="4.3.1.3. 使用子网的分组转发"></a>4.3.1.3. 使用子网的分组转发</h4><p>我们应当注意到，使用子网划分后，路由表必须包含以下三项内容:</p><p><strong>目的网络地址，子网掩码，下一跳地址</strong></p><p>在划分子网的情况下，路由器转发分组的算法如下：</p><ol><li>从收到的数据报的首部提取目的IP地址D；</li><li>先判断是否为直接交付。对路由器直接相连的网络逐个进行检查:用各网络的子网掩码和D逐位相“与”(AND操作)，看结果是否和相应的网络地址匹配。若匹配，则把分组进行直接交付(当然还需要把D转换成物理地址，把数据报封装成帧发送出去)，转发任务结束。否则就是间接交付，执行3；</li><li>若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的<br>下一跳路由器;否则，执行4；</li><li>对路由表中的每一行(目的网络地址，子网掩码，下一跳地址)，用其中的子网掩<br>码和D逐位相“与”(AND操作)，其结果为N。若N与该行的目的网络地址匹配，则把数<br>据报传送给该行指明的下一跳路由器;否则，执行5；</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器;否<br>则，执行6；</li><li>报告转发分组出错。</li></ol><h3 id="4-3-2-构造超网"><a href="#4-3-2-构造超网" class="headerlink" title="4.3.2. 构造超网"></a>4.3.2. 构造超网</h3><h4 id="4-3-2-1-网络前缀"><a href="#4-3-2-1-网络前缀" class="headerlink" title="4.3.2.1. 网络前缀"></a>4.3.2.1. 网络前缀</h4><p>因为IPv4的地址即将耗尽，出现无分类域间路由选择CIDR。</p><p><strong>特点</strong></p><ul><li>CIDR消除了传统的A类、B类和C类地址以及划分子网的概念，32位的IP地址划分为用来指明网络的“网络前缀”和主机号。其记法是：</li></ul><p><strong>IP地址∷={网络前缀&gt;，&lt;主机号&gt;}</strong></p><p>CDR还使用“斜线记法”，或称为CIDR记法，即在IP地址后面加上斜线然后写上网络前缀所占的位数。</p><p>CIDR使用32位的地址掩码。地址掩码由串1和一串0组成，而1的个数就是网络前缀的长度。斜线记法中，斜线后面的数字就是地址掩码中1的个数。</p><ul><li>CIDR把网络前缀都相同的连续的P地址组成一个“CIDR地址块”。</li></ul><p>由于一个CIDR地址块中有很多地址，所以在路由表中就利用CIDR地址块来查找目的<br>网络。这种地址的聚合常称为路由聚合( route aggregation)，它使得路由表中的一个项目可以表示原来传统分类地址的很多个(例如上千个)路由。路由聚合也称为构成超网。</p><p>常用的CIDR地址块：</p><table><thead><tr><th>CIDR前缀长度</th><th>点分十进制</th><th>包含的地址数</th><th>相当于包含分类的网络数</th></tr></thead><tbody><tr><td>/13</td><td>255.248.0.0</td><td>512K</td><td>8个B类或2048个C类</td></tr><tr><td>/14</td><td>255.252.0.0</td><td>256K</td><td>4个B类或1024个C类</td></tr><tr><td>/15</td><td>255.254.0.0</td><td>128K</td><td>2个B类或512个C类</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><p>使用CIDR的一个好处就是可以更加有效地分配IPv4的地址空间，可根据客户的需要<br>分配适当大小的CIDR地址块。然而在分类地址的环境中，向一个部门分配IP地址，就只能以/8，/16或/24为单位来分配，这就很不灵活。</p><p>构成超网是将网络前缀缩短。网络前缓越短，其地址块所包含的地址数就越多。而在三级结构的IP地址中，划分子网是使网络前缀变长。</p><h2 id="4-4-ICMP网际控制报文协议"><a href="#4-4-ICMP网际控制报文协议" class="headerlink" title="4.4. ICMP网际控制报文协议"></a>4.4. ICMP网际控制报文协议</h2><p>为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了网际控制报文协<br>议ICMP。ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP报文是装在IP数据报中，作为其中的数据部分。</p><p>两种常用的ICMP报文类型：</p><table><thead><tr><th>ICMP报文种类</th><th>类型的值</th><th>ICMP报文的类型</th></tr></thead><tbody><tr><td>差错报告报文</td><td>3</td><td>终点不可达：不能交付数据报</td></tr><tr><td>差错报告报文</td><td>11</td><td>时间超过：生存时间为零的数据报</td></tr><tr><td>差错报告报文</td><td>12</td><td>参数问题：数据报首部的参数不正确</td></tr><tr><td>差错报告报文</td><td>5</td><td>改变路由：最佳路由</td></tr><tr><td>询问报文</td><td>8或0</td><td>回送请求或回答：测试目的站是否可达以及了解其有关状态</td></tr><tr><td>询问报文</td><td>13或14</td><td>时间戳请求或回答：用于时钟同步和时间测量</td></tr></tbody></table><h2 id="4-5-路由选择协议"><a href="#4-5-路由选择协议" class="headerlink" title="4.5. 路由选择协议"></a>4.5. 路由选择协议</h2><p>倘若从路由算法能否随网络的通信量或拓扑自适应地进行调整变化来划分：</p><ul><li>静态路由选择策略：也叫做非自适应路由选择，特点是简单和开销较小，但不能及时适应网络状态的变化。对于很简单的小网络，完全可以采用静态路由选择，用人工配置每一条路由。</li><li>动态路由选择策略。也叫做自适应路由选择，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。适用于较复杂的大网络。</li></ul><p><strong>分层次的路由选择协议</strong></p><p>把整个互联网划分为许多较小的自治系统(autonomous system)，记为AS。一个AS对其他AS表现出的是一个单一的和一致的路由选择策略。</p><p>在目前的互联网中，一个大的ISP就是一个自治系统。这样，互联网就把路由选择协议<br>划分为两大类：</p><ul><li>内部网关协议IGP：即在一个自治系统内部使用的路由选择协议，而这与在互联网中的其他自治系统选用什么路由选择协议无关。如RIP和OSPF协议。</li><li>外部网关协议EGP：若源主机和目的主机处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议EGP。目前使用最多的外部网关协议是BGP的版本4(BGP4)。</li></ul><p>自治系统之间的路由选择也叫做域间路由选择，而在自治系统内部的路由选择叫做域内路由选择。</p><h3 id="4-5-1-内部网关协议RIP"><a href="#4-5-1-内部网关协议RIP" class="headerlink" title="4.5.1. 内部网关协议RIP"></a>4.5.1. 内部网关协议RIP</h3><h4 id="4-5-1-1-工作原理"><a href="#4-5-1-1-工作原理" class="headerlink" title="4.5.1.1. 工作原理"></a>4.5.1.1. 工作原理</h4><p>一种分布式的基于距离向量的路由选择协议。</p><p>RIP协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记<br>录。RIP协议将“距离”定义为从一路由器到直接连接的网络的距离定义为1。从一路由器到非直接连接的网络的距离定义为所经过的路由器数加1。</p><p><strong>特点</strong></p><ul><li>仅和相邻路由器交换信息。不相邻的路由器不交换信息</li><li>路由器交换的信息是当前本路由器所知道的全部信息，即自己现在的路由表。</li><li>按固定的时间间隔交换路由信息。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。</li></ul><h4 id="4-5-1-2-距离向量算法"><a href="#4-5-1-2-距离向量算法" class="headerlink" title="4.5.1.2. 距离向量算法"></a>4.5.1.2. 距离向量算法</h4><p>对每一个相邻路由器发送过来的RIP报文，进行以下步骤：</p><ul><li>对地址为ⅹ的相邻路由器发来的RIP报文，先修改此报文中的所有项目:把“下一跳”字段中的地址都改为X，并把所有的“距离”字段的值加1。每一个项目都有三个关键数据，即:到目的网络N，距离是d，下一跳路由器是X</li><li>对修改后的RP报文中的每一个项目，进行以下步骤:<ul><li>若原来的路由表中没有目的网络N，则把该项目添加到路由表中</li><li>否则(即在路由表中有目的网络N，这时就再査看下一跳路由器地址<ul><li>若下一跳路由器地址是Ⅹ，则把收到的项目替换原路由表中的项目</li><li>否则(即这个项目是:到目的网络N，但下一跳路由器不是X<ul><li>若收到的项目中的距离d小于路由表中的距离，则进行更新</li><li>否则什么也不做。</li></ul></li></ul></li></ul></li><li>若3分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达的路<br>由器，即把距离置为16(距离为16表示不可达)。</li><li>返回。</li></ul><p>RIP协议使得从每一个路由器到每一个目的网络的路由都是最短的。虽然所有的路由器最终都拥有了整个自治系统的全局路由信息，但由于每一个路由器的位置不同，它们的路由表当然也应当是不同的。</p><p><strong>优点</strong></p><ul><li>实现简单、开销较小。</li><li>好消息传播得快，但是坏消息传播得慢。</li></ul><p><strong>缺点</strong>n</p><ul><li>RIP限制了网络的规模，它能使用的最大距离为15(16表示不可达)。</li><li>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。最后，“坏消息传播得慢”，使更新过程的收敛时间过长。</li></ul><h3 id="4-5-2-内部网关协议OSPF"><a href="#4-5-2-内部网关协议OSPF" class="headerlink" title="4.5.2. 内部网关协议OSPF"></a>4.5.2. 内部网关协议OSPF</h3><p>开放最短路径优先OSPF，使用最短路径算法SPF，使用分布式的链路状态协议。它是为克服RIP的缺点而开发。</p><p><strong>特点</strong></p><ul><li>向本自治系统中所有路由器发送信息。这里使用的方法是洪泛法，路由器通过所有输出端口向所有相邻的路由器发送信息。而每一个相邻路由器又再将此信息发往其所有的相邻路由器(但不再发送给刚刚发来信息的那个路由器)。这样，最终整个区域中所有的路由器都得到了这个信息的一个副本。RIP协议是仅仅向自己相邻的几个路由器发送信息。</li><li>发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。所谓“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的度量”，称这个度量为“代价”。RIP协议发送的信息是到所有网络的距离和下一跳路由器。</li><li>只有当链路状态发生变化时，路由器才向所有路由器用洪泛法发送此信息。而不像<br>RIP那样，不管网络拓扑有无发生变化，路由器之间都要定期交换路由表的信息。</li></ul><p><strong>优点</strong></p><p>所有的路由器最终都能建立一个链路状态数据库，实际上就是全网的拓扑结构图。这个拓扑结构图在全网范围内是一致的。RIP协议的每一个路由器虽然知道到所有的网络的距离以及下一跳路由器，但却不知道全网的拓扑结构(只有到了下一跳路由器，才能知道再下一跳应当怎样走。</p><p>OSPF的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表，更新过程收敛得快是其重要优点。</p><p>OSPF不用UDP而是直接用IP数据报传送。</p><h3 id="4-5-3-外部网关协议BGP"><a href="#4-5-3-外部网关协议BGP" class="headerlink" title="4.5.3. 外部网关协议BGP"></a>4.5.3. 外部网关协议BGP</h3><p>内部网关协议(如RIP或OSPF)主要是设法使数据报在一个AS中尽可能有效地从源站传送到目的站。在一个AS内部也不需要考虑其他方面的策略。然而BGP使用的环境却不同。这主要是因为互联网的规模太大，使得自治系统AS之间路由选择非常困难，并且自治系统AS之间的路由选择必须考虑有关策略（自愿连接、安全等）。</p><p>所以边界网关协议BGP只能是力求寻找一条能够到达目的网络且比较好的<br>路由(不能兜圈子)，而并非要寻找一条最佳路由。</p><p>BGP采用了路径向量路由选择协议。</p><ol><li>每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“BGP发言人”。一般两个BGP发言人都是通过一个共享网络连接在一起的，而BGP发言人往往就是BGP边界路由器，也可以不是。</li><li>BGP发言人与其他AS的BGP发言人要交换路由信息，就要先建立TCP连接，彼此成为对方的邻站( neighbor〕或对等站(peer)。</li><li>边界网关协议BGP所交换的网终可达性的信息就是要到达某个网络所要经过的一系列自治系统。发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的较好路由。</li></ol><h1 id="5-运输层"><a href="#5-运输层" class="headerlink" title="5. 运输层"></a>5. 运输层</h1><h2 id="5-1-协议概述"><a href="#5-1-协议概述" class="headerlink" title="5.1. 协议概述"></a>5.1. 协议概述</h2><h3 id="5-1-1-进程之间的通信"><a href="#5-1-1-进程之间的通信" class="headerlink" title="5.1.1. 进程之间的通信"></a>5.1.1. 进程之间的通信</h3><p>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。当网络的边缘部分中的两台主机使用网络的核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。</p><p>运输层有一个很重要的功能—复用和分用。这里的“复用是指在发送方不同的应用进程都可以使用同一个运输层协议传送数据，而“分用”是指接收方的运输层在剥去报文的首部后能够把这些数据正确交付目的应用进程。</p><p>网络层为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。向高层用户屏蔽了下面网络核心的细节。</p><h3 id="5-1-2-两个主要协议"><a href="#5-1-2-两个主要协议" class="headerlink" title="5.1.2. 两个主要协议"></a>5.1.2. 两个主要协议</h3><ul><li>用户数据报协议UDP：UDP用户数据报，无连接，不可靠，尽最大努力交付的。</li><li>传输控制协议TCP：TCP报文段，面向连接，可靠的</li></ul><h3 id="5-1-3-端口"><a href="#5-1-3-端口" class="headerlink" title="5.1.3. 端口"></a>5.1.3. 端口</h3><p>为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法(而这种方法必须与特定操作系统无关)对TCP体系的应用进程进行标志。</p><p>解决这个问题的方法就是在运输层使用协议端口号，常简称为端口(port)。这就是说，虽然通信的终点是应用进程，但只要把所传送的报文交到目的主机的某个合适的目的端口，剩下的工作(即最后交付目的进程)就由TCP或UDP来完成。<br>这种在协议栈层间的抽象的协议端口是软件端口。</p><p>用一个16位端口号来标志一个端口。但端口号只具有本地意义，它只是为了标志本计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网不同计算机中，相同的端口号是没有关联的。16位的端口号可允许有65535个不同的端口。分为：</p><ul><li>服务器端使用的端口号<ul><li>熟知端口号 0~1023</li><li>等级端口号 1024~49151</li></ul></li><li>客户端使用的端口号 49152~65535</li></ul><p><strong>常见的熟知端口号</strong></p><table><thead><tr><th>FTP</th><th>TELNET</th><th>SMTP</th><th>DNS</th><th>TFTP</th><th>HTTP</th><th>SNMP</th><th>HTTPS</th></tr></thead><tbody><tr><td>21</td><td>23</td><td>25</td><td>53</td><td>69</td><td>80</td><td>161</td><td>443</td></tr></tbody></table><table><thead><tr><th>POP3</th><th>SSH</th><th>MySQL</th><th>Oracle</th><th>SQLServer</th><th>Sockets</th><th>Tomcat</th></tr></thead><tbody><tr><td>110</td><td>22</td><td>3306</td><td>1521</td><td>1433</td><td>1080</td><td>8080</td></tr></tbody></table><h2 id="5-2-用户数据报协议UDP"><a href="#5-2-用户数据报协议UDP" class="headerlink" title="5.2. 用户数据报协议UDP"></a>5.2. 用户数据报协议UDP</h2><ul><li>无连接的：减小开销和时延</li><li>尽最大努力：交付不可靠的</li><li>面向报文：保留上层报文的边界，一次交付一个完整的报文</li><li>没有拥塞控制：实时应用允许丢失，但需要低时延</li><li>支持一对一、一对多、多对一和多对多的交互通信</li><li>首部开销小：8字节</li></ul><p><img src="/images/network-basic/UDP.PNG"></p><ul><li>源端口：源端口号。在需要对方回信时选用。不需要时可用全0。</li><li>目的端口：目的端口号。这在终点交付报文时必须使用</li><li>长度：UDP用户数据报的长度，其最小值是8(仅有首部)。</li><li>检验和：检测UDP用户数据报在传输中是否有错。有错就丢弃，并由ICMP发送“终点不可达”。IP数据报只检验首部，UDP把首部和数据一起检验。</li></ul><h2 id="5-3-传输控制协议TCP概述"><a href="#5-3-传输控制协议TCP概述" class="headerlink" title="5.3. 传输控制协议TCP概述"></a>5.3. 传输控制协议TCP概述</h2><h3 id="5-3-1-TCP的主要特点"><a href="#5-3-1-TCP的主要特点" class="headerlink" title="5.3.1. TCP的主要特点"></a>5.3.1. TCP的主要特点</h3><ul><li>面向连接：建立连接、释放连接</li><li>每条TCP连接只能有两个端点：一对一</li><li>可靠交付</li><li>全双工通信：发送、接收缓存</li><li>面向字节流：然应用程序和TCP的交互是一次一个数据块(大小不等)，但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。TCP并不知道所传送的字节流的含义。</li></ul><h3 id="5-3-2-TCP的连接"><a href="#5-3-2-TCP的连接" class="headerlink" title="5.3.2. TCP的连接"></a>5.3.2. TCP的连接</h3><p>TCP的连接有两个断电，断电指的是套接字，即端口号拼接到IP地址：</p><p><strong>套接字 socket=(IP地址:端口号)</strong></p><p>每一条TCP连接唯一地被通信两端的两个端点(即两个套接字)所确定。即</p><p><strong>TCP连接:(socket1， socket2)=((IP1:port1)，(IP2:port2)</strong></p><h2 id="5-4-可靠传输的工作原理"><a href="#5-4-可靠传输的工作原理" class="headerlink" title="5.4. 可靠传输的工作原理"></a>5.4. 可靠传输的工作原理</h2><h3 id="5-4-1-停止等待协议"><a href="#5-4-1-停止等待协议" class="headerlink" title="5.4.1. 停止等待协议"></a>5.4.1. 停止等待协议</h3><p>“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。</p><h4 id="5-4-1-1-无差错情况"><a href="#5-4-1-1-无差错情况" class="headerlink" title="5.4.1.1. 无差错情况"></a>5.4.1.1. 无差错情况</h4><p>A发送分组M1，发完就暂停发送，等待B的确认。B收到了M1就向A发送确认。A在收到了对M1的确认后，就再发送下一个分组M2。同样，在收到B对M2的确认后，再发送M3。</p><p><img src="/images/network-basic/TCPstopwait.PNG"></p><h4 id="5-4-1-2-出现差错"><a href="#5-4-1-2-出现差错" class="headerlink" title="5.4.1.2. 出现差错"></a>5.4.1.2. 出现差错</h4><p>B接收M1时检测出了差错，就丢弃M1，其他什么也不做(不通知A收到有差错的分组)。A只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组，。这就叫做超时重传。要实现超时重传，就要在每发送完一个分组时设置一个超时计时器。如果在超时计时器到期之前收到了对方的确认，就撤销已设置的超时计时器。</p><p>因此要注意：</p><ol><li>A在发送完一个分组后，必须暂时保留已发送的分组的副本；</li><li>分组和确认分组都必须进行编号。</li><li>超时计时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些。</li></ol><h4 id="5-4-1-3-确认丢失和确认迟到"><a href="#5-4-1-3-确认丢失和确认迟到" class="headerlink" title="5.4.1.3. 确认丢失和确认迟到"></a>5.4.1.3. 确认丢失和确认迟到</h4><p><img src="/images/network-basic/TCPconfirmLossLate.PNG"></p><p><strong>确认丢失</strong></p><p>B所发送的对M1的确认丢失了。A在设定的超时重传时间内没有收到确认，并无法知道是自己发送的分组出错、丢失，或者是B发送的确认丢失了。因此A在超时计时器到期后就要重传M1。现在应注意B的动作。假定B又收到了重传的分组M1。这时应采取两个行动。</p><ol><li>丢弃这个重复的分组M1，不向上层交付。</li><li>向A发送确认。不能认为已经发送过确认就不再发送，因为A之所以重传M</li></ol><p><strong>确认迟到</strong></p><p>传输过程中没有出现差错，但B对分组M1的确认迟到了。A会收到重复的确认。对重复的确认的处理很简单:收下后就丢弃。B仍然会收到重复的M1，并且同样要丢弃重复的M1，并重传确认分组。</p><p>像上述的这种可靠传输协议常称为自动重传请求ARQ( Automatic Repeat reQuest)。意思<br>是重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组。</p><h4 id="5-4-1-4-信道利用率"><a href="#5-4-1-4-信道利用率" class="headerlink" title="5.4.1.4. 信道利用率"></a>5.4.1.4. 信道利用率</h4><p>停止等待协议的优点是简单，但缺点是信道利用率太低。</p><p><img src="/images/network-basic/TcpARQ.PNG"></p><p>当往返时间RTT远大于分组发送时间TD时，信道的利用率就会非常低。若出现重传，信道的利用率就还要降低。</p><p>为了提高传输效率，发送方可以采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地在传送。显然，这种传输方式可以获得很高的信道利用率。</p><p>即使用连续ARQ协议和滑动窗口协议。</p><h3 id="5-4-2-连续ARQ协议"><a href="#5-4-2-连续ARQ协议" class="headerlink" title="5.4.2. 连续ARQ协议"></a>5.4.2. 连续ARQ协议</h3><p>发送窗口的意义是:位于发送窗口内的5个分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。</p><p><img src="/images/network-basic/TcpSendWindow.PNG"></p><p>发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。接收方一般都是采用累积确认的方式。接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对按序到达的最后一个分组发送确认，这就表示:到这个分组为止的所有分组都已正确收到了。</p><p><strong>优缺点</strong></p><p>累积确认有优点也有缺点。优点是:容易实现，即使确认丢失也不必重传。但缺点是<br>不能向发送方反映出接收方已经正确收到的所有分组的信息，在通信质量不好时会多次重传。</p><h2 id="5-5-TCP报文段格式"><a href="#5-5-TCP报文段格式" class="headerlink" title="5.5. TCP报文段格式"></a>5.5. TCP报文段格式</h2><p>TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段。</p><p><img src="/images/network-basic/TCP.PNG"></p><ul><li>源端口和目的端口：各占2个字节，分别写入源端口号和目的端口号。</li><li>序号：占4字节。本报文段所发送的数据的第一个字节的序号。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。</li><li>确认号：占4字节，是期望收到对方下一个报文段的第一个数据字节的序号。若确认号=N，则表明:到序号N-1为止的所有数据都已正确收到。</li><li>数据偏移：占4位，实际上是指出TCP报文段的首部长度，单位是32位字(即以4字节）。</li><li>保留占6位，保留为今后使用，但目前应置为0。</li><li>紧急URG：当URG=1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(高优先级的数据)，而不要按原来的排队顺序来传送，例如<kbd>Ctrl + C</kbd>。TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据，这时要与首部中紧急指针字段配合使用。</li><li>确认ACK：仅当ACK=1时确认号字段才有效。当ACK=0时，确认号无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1。</li><li>推送PSH：当两个应用进程进行交互式的通信时，一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。发送方TCP把PSH置1，并立即创建一个报文段发送出去。接收方TCP收到PSH=1的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。</li><li>复位RST：当RST=1时，表明TCP连接中出现严重差错(如由于主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接。RST置1还用来拒绝一个非法的报文段或拒绝打开一个连接。</li><li>同步SYN：在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1。因此，SYN置为1就表示这是一个连接请求或连接接受报文。</li><li>终止FIN：用来释放一个连接。</li><li>窗口：占2字节。窗口指的是发送本报文段的的接收窗口(而不是自己的发送窗口)。窗口值代表目前允许对方发送的数据量(以字节为单位)。作为接收方让发送方设置其发送窗口的依据。</li><li>检验和：占2字节。检验和字段检验的范围包括首部和数据这两部分。</li><li>紧急指针：占2字节。紧急指针仅在URG=1时才有意义，它指出本报文段中的紧急数据的字节数，即紧急数据的末尾在报文段中的位置。</li><li>选项：长度可变，最长可达40字节。<ul><li>窗口扩大：高吞吐量下增大窗口数值的位数</li><li>时间戳：计算RTT；处理序号过大，防止序号取模绕回PAWS</li><li>选择确认</li></ul></li></ul><p>最大报文段长度MSS：每一个TCP报文段中的数据字段的最大长度。MSS太小，网络利用率降低；太大，IP层需要分片。</p><h2 id="5-6-TCP可靠传输的实现"><a href="#5-6-TCP可靠传输的实现" class="headerlink" title="5.6. TCP可靠传输的实现"></a>5.6. TCP可靠传输的实现</h2><h3 id="5-6-1-以字节为单位的滑动窗口"><a href="#5-6-1-以字节为单位的滑动窗口" class="headerlink" title="5.6.1. 以字节为单位的滑动窗口"></a>5.6.1. 以字节为单位的滑动窗口</h3><p>发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示己发送且己收到了确认。这些数据显然不需要再保留，而发送窗口前沿的前面部分表示不允许发送的。</p><p>发送窗口的位置由窗口前沿和后沿的位置共同确定。发送窗口后沿的变化情况有两种可能，即不动(没有收到新的确认)和前移(收到了新的确认)。发送窗口后沿不可能向后移动，因为不能撤销掉已收到的确认。发送窗口前沿通常是不断向前移动，但也有可能不动。</p><p><img src="/images/network-basic/TcpASend11.PNG"></p><p>B只能对按序收到的数据中的最高序号给出确认，因此B发送的确认报文段中的确认号仍然是31，而不能是32或33。<br>现在假定B收到了序号为31的数据，并把序号为31-33的数据交付主机，然后B删除这些数据。接着把接收窗口向前移动3个序号，同时给A发送确认，其中窗口值仍为20，但确认号是34。这表明B已经收到了到序号33为止的数据。我们注意到，B还收到了序号为37，38和40的数据，但这些都没有按序到达，只能先暂存在接收窗口中A收到B的确认后，就可以把发送窗口向前滑动3个序号，但指针P2不动。可以看出，现在A的可用窗口增大了，可发送的序号范围42-53。</p><p><img src="/images/network-basic/TcpAReceive.PNG"></p><p><strong>TCP的缓存与窗口的关系</strong></p><p><img src="/images/network-basic/TcpWinCacheRelation.PNG"></p><p>发送缓存用来暂时存放:</p><ul><li>发送应用程序传送给发送方TCP准备发送的数据;</li><li>TCP已发送出但尚未收到确认的数据。</li></ul><p>接收缓存用来暂时存放:</p><ul><li>按序到达的、但尚未被接收应用程序读取的数据</li><li>未按序到达的数据。</li></ul><p><strong>注意</strong></p><ol><li>在同一时刻，A的发送窗口并不总是和B的接收窗口一样大。因为通过网络传送窗口值需要经历一定的时间滞后；</li><li>对于不按序到达的数据应如何处理，TCP标准并无明确规定。如果接收方一律丢弃，对网络资源的利用不利，因此通常对不按序到达的数据是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程；</li><li>TCP要求接收方必须有累积确认的功能，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。</li></ol><h3 id="5-6-2-超时重传时间的选择"><a href="#5-6-2-超时重传时间的选择" class="headerlink" title="5.6.2. 超时重传时间的选择"></a>5.6.2. 超时重传时间的选择</h3><p>如果把超时重传时间设置得太短，就会引起很多报文段的不必要的重传，使网络负荷增大。但若把超时重传时间设置得过长，则又使网络的空闲时间增大，降低了传输效率。</p><p>TCP采用了一种自适应算法，它记录报文段的往返时间RTT。TCP保留了RTT的一个加权平均往返时间RTTs(这又称为平滑的往返时间）因为进行的是加权平均，因此得出的结果更加平滑)。每当第一次测量到RTT样本时，RTTs值就取为所测量到的RTT样本值。但以后每测量到一个新的RTT样本，就按下式重新计算一次RTTs：</p><p>新的RTTs=(1-α)×(旧的RTTs)+α*(新的RTT样本)</p><p>在上式中，0≤α&lt;1。若α很接近于零，表示新的RTTs值和旧的RTTs值相比变化不大，而对新的RTT样本影响不大(RTT值更新较慢)。若选择α接近于1，则表示新的RTTs值受新的RTT样本的影响较大(RT值更新较快)。</p><p>显然，超时计时器设置的超时重传时间RTO应略大于RTTs。RFC6298建议使用下式计算RTO</p><p>RTO=RTTs+4×RTTD</p><p>而RTTD是RTT的偏差的加权平均值，它与RTTs和新的RTT样本之差有关。</p><p>RFC6298建议这样计算RTTD。当第一次测量时，RTTD值取为测量到的RTT样本值的一半。在以后的测量中，则使用下式计算加权平均的RTT</p><p>新的RTTD=(1-β)×(旧的RTTD+β*|RTTs-新的RTT样本|</p><p>若收到的确认是对重传报文段的确认，但却被源主机当成是对原来的报文段的确认则这样计算出的RTTs和超时重传时间RTO就会偏大。若后面再发送的报文段又是经过重传后才收到确认报文段，则按此方法得出的超时重传时间RTO就越来越长。</p><p>Karn提出了一个算法:在计算加权平均RTTS时，只要报文段重传了，就不采用其往返时间样本，这样得出的加权平均RTTS和RTO就较准确。但是如果报文段的时延突然增大了很多，因<br>此在原来得出的重传时间内，不会收到确认报文段，于是就重传报文段。但根据Karn算<br>法，不考虑重传的报文段的往返时间样本，这样，超时重传时间就无法更新。</p><p>因此要对Karn算法进行修正。方法是:报文段每重传一次，就把超时重传时间RTO增大一些。典型的做法是取新的重传时间为旧的重传时间的2倍。当不再发生报文段的重传时，才根据上面给出的2式计算超时重传时间。实践证明，这种策略较为合理。</p><h3 id="5-6-3-选择确认SACK"><a href="#5-6-3-选择确认SACK" class="headerlink" title="5.6.3. 选择确认SACK"></a>5.6.3. 选择确认SACK</h3><p>若收到的报文段无差错，只是未按序号，中间还缺少一些序号的数据，那么能否设法只传送缺少的数据而不重传已经正确到达接收方的数据?选择确认就是一种可行的处理方法。</p><p><img src="/images/network-basic/SACK.PNG"></p><p>和前后字节不连续的每一个字节块都有两个边界:左边界和右边界。因此在图中用四个指针标记这些边界。左边界指出字节块的第一个字节的序号，但右边界减1才是字节块中的最后一个序号。</p><p>然而，SACK文档并没有指明发送方应当怎样响应SACK。因此大多数的实现还是重传所有未被确认的数据块。</p><h2 id="5-7-TCP的流量控制"><a href="#5-7-TCP的流量控制" class="headerlink" title="5.7. TCP的流量控制"></a>5.7. TCP的流量控制</h2><h3 id="5-7-1-利用滑动窗口实现流量控制"><a href="#5-7-1-利用滑动窗口实现流量控制" class="headerlink" title="5.7.1. 利用滑动窗口实现流量控制"></a>5.7.1. 利用滑动窗口实现流量控制</h3><p>所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</p><p><img src="/images/network-basic/TcpFlowControl.PNG"></p><p>现在我们考虑一种情况。B向A发送了零窗口的报文段后不久，B的接收缓存又有了一些存储空间。于是B向A发送了rwnd=400的报文段。然而这个报文段在传送过程中丢失了。A一直等待收到B发送的非零窗口的通知，而B也一直等待A发送的数据。如果没有其他措施，这种互相等待的死锁局面将一直延续下去。</p><p>为了解决这个问题，TCP为每一个连接设有一个持续计时器。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段(仅携带1字节的数据)，而对方就在确认这个探测报文段时给出了现在的窗口值。如果窗口仍然是零，那么收到这个报文段的一方就重新设置持续计时器。如果窗口不是零，那么死锁的僵局就可以打破了。</p><h3 id="5-7-2-TCP的传输效率"><a href="#5-7-2-TCP的传输效率" class="headerlink" title="5.7.2. TCP的传输效率"></a>5.7.2. TCP的传输效率</h3><p>不同的机制来控制TCP报文段的发送时机</p><ol><li>TCP维持一个变量，它等于最大报文段长度MSS。只要缓存中存放的数据达到MSS字节时，就组装成一个TCP报文段发送出去。</li><li>由发送方的应用进程指明要求发送报文段，即TCP支持的推送(push)操作。第三种机制是</li><li>发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段(但长度不能超过MSS)发送出去。</li></ol><p>在TCP的实现中广泛使用<strong>Nage算法</strong>。</p><p>算法如下:若发送应用进程把要发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。当发送方收到对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存。只有在收到对前一个报文段的确认后才继续发送下一个报文段。当数据到达较快而网络速率较慢时，用这样的方法可明显地减少所用的网络带宽。 Nagle算法还规定，当到达的数据已达到发送窗口大小的半或已达到报文段的最大长度时，就立即发送一个报文段。这样做，就可以有效地提高网络的吞吐量。</p><p><strong>糊涂窗口综合征</strong></p><p>设想一种情况:TCP接收方的缓存已满，而交互式的应用进程一次只从接收缓存中读取1个字节(这样就使接收缓存空间仅腾出1个字节)，然后向发送方发送确认，并把窗口设置为1个字节(但发送的数据报是40字节长)。接着，发送方又发来1个字节的数据(请注意，发送方发送的IP数据报是41字节长)。接收方发回确认，仍然将窗口设置为1个字节。这样进行下去，使网络的效率很低。</p><p>要解决这个问题，可以让接收方等待一段时间，使得或者接收缓存已有足够空间容纳最长的报文段，或者等到接收缓存已有一半空闲的空间。只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小。此外，发送方也不要发送太小的报文段，而是把数据积累成足够大的报文段，或达到接收方缓存的空间的一半大小。</p><h2 id="5-8-TCP的拥塞控制"><a href="#5-8-TCP的拥塞控制" class="headerlink" title="5.8. TCP的拥塞控制"></a>5.8. TCP的拥塞控制</h2><h3 id="5-8-1-拥塞控制的一般原理"><a href="#5-8-1-拥塞控制的一般原理" class="headerlink" title="5.8.1. 拥塞控制的一般原理"></a>5.8.1. 拥塞控制的一般原理</h3><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做<strong>拥塞</strong>。若网络中有许多资源同时呈现供应不足，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。</p><p>网络拥塞往往是由许多因素引起的。简单地扩大缓存的存储空间同样会造成网络资源的严重浪费，因而解决不了网络拥塞的问题。简单地将处理机的速率提高，可能会使上述情况缓解一些，但往往又会将瓶颈转移到其他地方。问题的实质往往是整个系统的各个部分不匹配。只有所有的部分都平衡了，问题才会得到解决。</p><p>拥塞控制与流量控制的关系密切，它们之间也存在着一些差别。所谓拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程。相反，流量控制往往是指点对点通信量的控制，是个端到端的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><p><img src="/images/network-basic/TcpCongestionControl.PNG"></p><p>从控制理论的角度来看有两种方法：</p><ul><li>开环控制：在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。</li><li>闭环控制是基于反馈环路的概念，主要有以下几种措施<ul><li>监测网络系统以便检测到拥塞在何时、何处发生。</li><li>把拥塞发生的信息传送到可采取行动的地方</li><li>调整网络系统的运行以解决出现的问题。</li></ul></li></ul><p>监测网络的拥塞：</p><ul><li>指标：由于缺少缓存空间而被丢弃的分组的百分数、平均队列长度、超时重传的分组数、平均分组时延、分组时延的标准差，等等。上述这些指标的上升都标志着拥塞的增长<br>般在监测到拥塞发生时，要将拥塞发生的信息传送到产生分组的源站。当然，通知<br>拥塞发生的分组同样会使网络更加拥塞</li><li>比特位：在路由器转发的分组中保留一个比特或字段，用该比特或字段的值表示网络没有拥塞或产生了拥塞。也可以由一些主机或路由器周期性地发出探测分组，以询问拥塞是否发生。</li></ul><h3 id="5-8-2-TCP的拥塞控制方法"><a href="#5-8-2-TCP的拥塞控制方法" class="headerlink" title="5.8.2. TCP的拥塞控制方法"></a>5.8.2. TCP的拥塞控制方法</h3><p>TCP进行拥塞控制的算法有四种：慢开始(sow-start)、拥塞避免(congestion avoidance)、快重传(fast retransmit)和快恢复(fast recovery)。</p><h4 id="5-8-2-1-慢开始"><a href="#5-8-2-1-慢开始" class="headerlink" title="5.8.2.1. 慢开始"></a>5.8.2.1. 慢开始</h4><p>发送方维持一个叫做<strong>拥塞窗口</strong>cwnd(congestion window)的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。<strong>发送方让自己的发送窗口等于拥塞窗口。</strong></p><p>发送方控制拥塞窗口的原则是:只要网络没有出现拥塞，拥塞窗口就可以再增大些，以便把更多的分组发送出去。但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些。</p><p>判断网络拥塞的依据就是出现了超时。</p><p>慢开始算法的思路是这样的:当主机开始发送数据时，是先探测一下，由小到大逐渐增大发送窗口，即由小到大逐渐增大拥塞窗口数值。</p><p>慢开始规定，在每收到一个对新的报文段的确认后，可以把拥塞窗口増加最多一个SMSS的数值。</p><p>拥塞窗口cwnd每次的增加量=min(N，SMSS)</p><p>请注意，实际上TCP是用<strong>字节数</strong>作为窗口大小的单位。但为叙述方便起见用报文段的个数作为窗口大小的单位。</p><p><img src="/images/network-basic/TcpSlowStart.PNG"></p><p>发送方每收到一个对新报文段的确认就使发送方的拥塞窗口加1每经过一个传输轮次，拥塞窗口cwnd就加倍。</p><p>一个传输轮次时间其实就是往返时间RTT(请注意，RTT并非是恒定的数值)。强调把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后个字节的确认。</p><p>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。慢开始门限ssthresh的用法如下:</p><p>当cwnd &lt; ssthresh时，使用上述的慢开始算法。<br>当cwnd &gt; ssthresh时，停止使用慢开始算法而改用拥塞避免算法。<br>当cwnd = ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法。</p><h4 id="5-8-2-2-拥塞避免"><a href="#5-8-2-2-拥塞避免" class="headerlink" title="5.8.2.2. 拥塞避免"></a>5.8.2.2. 拥塞避免</h4><p>拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是像慢开始阶段那样加倍增长。因此在拥塞避免阶段就有“加法増大”的特点。这表明在拥塞避免阶段，拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p><p>按线性规律增长。但请注意，“拥塞避免”并非完全能够避免了拥塞。“拥塞避免”是说托拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</p><p><img src="/images/network-basic/TcpCwnd.PNG"></p><p>当拥塞窗口cwnd=24时，网络出现了超时(图中的点2)，发送方判断为网络拥塞。于是调整门限值 ssthresh=cwnd/2=12，同时设置拥塞窗口cwnd=1，进入慢开始阶段</p><p>按照慢开始算法，发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值加1当拥塞窗口cwnd= ssthresh=12时(图中的点3，这是新的 ssthresh值)，改为执行拥塞避免算法，拥塞窗口按线性规律增大。</p><p>当拥塞窗口cwnd=16时(图中的点4)，出现了一个新的情况，就是发送方一连收到3<br>个对同一个报文段的重复确认(图中记为3-ACK)。</p><p>3-ACK解释：</p><p>有时，个别报文段会在网络中丢失，但实际上网络并未发生拥塞。如果发送方迟迟收不到确认，就会产生超时，就会误认为网络发生了拥塞。这就导致发送方错误地启动慢开始，把拥塞窗口cwnd又设置为1，因而降低了传输效率。</p><p>采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。</p><h4 id="5-8-2-3-快重传"><a href="#5-8-2-3-快重传" class="headerlink" title="5.8.2.3. 快重传"></a>5.8.2.3. 快重传</h4><p><img src="/images/network-basic/TcpFastRetransmit.PNG"></p><p>快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。如图5-26所示，接收方收到了M1和M2后都分别及时发出了确认。现假定接收方没有收到M3但却收到了M4本来接收方可以什么都不做。但按照快重传算法，接收方必须立即发送对M2的重复确认，以便让发送方及早知道接收方没有收到报文段M3。发送方接着发送M5和M6。接收方收到后也仍要再次分别发出对M2的重复确认。这样，发送方共收到了接收方的4个对M2的确认，其中后3个都是重复确认。</p><p>快重传算法规定，发送方只要一连收到3个重复确认，就知道接收方确实没有收到报文段M3，因而应当立即进行重传(即“快重传”)，这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。使用快重传可以使整个网络的吞吐量提高约20%。</p><p>因此，在图中的点4，发送方知道现在只是丢失了个别的报文段。于是不启动慢开始，而是执行快恢复算法。这时，发送方调整门限值 ssthresh=cwnd/2=8，同时设置拥塞窗口cwnd=ssthresh=8(图中的点6)，并开始执行拥塞避免算法。</p><h4 id="5-8-2-4-快恢复"><a href="#5-8-2-4-快恢复" class="headerlink" title="5.8.2.4. 快恢复"></a>5.8.2.4. 快恢复</h4><p>也有的快恢复实现是把快恢复开始时的拥塞窗口cwd值再增大一些(增大报文段的长度)，即等于新的 ssthresh+3×MSS。这样做的理由是:既然发送方收到3个重复的确认，就表明有3个分组已经离开了网络。这3个分组不再消耗网络的资源而是停留在接收方的缓存中(接收方发送出3个重复的确认就证明了这个事实)。可见现在网络中并不是堆积了分组而是减少了3个分组。因此可以适当把拥塞窗口扩大些。</p><h4 id="5-8-2-5-总结"><a href="#5-8-2-5-总结" class="headerlink" title="5.8.2.5. 总结"></a>5.8.2.5. 总结</h4><p><img src="/images/network-basic/TcpCongestionControlProcess.PNG"></p><p>在拥塞避免阶段，拥塞窗口是按照线性规律増大的，这常称为加法增大AI，而一旦出现超时或3个重复的确认，就要把门限值设置为当前拥塞窗口值的一半，并大大减小拥塞窗口的数值。这常称为“乘法减小”MD，二者合在一起就是所谓的AIMD算法。</p><p>总之，发送方的窗口的上限值应当取为接收方窗口rwnd和拥塞窗口cwnd这两个变量中较小的：</p><p><strong>发送方窗口的上限值 = Min[ rwnd ， cwnd ]</strong></p><p>当rwnd &lt; cwnd时，是接收方的接收能力限制发送方窗口的最大值</p><p>当cwnd &lt; rwnd时，则是网络的拥塞程度限制发送方窗口的最大值。</p><h3 id="5-8-3-主动队列管理AQM"><a href="#5-8-3-主动队列管理AQM" class="headerlink" title="5.8.3. 主动队列管理AQM"></a>5.8.3. 主动队列管理AQM</h3><p>网络层路由器的队列通常都是按照“先进先出”FIFO的规则处理到来的分组。当队列已满时，以后再到达的所有分组将都被丢弃。这就叫做<strong>尾部丢弃策略</strong>。这会同时影响到很多条TCP连接，结果使这许多TCP连接在同一时间突然都进入到慢开始状态。这在TCP的术语中称为全局同步。全局同步使得全网的通信量突然下降了很多，而在网络恢复正常后，其通<br>信量又突然增大很多。</p><p>为了避免发生网络中的全局同步现象，提出了主动队列管理AQM。AQM可以有不同实现方法，其中曾流行多年的就是随机早期检测RED。</p><p>实现RED时需要使路由器维持两个参数，即队列长度最小门限和最大门限。当每一个分组到达时，RED就按照规定的算法先计算当前的平均队列长度：</p><ol><li>若平均队列长度小于最小门限，则把新到达的分组放入队列进行排队</li><li>若平均队列长度超过最大门限，则把新到达的分组丢弃。</li><li>若平均队列长度在最小门限和最大门限之间，则按照某一丢弃概率p把新到达的分组丢弃(这就体现了丢弃分组的随机性)</li><li>由此可见，RED不是等到已经发生网络拥塞后才把所有在队列尾部的分组全部丢弃，<br>而是在检测到网络拥塞的早期征兆时(即路由器的平均队列长度达到一定数值时)，就以概<br>率p丢弃个别的分组，让拥塞控制只在个别的TCP连接上进行，因而避免发生全局性的拥<br>塞控制。</li></ol><h2 id="5-9-TCP的连接管理"><a href="#5-9-TCP的连接管理" class="headerlink" title="5.9. TCP的连接管理"></a>5.9. TCP的连接管理</h2><h3 id="5-9-1-TCP的连接建立"><a href="#5-9-1-TCP的连接建立" class="headerlink" title="5.9.1. TCP的连接建立"></a>5.9.1. TCP的连接建立</h3><p><img src="/images/network-basic/3handshake.PNG"></p><ol><li><p>开始，B的TCP服务器进程先创建传输控制块TCB，准备接受客户进程的连接请求。然后服务器进程就处于 LISTEN(收听)状态，等待客户的连接请求。如有，即作出响应。</p></li><li><p>A的TCP客户进程也是首先创建传输控制模块TCB。然后，在打算建立TCP连接时，向B发出连接请求报文段，这时首部中的同步位SYN=1，同时选择一个初始序号seq=ⅹ。TCP规定，SYN报文段(即SYN=1的报文段)不能携带数据，但要消耗掉一个序号这时，TCP客户进程进入 SYN-SENT(同步已发送)状态。</p></li><li><p>B收到连接请求报文段后，如同意建立连接，则向A发送确认。在确认报文段中应把SYN位和ACK位都置1，确认号是ack=x+1，同时也为自己选择一个初始序号seq=y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时TCP服务器进程进入 SYN-RCVD(同步收到)状态。</p></li><li><p>TCP客户进程收到B的确认后，还要向B给出确认。确认报文段的ACK置1，确认号ack=y+1，而自己的序号seq=x+1。TCP的标准规定，ACK报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是seq=x。</p></li><li><p>这时，TCP连接已经建立，A进入 ESTABLISHED(已建立连接)状态。当B收到A的确认后，也进入 ESTABLISHED状态</p></li></ol><p>为什么A最后还要发送一次确认呢?这主要是为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误。</p><p>所谓“已失效的连接请求报文段”是这样产生的。考虑一种正常情况，A发出连接请求，但因连接请求报文丢失而未收到确认。于是A再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A共发送了两个连接请求报文段，其中第一个丢失，第二个到达了B，没有“已失效的连接请求报文段”。现假定出现一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达B。本来这是一个早已失效的报文段。但B收到此失效的连接请求报文段后，就误认为是A又发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。假定不采用报文握手，那么只要B发出确认，新的连接就建立了由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据。但B却以为新的运输连接已经建立了，并一直等待A发来数据。B的许多资源就这样白白浪费了。</p><h3 id="5-9-2-TCP的连接释放"><a href="#5-9-2-TCP的连接释放" class="headerlink" title="5.9.2. TCP的连接释放"></a>5.9.2. TCP的连接释放</h3><p><img src="/images/network-basic/4handshake.PNG"></p><ol><li><p>数据传输结束后，通信的双方都可释放连接。现在A和B都处于 ESTABLISHED状态。A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。A把连接释放报文段首部的终止控制位FN置1，其序号seq=u，它等于前面已传送过的数据的最后一个字节的序号加1。这时A进入FⅠ N-WAIT-1(终止等待1)状态，等待B的确认。请注意，TCP规定，FIN报文段即使不携带数据，它也消耗掉序号。</p></li><li><p>B收到连接释放报文段后即发出确认，确认号是ack=u+1，而这个报文段自己的序号是v，等于B前面已传送过的数据的最后一个字节的序号加1。然后B就进入 CLOSEWAT(关闭等待)状态。TCP服务器进程这时应通知高层应用进程，因而从A到B这个方向的连接就释放了，这时的TCP连接处于<strong>半关闭</strong>状态，即A已经没有数据要发送了，但B若发送数据，A仍要接收。也就是说，从B到A这个方向的连接并未关闭，这个状态可能会持续一段时间。</p></li><li><p>A收到来自B的确认后，就进入 FIN-WAIT2(终止等待2)状态，等待B发出的连接释放报文段。</p></li><li><p>若B已经没有要向A发送的数据，其应用进程就通知TCP释放连接。这时B发出的连接释放报文段必须使FIN=1。现假定B的序号为w(在半关闭状态B可能又发送了一些数据)。B还必须重复上次已发送过的确认号ack=u+1。这时B就进入 LAST-ACK(最后确认)状态，等待A的确认。</p></li><li><p>A在收到B的连接释放报文段后，必须对此发出确认。在确认报文段中把ACK置1，确认号ack=w+1，而自己的序号是seq=u+1(根据TCP标准，前面发送过的FIN报文段要消耗一个序号)。然后进入到 TIME-WAIT(时间等待)状态。请注意，现在TCP连接还没有释放掉。必须经过时间等待计时器( TIME-WAIT timer)设置的时间2MSL后，A才进入到 CLOSED状态。</p></li></ol><p>MSL：最长报文段寿命。</p><p>为什么A在 TMME-WAIT状态必须等待2MSL的时间呢?</p><ol><li>为了保证A发送的最后一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而使处在 LAST-ACK状态的B收不到对已发送的FN+ACK报文段的确认。B会超时重传这个FN+ACK报文段，而A就能在2MSL时间内收到这个重传的FIN+ACK报文段。接着A重传一次确认，重新启动2MSL计时器。最后，A和B都正常进入到CLOSED状态。如果A在 TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后立即释放连接，那么就无法收到B重传的FN+ACK报文段，因而也不会再发送一次确认报文段。这样，B就无法按照正常步骤进入 CLOSED状态。1MSL时间留给最后的ACK确认报文段到达服务器端，1MSL时间留给服务器端再次发送的FIN。</li><li>防止上一节提到的“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。B只要收到了A发出的确认，就进入 CLOSED状态。同样，B在撤销相应的传输控制块TCB后，就结束了这次的TCP连接。我们注意到，B结束TCP连接的时间要比A早。</li></ol><p><strong>保活计时器</strong></p><p>设想有这样的情况:客户已主动与服务器建立了TCP连接。但后来客户端的主机突然出故障。显然，服务器以后就不能再收到客户发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就是使用保活计时器。服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两小时。若两小时没有收到客户的数据，服务器就发送一个探测报文段，以后则每隔75秒钟发送一次。若一连发送10个探测报文段后仍无客户的响应，服务器就认为客户端出了故障，接着就关闭这个连接。</p><h3 id="5-9-3-TCP的有限状态机"><a href="#5-9-3-TCP的有限状态机" class="headerlink" title="5.9.3. TCP的有限状态机"></a>5.9.3. TCP的有限状态机</h3><p><img src="/images/network-basic/TcpFiniteState.PNG"></p><h1 id="6-应用层"><a href="#6-应用层" class="headerlink" title="6. 应用层"></a>6. 应用层</h1><h2 id="6-1-域名系统DNS"><a href="#6-1-域名系统DNS" class="headerlink" title="6.1. 域名系统DNS"></a>6.1. 域名系统DNS</h2><p><strong>顶级域名：</strong></p><ul><li>国家顶级域名：.cn .us</li><li>通用顶级域名：.com .org</li><li>基础结构域名：.arpa</li></ul><p><strong>互联网的域名结构：</strong></p><p><img src="/images/network-basic/domin.PNG"></p><p><strong>域名服务器：</strong></p><ul><li>根域名服务器：最高层次的、最重要的域名服务器</li><li>顶级域名服务器：负责管理在该顶级域名服务器下注册的所有二级域名</li><li>权限域名服务器：负责一个区的域名服务器</li><li>本地域名服务器：默认域名服务器</li></ul><p><img src="/images/network-basic/nameServer.PNG"></p><p><strong>解析过程：</strong></p><ol><li>主机向本地域名服务器的查询一般都是采用递归查询。</li></ol><p>所谓递归查询就是:如果主机所询问的本地域名服务器不知道被査询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文(即替该主机继续查询)，而不是让该主机自己进行下一步的查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。</p><ol start="2"><li>本地域名服务器向根域名服务器的查询通常是采用迭代查询</li></ol><p>迭代査询的特点是这样的:当根域名服务器收到本地域名服务器发出的迭代查询请求报文时要么给出所要查询的IP地址，要么告诉本地域名服务器:“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询(而不是替本地域名服务器进行后续的查询)。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地域名服务器下一步应当向哪一个权限域名服务器进行查询，本地域名服务器就这样进行迭代査询。最后，知道了所要解析的域名的IP地址，然后把这个结果返回给发起查询的主机。</p><p><img src="/images/network-basic/nameQuery.PNG"></p><p>为了提高DNS查询效率，并减轻根域名服务器的负荷和减少互联网上的DNs查询报文数量，在域名服务器中广泛地使用了高速缓存(有时也称为高速缓存域名服务器)。由于名字到地址的绑定并不经常改变，为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并处理超过合理时间的项。</p><h2 id="6-2-文件传送协议"><a href="#6-2-文件传送协议" class="headerlink" title="6.2. 文件传送协议"></a>6.2. 文件传送协议</h2><h3 id="6-2-1-FTP"><a href="#6-2-1-FTP" class="headerlink" title="6.2.1. FTP"></a>6.2.1. FTP</h3><p>文件传送协议FTP是互联网上使用得最广泛的文件送协议，提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限，FTP屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件。</p><p>基于TCP的FTP和基于UDP的简单文件传送协议TFTP，它们都是文件共享协议中的一大类，即复制整个文件。而网络文件系统NFS则采用另一种思路，允许应用进程打开一个远地文件，并能在该文件的某一个特定的位置上开始读写数据。在网络上传送的只是少量的修改数据。</p><p>FTP的服务器进程由两大部分组成:一个主进程，负责接受新的请求;另外有若干个从属进程，<br>负责处理单个请求</p><p><strong>主进程的工作步骤</strong></p><ol><li>打开熟知端口(端口号为21)，使客户进程能够连接上</li><li>等待客户进程发出连接请求</li><li>启动从属进程处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程发之()回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并行的</li></ol><p>两个从属进程:控制进程和数据传送进程。为简单起见，服务器端的主进程没有画上</p><p>在进行文件传输时，FTP的客户和服务器之间要建立两个并行的TCP连接:“控制连<br>接（21号端口）”和“数据连接（20号端口）”。控制连接在整个会话期间一直保持打开，FTP客户所发出的传送请求，通过控制连接发送给服务器端的控制进程，但控制连接并不用来传送文件。实际用于传输文件的是“数据连接”。</p><h3 id="6-2-2-TFTP"><a href="#6-2-2-TFTP" class="headerlink" title="6.2.2. TFTP"></a>6.2.2. TFTP</h3><p>简单文件传送协议TFTP，它是个很小且易于实现的文件传送协议。也使用客户服务器方式，但它使用UDP数据报，因此TFTP需要有自己的差错改正措施。TFTP只支持文件传输而不支持交互。TFTP没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。</p><p>每次传送的数据报文中有512字节的数据，但最后一次可不足512字节，这正好可作为文件结束的标志。</p><p><strong>优点：</strong></p><ol><li>TFTP可用于UDP环境</li><li>TFTP代码所占的内存较小</li></ol><h2 id="6-3-超文本传送协议HTTP"><a href="#6-3-超文本传送协议HTTP" class="headerlink" title="6.3. 超文本传送协议HTTP"></a>6.3. 超文本传送协议HTTP</h2><h3 id="6-3-1-HTTP基本过程"><a href="#6-3-1-HTTP基本过程" class="headerlink" title="6.3.1. HTTP基本过程"></a>6.3.1. HTTP基本过程</h3><p>统一资源定位符URL：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/路径&gt;</p><p>URL里面的协议和主机不分大小写，路径有时区分。</p><p>HTTP使用了面向连接的TCP作为运输层协议，保证了数据的可靠传输。但是HTTP协议本身是无连接的。</p><p>HTTP协议是无状态的。也就是说，同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时的相同。</p><p>万维网客户就把HTTP请求报文作为建立TCP连接的三报文握手中的第三个报文的数据，发送给万维网服务器。服务器收到HTTP请求报文后，就把所请求的文档作为响应报文返回给客户。</p><p><img src="/images/network-basic/HTTPtime.PNG"></p><p>所以，请求一个万维网文档所需的时间是该文档的传输时间加上两倍往返时间RTT。</p><p><strong>HTTP/1.0的主要缺点</strong></p><ul><li>每请求一个文档就要有两倍RTT的开销。</li><li>万维网客户和服务器每一次建立新的TCP连接都要分配缓存和变量。特别是同时服务于大量客户的请求，使用并行TCP连接可以缩短响应时间。</li></ul><p><strong>HTTP/1.1协议</strong>较好地解决了这个问题，它使用了持续连接( persistent connection)。所谓持续连接就是万维网服务器在发送响应后仍然在一段时间内保持这条连接，使同一个客户(浏览器)和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。</p><p><strong>持续连接的工作方式：</strong></p><ul><li>非流水线方式：客户在收到前一个响应后才能发出下一个请求。因此客户每访问一次对象都要用去一个往返时间RTT，比1.0少一个。</li><li>流水线方式：客户在收到HTTP的响应报文之前就能够接着发送新的请求报文。因此客户访问所有的对象只需花费一个RTT时间。</li></ul><p><strong>代理服务器</strong></p><p>代理服务器(proxy server)是一种网络实体，它又称为万维网高速缓存( Web cache)。代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这个请求与暂时存放的请求相同，就返回暂存的响应，而不需要按URL的地址再次去互联网<br>访问该资源。代理服务器可在客户端或服务器端工作，也可在中间系统上工作。</p><h3 id="6-3-2-HTTP报文"><a href="#6-3-2-HTTP报文" class="headerlink" title="6.3.2. HTTP报文"></a>6.3.2. HTTP报文</h3><ul><li>请求报文</li><li>响应报文</li></ul><p><img src="/images/network-basic/HTTPmessage.PNG"></p><p>由于HTTP是面向文本的，因此在报文中的每一个字段都是一些ASCI码串，因而各个字段的长度都是不确定的。</p><p>HTTP请求报文和响应报文都是由三个部分组成的，区别仅开始行不同。</p><h4 id="6-3-2-1-HTTP请求报文"><a href="#6-3-2-1-HTTP请求报文" class="headerlink" title="6.3.2.1. HTTP请求报文"></a>6.3.2.1. HTTP请求报文</h4><p>请求报文的第一行有方法，请求资源的URL，以及HTTP的版本。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Get</td><td>请求资源</td></tr><tr><td>Post</td><td>向服务端发送资源</td></tr><tr><td>Delete</td><td>用于删除资源</td></tr><tr><td>Put</td><td>用于资源的更新，若资源不存在则新建一个</td></tr><tr><td>Option</td><td>请求一些选项信息</td></tr><tr><td>Head</td><td>只请求资源的头部，该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载， 以此可以节约带宽资源</td></tr><tr><td>Trace</td><td>用于环回测试的请求报文</td></tr><tr><td>Connect</td><td>用于代理服务器</td></tr></tbody></table><p><strong>Get/Post的区别</strong></p><ul><li>Get请求的参数放在URL里，有长度限制；Post请求的参数放在实体里，没有限制。</li><li>Get请求比起Post请求更加不安全，因为参数放在URL中，不能用来传递敏感信息。</li><li>GET用于信息获取，而且应该是安全和幂等的（对同一URL的多个请求应该返回同样的结果）；POST请求表示可能修改服务器上资源的请求</li></ul><h4 id="6-3-2-2-HTTP响应报文报文"><a href="#6-3-2-2-HTTP响应报文报文" class="headerlink" title="6.3.2.2. HTTP响应报文报文"></a>6.3.2.2. HTTP响应报文报文</h4><p>状态行包括三项内容，即HTTP的版本，状态码，以及解释状态码的简单短语</p><p>状态码都是三位数字的，分为5大类：</p><ul><li>1xx：通知信息</li><li>2xx：成功</li><li>3xx：重定向，中间态，如要完成请求还必须采取进一步的行动</li><li>4xx：客户的差错，如请求中有错误的语法或不能完成。</li><li>5xx：服务器错误，这些状态代码表示服务器在尝试处理请求时发生内部错误。</li></ul><p>具体的：</p><ul><li><p>200 OK：表示从客户端发送给服务器的请求被正常处理并返回；</p></li><li><p>204 No Content：表示客户端发送给客户端的请求得到了成功处理，但在返回的响应报文中没有资源可以返回；</p></li><li><p>206 Patial Content：表示客户端进行了范围请求，并且服务器成功执行了这部分的GET请求。</p></li><li><p>301 Moved Permanently：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL；</p></li><li><p>302 Found：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL；</p></li></ul><blockquote><p>永久是指原来访问的资源已经永久删除啦，客户端应该根据新的URI访问重定向。<br>临时是指访问的资源可能暂时先用location的URI访问，但旧资源还在的，下次你再来访问的时候可能就不用重定向了。</p></blockquote><ul><li>303 See Other：表示请求的资源被分配了新的URL，客户端应使用GET方法定向获取请求的资源；</li><li>304 Not Modified：该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但是从缓存获取资源</li></ul><blockquote><p>该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但是从缓存获取资源客户端在请求一个文件的时候，发现自己有该请求之前的缓存的文件，并且记录了 Last Modified ，那么在请求头中会包含 If Modified Since ，这个时间就是缓存文件的 Last Modified 。因此，如果请求中包含 If Modified Since，就说明已经有缓存在客户端。服务端只要判断这个时间和当前请求的文件的修改时间就可以确定是返回 304 还是 200 。在服务端的返回的响应头中通常有Last Modified 如果此值与请求头中的If Modified Since时间一致那么返回就是304，否则就是200。<br>对于静态文件，例如：CSS、图片，服务器会自动完成 Last Modified 和 If Modified Since 的比较，完成缓存或者更新。但是对于动态页面，就是动态产生的页面，往往没有包含 Last Modified 信息，这样浏览器、网关等都不会做缓存，也就是在每次请求的时候都完成一个 200 的请求。<br>因此，对于动态页面做缓存加速，首先要在 Response 的 HTTP Header 中增加 Last Modified 定义，其次根据 Request 中的 If Modified Since 和被请求内容的更新时间来返回 200 或者 304 。虽然在返回 304 的时候已经做了一次数据库查询，但是可以避免接下来更多的数据库查询，并且没有返回页面内容而只是一个 HTTP Header，从而大大的降低带宽的消耗，对于用户的感觉也是提高。</p></blockquote><ul><li><p>307 Temporary Redirect：临时重定向，与303有着相同的含义，307会遵照浏览器标准不会从POST变成GET；（不同浏览器可能会出现不同的情况）；</p></li><li><p>400 Bad Request：表示请求报文中存在语法错误；</p></li><li><p>401 Unauthorized：未经许可，需要通过HTTP认证；</p></li><li><p>403 Forbidden：服务器拒绝该次访问（访问权限出现问题）；</p></li><li><p>404 Not Found：表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；</p></li><li><p>500 Inter Server Error：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时；</p></li><li><p>503 Server Unavailable：表示服务器暂时处于超负载或正在进行停机维护，无法处理请求；</p></li></ul><p><strong>重定向</strong></p><p>所谓重定向就是，当浏览器向服务端发送url 请求的时候返回状态码为30x时表示请求被重定向了，例如请求时<a href="http://www.a.com/">http://www.a.com</a> 返回的请求头中location:<a href="https://www.a.com/">https://www.a.com</a> 那么客户端就要重新根据location 提供的信息重新发起新的请求。例如在外网的ingress  配置http 强制跳转https 的时候就是通过配置301强制跳转的。</p><p>请求报文：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/pet-products.txt</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.joes-hardware.com</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*</span><br></pre></td></tr></table></figure><p>服务端响应报文重定向到另一个地址：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">301</span> OK</span><br><span class="line"><span class="attribute">Location</span><span class="punctuation">: </span>http://www.gentle-grooming.com/</span><br><span class="line"><span class="attribute">Content-length</span><span class="punctuation">: </span>56</span><br><span class="line"><span class="attribute">Content-type</span><span class="punctuation">: </span>text/plain</span><br></pre></td></tr></table></figure><p>客户端浏览器收到重定向响应报文后，将发起一个向新地址的请求：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1  </span><br><span class="line">Host: www.gentle-grooming.com</span><br><span class="line">Accept: *</span><br></pre></td></tr></table></figure><p>新地址的响应报文：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-type</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Content-length</span><span class="punctuation">: </span>3307</span><br></pre></td></tr></table></figure><h3 id="6-3-3-HTTP协议的区别"><a href="#6-3-3-HTTP协议的区别" class="headerlink" title="6.3.3. HTTP协议的区别"></a>6.3.3. HTTP协议的区别</h3><p><strong>HTTP1.1比起1.0</strong></p><ol><li>缓存处理。在HTTP1.0中主要使用header里的If-Modified-Since、Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since， If-Match， If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li>带宽优化及网络连接的使用。HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li>错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li>Host头处理，为虚拟化准备。在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li><li>长连接。HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li></ol><p><strong>HTTP2.0比起1.1</strong></p><ol><li>新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li><li>多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的id将request再归属到各自不同的服务端请求里面。</li><li>header压缩、缓存。如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li><li>服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。</li></ol><p><img src="/images/network-basic/HTTPdiff.jpg"></p><h3 id="6-3-4-HTTPS"><a href="#6-3-4-HTTPS" class="headerlink" title="6.3.4. HTTPS"></a>6.3.4. HTTPS</h3><p>HTTPS：是以安全为目标的HTTP通道，简单讲：HTTPS = HTTP + TLS/SSL（TLS的前身是SSL）。</p><p>HTTPS协议的主要作用：</p><ul><li>加密数据，建立一个信息安全通道，来保证数据传输的安全；另一种就是</li><li>对网站服务器进行真实身份认证。</li></ul><h4 id="6-3-4-1-HTTPS的工作原理"><a href="#6-3-4-1-HTTPS的工作原理" class="headerlink" title="6.3.4.1. HTTPS的工作原理"></a>6.3.4.1. HTTPS的工作原理</h4><p><img src="/images/network-basic/HTTPS.png"></p><ol><li>Client发起一个HTTPS的请求，并将自己支持的加密规则发给Server。</li><li>Server从中选出一资加密算法和HASH算法，把自己的身份信息以公钥证书形式返回给客户端。</li><li>Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。</li><li>Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥。</li><li>Client使用约定好的HASH算法计算握手消息，并用生成的随机数对消息加密，发给Server。</li><li>Server使用自己的私钥解密，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。使用密码解析Client发来的握手消息，并验证HASH是否一致。</li><li>Server使用对称密钥加密一段内容，发送给Client。</li><li>Client使用对称密钥解密响应的密文，并计算HASH，得到明文内容。</li></ol><p>Server与Client互相发送加密的握手消息并验证，目的是保证双方获得一致的密码，并且可以正常地加解密，做一次测试。</p><p>非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据加密，HASH算法用于验证数据完整性。</p><p>SSL握手过程中有任何错误都会是加密连接断开，从而阻止隐私信息的传输，非常安全。攻击者常采用假证书欺骗客户端。</p><h4 id="6-3-4-2-HTTPS和HTTP的区别"><a href="#6-3-4-2-HTTPS和HTTP的区别" class="headerlink" title="6.3.4.2. HTTPS和HTTP的区别"></a>6.3.4.2. HTTPS和HTTP的区别</h4><ol><li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li><li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</li></ol><h3 id="6-3-5-HTTP缓存机制"><a href="#6-3-5-HTTP缓存机制" class="headerlink" title="6.3.5. HTTP缓存机制"></a>6.3.5. HTTP缓存机制</h3><p>浏览器的缓存机制也就是我们说的HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的，所以在分析浏览器缓存机制之前，我们先使用图文简单介绍一下HTTP报文，HTTP报文分为两种：</p><ul><li>HTTP请求(Request)报文，报文格式为：请求行 – HTTP头(通用信息头，请求头，实体头) – 请求报文主体(只有POST才有报文主体)</li></ul><p><img src="/images/network-basic/HttpRequestHead.png"></p><ul><li>HTTP响应(Response)报文，报文格式为：状态行 – HTTP头(通用信息头，响应头，实体头) – 响应报文主体</li></ul><p><img src="/images/network-basic/HttpResponseHead.png"></p><p>通用信息头指的是请求和响应报文都支持的头域，分别为Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via；</p><p>实体头则是实体信息的实体头域，分别为Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。</p><p>浏览器与服务器通信的方式为应答模式，即：浏览器发起HTTP请求 – 服务器响应该请求。</p><p><img src="/images/network-basic/HttpFirstRequest.png"></p><ol><li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li><li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li></ol><p>根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强制缓存和协商缓存。</p><h4 id="6-3-5-1-强制缓存"><a href="#6-3-5-1-强制缓存" class="headerlink" title="6.3.5.1. 强制缓存"></a>6.3.5.1. 强制缓存</h4><p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种：</p><ol><li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）：</li></ol><p><img src="/images/network-basic/HttpForceCache1.png"></p><ol start="2"><li>存在该缓存结果和缓存标识，但是结果已经失效，强制缓存失效，则使用协商缓存：</li></ol><p><img src="/images/network-basic/HttpForceCache2.png"></p><p>（3）存在该缓存结果和缓存标识，且该结果没有还没有失效，强制缓存生效，直接返回该结果：</p><p><img src="/images/network-basic/HttpForceCache3.png"></p><p><strong>强制缓存的缓存规则</strong></p><p>当浏览器向服务器发送请求的时候，服务器会将缓存规则（放入HTTP响应的报文的HTTP头中和请求结果一起）返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Conctrol的优先级比Expires高。</p><ol><li>Expires</li></ol><p>Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求的结果缓存的到期时间（绝对时间），即再次发送请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。</p><p>到了HTTP/1.1，Expires已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，如果客户端与服务端的时间由于某些原因（时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存直接失效，那么强制缓存存在的意义就毫无意义。</p><ol><li>Cache-Control</li></ol><p>取值为：</p><ul><li>public：所有内容都将被缓存（客户端和代理服务器都可缓存）</li><li>private：所有内容只有客户端可以缓存，Cache-Control的默认取值</li><li>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li><li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li><li>max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效（相对时间）</li></ul><p><strong>浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？</strong></p><p>内存缓存(from memory cache)和硬盘缓存(from disk cache):</p><ol><li>内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性：</li></ol><ul><li>快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。</li><li>时效性：一旦该进程关闭，则该进程的内存则会清空。</li></ul><ol start="2"><li>硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。</li></ol><p>在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。</p><p>行为分析：</p><p>访问某个网站 –&gt; 200 –&gt; 关闭博客的标签页 –&gt; 重新打开网站（渲染） –&gt; 200(from disk cache) –&gt; 刷新 –&gt; 200(from memory cache)。ctrl+F5 强制刷新就会200 发起新的请求而忽略缓存。</p><h4 id="6-3-5-2-协商缓存"><a href="#6-3-5-2-协商缓存" class="headerlink" title="6.3.5.2. 协商缓存"></a>6.3.5.2. 协商缓存</h4><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p><ol><li>协商缓存生效，返回304：</li></ol><p><img src="/images/network-basic/HttpConsultCacheSucc.png"></p><ol start="2"><li>协商缓存失败，返回200和请求结果：</li></ol><p><img src="/images/network-basic/HttpConsultCacheFail.png"></p><p>同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：</p><ul><li>Last-Modified / If-Modified-Since</li><li>Etag / If-None-Match</li></ul><p>其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。</p><p><strong>Last-Modified / If-Modified-Since</strong></p><ol><li>Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间，时间值。</li><li>If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，告诉服务器上次请求该资源时返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比：</li></ol><ul><li>若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；</li><li>否则则返回304，代表资源无更新，可继续使用缓存文件。</li></ul><p><strong>Etag / If-None-Match</strong></p><ol><li>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)</li><li>If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比：</li></ol><ul><li>一致则返回304，代表资源无更新，继续使用缓存文件；</li><li>不一致则重新返回资源文件，状态码为200。</li></ul><h4 id="6-3-5-3-总结"><a href="#6-3-5-3-总结" class="headerlink" title="6.3.5.3. 总结"></a>6.3.5.3. 总结</h4><p>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)</p><p>协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存，主要过程如下：</p><p><img src="/images/network-basic/HttpCache.png"></p><h3 id="6-3-6-session和cookie"><a href="#6-3-6-session和cookie" class="headerlink" title="6.3.6. session和cookie"></a>6.3.6. session和cookie</h3><p><strong>session与cookie的区别</strong></p><p>session：Session 是存放在服务器端的，类似于Session结构来存放用户数据，当浏览器 第一次发送请求时，服务器自动生成了一个Session和一个Session ID用来唯一标识这个Session，并将其通过响应发送到浏览器。当浏览器第二次发送请求，会将前一次服务器响应中的Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户对应的Session。由于Session存放在服务器端，所以随着时间的推移或者用户访问的增多，会给服务器增加负担。使用的时候要考虑下服务器的性能。</p><p>cookie：Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端会把Cookie保存起来。由于Cookie是存放在客户端，是可见的，安全性就会很低。因此不建议将一些重要的信息放在cookie中。</p><p><strong>区别</strong></p><ul><li>cookie存放在客户端，session存放在服务器端</li><li>cookie不是很安全，别人可以分析你本地的cookie信息进行cookie欺骗，因此重要信息应考虑保存在服务器端</li><li>session一定时间内回报存在服务器端，当访问量增大时，会影响服务器性能，从性能方面考虑应使用cookie</li><li>不同浏览器对cookie的数据大小限制不同，个数限制也不同</li><li>可以考虑将登陆信息等重要信息存放为session，不重要的信息可以放在cookie中</li></ul><p><strong>联系</strong></p><ul><li>都是用来记录用户的信息，以便让服务器分辨不同的用户</li><li>可以搭配使用，但都有自己的使用局限，要考虑到安全和性能的问题</li></ul><p><strong>如果客户端禁止 cookie，session 还能用吗？</strong></p><p>如果浏览器禁止cookie，那么客户端访问服务端时无法携带sessionid，服务端无法识别用户身份，便无法进行会话控制，session失效。但可以通过以下几种方法：</p><ul><li>URL重写：URL重写要求将站点中的所有超链接都进行改造，在超链接后用一个特殊的参数JSESSIONID保存当前浏览器对应session的编号，这样一来，当用户点击超链接访问服务器时，服务器可以从URL后的参数中分析出JSESSIONID，从而找到对应的sesison使用.</li><li>用文件、数据库等形式保存Session ID，在跨页过程中手动调用</li></ul><h2 id="6-4-输入URL之后会发生什么"><a href="#6-4-输入URL之后会发生什么" class="headerlink" title="6.4. 输入URL之后会发生什么"></a>6.4. 输入URL之后会发生什么</h2><h3 id="6-4-1-大纲"><a href="#6-4-1-大纲" class="headerlink" title="6.4.1. 大纲"></a>6.4.1. 大纲</h3><ol><li>浏览器解析URL</li><li>查找资源缓存</li><li>DNS解析</li><li>建立TCP连接（三次握手）</li><li>HTTP/HTTPS发起请求</li><li>对TCP报文打包，加入源IP地址和目标IP地址</li><li>网络层查询下一跳路由，ARP查询下一跳路由的MAC地址</li><li>数据链路层对IP报文打包并附上MAC地址</li><li>物理层发送数据</li><li>服务器处理请求，响应，浏览器接收HTTP响应</li><li>选择关闭TCP连接（四次挥手）</li><li>编码、解析构建规则树</li><li>渲染树</li></ol><h3 id="6-4-2-具体过程"><a href="#6-4-2-具体过程" class="headerlink" title="6.4.2. 具体过程"></a>6.4.2. 具体过程</h3><ul><li>浏览器解析URL获取协议、域名、端口、路径；</li><li>查看浏览器是否有资源的缓存<ul><li>有。判断是否过期<ul><li>没过期。直接读取缓存</li><li>过期。<ul><li>Etag和If-None-Match</li><li>Last-Modify和lf-Modified-Since</li><li>文件修改了则把新资源发给浏览器（状态码200），没修改则告诉浏览器读取缓存（状态码304）</li></ul></li></ul></li><li>没有则进行下一步</li></ul></li><li>DNS解析<ul><li>寻找浏览器是否存在缓存，若没有</li><li>寻找操作系统是否存在缓存，若没有</li><li>寻找hosts文件中是否有域名和ip的对应关系，若没有</li><li>查找路由器中是否有缓存</li><li>寻找DNS服务器是否没缓存，若没有</li><li>向本地域名服务器递归查询</li><li>本地域名服务器想根域名服务器迭代查询</li></ul></li><li>生成HTTP请求</li><li>建立TCP连接，三次握手<ul><li>客户端发送SYN=1，Seq=X</li><li>服务端发回SYN=1，ACK=X+1，Seq=Y</li><li>客户端发送ACK=Y+1，Seq=Y + 1</li></ul></li><li>如果是HTTP请求，对HTTP报文进行报文分割并标记序号和端口号</li><li>如果是HTTPS请求<ul><li>Client发起一个HTTPS的请求，并将自己支持的加密规则发给Server。</li><li>Server从中选出一资加密算法和HASH算法，把自己的身份信息以公钥证书形式返回给客户端。</li><li>Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。</li><li>Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥。</li><li>Client使用约定好的HASH算法计算握手消息，并用生成的随机数对消息加密，发给Server。</li><li>Server使用自己的私钥解密，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。使用密码解析Client发来的握手消息，并验证HASH是否一致。</li><li>Server使用对称密钥加密一段内容，发送给Client。</li><li>Client使用对称密钥解密响应的密文，并计算HASH，得到明文内容。</li></ul></li><li>对TCP报文打包，加入源IP地址和目标IP地址。</li><li>网络层根据目标IP地址和路由表，查询下一跳路由。使用ARP查询下一跳路由的MAC地址。</li><li> 数据链路层对IP报文打包并附上MAC地址。</li><li> 物理层发送数据。</li><li> 服务器在收到浏览器发送的HTTP请求之后，会将收到的HTTP报文封装成HTTP的Request对象，并通过不同的Web服务器进行处理，处理完的结果以HTTP的Response对象返回，主要包括状态码，响应头，响应报文三个部分。</li><li> 浏览器接收到HTTP响应，关闭TCP连接或保持复用，四次握手。</li><li> 如果说响应的内容是HTML文档的话，就需要浏览器进行解析渲染呈现给用户。</li><li> 根据响应头的字符集进行解码如果响应头没有字符集，则浏览器会默认用一套解码规则，当解析html解析到meta标签中的编码规则时，则替换成新的解码方式重新解码。</li><li> 浏览器通过解析HTML，生成DOM树，解析CSS，生成CSS规则树。</li><li> 然后通过DOM树和CSS规则树生成渲染树。渲染树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。repaint（重画颜色等，不影响布局）和reflow（组件的几何尺寸变了，重新验证并计算渲染树）。</li></ul><h1 id="7-参考链接"><a href="#7-参考链接" class="headerlink" title="7. 参考链接"></a>7. 参考链接</h1><ul><li>《计算机网络（第7版）》谢希仁，电子工业出版社</li><li><a href="https://www.cnblogs.com/maybe2030/p/4781555.html">计算机网络基础知识总结</a></li><li><a href="https://blog.csdn.net/yaopeng_2005/article/details/7064869">OSI七层模型详解</a></li><li><a href="https://www.cnblogs.com/zhengshiqiang47/p/8673559.html">HTTP协议以及HTTP2.0/1.1/1.0区别</a></li><li><a href="https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A">HTTP1.0、HTTP1.1 和 HTTP2.0 的区别</a></li><li><a href="https://blog.csdn.net/banana960531/article/details/85621865">HTTP常见状态码（14种）</a></li><li><a href="https://messiahhh.github.io/blog/frontend">菜鸟向前端指南</a></li><li><a href="https://www.cnblogs.com/wqhwe/p/5407468.html">HTTP与HTTPS的区别</a></li><li><a href="https://www.cnblogs.com/wuwuyong/p/12198928.html">计算机网络常见面试题</a></li><li><a href="https://www.cnblogs.com/inception6-lxc/p/9152691.html">计算机网络常见面试题</a></li><li><a href="https://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html">计算机网络之面试常考</a></li><li><a href="https://blog.csdn.net/weixin_41969587/article/details/88836161">HTTP请求和响应3：状态码（status）</a></li><li><a href="https://www.cnblogs.com/fanggege/p/13207204.html">http 状态码之3xx</a></li><li><a href="https://www.cnblogs.com/chengxs/p/10396066.html">彻底理解浏览器的缓存机制(htp绶存机制)</a></li><li><a href="https://mp.weixin.qq.com/s/DId9NRXF0SaMyCo27vmojg">这样看 B 站，可以更快！</a></li><li><a href="https://www.cnblogs.com/jxxblogs/p/12088924.html">session与cookie的区别？ 如果客户端禁止 cookie session 还能用吗？</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;概述、物理层、数据链路层、网络层、运输层、应用层。&lt;/p&gt;
&lt;p&gt;70页、5万字，超长总结。&lt;/p&gt;</summary>
    
    
    
    <category term="Study" scheme="https://memorykk.cn/categories/Study/"/>
    
    
    <category term="Network" scheme="https://memorykk.cn/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>网络爬虫基础</title>
    <link href="https://memorykk.cn/webCrawler-basic.html"/>
    <id>https://memorykk.cn/webCrawler-basic.html</id>
    <published>2021-03-13T04:48:16.000Z</published>
    <updated>2021-03-16T07:31:13.155Z</updated>
    
    <content type="html"><![CDATA[<p>待写</p><span id="more"></span><p>正文</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;待写&lt;/p&gt;</summary>
    
    
    
    <category term="Tool" scheme="https://memorykk.cn/categories/Tool/"/>
    
    
  </entry>
  
  <entry>
    <title>蓝桥杯Java</title>
    <link href="https://memorykk.cn/lanqiao-P11.html"/>
    <id>https://memorykk.cn/lanqiao-P11.html</id>
    <published>2021-03-10T12:50:02.000Z</published>
    <updated>2021-03-16T06:09:24.414Z</updated>
    
    <content type="html"><![CDATA[<p>第十一届蓝桥杯大赛软件类省赛Java大学B组第一场 &amp; 第一次校内模拟  &amp; 第三次校内模拟<br>详解及总结</p><span id="more"></span><hr><p><strong>目录</strong></p><ul><li><a href="#%E7%9C%81%E8%B5%9B">省赛</a><ul><li><a href="#A%E8%A7%A3%E5%AF%86">A解密</a></li><li><a href="#B%E7%BA%AA%E5%BF%B5%E6%97%A5">B纪念日</a></li><li><a href="#C%E5%90%88%E5%B9%B6%E6%A3%80%E6%B5%8B">C合并检测</a></li><li><a href="#D%E5%88%86%E9%85%8D%E5%8F%A3%E7%BD%A9">D分配口罩</a></li><li><a href="#E%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0">E斐波那契数列最大公约数</a></li><li><a href="#F%E5%88%86%E7%B1%BB%E8%AE%A1%E6%95%B0">F分类计数</a></li><li><a href="#G%E5%85%AB%E6%AC%A1%E6%B1%82%E5%92%8C">G八次求和</a></li><li><a href="#H%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81">H字符串编码</a></li><li><a href="#I%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9">I二叉搜索树插入节点</a></li></ul></li><li><a href="#%E6%A0%A1%E5%86%85%E6%A8%A1%E6%8B%9F%E8%B5%9B%E4%B8%80">校内模拟赛一</a><ul><li><a href="#A%E8%AE%A1%E7%AE%97">A计算</a></li><li><a href="#B%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0">B约数个数</a></li><li><a href="#C%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0">C叶节点数</a></li><li><a href="#D%E5%8C%85%E5%90%AB%E6%95%B0%E5%AD%979">D包含数字9</a></li><li><a href="#E%E6%95%B0%E4%BD%8D%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0">E数位递增的数</a></li><li><a href="#F%E9%80%92%E5%A2%9E%E4%B8%89%E5%85%83%E7%BB%84">F递增三元组</a></li><li><a href="#G%E9%9F%B3%E8%8A%82%E5%88%A4%E6%96%AD">G音节判断</a></li><li><a href="#H%E9%95%BF%E8%8D%89">H长草</a></li></ul></li><li><a href="#%E6%A0%A1%E5%86%85%E6%A8%A1%E6%8B%9F%E8%B5%9B%E4%B8%89">校内模拟赛三</a><ul><li><a href="#A">A</a></li><li><a href="#B">B</a></li><li><a href="#C">C</a></li><li><a href="#D">D</a></li><li><a href="#E">E</a></li><li><a href="#F">F</a></li><li><a href="#G">G</a></li><li><a href="#H">H</a></li><li><a href="#I">I</a></li><li><a href="#J">J</a></li></ul></li><li><a href="#%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%8D%A2">字符转换</a></li></ul><hr><h1 id="省赛"><a href="#省赛" class="headerlink" title="省赛"></a>省赛</h1><h2 id="A解密"><a href="#A解密" class="headerlink" title="A解密"></a>A解密</h2><p><img src="/images/lanqiao-P11/P11A1.png" alt="P11A1.png"><br><img src="/images/lanqiao-P11/P11A2.png" alt="P11A2.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String tc = <span class="string">&quot;yxmdacikntjhqlgoufszpwbrev&quot;</span>;</span><br><span class="line">        String str = <span class="string">&quot;EaFnjISplhFviDhwFbEjRjfIBBkRyY&quot;</span>;</span><br><span class="line">        String result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> xi;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (temp &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                temp += <span class="string">&#x27;a&#x27;</span> - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">                xi = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                xi = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result += (<span class="keyword">char</span>) (xi + tc.indexOf(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YeRikGSunlRzgDlvRwYkXkrGWWhXaA</span><br></pre></td></tr></table></figure><h2 id="B纪念日"><a href="#B纪念日" class="headerlink" title="B纪念日"></a>B纪念日</h2><p><img src="/images/lanqiao-P11/P11B.png" alt="P11B.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r=<span class="number">0</span>,p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1921</span>;i&lt;<span class="number">2020</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">100</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">400</span>==<span class="number">0</span>) &#123;</span><br><span class="line">                    r++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    p++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">4</span>==<span class="number">0</span>) &#123;</span><br><span class="line">                    r++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    p++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println((r*<span class="number">366</span>+p*<span class="number">365</span>-<span class="number">21</span>)*<span class="number">24</span>*<span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">52038720</span><br></pre></td></tr></table></figure><h2 id="C合并检测"><a href="#C合并检测" class="headerlink" title="C合并检测"></a>C合并检测</h2><p><img src="/images/lanqiao-P11/P11C.png" alt="P11C.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minK =<span class="number">0</span>,min=<span class="number">99999999</span>,temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">100</span> %i != <span class="number">0</span>)&#123;</span><br><span class="line">                temp =(<span class="number">100</span>/i)+i+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp=(<span class="number">100</span>/i)+i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp&lt;min)&#123;</span><br><span class="line">                min=temp;</span><br><span class="line">                minK=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(minK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="D分配口罩"><a href="#D分配口罩" class="headerlink" title="D分配口罩"></a>D分配口罩</h2><p><img src="/images/lanqiao-P11/P11D.png" alt="P11D.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *当要求在长度为n的大序列中取出长度为0-n的小序列时用DFS，一次性可求出，</span></span><br><span class="line"><span class="comment"> *如n=5,要求排列组合中求出A(1,5)、A(2,5)、...A(5,5)，跟穷举一样。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main4</span> </span>&#123;</span><br><span class="line"><span class="comment">//    public static int[] arr = &#123;9090400, 8499400, 5926800, 8547000, 4958200, 4422600, 5751200,4175600,</span></span><br><span class="line"><span class="comment">//    6309600, 5865200, 6604400, 4635000, 10663400, 8087200, 4554000&#125;;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">16</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[arr.length];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; arr.length; x++) &#123;</span><br><span class="line">            sum += arr[x];</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        System.out.println(min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= sum / <span class="number">2</span>) &#123;</span><br><span class="line">            min = Math.min(min, Math.abs(sum - index * <span class="number">2</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;___________________________________&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; arr.length; x++) &#123;</span><br><span class="line">            <span class="comment">//若未访问过</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[x]) &#123;</span><br><span class="line">                visited[x] = <span class="keyword">true</span>;</span><br><span class="line">                res[x]=arr[x];</span><br><span class="line">                dfs(index + arr[x]);</span><br><span class="line">                visited[x] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(index==<span class="number">0</span>||index==<span class="number">1</span>)</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+index+<span class="string">&quot;层--第&quot;</span>+x+<span class="string">&quot;个--&quot;</span>+Arrays.toString(res)+<span class="string">&quot;--结果：&quot;</span>+min);</span><br><span class="line">            res[x]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2400</span><br></pre></td></tr></table></figure><h2 id="E斐波那契数列最大公约数"><a href="#E斐波那契数列最大公约数" class="headerlink" title="E斐波那契数列最大公约数"></a>E斐波那契数列最大公约数</h2><p><img src="/images/lanqiao-P11/P11E.png" alt="P11E.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BigInteger arr[] = <span class="keyword">new</span> BigInteger[<span class="number">2025</span>]; <span class="comment">// int long型数据均会爆数组</span></span><br><span class="line">        arr[<span class="number">0</span>] = BigInteger.ZERO;</span><br><span class="line">        arr[<span class="number">1</span>] = arr[<span class="number">2</span>] = BigInteger.ONE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">2020</span>; i++) &#123;</span><br><span class="line">            arr[i] = arr[i - <span class="number">1</span>].add(arr[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(gcd(arr[<span class="number">2020</span>],arr[<span class="number">520</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigInteger <span class="title">gcd</span><span class="params">(BigInteger  a,BigInteger  b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.equals(BigInteger.ZERO)?a:gcd(b,a.mod(b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6765</span><br></pre></td></tr></table></figure><h2 id="F分类计数"><a href="#F分类计数" class="headerlink" title="F分类计数"></a>F分类计数</h2><p><img src="/images/lanqiao-P11/P11F.png" alt="P11F.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> H=<span class="number">0</span>,L=<span class="number">0</span>,D=<span class="number">0</span>;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = input.next();</span><br><span class="line">        <span class="keyword">char</span>[] arr = str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; arr[i]&lt;=<span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">                H++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i]&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; arr[i]&lt;=<span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">                L++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; arr[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                D++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(H);</span><br><span class="line">        System.out.println(L);</span><br><span class="line">        System.out.println(D);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G八次求和"><a href="#G八次求和" class="headerlink" title="G八次求和"></a>G八次求和</h2><p><img src="/images/lanqiao-P11/P11G.png" alt="P11G.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BigInteger base = <span class="keyword">new</span> BigInteger(<span class="keyword">new</span> Scanner(System.in).next());</span><br><span class="line">        BigInteger result = BigInteger.ZERO;</span><br><span class="line">        <span class="keyword">for</span>(BigInteger i=BigInteger.ONE;i.compareTo(base)&lt;<span class="number">1</span>;i=i.add(BigInteger.ONE))&#123;</span><br><span class="line">            result = result.add(i.pow(<span class="number">8</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result.mod(<span class="keyword">new</span> BigInteger(<span class="string">&quot;123456789&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H字符串编码"><a href="#H字符串编码" class="headerlink" title="H字符串编码"></a>H字符串编码</h2><p><img src="/images/lanqiao-P11/P11H.png" alt="P11H.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">char</span>[] arrC = <span class="keyword">new</span> Scanner(System.in).next().toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[arrC.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arrC.length;i++)&#123;</span><br><span class="line">            arr[i] = arrC[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;<span class="number">2</span>)&#123;</span><br><span class="line">                res += (<span class="keyword">char</span>)(arr[i]+<span class="string">&#x27;A&#x27;</span>-<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i]*<span class="number">10</span>+arr[i+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (temp &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    res += (<span class="keyword">char</span>)(temp+<span class="string">&#x27;A&#x27;</span>-<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    res += (<span class="keyword">char</span>)(arr[i] + <span class="string">&#x27;A&#x27;</span>-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="I二叉搜索树插入节点"><a href="#I二叉搜索树插入节点" class="headerlink" title="I二叉搜索树插入节点"></a>I二叉搜索树插入节点</h2><p><img src="/images/lanqiao-P11/P11I1.png" alt="P11I1.png"><br><img src="/images/lanqiao-P11/P11I2.png" alt="P11I2.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main9</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">        <span class="keyword">int</span> k = input.nextInt();</span><br><span class="line">        <span class="keyword">long</span> w[] = <span class="keyword">new</span> <span class="keyword">long</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> p[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="comment">//第i个节点权值w[i]，其父节点编号p[i],权值pw[i]</span></span><br><span class="line">            p[i] = input.nextInt();</span><br><span class="line">            w[i] = input.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> parentW=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> cntW=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;w.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i]==k)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                parentW=w[p[i]];</span><br><span class="line">                cntW=w[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==<span class="number">2</span>)&#123;</span><br><span class="line">            System.out.println(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//插入右子树</span></span><br><span class="line">            <span class="keyword">if</span>(cntW&lt;parentW)&#123;</span><br><span class="line">                <span class="comment">//K是其父的左子树</span></span><br><span class="line">                <span class="keyword">if</span>(w[k]&lt;w[p[k]])&#123;</span><br><span class="line">                    System.out.println(w[k]-w[p[k]]-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//K是其父的右子树</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.println(-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//插入左子树</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//K是其父的左子树</span></span><br><span class="line">                <span class="keyword">if</span>(w[k]&lt;w[p[k]])&#123;</span><br><span class="line">                    System.out.println(-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//K是其父的右子树</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.println(w[k]-w[p[k]]-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="校内模拟赛一"><a href="#校内模拟赛一" class="headerlink" title="校内模拟赛一"></a>校内模拟赛一</h1><h2 id="A计算"><a href="#A计算" class="headerlink" title="A计算"></a>A计算</h2><blockquote><p>在计算机存储中，15.125GB是多少MB？</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">1024</span>*<span class="number">15.125</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15488</span><br></pre></td></tr></table></figure><h2 id="B约数个数"><a href="#B约数个数" class="headerlink" title="B约数个数"></a>B约数个数</h2><blockquote><p>1200000有多少个约数（只计算正约数）。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1200000</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">1200000</span>%i==<span class="number">0</span>)&#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">96</span><br></pre></td></tr></table></figure><h2 id="C叶节点数"><a href="#C叶节点数" class="headerlink" title="C叶节点数"></a>C叶节点数</h2><blockquote><p>一棵包含有2019个结点的二叉树，最多包含多少个叶结点？</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n0&#x3D;n2+1</span><br><span class="line">n0+n1+n2&#x3D;2019</span><br><span class="line"></span><br><span class="line">max(n0)&#x3D;1010</span><br></pre></td></tr></table></figure><h2 id="D包含数字9"><a href="#D包含数字9" class="headerlink" title="D包含数字9"></a>D包含数字9</h2><blockquote><p>在1至2019中，有多少个数的数位中包含数字9？<br>注意，有的数中的数位中包含多个9，这个数只算一次。例如，1999这个数包含数字9，在计算只是算一个数。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2019</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] arr=(String.valueOf(i)).toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]==<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">544</span><br></pre></td></tr></table></figure><h2 id="E数位递增的数"><a href="#E数位递增的数" class="headerlink" title="E数位递增的数"></a>E数位递增的数</h2><blockquote><p>【问题描述】<br>一个正整数如果任何一个数位不大于右边相邻的数位，则称为一个数位递增的数，例如1135是一个数位递增的数，而1024不是一个数位递增的数。<br>给定正整数 n，请问在整数 1 至 n 中有多少个数位递增的数？<br>【输入格式】<br>输入的第一行包含一个整数 n。<br>【输出格式】<br>输出一行包含一个整数，表示答案。<br>【样例输入】<br>30<br>【样例输出】<br>26<br>【评测用例规模与约定】<br>对于 40% 的评测用例，1 &lt;= n &lt;= 1000。<br>对于 80% 的评测用例，1 &lt;= n &lt;= 100000。<br>对于所有评测用例，1 &lt;= n &lt;= 1000000。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> n = <span class="keyword">new</span> Scanner(System.in).nextLong();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] arr=(<span class="string">&quot;&quot;</span>+i).toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;arr.length-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j==arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F递增三元组"><a href="#F递增三元组" class="headerlink" title="F递增三元组"></a>F递增三元组</h2><blockquote><p>【问题描述】<br>在数列 a[1], a[2], …, a[n] 中，如果对于下标 i, j, k 满足 0&lt;i&lt;j&lt;k&lt;n+1 且 a[i]&lt;a[j]&lt;a[k]，则称 a[i], a[j], a[k] 为一组递增三元组，a[j]为递增三元组的中心。<br>给定一个数列，请问数列中有多少个元素可能是递增三元组的中心。<br>【输入格式】<br>输入的第一行包含一个整数 n。<br>第二行包含 n 个整数 a[1], a[2], …, a[n]，相邻的整数间用空格分隔，表示给定的数列。<br>【输出格式】<br>输出一行包含一个整数，表示答案。<br>【样例输入】<br>5<br>1 2 5 3 5<br>【样例输出】<br>2<br>【样例说明】<br>a[2] 和 a[4] 可能是三元组的中心。<br>【评测用例规模与约定】<br>对于 50% 的评测用例，2 &lt;= n &lt;= 100，0 &lt;= 数列中的数 &lt;= 1000。<br>对于所有评测用例，2 &lt;= n &lt;= 1000，0 &lt;= 数列中的数 &lt;= 10000。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> index = input.nextInt() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">        <span class="keyword">boolean</span>[] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[index];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = input.nextInt();</span><br><span class="line">            flag[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; arr.length; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (arr[j] &lt; arr[k] &amp;&amp; !flag[j]) &#123;</span><br><span class="line">                            flag[j] = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[i])&#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G音节判断"><a href="#G音节判断" class="headerlink" title="G音节判断"></a>G音节判断</h2><blockquote><p>【问题描述】<br>小明对类似于 hello 这种单词非常感兴趣，这种单词可以正好分为四段，第一段&gt; 由一个或多个辅音字母组成，第二段由一个或多个元音字母组成，第三段由一个或多个辅音字母组成，第四段由一个或多个元音字母组成。<br>给定一个单词，请判断这个单词是否也是这种单词，如果是请输出yes，否则请输出no。<br>元音字母包括 a, e, i, o, u，共五个，其他均为辅音字母。<br>【输入格式】<br>输入一行，包含一个单词，单词中只包含小写英文字母。<br>【输出格式】<br>输出答案，或者为yes，或者为no。<br>【样例输入】<br>lanqiao<br>【样例输出】<br>yes<br>【样例输入】<br>world<br>【样例输出】<br>no<br>【评测用例规模与约定】<br>对于所有评测用例，单词中的字母个数不超过100。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//public class Main7 &#123;</span></span><br><span class="line"><span class="comment">//    public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">//        int ex=0;</span></span><br><span class="line"><span class="comment">//        char[] arr=new Scanner(System.in).nextLine().toCharArray();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        if(isYuan(arr[0]))&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;no&quot;);</span></span><br><span class="line"><span class="comment">//            return;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        if(!isYuan(arr[arr.length-1]))&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;no&quot;);</span></span><br><span class="line"><span class="comment">//            return;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        for(int i=0;i&lt;arr.length-1;i++)&#123;</span></span><br><span class="line"><span class="comment">//            if(!isYuan(arr[i]))&#123;</span></span><br><span class="line"><span class="comment">//                if(isYuan(arr[i+1])) &#123;</span></span><br><span class="line"><span class="comment">//                    ex++;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;else&#123;</span></span><br><span class="line"><span class="comment">//                if(!isYuan(arr[i+1])) &#123;</span></span><br><span class="line"><span class="comment">//                    ex++;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        if(ex==3)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;yes&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;else&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;no&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    public static boolean isYuan(char c)&#123;</span></span><br><span class="line"><span class="comment">//        if(c==&#x27;a&#x27;||c==&#x27;e&#x27;||c==&#x27;i&#x27;||c==&#x27;o&#x27;||c==&#x27;u&#x27;)&#123;</span></span><br><span class="line"><span class="comment">//            return true;</span></span><br><span class="line"><span class="comment">//        &#125;else&#123;</span></span><br><span class="line"><span class="comment">//            return false;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正则表达式解法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">&quot;[^aeiou]+[aeiou]+[^aeiou]+[aeiou]+&quot;</span>);</span><br><span class="line">        Matcher m = p.matcher(<span class="keyword">new</span> Scanner(System.in).nextLine());</span><br><span class="line">        <span class="keyword">if</span> (m.matches()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H长草"><a href="#H长草" class="headerlink" title="H长草"></a>H长草</h2><blockquote><p>【问题描述】<br>小明有一块空地，他将这块空地划分为 n 行 m 列的小块，每行和每列的长度都为 1。<br>小明选了其中的一些小块空地，种上了草，其他小块仍然保持是空地。<br>这些草长得很快，每个月，草都会向外长出一些，如果一个小块种了草，则它将向自己的上、下、左、右四小块空地扩展，这四小块空地都将变为有草的小块。<br>请告诉小明，k 个月后空地上哪些地方有草。<br>【输入格式】<br>输入的第一行包含两个整数 n, m。<br>接下来 n 行，每行包含 m 个字母，表示初始的空地状态，字母之间没有空格。如果为小数点，表示为空地，如果字母为 g，表示种了草。<br>接下来包含一个整数 k。<br>【输出格式】<br>输出 n 行，每行包含 m 个字母，表示 k 个月后空地的状态。如果为小数点，表示为空地，如果字母为 g，表示长了草。<br>【样例输入】<br>4 5<br>.g…<br>…..<br>..g..<br>…..<br>2<br>【样例输出】<br>gggg.<br>gggg.<br>ggggg<br>.ggg.<br>【评测用例规模与约定】<br>对于 30% 的评测用例，2 &lt;= n, m &lt;= 20。<br>对于 70% 的评测用例，2 &lt;= n, m &lt;= 100。<br>对于所有评测用例，2 &lt;= n, m &lt;= 1000，1 &lt;= k &lt;= 1000。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n=input.nextInt();</span><br><span class="line">        <span class="keyword">int</span> m=input.nextInt();</span><br><span class="line">        <span class="keyword">char</span>[][] arr = <span class="keyword">new</span> <span class="keyword">char</span>[n][m];</span><br><span class="line">        <span class="keyword">boolean</span>[][] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][m];</span><br><span class="line">        input.nextLine();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            String temp = input.nextLine();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                arr[i][j]=temp.charAt(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = input.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//刷新标记</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[i][j]==<span class="string">&#x27;g&#x27;</span>)&#123;</span><br><span class="line">                        flag[i][j]=<span class="keyword">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        flag[i][j]=<span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[i][j]==<span class="string">&#x27;g&#x27;</span> &amp;&amp; flag[i][j]) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(i-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; arr[i-<span class="number">1</span>][j]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                            arr[i-<span class="number">1</span>][j]=<span class="string">&#x27;g&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n &amp;&amp; arr[i+<span class="number">1</span>][j]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                            arr[i+<span class="number">1</span>][j]=<span class="string">&#x27;g&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(j-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; arr[i][j-<span class="number">1</span>]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                            arr[i][j-<span class="number">1</span>]=<span class="string">&#x27;g&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(j+<span class="number">1</span>&lt;m &amp;&amp; arr[i][j+<span class="number">1</span>]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                            arr[i][j+<span class="number">1</span>]=<span class="string">&#x27;g&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                System.out.print((arr[i][j]));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="校内模拟赛三"><a href="#校内模拟赛三" class="headerlink" title="校内模拟赛三"></a>校内模拟赛三</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><blockquote><p>请问在 1 到 2020 中，有多少个数与 2020 互质，即有多少个数与 2020 的最大公约数为 1。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2020</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(gcd(<span class="number">2020</span>,i)==<span class="number">1</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i%j==<span class="number">0</span>)?j:gcd(j,i%j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">800</span><br></pre></td></tr></table></figure><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><blockquote><p>ASCII 码将每个字符对应到一个数值（编码），用于信息的表示和传输。在 ASCII 码中，英文字母是按从小到大的顺序依次编码的，例如：字母 A 编码是 65, 字母 B 编码是 66，字母 C 编码是 67，请问字母 Q 编码是多少？</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println((<span class="keyword">int</span>)<span class="string">&#x27;Q&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">81</span><br></pre></td></tr></table></figure><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote><p>有一棵二叉树，一个由2021个结点，其中有1000个结点有两个子结点，其他的结点有一个或者0个子结点。<br>请问，这棵二叉树有多少个叶结点？</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n0&#x3D;n2+1</span><br><span class="line">n2&#x3D;1000</span><br><span class="line"></span><br><span class="line">n0&#x3D;1001</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1001</span><br></pre></td></tr></table></figure><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote><p>对于整数 v 和 p，定义 Pierce 序列为：<br>　　a[1] = v<br>　　a[i] = p % a[i-1]<br>　　例如，当 v = 8, p = 21 时，对应的 Pierce 序列为<br>　　a[1] = 8<br>　　a[2] = 5<br>　　a[3] = 1<br>　　再往后计算，值变为 0，不在我们考虑的范围内。因此当 v = 8, p = 21 时， Pierce 序列的长度为 3。<br>　　当 p 一定时，对于不同的 v 值，Pierce 序列的长度可能不同。<br>　　当 p=2021 时，最长的 Pierce 序列出现在 v=1160 时，请问这个序列有多长？</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v=<span class="number">1160</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">1</span>,p=<span class="number">2021</span>;</span><br><span class="line">        <span class="keyword">while</span>(v!=<span class="number">1</span>)&#123;</span><br><span class="line">            v = p%v;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote><p>在 Excel 中，第 1 列到第 26 列的列名依次为 A 到 Z，从第 27 列开始，列名有两个字母组成，第 27 列到第 702 列的列名依次为 AA 到 ZZ。之后的列再用 3 个字母、4 个字母表示。<br>请问，第 2021 列的列名是什么？</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">2021</span>;</span><br><span class="line">        <span class="keyword">int</span> i=p/(<span class="number">26</span>*<span class="number">26</span>);</span><br><span class="line">        <span class="keyword">int</span> j=(p%(<span class="number">26</span>*<span class="number">26</span>))/<span class="number">26</span>;</span><br><span class="line">        <span class="keyword">int</span> k=p-i*<span class="number">26</span>*<span class="number">26</span>-j*<span class="number">26</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>) (<span class="string">&#x27;A&#x27;</span> + i - <span class="number">1</span>) + <span class="string">&quot;&quot;</span> + (<span class="keyword">char</span>) (<span class="string">&#x27;A&#x27;</span> + j - <span class="number">1</span>) + <span class="string">&quot;&quot;</span> + (<span class="keyword">char</span>) (<span class="string">&#x27;A&#x27;</span> + k - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>) (<span class="string">&#x27;A&#x27;</span> + j - <span class="number">1</span>) + <span class="string">&quot;&quot;</span> + (<span class="keyword">char</span>) (<span class="string">&#x27;A&#x27;</span> + k - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>) ((<span class="keyword">char</span>) (<span class="string">&#x27;A&#x27;</span> + k - <span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BYS</span><br></pre></td></tr></table></figure><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote><p>【问题描述】<br>斐波那契数列是这样一个数列：它的第一项和第二项都是1，从第三项开始每一项都是前两项的和。<br>根据以上定义，我们容易计算出斐波那契数列的前几项依次是：1, 1, 2, 3, 5, 8, 13, 21, 34, 55 ……<br>现在请你计算斐波那契数列第N项是奇数还是偶数？</p><p>【输入格式】<br>输入的包含一个整数N。</p><p>【输出格式】<br>如果是奇数输出1，是偶数输出0。</p><p>【样例输入】<br>10</p><p>【样例输出】<br>1</p><p>【提示】<br>找规律。</p><p>【评测用例规模与约定】<br>对于所有评测用例，1 &lt;= N &lt;= 1000000000。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="keyword">new</span> Scanner(System.in).nextInt();</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><blockquote><p>【问题描述】<br>在书写一个较大的整数时，为了方便看清数位，通常会在数位之间加上逗号来分割数位，具体的，从右向左，每三位分成一段，相邻的段之间加一个逗号。<br>例如，1234567 写成 1,234,567。<br>例如，17179869184 写成 17,179,869,184。<br>给定一个整数，请将这个整数增加分割符后输出。</p><p>【输入格式】<br>输入一行包含一个整数 v。</p><p>【输出格式】<br>输出增加分割符后的整数。</p><p>【样例输入】<br>1234567</p><p>【样例输出】<br>1,234,567</p><p>【样例输入】<br>17179869184</p><p>【样例输出】<br>17,179,869,184</p><p>【评测用例规模与约定】<br>对于 50% 的评测用例，0 &lt;= v &lt; 10^9 (10的9次方)。<br>对于所有评测用例，0 &lt;= v &lt; 10^18 (10的18次方)。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String temp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">char</span>[] arr=<span class="keyword">new</span> Scanner(System.in).next().toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] tempArr=<span class="keyword">new</span> <span class="keyword">char</span>[arr.length*<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=arr.length;i++)&#123;</span><br><span class="line">            temp += arr[arr.length-i];</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span> &amp;&amp; i!=arr.length)&#123;</span><br><span class="line">                temp += <span class="string">&quot;,&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tempArr = temp.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= tempArr.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            System.out.print(tempArr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><blockquote><p>【问题描述】<br>给定一个矩阵 M，由 n 行 m 列组成，第 i 行第 j 列值为 M[i][j]。<br>定义矩阵 M 的重量为矩阵中所有元素的和，几位weight(M)<br>请找到矩阵左上角的一个子矩阵S（矩阵的前 r 行中的前 c 列组成），使得这个子矩阵的重量的两倍最接近矩阵 M 重量。即 |2 weight(S)-weight(M)| 最小。<br>如果有多个子矩阵满足条件，请找出面积 r * c 最小的一个。<br>如果仍然有多个子矩阵满足条件，请找出其中 r 最小的一个。</p><p>【输入格式】<br>输入第一行包含两个整数 n, m，表示矩阵的大小。<br>接下来 n 行，每行 m 个整数，表示给定的矩阵M。</p><p>【输出格式】<br>输出一行，包含两个整数 r, c，表示子矩阵为矩阵 M 的前 r 行中的前 c 列。</p><p>【样例输入】<br>3 4<br>3 0 1 1<br>1 0 1 1<br>1 1 -2 4</p><p>【样例输出】<br>2 3</p><p>【评测用例规模与约定】<br>对于 30% 的评测用例，1 &lt;= n, m &lt;= 20, -10 &lt;= M[i][j] &lt;= 10。<br>对于 50% 的评测用例，1 &lt;= n, m &lt;= 100, -100 &lt;= M[i][j] &lt;= 100。<br>对于所有评测用例，1 &lt;= n, m &lt;= 1000, -1000 &lt;= M[i][j] &lt;= 1000。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">        <span class="keyword">int</span> m = input.nextInt();</span><br><span class="line">        <span class="keyword">int</span> weight=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span> [n*m];</span><br><span class="line">        <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span> [n*m];</span><br><span class="line">        <span class="comment">//权值</span></span><br><span class="line">        <span class="keyword">int</span> arr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="comment">//权值和</span></span><br><span class="line">        <span class="keyword">int</span> weightArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="comment">//差值</span></span><br><span class="line">        <span class="keyword">int</span> diffArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                arr[i][j] = input.nextInt();</span><br><span class="line">                weight += arr[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        weight /= <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//遍历计算第一行的权值和</span></span><br><span class="line">        <span class="keyword">int</span> tempWeight=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            tempWeight += arr[i][<span class="number">0</span>];</span><br><span class="line">            weightArr[i][<span class="number">0</span>] = tempWeight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历计算第一列的权值和</span></span><br><span class="line">        tempWeight=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            tempWeight += arr[<span class="number">0</span>][j];</span><br><span class="line">            weightArr[<span class="number">0</span>][j] = tempWeight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出计算所有项对应的权值和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">                weightArr[i][j] = arr[i][j] + weightArr[i-<span class="number">1</span>][j] + weightArr[i][j-<span class="number">1</span>] - weightArr[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找出最小差值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                diffArr[i][j] = Math.abs(weightArr[i][j]-weight);</span><br><span class="line">                <span class="keyword">if</span>(diffArr[i][j]&lt;min)&#123;</span><br><span class="line">                    min = diffArr[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(min);</span><br><span class="line">        <span class="comment">//统计最小值的个数cnt，并将下标记录在数组r[]c[]</span></span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(diffArr[i][j]==min)&#123;</span><br><span class="line">                    r[cnt]=i;</span><br><span class="line">                    c[cnt]=j;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//差值唯一</span></span><br><span class="line">        <span class="keyword">int</span>[] diffRC = <span class="keyword">new</span> <span class="keyword">int</span>[cnt];</span><br><span class="line">        <span class="keyword">int</span> minRC = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(cnt==<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="string">&quot;A:&quot;</span>+r[<span class="number">0</span>]+<span class="number">1</span>)+<span class="string">&quot; &quot;</span>+(c[<span class="number">0</span>]+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有多个相等的差值，判断r*c</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">                diffRC[i] = (r[i]+<span class="number">1</span>)*(c[i]+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(diffRC[i]&lt;minRC)&#123;</span><br><span class="line">                    minRC=diffRC[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计最小的R*C，个数cntRC</span></span><br><span class="line">        <span class="keyword">int</span> cntRC=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] diffR = <span class="keyword">new</span> <span class="keyword">int</span>[cnt];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(diffRC[i]==minRC)&#123;</span><br><span class="line">                diffR[cntRC]=i;</span><br><span class="line">                System.out.println(<span class="string">&quot;diffR[cntRC]：&quot;</span>+(r[diffR[cntRC]]+<span class="number">1</span>)+<span class="string">&quot; &quot;</span>+(c[diffR[cntRC]]+<span class="number">1</span>));</span><br><span class="line">                System.out.println(minRC);</span><br><span class="line">                cntRC++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;cntRC:&quot;</span>+cntRC);</span><br><span class="line">        <span class="keyword">int</span> minR = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> minRi = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//只有一个最小的R*C</span></span><br><span class="line">        <span class="keyword">if</span>(cntRC==<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="string">&quot;B:&quot;</span>+r[diffR[<span class="number">0</span>]]+<span class="number">1</span>)+<span class="string">&quot; &quot;</span>+(c[diffR[<span class="number">0</span>]]+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有多个最小的R*C，输出最小的R minR</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cntRC;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(r[diffR[i]]&lt;minR)&#123;</span><br><span class="line">                    minR=r[diffR[i]];</span><br><span class="line">                    minRi=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println((<span class="string">&quot;C:&quot;</span>+(r[diffR[minRi]]+<span class="number">1</span>))+<span class="string">&quot; &quot;</span>+(c[diffR[minRi]]+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">2 4 -2</span></span><br><span class="line"><span class="comment">6 0 2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">-----</span></span><br><span class="line"><span class="comment">12:6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2 6 4</span></span><br><span class="line"><span class="comment">8 12 12</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4 0 2</span></span><br><span class="line"><span class="comment">2 6 6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">3 0 1 1</span></span><br><span class="line"><span class="comment">1 0 1 1</span></span><br><span class="line"><span class="comment">1 1 -2 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">1 -1 1</span></span><br><span class="line"><span class="comment">-1 1 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><blockquote><p>【问题描述】<br>杂货铺老板一共有N件物品，每件物品具有ABC三种属性中的一种或多种。从杂货铺老板处购得一件物品需要支付相应的代价。<br>现在你需要计算出如何购买物品，可以使得ABC三种属性中的每一种都在至少一件购买的物品中出现，并且支付的总代价最小。</p><p>【输入格式】<br>输入第一行包含一个整数N。<br>以下N行，每行包含一个整数C和一个只包含”ABC”的字符串，代表购得该物品的代价和其具有的属性。</p><p>【输出格式】<br>输出一个整数，代表最小的代价。如果无论如何凑不齐ABC三种属性，输出-1。</p><p>【样例输入】<br>5<br>10 A<br>9 BC<br>11 CA<br>4 A<br>5 B</p><p>【样例输出】<br>13</p><p>【评测用例规模与约定】<br>对于50%的评测用例，1 &lt;= N &lt;= 20<br>对于所有评测用例，1 &lt;= N &lt;= 1000， 1 &lt;= C &lt;= 100000</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main91</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n=input.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] flag = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        Arrays.fill(flag,Integer.MAX_VALUE);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> w = input.nextInt();</span><br><span class="line">            v=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">char</span>[] str = input.next().toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;str.length;j++)&#123;</span><br><span class="line">                v |= <span class="number">1</span>&lt;&lt;(str[j]-<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;flag.length;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((k&amp;v)!=v &amp;&amp; flag[k]!=Integer.MAX_VALUE &amp;&amp; w+flag[k]&lt;flag[k|v])&#123;</span><br><span class="line">                    flag[k|v] = w+flag[k];</span><br><span class="line">                &#125;</span><br><span class="line">                flag[v]=Math.min(flag[v],w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(flag[<span class="number">7</span>]==Integer.MAX_VALUE?-<span class="number">1</span>:flag[<span class="number">7</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="J"><a href="#J" class="headerlink" title="J"></a>J</h2><blockquote><p>记不清了，之后补吧。<br>大意是：<br>输入一个n*m的数组，求出每个元素与它周围一圈的元素中最大的元素，输出数组</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 当时考试没想到，就“硬”写出来的暴力，不推荐</span></span><br><span class="line"><span class="comment"> * 更好的方法是读入矩阵并将其放置在比它大一圈的数组中，保持数据在中央，边缘置为</span></span><br><span class="line"><span class="comment"> * 这样就不用考虑4、6个的情况，只需要比较9个数的函数就可以</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">        <span class="keyword">int</span> m = input.nextInt();</span><br><span class="line">        <span class="keyword">int</span> arr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="keyword">int</span> res[][] = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                arr[i][j] = input.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>) &#123;</span><br><span class="line">        res[<span class="number">0</span>][i]=max4(arr[<span class="number">0</span>][<span class="number">0</span>],arr[<span class="number">0</span>][<span class="number">1</span>],arr[<span class="number">1</span>][<span class="number">0</span>],arr[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i==m-<span class="number">1</span>) &#123;</span><br><span class="line">        res[<span class="number">0</span>][i]=max4(arr[<span class="number">0</span>][m-<span class="number">1</span>],arr[<span class="number">0</span>][m-<span class="number">2</span>],arr[<span class="number">1</span>][m-<span class="number">1</span>],arr[<span class="number">1</span>][m-<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        res[<span class="number">0</span>][i]=max6(arr[<span class="number">0</span>][i-<span class="number">1</span>],arr[<span class="number">0</span>][i],arr[<span class="number">0</span>][i+<span class="number">1</span>],arr[<span class="number">1</span>][i-<span class="number">1</span>],arr[<span class="number">1</span>][i],arr[<span class="number">1</span>][i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>) &#123;</span><br><span class="line">        res[n-<span class="number">1</span>][i]=max4(arr[n-<span class="number">1</span>][<span class="number">0</span>],arr[n-<span class="number">1</span>][<span class="number">1</span>],arr[n-<span class="number">2</span>][<span class="number">0</span>],arr[n-<span class="number">2</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i==m-<span class="number">1</span>) &#123;</span><br><span class="line">        res[n-<span class="number">1</span>][i]=max4(arr[n-<span class="number">1</span>][m-<span class="number">1</span>],arr[n-<span class="number">1</span>][m-<span class="number">2</span>],arr[n-<span class="number">2</span>][m-<span class="number">1</span>],arr[n-<span class="number">2</span>][m-<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        res[n-<span class="number">1</span>][i]=max6(arr[n-<span class="number">1</span>][i-<span class="number">1</span>],arr[n-<span class="number">1</span>][i],arr[n-<span class="number">1</span>][i+<span class="number">1</span>],arr[n-<span class="number">2</span>][i-<span class="number">1</span>],arr[n-<span class="number">2</span>][i],arr[n-<span class="number">2</span>][i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n-<span class="number">1</span>;i++) &#123;</span><br><span class="line">        res[i][<span class="number">0</span>]=max6(arr[i-<span class="number">1</span>][<span class="number">0</span>],arr[i][<span class="number">0</span>],arr[i+<span class="number">1</span>][<span class="number">0</span>],arr[i-<span class="number">1</span>][<span class="number">1</span>],arr[i][<span class="number">1</span>],arr[i+<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n-<span class="number">1</span>;i++) &#123;</span><br><span class="line">        res[i][m-<span class="number">1</span>]=max6(arr[i-<span class="number">1</span>][m-<span class="number">1</span>],arr[i][m-<span class="number">1</span>],arr[i+<span class="number">1</span>][m-<span class="number">1</span>],arr[i-<span class="number">1</span>][m-<span class="number">2</span>],arr[i][m-<span class="number">2</span>],arr[i+<span class="number">1</span>][m-<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//中间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n-<span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m-<span class="number">1</span>;j++) &#123;</span><br><span class="line">        res[i][j]=max9(arr[i-<span class="number">1</span>][j-<span class="number">1</span>],arr[i-<span class="number">1</span>][j],arr[i-<span class="number">1</span>][j+<span class="number">1</span>],arr[i][j-<span class="number">1</span>],arr[i][j],arr[i][j+<span class="number">1</span>],arr[i+<span class="number">1</span>][j-<span class="number">1</span>],arr[i+<span class="number">1</span>][j],arr[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==m-<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print(res[i][j]);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.print(res[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max4</span><span class="params">(<span class="keyword">int</span> a0,<span class="keyword">int</span> a1,<span class="keyword">int</span> a2,<span class="keyword">int</span> a3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">    a[<span class="number">0</span>] = a0;</span><br><span class="line">    a[<span class="number">1</span>] = a1;</span><br><span class="line">    a[<span class="number">2</span>] = a2;</span><br><span class="line">    a[<span class="number">3</span>] = a3;</span><br><span class="line">    <span class="keyword">int</span> temp = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]&gt;temp) &#123;</span><br><span class="line">    temp = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max6</span><span class="params">(<span class="keyword">int</span> a0,<span class="keyword">int</span> a1,<span class="keyword">int</span> a2,<span class="keyword">int</span> a3,<span class="keyword">int</span> a4,<span class="keyword">int</span> a5)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>];</span><br><span class="line">    a[<span class="number">0</span>] = a0;</span><br><span class="line">    a[<span class="number">1</span>] = a1;</span><br><span class="line">    a[<span class="number">2</span>] = a2;</span><br><span class="line">    a[<span class="number">3</span>] = a3;</span><br><span class="line">    a[<span class="number">4</span>] = a4;</span><br><span class="line">    a[<span class="number">5</span>] = a5;</span><br><span class="line">    <span class="keyword">int</span> temp = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]&gt;temp) &#123;</span><br><span class="line">    temp = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max9</span><span class="params">(<span class="keyword">int</span> a0,<span class="keyword">int</span> a1,<span class="keyword">int</span> a2,<span class="keyword">int</span> a3,<span class="keyword">int</span> a4,<span class="keyword">int</span> a5,<span class="keyword">int</span> a6,<span class="keyword">int</span> a7,<span class="keyword">int</span> a8)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>];</span><br><span class="line">    a[<span class="number">0</span>] = a0;</span><br><span class="line">    a[<span class="number">1</span>] = a1;</span><br><span class="line">    a[<span class="number">2</span>] = a2;</span><br><span class="line">    a[<span class="number">3</span>] = a3;</span><br><span class="line">    a[<span class="number">4</span>] = a4;</span><br><span class="line">    a[<span class="number">5</span>] = a5;</span><br><span class="line">    a[<span class="number">6</span>] = a6;</span><br><span class="line">    a[<span class="number">7</span>] = a7;</span><br><span class="line">    a[<span class="number">8</span>] = a8;</span><br><span class="line">    <span class="keyword">int</span> temp = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]&gt;temp) &#123;</span><br><span class="line">    temp = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="K"><a href="#K" class="headerlink" title="K"></a>K</h2><blockquote><p>给定一个序列 (a_1, a_2, …, a_n), 它的一个上升子序列是指从序列中取出一些元素，按照原来的顺序排列后，是单调递增的序列。<br> 例如，对于序列 (3, 2, 7, 6, 7)，取出下标为 2, 4, 5 的元素 a_2, a_4, a_5，即 2, 6, 7，是一个上升子序列。<br> 在这个序列中，有 7 个长度为 2 的上升子序列，例如</p><p>   下标 1, 3 对应的 3, 7；<br>　　1. 下标 1, 4 对应的 3, 6；<br>　　2. 下标 1, 5 对应的 3, 7；<br>　　3. 下标 2, 3 对应的 2, 7；<br>　　4. 下标 2, 4 对应的 2, 6；<br>　　5. 下标 2, 5 对应的 2, 7；<br>　　6. 下标 4, 5 对应的 6, 7。<br>注意，可能有下标不同但对应数值相同的上升子序列，他们应当算成不同的上升子序列。<br>　　给定序列，请问序列中一共有多少个长度为 k 的上升子序列。<br>输入格式<br>　　输入第一行包含两个整数 n, k，表示序列的长度和上升子序列的长度。<br>　　第二行包含 n 个整数 a_1, a_2, …, a_n，表示给定的序列。<br>输出格式<br>　　输出一行，包含一个整数，表示长度为 k 的上升子序列的数量，答案可能很大，请输出答案除以 1000007 的余数。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> res;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = input.nextInt();</span><br><span class="line">        k = input.nextInt();</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            arr[i] = input.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        res = DFS(i,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res%<span class="number">1000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> kk)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(kk==k) &#123;</span><br><span class="line">    res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[j]&gt;arr[i]) &#123;</span><br><span class="line">        res++;</span><br><span class="line">        DFS(j,kk+<span class="number">1</span>);</span><br><span class="line">        res--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符转换"><a href="#字符转换" class="headerlink" title="字符转换"></a>字符转换</h1><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>String -&gt; char</td><td>toCharArray();<br>charAt();</td></tr><tr><td>char -&gt; String</td><td>String.valueOf(‘’);<br>“”+’’</td></tr><tr><td>String -&gt; int</td><td>int=Integer.parseInt(“”);<br>int=Integer.valueOf(“”).intValue();</td></tr><tr><td>int -&gt; String</td><td>String.valueOf()；<br>Integer.toString()；<br>String=””+int;</td></tr><tr><td>char -&gt; int(ascii)</td><td>int=char;</td></tr><tr><td>int(ascii) -&gt; char</td><td>char=(char)int;</td></tr><tr><td>char -&gt; int</td><td>int=’’-‘0’;</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;第十一届蓝桥杯大赛软件类省赛Java大学B组第一场 &amp;amp; 第一次校内模拟  &amp;amp; 第三次校内模拟&lt;br&gt;详解及总结&lt;/p&gt;</summary>
    
    
    
    <category term="Study" scheme="https://memorykk.cn/categories/Study/"/>
    
    
    <category term="lanqiao" scheme="https://memorykk.cn/tags/lanqiao/"/>
    
  </entry>
  
  <entry>
    <title>《鸟哥的Linux私房菜》第0-3章</title>
    <link href="https://memorykk.cn/linux-vbird-0-3.html"/>
    <id>https://memorykk.cn/linux-vbird-0-3.html</id>
    <published>2021-02-20T06:08:11.000Z</published>
    <updated>2021-03-11T14:58:40.926Z</updated>
    
    <content type="html"><![CDATA[<p>基础篇第 0-3 章学习笔记</p><span id="more"></span><hr><p><strong>目录</strong></p><ul><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%AE%BA">计算机概论</a><ul><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6">计算机硬件</a></li><li><a href="#CPU">CPU</a></li><li><a href="#%E5%86%85%E5%AD%98">内存</a></li><li><a href="#%E6%98%BE%E5%8D%A1">显卡</a></li><li><a href="#%E7%A1%AC%E7%9B%98%E4%B8%8E%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87">硬盘与存储设备</a></li><li><a href="#PCI%E9%80%82%E9%85%8D%E5%8D%A1">PCI 适配卡</a></li><li><a href="#%E4%B8%BB%E6%9D%BF">主板</a></li><li><a href="#%E7%94%B5%E6%BA%90">电源</a></li><li><a href="#%E6%96%87%E5%AD%97%E7%BC%96%E7%A0%81%E7%B3%BB%E7%BB%9F">文字编码系统</a></li><li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a></li><li><a href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">应用程序</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></li><li><a href="#Linux%E6%98%AF%E4%BB%80%E4%B9%88">Linux是什么</a><ul><li><a href="#%E5%8E%86%E5%8F%B2">历史</a></li><li><a href="#Linux%E7%9A%84%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC">Linux的内核版本</a></li><li><a href="#Linux-distribution">Linux distribution</a></li><li><a href="#Linux%E7%9A%84%E7%89%B9%E8%89%B2">Linux的特色</a></li></ul></li><li><a href="#%E4%B8%BB%E6%9C%BA%E8%A7%84%E5%88%92%E4%B8%8E%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA">主机规划与磁盘分区</a><ul><li><a href="#%E7%A3%81%E7%9B%98%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E5%90%8D%E7%9A%84%E5%85%B3%E7%B3%BB">磁盘连接的方式与设备文件名的关系</a><ul><li><a href="#IDE%E8%AE%BE%E5%A4%87">IDE设备</a></li><li><a href="#SATA%E8%AE%BE%E5%A4%87">SATA设备</a></li></ul></li><li><a href="#%E7%A3%81%E7%9B%98%E7%9A%84%E7%BB%84%E6%88%90">磁盘的组成</a></li><li><a href="#%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E8%A1%A8">磁盘分区表</a></li><li><a href="#%E5%BC%80%E6%9C%BA%E6%B5%81%E7%A8%8B%E4%B8%8E%E4%B8%BB%E5%BC%95%E5%AF%BC%E5%88%86%E5%8C%BAMBR">开机流程与主引导分区MBR</a><ul><li><a href="#%E5%BC%80%E6%9C%BA%E6%B5%81%E7%A8%8B">开机流程</a></li><li><a href="#BootLoader%E7%9A%84%E5%8A%9F%E8%83%BD">BootLoader的功能</a></li></ul></li><li><a href="#%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E7%9A%84%E9%80%89%E6%8B%A9">磁盘分区的选择</a></li><li><a href="#%E4%B8%BB%E6%9C%BA%E7%A1%AC%E7%9B%98%E7%9A%84%E4%B8%BB%E8%A6%81%E8%A7%84%E5%88%92">主机硬盘的主要规划</a></li></ul></li><li><a href="#%E5%AE%89%E8%A3%85CentOS-5-x%E4%B8%8E%E5%A4%9A%E9%87%8D%E5%BC%95%E5%AF%BC">安装CentOS 5.x与多重引导</a><ul><li><a href="#%E5%AE%89%E8%A3%85%E8%A7%84%E5%88%92">安装规划</a></li><li><a href="#%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4">安装步骤</a></li></ul></li></ul><hr><h1 id="计算机概论"><a href="#计算机概论" class="headerlink" title="计算机概论"></a>计算机概论</h1><h2 id="计算机硬件"><a href="#计算机硬件" class="headerlink" title="计算机硬件"></a>计算机硬件</h2><p><img src="/images/linux-vbird-0-3/computer.png" alt="computer.png"></p><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>CPU 的架构：</p><ul><li>精简指令集 RISC：单指令工作简单，执行快。arm</li><li>复杂指令集 CISC。单指令工作复杂，执行慢。intel(x86)、amd(x86_64)<br>1Byte=8bit</li></ul><p><img src="/images/linux-vbird-0-3/problem_memory.png" alt="problem_memory.png"></p><p>原本的单核 CPU 仅有一个运算单元,所谓的多核则是在一个 CPU 封装当中嵌入了两个以上的运算内核,简单地说,就是一个实际的 CPU 外壳中含有两个以上的 CPU 单元。<br>amd 内存与 cpu 直连，intel 内存通过北桥与 cpu 连接</p><p><strong>CPU 频率=外频*倍频</strong></p><ul><li>外频：cpu 与外部传输速率</li><li>倍频：cpu 内部运算的加速功能（出厂固定）</li></ul><p>超频：通过主板的设定功能更改成较高频率的一种方式。因为频率并非正常速度,故可能会造成死机等。</p><p>总线宽度：32/64<br>CPU 有向下兼容的能力</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>个人计算机的内存主要组件为动态随机访问内存 DRAM，挥发性</p><ul><li>SDRAM</li><li>DDR SDRAM：双倍数据传输速度 - DDR - DDRⅡ - DDRⅢ<br>双通道设计：两根 64 位总线宽度-&gt;128 位<br> CPU 外频=内存外频<br> 第二层缓存：常用的数据或程序放置在 CPU 内部，不在通过北桥从内存加载<br> DRAM 频率速度无法达到 L2=CPU 外频，因此使用静态随机访问内存 SRAM<br> <strong>只读存储器 ROM</strong><br>主板上组件参数存储在 CMOS 中，BIOS 是一套写死在 ROM 上的程序，非挥发性，系统开机时首先读取 BIOS；固件很多采用 ROM 进行软件写入；ROM 无法改写，因此 BIOS 通常写入 Flash Memory 或 EEPROM 中，以更新。</li></ul><h2 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h2><p>一般对于图形影像的显示重点在于分辨率与色彩深度，因为每个图像显示的颜色会占用内存，因此显卡上面会有一个内存的容量，这个显存容量将会影响到最终你的屏幕分辨率与色彩深度。越大越好。<br> 在显卡上嵌入 3D 加速芯片提升运算能力，即 GPU。<br> 北桥通信<br> 规格：AGP-&gt;PCI-&gt;PCIe</p><h2 id="硬盘与存储设备"><a href="#硬盘与存储设备" class="headerlink" title="硬盘与存储设备"></a>硬盘与存储设备</h2><p>硬盘：盘片、机械手臂、磁头、主轴马达。<br> 盘片上的数据：<br>磁盘上最小存储单位：扇区 512bytes；扇区组成圆：磁道；所有片上面的同一磁道：柱面（分割硬盘的最小单位）。<br>磁盘容量=header 数量<em>每个 header 负责的柱面数量</em>每个柱面所含有的扇区数量*扇区的容量<br>传输接口： - IDE 接口：连接两个设备，理论 133MB/s - SATA 接口：PC，一个设备，利于散热，理论 300MB/s</p><p>缓冲存储器：加速读取<br> 转速：主轴马达转动盘片<br> 运转：正常关机使机械手臂归回原位；避免移动主机使硬盘抖动</p><h2 id="PCI适配卡"><a href="#PCI适配卡" class="headerlink" title="PCI适配卡"></a>PCI适配卡</h2><p>用户额外的功能卡安插在 PCI 插槽上，很多组件（声卡、网卡）采用 PCI 接口传输，现多 PCIe</p><h2 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h2><p>主板上面负责通信各个组件的就是芯片组，芯片组一般分为北桥与南桥，需要散热。北桥负责 CPU/RAM/VGA 等的连接,南桥则负责 PCI 接口与速度较慢的 I/O 设备。<br> 芯片组：集成（显卡、网卡）型、独立型<br> I/O 地址：标识不同的设备；IRQ 中断信道：告知 CPU 该设备工作情况方便分配工作。sharing IRQ 技术。<br> CMOS 与 BIOS</p><h2 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h2><p>能源转换率<br> 接口</p><h2 id="文字编码系统"><a href="#文字编码系统" class="headerlink" title="文字编码系统"></a>文字编码系统</h2><p>英文：ASCII，一个字符占用 1B<br> 中文：big5（简体 gb2312），占用 2B<br> ISO/IEC 制订了 Unicode 编码系统，即 UTF8</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>内核、接口以及相关应用<br> 操作系统内核（kernel）：管理计算机的所有活动及驱动系统中的所有硬件，分配资源。内核所放置到内存中的区块受保护，开机后常驻内存。参考硬件规格，硬件不同则内核不同。<br> 系统调用（System Call）：一套开发接口，开发软件参考内核功能相关的开发接口。</p><p>内核功能：</p><ol><li>系统调用接口：与内核通信，软件开发</li><li>程序管理：多任务环境下有效分配资源</li><li>内存管理：虚拟内存功能提供在内存不足时的内存交换 swap</li><li>文件系统管理</li><li>设备驱动</li></ol><p>操作系统与驱动程序：OS 提供开发接口，让硬件开发商制作驱动，安装。</p><h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2><p>程序与 OS 有关系</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>计算机的定义为：”接受用户输入指令与数据，经由中央处理器的数据与逻辑单元运算处理后，以产生或存储成有用的信息“。<br> 计算机的五大单元包括输入单元、输出单元、CP∪ 内部的控制单元、算术逻辑单元与内存五大部分。<br> 数据会流进流出内存是 CPU 所发布的控制命令，而 CPU 实际要处理的数据则完全来自于内存。<br> CPU 依设计理念主要分为精简指令集(RSC)与复杂指令集(CSC)系统。<br> 关于 CPU 的频率部分，外频指的是 cPU 与外部组件进行数据传输时的速度,倍频则是 CPU 内部用来加速工作性能的一个倍数，两者相乘才是 cPU 的频率速度。<br> 一般主板芯片组分为北桥与南桥，北桥的总线称为系统总线,因为是内存传输的主要信道所以速度较快。南桥就是所谓的输入/输出(I/O)总线,主要在于连系硬盘、USB、网卡等接口设备。<br> 北桥所支持的频率我们称为前端总线速度( Front Side Bus,FSB),而每次传送的位数则是总线宽度。<br> CPU 每次能够处理的数据量称为字组大小( word size),字组大小依据 cPU 的设计而有 32 位与 64 位之分。我们现在所称的计算机是 32 或 64 位主要是依据这个 CPU 解析的字组大小而来的!<br> 个人计算机的内存主要组件为动态随机访问内存( Dynamic Random Access Memory,DRAM），至于 CPU 内部的第二层缓存则使用静态随机访问内存（Static Random Access Memory, SRAM）。<br> BIOS(Basic Input Output System)是一套程序,这套程序是写死到主板上面的一个内存芯片中,这个内存芯片在没有通电时也能够将数据记录下来,那就是只读存储器(Read Only Memory,ROM)。<br> 显卡的规格有 PCI/AGP/PCe,目前的主流为 Pcle 接口。<br> 硬盘是由盘片、机械手臂、磁头与主轴马达所组成的,其中盘片的组成为扇区、磁道与柱面。<br> 操作系统( Operating System,Os)其实也是一组程序,这组程序的重点在于管理计算机的所有活动以及驱动系统中的所有硬件。<br> 计算机主要以二进制作为单位,常用的磁盘容量单位为 Byte,其单位换算为 1Byte=8bt<br> 操作系统仅在于驱动与管理硬件,而要使用硬件时,就得需要通过应用软件或者是 she 的功能,来调用操作系统操纵硬件工作。目前,操作系统除了上述功能外,通常已经包含了日常工作所需要的应用软件在内了。</p><h1 id="Linux是什么"><a href="#Linux是什么" class="headerlink" title="Linux是什么"></a>Linux是什么</h1><p>Linux 是 OS 内核，包含内核及工具，沿袭 Unix，提供了一个完整的 OS 中最底层的硬件控制与资源管理的完整架构。</p><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><ul><li>Bell 实验室开发 Multics 分时系统无果，Ken Thompson 用汇编语言编写内核程序 Unics，之后为了移植，改用 C 语言编写内核发性 UNIX 正式版本，强调多用户多任务的兼容分时系统。后来 AT&amp;T 收回 UNIX 源码版权，谭宁邦自主编写 Minix，用于教学，公开源码，付费发行。</li><li>史托曼为了创建一个自由开放的 UNIX 操作系统，开始 GNU 项目，成立自由软件基金会 FSF，合作之下完成 GNU C Compiler，撰写通用公共许可证 GPL（CopyLeft），1991 年，芬兰大学生 Linus Torvalds 宣称 LInux 内核程序可以在 Intel 386 上运行。</li><li>GNU：发布软件的同时公布源码。</li><li>GNU GPL：GPL 代表具有自由度的软件，用户可以自由执行、复制、再发行、学习、修改与强化，但不能取消 GPL 授权，软件是自由的，但软件相关的“服务”是可以商业的。Open Source 的好处即修改程序代码去适合的工作环境。</li></ul><h2 id="Linux的内核版本"><a href="#Linux的内核版本" class="headerlink" title="Linux的内核版本"></a>Linux的内核版本</h2><p><strong>主版本.次版本.释出版本-修改版本</strong></p><ul><li>次版本为奇数：开发中版本，内核工程师使用；</li><li>次版本为偶数：稳定版本，家庭计算机以及企业版本。</li><li>释出版本：主次版本不变情况下，新增功能累积到一定程度之后释出。</li><li>Linux 内核版本与 distibution 版本并不相同</li></ul><h2 id="Linux-distribution"><a href="#Linux-distribution" class="headerlink" title="Linux distribution"></a>Linux distribution</h2><p>Linux 是 kernel，GNU GPL 授权模式，参考 POSIX 设计规范（POSIX 即可携式操作系统接口，重点在于规范内核与应用程序之间的接口），兼容 UNIX 操作系统，即 UNIX Like。</p><ul><li>为了让用户能够接触到 Linux，于是很多的商业公司或非营利团体就将 Kernel+ Softwares+ Tools 集成起来，加上自己具有创意的工具程序,这个工具程序可以让用户以光盘、DvD 或者通过网络直接安装管理 Lnux 系统。称为 dLinux distribution。</li></ul><p><img src="/images/linux-vbird-0-3/linux_distribution.png" alt="linux_distribution.png"></p><ul><li>Linux standard Base(LsSB)等标准来规范开发者,以及目录架构的 Fle system Hierarchy Standard(FHS)标准规范，它们的唯一差别可能就是该开发者自家所开发出来的管理工具以及套件管理的模式。所以说，基本上，每个 Linux distributions 除了架构的严谨度与选择的套件内容外，其实差异并不太大，最大的差异在于软件的安装模式。</li><li>团队版适合个人（更新快），商业版适合服务器（稳定）。</li><li>事实上鸟哥认为 distributions 主要分为两大系统，一种是使用 RPM 方式安装软件的系统,包括 Red Hat， Fedora，SusE，Centos 等都是这类；一种则是使用 Debian 的 dpkg 方式安装软件的系统，包括 Debian，Ubuntu，B2D 等。</li></ul><h2 id="Linux的特色"><a href="#Linux的特色" class="headerlink" title="Linux的特色"></a>Linux的特色</h2><ul><li>稳定的系统</li><li>免费或少许费用</li><li>安全性、漏洞的快速修补</li><li>多任务、多用户</li><li>用户、用户组</li><li>相对不耗资源</li><li>需要小内核的嵌入式系统</li><li>整合度佳且多样的用户界面（GUI）</li></ul><h1 id="主机规划与磁盘分区"><a href="#主机规划与磁盘分区" class="headerlink" title="主机规划与磁盘分区"></a>主机规划与磁盘分区</h1><p>各个硬件设备在 linux 中当成一个文件来对待，几乎所有的硬件设备文件在/dev 目录里。<br>Windows 下不管有多少个 IDE 设备都是顺序地分配盘符，而在 Linux 下是认真区分对待每一个硬盘的。<br><em>（来自<a href="https://blog.csdn.net/weixin_32482133/article/details/112946362">https://blog.csdn.net/weixin_32482133/article/details/112946362</a>）</em></p><h2 id="磁盘连接的方式与设备文件名的关系"><a href="#磁盘连接的方式与设备文件名的关系" class="headerlink" title="磁盘连接的方式与设备文件名的关系"></a>磁盘连接的方式与设备文件名的关系</h2><table><thead><tr><th>接口</th><th>命名</th></tr></thead><tbody><tr><td>IDE 设备</td><td>/dev/hd[a-d]</td></tr><tr><td>SCSI/SATA/USB 硬盘</td><td>/dev/sd[a-p]</td></tr></tbody></table><h3 id="IDE设备"><a href="#IDE设备" class="headerlink" title="IDE设备"></a>IDE设备</h3><p>一个 IDE 扁平线缆可以连接两个 IDE 设备，通常主机会提供两个接口 IDE1（primary）和 IDE2（secondary），故可以连接四个 IDE 设备，每个扁平线缆上的 IDE 设备分为 Master/Slave。</p><table><thead><tr><th>IDE</th><th>Master</th><th>Slave</th></tr></thead><tbody><tr><td>IDE1（primary）</td><td>/dev/hda</td><td>/dev/hdb</td></tr><tr><td>IDE2（secondary）</td><td>/dev/hdc</td><td>/dev/hdd</td></tr></tbody></table><h3 id="SATA设备"><a href="#SATA设备" class="headerlink" title="SATA设备"></a>SATA设备</h3><p>SATA/SCSI/USB 等磁盘接口使用 SCSI 模块驱动，使用/dev/sd[a-p]格式，SATA/USB 接口的磁盘根本没有顺序，文件名由 Linux 内核检测到磁盘的顺序排列。</p><h2 id="磁盘的组成"><a href="#磁盘的组成" class="headerlink" title="磁盘的组成"></a>磁盘的组成</h2><p>磁盘的第一个扇区（512bytes）记录重要信息：</p><ul><li>主引导分区 MBR（446bytes）：安装引导加载程序的地方。系统开机时主动读取，系统知道程序存放位置和如何开机。</li><li>分区表（64bytes）：记录整块硬盘分区的状态。硬盘必须切割才能使用。</li></ul><p><img src="/images/linux-vbird-0-3/disk_constitute.png" alt="disk_constitute.png"></p><h2 id="磁盘分区表"><a href="#磁盘分区表" class="headerlink" title="磁盘分区表"></a>磁盘分区表</h2><p>分区的最小单位是柱面，参考柱面号码切割硬盘，在分区表所在的 64bytes 容量中，分为四组记录区，每组记录区记录了该区段的起始与结束的柱面号码。这四个分区称为主或扩展分区。</p><p><img src="/images/linux-vbird-0-3/disk_separate1.png" alt="disk_separate1.png"></p><p>系统写入磁盘时，一定会参考分区表。分区的目的：安全性与性能。<br>利用额外的（第一个扇区之外的）扇区记录更多的分区信息，扩展分区本身不能被格式化，主分区与逻辑分区可以。</p><p><img src="/images/linux-vbird-0-3/disk_separate2.png" alt="disk_separate2.png"></p><p>这五个由扩展分区切割的分区成为逻辑分区（5个），设备名从主分区保留之后开始。<br>    主分区+扩展分区≤4（硬盘限制）；<br>    扩展分区≤1（操作系统限制）。<br>    P主分区、E扩展分区、L逻辑分区。主分区和扩展分区之外的空间将被浪费。考虑到连续性，E分配在最后。分区&gt;4时，一定要有E。<br>    例如：在第二块SATA硬盘下分6个分区，有方法：</p><p><img src="/images/linux-vbird-0-3/disk_separate3.png" alt="disk_separate3.png"><br><img src="/images/linux-vbird-0-3/disk_separate4.png" alt="disk_separate4.png"></p><h2 id="开机流程与主引导分区MBR"><a href="#开机流程与主引导分区MBR" class="headerlink" title="开机流程与主引导分区MBR"></a>开机流程与主引导分区MBR</h2><h3 id="开机流程"><a href="#开机流程" class="headerlink" title="开机流程"></a>开机流程</h3><ol><li>BIOS：开机主动执行韧体 BIOS，寻找开机设备（根据用户设置的能开机的硬盘）</li><li>MBR：分析存储设备（如硬盘）第一个扇区的 MBR 位置，内置引导加载程序</li><li>引导加载程序 Boot Loader：加载内核</li><li>内核文件：OS 工作。</li></ol><p>BIOS 和 MBR 由硬件支持，BootLoader 由 OS 支持。</p><h3 id="BootLoader的功能"><a href="#BootLoader的功能" class="headerlink" title="BootLoader的功能"></a>BootLoader的功能</h3><ul><li><p>提供菜单：多重引导</p></li><li><p>载入内核：指向可开机的程序区段</p></li><li><p>转交其他 Loader（一个硬盘上包含多个系统，如双系统）</p><p>硬盘的每个分区都有自己的启动扇区，内核文件实际放置在各分区内，Loader 只认识自己分区的内核以及其他 Loader。</p></li></ul><p><img src="/images/linux-vbird-0-3/mbr.png" alt="mbr.png"></p><h2 id="磁盘分区的选择"><a href="#磁盘分区的选择" class="headerlink" title="磁盘分区的选择"></a>磁盘分区的选择</h2><p>Linux 所有数据以文件形态呈现，使用目录树结构，实际存放在磁盘分区中。</p><p>挂载：文件系统与目录树的关系</p><ul><li>将一个目录当作磁盘的入口，进入目录即可读取分区。即“挂载”与“挂载点”，最重要的根目录一定需要挂载到某分区。<br>（磁盘上有/file，挂载到/mnt 下，即访问路径/mnt/file）</li><li>安装 distribution，自定义安装 Custom 模式，建议仅区分主分区/和交换分区 swap（补充内存）。更详细的分区方案参考网络。</li></ul><h2 id="主机硬盘的主要规划"><a href="#主机硬盘的主要规划" class="headerlink" title="主机硬盘的主要规划"></a>主机硬盘的主要规划</h2><p>  主机硬盘的需求和主机开放的服务有关，还需要注意数据分类和安全。</p><p>  最简单的的分区方法<br>  / &amp; swap &amp; 未分区</p><p>  根据用途：</p><p>  容量大且读写频繁的目录：/ /usr /home /var swap<br>  大硬盘配合旧主机造成无法开机的问题<br>  旧主板找不到大容量磁盘，导致误判，但是 Linux 内核顺利开机后会重新检测硬盘而不例会 BIOS，所以 Linux 能够安装。<br>  但是安装完毕无法开机，BIOS 不能正确识别硬盘，开机错误。BIOS 只能读取前面的扇区，故将启动扇区所在分区规范在 ≤1024 个柱面以内。<br>  分区/boot &amp; / &amp; swap，/boot 100MB 左右，放在硬盘最前面。</p><h1 id="安装CentOS-5-x与多重引导"><a href="#安装CentOS-5-x与多重引导" class="headerlink" title="安装CentOS 5.x与多重引导"></a>安装CentOS 5.x与多重引导</h1><h2 id="安装规划"><a href="#安装规划" class="headerlink" title="安装规划"></a>安装规划</h2><ul><li>Linux主机的角色定位</li><li>选择distribution</li><li>计算机硬件配置</li><li>磁盘分区配置：/boot&amp;/&amp;/home&amp;swap  PPPL</li><li>引导装载程序BootLoader：安装到MBR</li><li>选择软件：默认/最小/全部/自定义</li></ul><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol><li>调整启动媒体(BIOS):使用Linux安装光盘，调整BIOS的开机启动顺序为光盘；（无法以DVD开机时很可能是由于计算机硬件不支持、光驱会挑片、光盘问题、硬件超频等）</li><li>选择安装结构与开机:包括图形界面命令行界面等，也可加入特殊参数（硬件检测、安装媒体、内存测试）来开机进入安装界面；</li><li>选择语系数据:由于不同地区的键盘按键不同，此时需要调整语系/键盘/鼠标等配置；</li><li>磁盘分区:最重要的项目之一。提前规划。</li></ol><p>四种分区结构：</p><ul><li>整块硬盘：删除所有分区并创建默认分区结构</li><li>Linux分区：删除Linux分区并创建默认分区</li><li>选定驱动器的空闲空间：未分区空间</li><li>建立自定义分区结构</li></ul><p>Linux支持的文件系统类型：<br><em>（二三版书上介绍有差别）</em><br>ext2/ext3：Linux使用的文件系统类型，ext3/ext4比ext2多日志记录，恢复系统较为迅速</p><ol start="5"><li>引导装载程序、网络、时区设置与root密码:一些需要的系统基础设置!</li><li>软件选择:需要什么样的软件?全部安装还是默认安装即可?</li><li>安装后的首次设置:安装完毕后还有一些事项要处理,包括用户、 SELinux与防火墙等</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;基础篇第 0-3 章学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="Study" scheme="https://memorykk.cn/categories/Study/"/>
    
    
    <category term="linux" scheme="https://memorykk.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>记一次使用Github登录Gitalk跳至首页的解决过程</title>
    <link href="https://memorykk.cn/gitalk-405.html"/>
    <id>https://memorykk.cn/gitalk-405.html</id>
    <published>2021-02-19T08:45:48.000Z</published>
    <updated>2021-02-19T11:41:54.450Z</updated>
    
    <content type="html"><![CDATA[<p>使用自定义域名之后的 Github page 在使用 Github 登录 Github 时跳转首页，无限循环</p><span id="more"></span><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>博客使用的是Hexo+Github+Gitalk，使用 Github 登录 Gitalk 之后跳转至首页，无限循环，地址栏URL显示为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;memorykk.cn&#x2F;?error&#x3D;redirect_uri_mismatch&amp;error_description&#x3D;The+redirect_uri+MUST+match+the+registered+callback+URL+for+this+application.&amp;error_uri&#x3D;https%3A%2F%2Fdocs.github.com%2Fapps%2Fmanaging-oauth-apps%2Ftroubleshooting-authorization-request-errors%2F%23redirect-uri-mismatch</span><br></pre></td></tr></table></figure><h1 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h1><p>为了更清楚地检查，将此 URL 中的 Unicode 转为中文：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;memorykk.cn&#x2F;?</span><br><span class="line">error&#x3D;redirect_uri_mismatch&amp;</span><br><span class="line">error_description&#x3D;The+redirect_uri+MUST+match+the+registered+callback+URL+for+this+application.&amp;</span><br><span class="line">error_uri&#x3D;https:&#x2F;&#x2F;docs.github.com&#x2F;apps&#x2F;managing-oauth-apps&#x2F;troubleshooting-authorization-request-errors&#x2F;#redirect-uri-mismatch</span><br></pre></td></tr></table></figure><p>根据描述，<kbd>redirect error</kbd> <kbd>registered callback URL</kbd>不匹配。</p><p>打开<kbd>F12</kbd>查看<kbd>Network</kbd>：</p><p><img src="/images/gitalk-405/reirect_uri.png" alt="reirect_uri.png"></p><p><kbd>this application</kbd>我使用的是<kbd>OAuth Apps</kbd>，查看其Authorization callback URL，果不其然：</p><p><img src="/images/gitalk-405/Auth_callback_URL.png" alt="Auth_callback_URL.png"></p><p><code>http</code>和<code>https</code>的差别还是很大的！修改Authorization callback URL为<code>https</code>之后成功了。</p><p>点击<kbd>使用GitHub登录</kbd>之后，又出现 405 问题，<br><img src="/images/gitalk-405/405.png" alt="405.png"><br>打开<kbd>F12</kbd>查看<kbd>Network</kbd>：<br><img src="/images/gitalk-405/url1.png" alt="url1.png"><br>转换为中文：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Request URL: https:&#x2F;&#x2F;memorykk.cn&#x2F;TeamSpeak&#x2F;%7B%7B%20theme.gitalk.proxy%20%7D%7D</span><br><span class="line"></span><br><span class="line">Request URL: https:&#x2F;&#x2F;memorykk.cn&#x2F;TeamSpeak&#x2F;&#123;&#123; theme.gitalk.proxy &#125;&#125;</span><br></pre></td></tr></table></figure><p>好家伙，这还是源代码形式啊，坑定是后台有什么问题！<br>检查<kbd>theme\layout\components\comment.ejs</kbd>，这行代码果然是从这里出来的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var gitalk &#x3D; new Gitalk(&#123;</span><br><span class="line">clientID: &#39;&lt;%&#x3D; theme.gitalk_client_id %&gt;&#39;,</span><br><span class="line">clientSecret: &#39;&lt;%&#x3D; theme.gitalk_client_secret %&gt;&#39;,</span><br><span class="line">repo: &#39;&lt;%&#x3D; theme.gitalk_repo %&gt;&#39;,</span><br><span class="line">owner: &#39;&lt;%&#x3D; theme.gitalk_owner %&gt;&#39;,</span><br><span class="line">admin: [&#39;&lt;%- theme.gitalk_admin.join(&quot;&#39;, &#39;&quot;) %&gt;&#39;],</span><br><span class="line">id: location.pathname,</span><br><span class="line">distractionFreeMode: false,</span><br><span class="line">createIssueManually: true,</span><br><span class="line">proxy: &#39;&#123;&#123; theme.gitalk.proxy &#125;&#125;&#39;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>之前对node.js也不了解（虽然现在也一样，允悲），没注意格式。仿照上面几行代码改成：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy: &#39;&lt;%&#x3D; theme.gitalk.proxy %&gt;&#39;,</span><br></pre></td></tr></table></figure><p>还是报 405 错误，打开<kbd>F12</kbd>查看：<br><img src="/images/gitalk-405/405_2.png" alt="405_2.png"></p><p>总感觉之前白嫖的 CorsAnywhere Proxy 链接压根没有传递过去，直接手动写死在里面：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy: &#39;https:&#x2F;&#x2F;netnr-proxy.cloudno.de&#x2F;https:&#x2F;&#x2F;github.com&#x2F;login&#x2F;oauth&#x2F;access_token&#39;,</span><br></pre></td></tr></table></figure><p>好家伙，成功了，ohhhhhhhhhhh，虽然这种做法极不优雅！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>网页出错先用<kbd>F12</kbd>看看哪部分的问题，顺藤摸瓜，缩小范围。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用自定义域名之后的 Github page 在使用 Github 登录 Github 时跳转首页，无限循环&lt;/p&gt;</summary>
    
    
    
    <category term="Log" scheme="https://memorykk.cn/categories/Log/"/>
    
    
    <category term="Gitalk" scheme="https://memorykk.cn/tags/Gitalk/"/>
    
  </entry>
  
  <entry>
    <title>TeamSpeak</title>
    <link href="https://memorykk.cn/TeamSpeak.html"/>
    <id>https://memorykk.cn/TeamSpeak.html</id>
    <published>2021-02-19T06:22:14.000Z</published>
    <updated>2021-03-12T05:08:52.944Z</updated>
    
    <content type="html"><![CDATA[<p>一个简易的TeamSpeak使用教程</p><span id="more"></span><p>更新于2021-02-19 14:22:14：<br>旧地址<del>memorykk.cn</del>已不可用，为了您后续的正常使用，请使用新地址<text style="color:white;background-color:red">ts.memorykk.cn</text></p><p><img src="/images/TeamSpeak/address.png" alt="address.png"></p><hr><p>更新于2020/5/22 15:30：</p><p>根据 @洛杉矶湖人名宿孙悦 ​的提醒，<text style="color:red">不推荐下载ts1.cn的盗版客户端，也不推荐俱乐部或者各位玩家租用ts1.cn的盗版服务器。</text>具体可<a href="https://bbs.hupu.com/32525047.html">查看原帖</a>，所以希望大家去官网下载正版软件，如果官网或github下载太慢，可以点正文中转存的链接，都是一样的。</p><hr><p>去年自己搭建了一个TeamSpeak服务器，闲着也是闲着，分享出来给大家使用，市面上的服务器要么收费、要么音质权限不给，本服务器免费共享，合法合规，不涉及隐私信息等，请放心使用！</p><h1 id="什么是TeamSpeak"><a href="#什么是TeamSpeak" class="headerlink" title="什么是TeamSpeak"></a>什么是TeamSpeak</h1><blockquote><p>TeamSpeak (简称TS) 是一套专有的VoIP软件，使用者可以用耳机和麦克风，通过客户端软件连线到指定的服务器，与在服务器内频道的其他使用者进行通话。是一种很像电话会议的方式。 通常 TeamSpeak 的使用者大多为多人连线游戏的玩家，与同队伍的玩家进行通讯。在游戏的对战方面，语音对话通讯具有竞争优势。</p></blockquote><p>简言之，TeamSpeak是一款非常优秀的语音软件，类似于国内的YY语音、TT语音等，PUBG、CSGO等项目职业选手都在使用，在和小伙伴激情上分时，你该不会还在使用QQ微信电话吧？那么TS优点在哪里呢？有几点：</p><ul><li>界面简洁，没有广告，没有花里胡哨的付费内容；</li><li>极高的音乐级音质，超低的延迟；</li><li>独有的麦克风降噪、键盘声衰减、回声消除；</li><li>自动感应麦真的很好用。</li></ul><h1 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h1><ol><li>下载TeamSpeak客户端（最新版本为3.5.6）</li></ol><ul><li><a href="https://teamspeak.com/zh-CN/downloads/#client">官网下载</a></li><li>转存下载：（文件和官网一样，解决下载过慢问题）<ul><li><a href="https://wwa.lanzous.com/izgdukunldc">WINDOWS CLIENT 32-BIT 3.5.6</a></li><li><a href="https://wwa.lanzous.com/iQ78Wkun8ab">WINDOWS CLIENT 64-BIT 3.5.6</a></li><li><a href="https://memorykk.cn/src/TeamSpeak3-Client-macosx-3.5.6.dmg">MACOS CLIENT UNIVERSAL BINARY 3.5.6</a></li><li><a href="https://memorykk.cn/src/TeamSpeak3-Client-linux_x86-3.5.6.run">LINUX CLIENT 32-BIT 3.5.6</a></li><li><a href="https://memorykk.cn/src/TeamSpeak3-Client-linux_amd64-3.5.6.run">LINUX CLIENT 64-BIT 3.5.6</a></li></ul></li><li><a href="https://wwa.lanzous.com/icw5xgd">下载中文语音包&amp;语言包</a></li></ul><ol start="2"><li>安装客户端和中文包</li></ol><p>默认“下一步”就完事了，打开如下：</p><p><img src="/images/TeamSpeak/2-1.png" alt="2-1.png"><br><img src="/images/TeamSpeak/2-2.png" alt="2-2.png"></p><ol start="3"><li>注册登录你的TS账号（跳过这一步也可以）</li></ol><p>安装软件后会弹出来，没弹出来可以依次点击 <kbd>工具</kbd>-&gt;<kbd>选项</kbd>-&gt;<kbd>myTeamSpeak​</kbd> 继续操作。</p><p><img src="/images/TeamSpeak/3.png" alt="3.png"></p><ol start="4"><li>设置语音输入方式</li></ol><p>依次点击 <kbd>工具</kbd>-&gt;<kbd>选项</kbd>-&gt;<kbd>输入</kbd> 建议设置如下：</p><p><img src="/images/TeamSpeak/4.png" alt="4.png"></p><p>语音输入方式：</p><ul><li>Automatic：自动感应麦</li><li>Volume Gate：自定义麦克风的收音敏感度，点“开始测试”，比最高的分贝低一点就可以了</li><li>Hybrid：不懂，没用过</li></ul><ol start="5"><li>连接服务器</li></ol><p>依次点击左上角 <kbd>连接</kbd>-&gt;<kbd>连接</kbd>-&gt;输入服务器地址（<strong>ts.memorykk.cn</strong>）和昵称，无密码，直接点击连接，自动进入大厅。</p><p><img src="/images/TeamSpeak/5.png" alt="5.png"></p><ol start="6"><li>开房间</li></ol><p>空白处右键单击“创建频道”，设置房间名，有需要的可以设置密码，点击确定，房间开好了，双击房间名即可进入，这时候你就可以让你的小伙伴直接进入你的房间就完事了。</p><p><img src="/images/TeamSpeak/6-1.png" alt="6-1.png"><br><img src="/images/TeamSpeak/6-2.png" alt="6-2.png"></p><p><strong>注意</strong>：创建频道如果选择临时，当频道最后一人离开时，频道会自动消失。</p><p><strong>注意</strong>：可以设置频道音质，右键单击频道-&gt;声音-&gt;拖到质量条。</p><p>最后，有问题到下方留言或是查看<a href="https://memorykk.cn/about/">联系方式</a>，希望大家玩得开心。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个简易的TeamSpeak使用教程&lt;/p&gt;</summary>
    
    
    
    <category term="Tool" scheme="https://memorykk.cn/categories/Tool/"/>
    
    
    <category term="TeamSpeak" scheme="https://memorykk.cn/tags/TeamSpeak/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="https://memorykk.cn/Git.html"/>
    <id>https://memorykk.cn/Git.html</id>
    <published>2021-02-15T02:49:13.000Z</published>
    <updated>2021-02-18T14:26:23.672Z</updated>
    
    <content type="html"><![CDATA[<p>Git是目前世界上最先进的分布式版本控制系统（没有之一）。</p><span id="more"></span><hr><p><strong>目录</strong></p><ul><li><a href="#%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6">版本控制</a></li><li><a href="#%E5%AE%89%E8%A3%85git">安装Git</a><ul><li><a href="#linux">Linux</a></li><li><a href="#linux-1">Linux</a><ul><li><a href="#debianubuntu">Debian/Ubuntu</a></li><li><a href="#centosredhat">Centos/RedHat</a></li></ul></li><li><a href="#windows">Windows</a></li></ul></li><li><a href="#%E9%85%8D%E7%BD%AEgit">配置Git</a><ul><li><a href="#%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8Cemail">配置用户名和Email</a></li><li><a href="#%E5%A2%9E%E5%88%A0%E9%85%8D%E7%BD%AE%E9%A1%B9">增删配置项</a><ul><li><a href="#%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE%E9%A1%B9">添加配置项</a></li><li><a href="#%E5%88%A0%E9%99%A4%E9%85%8D%E7%BD%AE%E9%A1%B9">删除配置项</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E9%85%8D%E7%BD%AE%E9%A1%B9">更多配置项</a></li></ul></li><li><a href="#git%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">Git基本概念</a></li><li><a href="#git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">Git工作流程</a></li><li><a href="#git%E6%93%8D%E4%BD%9C">Git操作</a><ul><li><a href="#git%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93">Git创建版本库</a><ul><li><a href="#%E5%9C%A8%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%96">在工作目录中初始化</a></li><li><a href="#%E4%BB%8E%E7%8E%B0%E6%9C%89%E4%BB%93%E5%BA%93%E5%85%8B%E9%9A%86">从现有仓库克隆</a></li></ul></li><li><a href="#%E6%96%87%E4%BB%B6%E6%9B%B4%E6%96%B0">文件更新</a><ul><li><a href="#%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81">文件状态</a></li><li><a href="#%E6%A3%80%E6%9F%A5%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81">检查文件状态</a></li><li><a href="#%E8%B7%9F%E8%B8%AA%E6%96%87%E4%BB%B6">跟踪文件</a></li><li><a href="#%E6%9A%82%E5%AD%98%E5%B7%B2%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6">暂存已修改文件</a></li><li><a href="#%E5%BF%BD%E7%95%A5%E6%9F%90%E4%BA%9B%E6%96%87%E4%BB%B6">忽略某些文件</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E6%9C%AA%E6%9A%82%E5%AD%98%E7%9A%84%E6%9B%B4%E6%96%B0">查看未暂存的更新</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E5%B7%B2%E6%9A%82%E5%AD%98%E7%9A%84%E6%9B%B4%E6%96%B0">查看已暂存的更新</a></li><li><a href="#%E6%8F%90%E4%BA%A4%E6%9B%B4%E6%96%B0">提交更新</a></li><li><a href="#%E8%B7%B3%E8%BF%87%E4%BD%BF%E7%94%A8%E6%9A%82%E5%AD%98%E5%8C%BA%E5%9F%9F">跳过使用暂存区域</a></li><li><a href="#%E7%A7%BB%E9%99%A4%E6%96%87%E4%BB%B6">移除文件</a></li><li><a href="#%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6">移动文件</a></li></ul></li><li><a href="#%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2">查看提交历史</a><ul><li><a href="#%E9%99%90%E5%88%B6%E8%BE%93%E5%87%BA%E9%95%BF%E5%BA%A6">限制输出长度</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%B7%A5%E5%85%B7%E6%9F%A5%E9%98%85%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2">使用图形化工具查阅提交历史</a></li></ul></li><li><a href="#%E6%92%A4%E9%94%80">撤销</a><ul><li><a href="#%E4%BF%AE%E6%94%B9%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E6%8F%90%E4%BA%A4">修改最后一次提交</a></li><li><a href="#%E5%8F%96%E6%B6%88%E5%B7%B2%E7%BB%8F%E6%9A%82%E5%AD%98%E7%9A%84%E6%96%87%E4%BB%B6">取消已经暂存的文件</a></li><li><a href="#%E5%8F%96%E6%B6%88%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%AE%E6%94%B9">取消对文件的修改</a></li><li><a href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93">文件操作总结</a></li></ul></li></ul></li><li><a href="#git%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">Git远程仓库</a><ul><li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">查看远程仓库</a></li><li><a href="#%E6%B7%BB%E5%8A%A0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">添加远程仓库</a></li><li><a href="#%E4%BB%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E6%8A%93%E5%8F%96%E6%95%B0%E6%8D%AE">从远程仓库抓取数据</a></li><li><a href="#%E6%8E%A8%E9%80%81%E6%95%B0%E6%8D%AE%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">推送数据到远程仓库</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%BF%A1%E6%81%AF">查看远程仓库信息</a></li><li><a href="#%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E5%88%A0%E9%99%A4%E5%92%8C%E9%87%8D%E5%91%BD%E5%90%8D">远程仓库的删除和重命名</a><ul><li><a href="#%E9%87%8D%E5%91%BD%E5%90%8D">重命名</a></li><li><a href="#%E5%88%A0%E9%99%A4">删除</a></li></ul></li></ul></li><li><a href="#%E7%89%88%E6%9C%AC%E6%A0%87%E7%AD%BE">版本标签</a><ul><li><a href="#%E6%98%BE%E7%A4%BA%E5%B7%B2%E6%9C%89%E6%A0%87%E7%AD%BE">显示已有标签</a></li><li><a href="#%E6%96%B0%E5%BB%BA%E6%A0%87%E7%AD%BE">新建标签</a><ul><li><a href="#%E5%90%AB%E9%99%84%E6%B3%A8%E7%9A%84%E6%A0%87%E7%AD%BE">含附注的标签</a></li><li><a href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%A0%87%E7%AD%BE">轻量级标签</a></li><li><a href="#%E7%AD%BE%E7%BD%B2%E6%A0%87%E7%AD%BE">签署标签</a></li><li><a href="#%E9%AA%8C%E8%AF%81%E6%A0%87%E7%AD%BE">验证标签</a></li></ul></li><li><a href="#%E5%90%8E%E6%9C%9F%E5%8A%A0%E6%B3%A8%E6%A0%87%E7%AD%BE">后期加注标签</a></li><li><a href="#%E5%88%86%E4%BA%AB%E6%A0%87%E7%AD%BE">分享标签</a></li></ul></li><li><a href="#git%E5%88%86%E6%94%AF">Git分支</a><ul><li><a href="#%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B">分支简介</a></li><li><a href="#%E6%96%B0%E5%BB%BA%E5%88%86%E6%94%AF">新建分支</a></li><li><a href="#head">HEAD</a></li><li><a href="#%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF">切换分支</a></li><li><a href="#%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF">合并分支</a></li><li><a href="#%E9%81%87%E5%88%B0%E5%86%B2%E7%AA%81%E6%97%B6%E7%9A%84%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6">遇到冲突时的分支合并</a></li><li><a href="#%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF">删除分支</a></li><li><a href="#%E6%A1%88%E4%BE%8B">案例</a></li><li><a href="#%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86">分支管理</a></li><li><a href="#%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">远程分支</a></li><li><a href="#%E6%8E%A8%E9%80%81%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF">推送本地分支</a></li><li><a href="#%E8%B7%9F%E8%B8%AA%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">跟踪远程分支</a></li><li><a href="#%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">删除远程分支</a></li><li><a href="#%E5%88%86%E6%94%AF%E8%A1%8D%E5%90%88">分支衍合</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li></ul><hr><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。最初由 Linus Torvalds 为了帮助管理 Linux 内核开发而花了两周时间自己用C写出来的。（理那厮·掏袜子真的太绝了⊙ｏ⊙）</p><h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p>版本控制系统分为本地式、集中式和分布式。</p><ul><li><p>本地式：适合个人使用，用于记录文件更新。代表：RCS</p><img src="/images/Git/local.png" class=""></li><li><p>集中式：必须联网，断网后可编辑无法commit和回滚。版本库都存在中央服务器上，用户的本地只有自己以前所同步的版本，没有完整的版本库。代表：SVN、CVS、VSS。<br>假设SVN服务器没了，那你丢掉了所有历史信息，因为你的本地只有当前版本以及部分历史信息。</p><img src="/images/Git/centralization.png" class=""></li><li><p>分布式：只有在push、pull时需要联网，断网后可正常commit。中央服务器只为了修改起来方便，可有可无，每个用户本地都是一个完整的版本库。代表：Git。<br>每个人都同时对同一版本修改，commit操作提交到本地，多人协作时需要push操作和别人同步，但是团队人数多会导致非常麻烦，所以出现所谓的（便于修改的）中央服务器。<br>假设GitHub服务器没了，你不会丢掉任何git历史信息，因为你的本地有完整的版本库信息，你可以把本地的git库重新上传到另外的git服务商。 </p><img src="/images/Git/distributed.png" class=""></li></ul><p><strong>Git的特点</strong></p><ul><li><p>直接记录快照，而非差异比较<br>Git 只关心文件数据的<strong>整体</strong>是否发生变化，而大多数其他系统则只关心文件内容的具体差异。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。有变化则保存，无则链接。</p></li><li><p>近乎所有操作都是本地执行</p></li><li><p>时刻保持数据完整性<br>保存在 Git 数据库中的东西都是用此哈希值来作索引的，而不是靠文件名。</p></li><li><p>多数操作仅添加数据</p></li></ul><h1 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h1><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。<br><code>yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel</code><br>或<br><code>$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev</code><br>下载源码：<a href="http://git-scm.com/download">http://git-scm.com/download</a><br>编译安装<br><code>$ tar -zxf git-1.7.2.2.tar.gz</code><br><code>$ cd git-1.7.2.2</code><br><code>$ make prefix=/usr/local all</code><br><code>$ sudo make prefix=/usr/local install</code></p><h2 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h2><h3 id="Debian-Ubuntu"><a href="#Debian-Ubuntu" class="headerlink" title="Debian/Ubuntu"></a>Debian/Ubuntu</h3><p><code>$ sudo apt-get install git</code></p><h3 id="Centos-RedHat"><a href="#Centos-RedHat" class="headerlink" title="Centos/RedHat"></a>Centos/RedHat</h3><p><code>$ yum install git-core</code></p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p><a href="https://git-scm.com/downloads">官网下载</a><br><a href="https://npm.taobao.org/mirrors/git-for-windows/">镜像下载</a><br>默认安装。</p><img src="/images/Git/winGit.PNG" class=""><ul><li><kbd>Git Bash</kbd>：Unix与Linux风格的命令行（<strong>推荐</strong>）</li><li><kbd>Git CMD</kbd>：DOS风格的命令</li><li><kbd>Git GUI</kbd>：图形界面（<strong>新手不推荐</strong>）  </li></ul><p>打开<kbd>Git Bash</kbd>检查一下：  </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git --version</span></span><br><span class="line">git version 2.29.2.windows.2</span><br></pre></td></tr></table></figure><h1 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h1><h2 id="配置用户名和Email"><a href="#配置用户名和Email" class="headerlink" title="配置用户名和Email"></a>配置用户名和Email</h2><p>信息将会嵌入你的每次提交中。</p><p><strong>配置级别</strong>  </p><ul><li>系统级<kbd>--system</kbd>：系统中所有用户适用的配置<ul><li>Linux：/etc/gitconfig</li><li>Windows：Git/mingw64/etc/gitconfig</li></ul></li><li>用户级<kbd>--global</kbd>：当前用户适用的配置<ul><li>Linux：~/.gitconfig</li><li>Windows：C:/Users/Administrator/.gitconfig</li></ul></li><li>项目级<kbd>--local</kbd>：特定项目适用的配置<ul><li>Linux：gitProject/.gitconfig</li><li>Windows：gitProject/.gitconfig</li></ul></li></ul><p>低级覆盖高级：<strong>local&lt;globall&lt;system</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">&quot;Your Name&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">&quot;Your Email&quot;</span></span></span><br></pre></td></tr></table></figure><p>如果用了<kbd>--global</kbd>选项，所有项目都会默认使用这个全局配置，不加则为某个特定的项目信息。</p><h2 id="增删配置项"><a href="#增删配置项" class="headerlink" title="增删配置项"></a>增删配置项</h2><h3 id="添加配置项"><a href="#添加配置项" class="headerlink" title="添加配置项"></a>添加配置项</h3><p><code>git config [--local|--global|--system]  section.key value</code></p><p>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">51139@DESKTOP MINGW64 /e/blog</span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global Student.number 2018000001</span></span><br><span class="line">51139@DESKTOP MINGW64 /e/blog</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat C:/Users/51139/.gitconfig</span></span><br><span class="line">[user]</span><br><span class="line">        name = memorykkk</span><br><span class="line">        email = 511390937@qq.com</span><br><span class="line">[Student]</span><br><span class="line">        number = 2018000001</span><br></pre></td></tr></table></figure><h3 id="删除配置项"><a href="#删除配置项" class="headerlink" title="删除配置项"></a>删除配置项</h3><p><code>git config [--local|--global|--system] --unset section.key</code></p><h2 id="更多配置项"><a href="#更多配置项" class="headerlink" title="更多配置项"></a>更多配置项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config -l, --list     #list all    列出所有</span><br><span class="line">git config -e, --edit     #open an editor    打开一个编辑器</span><br><span class="line">git config --global color.ui true   #打开所有的默认终端着色</span><br><span class="line">git config --global alias.ci commit   #别名 ci 是commit的别名</span><br><span class="line">user.name  #用户名</span><br><span class="line">user.email  #邮箱</span><br><span class="line">core.editor  #文本编辑器  </span><br><span class="line">merge.tool  #差异分析工具  </span><br><span class="line">core.paper &quot;less -N&quot;  #配置显示方式  </span><br><span class="line">color.diff true  #diff颜色配置  </span><br><span class="line">alias.co checkout  #设置别名</span><br><span class="line">git config user.name  #获得用户名</span><br><span class="line">git config core.filemode false  #忽略修改权限的文件 </span><br></pre></td></tr></table></figure><p>学习<kbd>config</kbd>命令，运行  <code>$ git help config</code></p><p>查看手册 <a href="https://git-scm.com/docs/git-config">git config</a></p><h1 id="Git基本概念"><a href="#Git基本概念" class="headerlink" title="Git基本概念"></a>Git基本概念</h1><ol><li>Git本地有三个工作区域：<strong>工作区</strong>（Workspace）、<strong>暂存区</strong>（Index/Stage）、<strong>仓库</strong>（Repository），加上<strong>远程仓库</strong>（Remote）共四个工作区域。</li></ol><p>Git 各个命令可以理解为在各个仓库间转移数据，各个命令对应对每个仓库输入输出。</p><ul><li>Workspace：工作区，平时能看到的存放项目代码的地方</li><li>Index / Stage：暂存区，临时存放改动，保存即将提交到文件列表信息的文件，有时也叫作索引</li><li>Repository：仓库区（或本地仓库），安全存放数据的位置，含所有版本的数据，HEAD指向最新版本</li><li>Remote：远程仓库，托管代码的服务器，用于远程数据交换</li></ul><ol start="2"><li>对于本地三个区域的关系如下：<br><img src="/images/Git/local_relation.png" alt="local_relation"></li></ol><ul><li><p>Directory：使用Git管理的仓库，包含我们的工作空间和Git的管理空间</p></li><li><p>WorkSpace：需要通过Git进行版本控制的目录和文件组成工作空间</p></li><li><p>.git：存放Git管理信息的目录，初始化仓库的时候自动创建</p></li><li><p>Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前存放所有的更新</p></li><li><p>Local Repo：本地仓库，HEAD会只是当前的开发分支（branch）。</p></li><li><p>Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。<br>观察命令对各区域的影响：<br><img src="/images/Git/git_theory.jpg" alt="git_theory"></p></li><li><p>master 是 master 分支所代表的目录树，此时 HEAD 实际是指向 master 分支的一个”游标”，objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。</p></li><li><p>当对工作区修改（或新增）的文件执行 <kbd>git add</kbd> 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</p></li><li><p>当执行提交操作 <kbd>git commit</kbd>时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</p></li><li><p>当执行 <kbd>git reset HEAD</kbd> 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</p></li><li><p>当执行 <kbd>git rm --cached &lt;file></kbd> 命令时，会直接从暂存区删除文件，工作区则不做出改变。</p></li><li><p>当执行 <kbd>git checkout .</kbd> 或者 <kbd>git checkout -- &lt;file></kbd> 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</p></li><li><p>当执行 <kbd>git checkout HEAD .</kbd> 或者 <kbd>git checkout HEAD &lt;file></kbd> 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</p></li></ul><ol start="3"><li>若对四个区域分级：workspace &lt; index &lt; repository &lt; remote，基本的转移如下表，参数和选项决定数据来源。</li></ol><table><thead><tr><th></th><th>低等级输入</th><th>高等级输入</th></tr></thead><tbody><tr><td>workspace</td><td>手动</td><td>git checkout/git stash</td></tr><tr><td>index/stage</td><td>git add</td><td>git reset</td></tr><tr><td>repository</td><td>git commit</td><td>git pull</td></tr><tr><td>remote</td><td>git push</td><td>-</td></tr></tbody></table><p>四个区域转换关系如下：<br><img src="/images/Git/git_transition.png" alt="git_transition"></p><h1 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h1><p>一般工作流程如下：</p><ul><li>在工作目录中修改某些文件。</li><li>对修改后的文件进行快照，然后保存到暂存区域。</li><li>提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。</li></ul><p><img src="/images/Git/git-process-img.png" alt="git-process"></p><h1 id="Git操作"><a href="#Git操作" class="headerlink" title="Git操作"></a>Git操作</h1><h2 id="Git创建版本库"><a href="#Git创建版本库" class="headerlink" title="Git创建版本库"></a>Git创建版本库</h2><ul><li>在工作目录中初始化新仓库</li><li>从现有仓库克隆</li></ul><h3 id="在工作目录中初始化"><a href="#在工作目录中初始化" class="headerlink" title="在工作目录中初始化"></a>在工作目录中初始化</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure><p>在新建空目录或已有目录中，使用命令 <code>git init</code> 初始化一个新仓库。初始化后该目录下自动生成<kbd>.git</kbd>目录，用于生成所有 Git 需要的数据和资源。</p><p><strong>文件加入版本库</strong><br>将文件添加到仓库（workspace -&gt; stage）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add &lt;file&gt;</span></span><br></pre></td></tr></table></figure><p>执行后没有任何信息则代表执行成功。</p><p>将文件提交到仓库（stage -&gt; repository）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m &lt;message&gt;</span></span><br></pre></td></tr></table></figure><p>多次<kbd>add</kbd>不同的文件，但只需一次<kbd>commit</kbd>就可以提交。</p><h3 id="从现有仓库克隆"><a href="#从现有仓库克隆" class="headerlink" title="从现有仓库克隆"></a>从现有仓库克隆</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> &lt;url&gt; &lt;newName&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Git 收取的是项目历史的完整数据（每一个文件的每一个版本），而不是某个特定版本，服务器上有的数据克隆之后本地也都有了。  </li><li><kbd>url</kbd> 支持 git 协议或 SSH 传输协议。通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。  </li><li>克隆之后的目录名为 url 中 .git 前的名称，通过 <kbd>&lt;newName></kbd> 可以自定义。目录中包含<kbd>.git</kbd>目录，用于保存下载下来的所有版本记录，然后从中取出最新版本的文件拷贝。</li></ul><h2 id="文件更新"><a href="#文件更新" class="headerlink" title="文件更新"></a>文件更新</h2><h3 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h3><p>文件状态主要分两种，已跟踪（tracked）即本来就被纳入版本控制管理的文件，其它文件即未跟踪（untracked）。</p><ul><li>Untracked：未跟踪，此文件没有加入到git库，不参与版本控制。通过 <code>git add</code> 状态变为staged</li><li>Unmodify：文件已经入库，未修改，即版本库中的文件快照内容与文件夹中完全一致。这种文件被修改成为Modified，通过<code>git rm</code>移出版本库成为Untracked</li><li>Modified：文件已修改。这种文件通过<code>git add</code>可变成staged，通过<code>git checkout</code>则丢弃修改回到unmodify</li><li>Staged：暂存状态。通过<code>git commit</code>则将修改同步到库中，这时库中的文件和本地文件又变为一致，变为Unmodify状态。执行<code>git reset HEAD &lt;filename&gt;</code>取消暂存，变为Modified</li></ul><p>初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改（unmodified）。<br>文件状态变化周期：<br><img src="/images/Git/file-status.png" alt="file-status"></p><p>修改后的文件状态是 modified，逐步放在暂存区域，最后一次性提交。</p><h3 id="检查文件状态"><a href="#检查文件状态" class="headerlink" title="检查文件状态"></a>检查文件状态</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看指定文件状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status &lt;filename&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看所有文件状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br></pre></td></tr></table></figure><p>例如创建README之后：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim README</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Untracked files:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># README</span></span></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><p>表示当前处在<kbd>master</kbd>分支，未跟踪文件里包含 README，即 Git 之前的快照中没有这个文件，未纳入管理。</p><h3 id="跟踪文件"><a href="#跟踪文件" class="headerlink" title="跟踪文件"></a>跟踪文件</h3><p>（workspace -&gt; stage；untracked -&gt; staged）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加指定文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add &lt;file1&gt; &lt;file2&gt; ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加指定目录到暂存区，包括子目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add &lt;dir&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加当前目录的所有文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add README</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">    # On branch master</span><br><span class="line">    # Changes to be committed:</span><br><span class="line">    # (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">    #</span><br><span class="line">    # new file: README</span><br><span class="line">    #</span><br></pre></td></tr></table></figure><p>“Changes to be committed:” 表示其下的文件处于暂存区</p><h3 id="暂存已修改文件"><a href="#暂存已修改文件" class="headerlink" title="暂存已修改文件"></a>暂存已修改文件</h3><p>（untracked -&gt; staged）<br>修改一个已跟踪的文件后</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">    # On branch master</span><br><span class="line">    # Changes not staged for commit:</span><br><span class="line">    # (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">    #</span><br><span class="line">    # modified: benchmarks.rb</span><br><span class="line">    #</span><br></pre></td></tr></table></figure><p>“Changes not staged for commit:” 表示该文件内容发生变化但还未放到暂存区，需要重新运行 <code>git add</code> 命令。<br>也就是说，文件修改之后必须再次 <code>git add</code>，否则 <code>git commit</code> 提交的是修改前版本。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add benchmarks.rb</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># new file: README</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> modified: benchmarks.rb</span></span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure><p><code>git add</code> 根据目标文件的状态产生不同的效果：</p><ul><li>开始跟踪新文件</li><li>把已跟踪的文件放到暂存区</li><li>合并时把有冲突的文件标记为已解决状态</li></ul><h3 id="忽略某些文件"><a href="#忽略某些文件" class="headerlink" title="忽略某些文件"></a>忽略某些文件</h3><p>有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。有以下三种方式：</p><ol><li><p>创建<kbd>.gitignore</kbd>文件</p></li><li><p>项目设置中指定排除文件<br>临时指定。需要编辑当前项目中的 .git/info/exclude 文件</p></li><li><p>定义Git全局的 .gitignore 文件<br>设置全局的.gitignore文件来管理所有Git项目的行为。创建.gitignore文件，存放在任意位置，然后使用命令 <code># git config --global core.excludesfile ~/.gitignore</code> 配置。</p></li></ol><p>格式规范如下：</p><ul><li>每行一个，空格不匹配任意文件，可作为分隔符，可用反斜杠转义</li><li>所有空行或者以注释符号 <kbd>＃</kbd> 开头的行都会被 Git 忽略</li><li>可以使用标准的 glob 模式匹配：shell 所使用的简化了的正则表达式</li><li>匹配模式最后跟反斜杠<kbd>/</kbd>说明要忽略的是目录下所有文件</li><li>使用两个星号”**” 表示匹配任意中间目录</li><li><kbd>/</kbd>结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件；<kbd>/</kbd>开始的模式匹配项目根目录</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号<kbd>!</kbd>取反。</li><li>关于优先级等更多语法查看<a href="https://www.cnblogs.com/kevingrace/p/5690241.html">Git忽略提交规则 - .gitignore配置运维总结</a></li></ul><p>一般来说每个Git项目中都需要一个“.gitignore”文件，告诉Git哪些文件不需要添加到版本管理中，实际项目中很多文件都是不需要版本管理的，例如日志、缩略图、敏感信息等。</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span></span><br><span class="line">    doc/*.txt</span><br></pre></td></tr></table></figure><h3 id="查看未暂存的更新"><a href="#查看未暂存的更新" class="headerlink" title="查看未暂存的更新"></a>查看未暂存的更新</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br></pre></td></tr></table></figure><p>查看工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。<br>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br><span class="line">    diff --git a/benchmarks.rb b/benchmarks.rb</span><br><span class="line">    index 3cb747f..da65585 100644</span><br><span class="line">    --- a/benchmarks.rb</span><br><span class="line">    +++ b/benchmarks.rb</span><br><span class="line">    @@ -36,6 +36,10 @@ def main</span><br><span class="line">    @commit.parents[0].parents[0].parents[0]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    + run_code(x, &#x27;commits 1&#x27;) do</span><br><span class="line">    + git.commits.size</span><br><span class="line">    + end</span><br><span class="line">    +</span><br><span class="line">    run_code(x, &#x27;commits 2&#x27;) do</span><br><span class="line">    log = git.commits(&#x27;master&#x27;, 15)</span><br><span class="line">    log.size</span><br></pre></td></tr></table></figure><h3 id="查看已暂存的更新"><a href="#查看已暂存的更新" class="headerlink" title="查看已暂存的更新"></a>查看已暂存的更新</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached</span></span><br></pre></td></tr></table></figure><p>查看已经暂存起来的文件和上次提交时的快照之间的差异</p><h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h3><p>（staged -&gt; commited；stage -&gt; repository）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m &lt;file&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区的指定文件到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit &lt;file1&gt; &lt;file2&gt; ... -m &lt;message&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交工作区自上次commit之后的变化，直接到仓库区，跳过add,对新文件无效</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交时显示所有diff信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -v</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果我们提交后发现有个文件改错了，将修改过的文件通过<span class="string">&quot;git add&quot;</span>后执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m &lt;message&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend &lt;file1&gt; &lt;file2&gt; ...</span> </span><br></pre></td></tr></table></figure><p>使用 <code>git status</code> 查看暂存区域状态，准备妥当之后就可以提交了。<br>这样看来暂存区的意义在于<strong>精心准备</strong>每次提交。  </p><ul><li>直接使用不加 <kbd>-m</kbd> 的 <code>git commit</code> 提交会打开编辑器（通过 <code>$ git config --global core.editor emacs</code> 配置）以便输入本次提交的说明。</li><li>使用<kbd>-m</kbd>选项比较方便。</li></ul><p>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;Story 182: Fix benchmarks for speed&quot;</span></span></span><br><span class="line">    [master]: created 463dc4f: &quot;Fix benchmarks for speed&quot;</span><br><span class="line">    2 files changed, 3 insertions(+), 0 deletions(-)</span><br><span class="line">    create mode 100644 README</span><br></pre></td></tr></table></figure><p>显示了提交的分支（master）、SHA-1校验和（463dc4f）、修改过的文件数（2）和增（3）删<strong>行数</strong>。  </p><p>因为修改后但未暂存的处于已修改态（modified），只能纳入下一次版本。  </p><p><strong>每次提交都是对项目的一次快照，以后可以回退</strong></p><h3 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -a -m &lt;message&gt;</span></span><br></pre></td></tr></table></figure><p>Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤，对新文件无效</p><h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><ol><li>从 Git 中移除文件</li></ol><p>未跟踪文件对 Git 来说不存在，手动<code>rm</code>即可，已跟踪文件就必须要从已跟踪文件清单（stage）中移除，然后提交。可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm &lt;file&gt;</span></span><br></pre></td></tr></table></figure><p>如果只是简单地从工作目录中手工删除文件，运行 <code>git status</code> 时就会在 “Changes not staged for commit” 部分（未暂存清单）看到。（判断为“修改”操作？）</p><ol start="2"><li>从 Git 中移除，但仍然希望保留在当前工作目录<br>（stage -&gt; workspace；tracked:staged -&gt; untracked）<br>即不小心纳入仓库后，想要移除跟踪但不删除文件。</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm --cached &lt;file&gt;</span></span><br></pre></td></tr></table></figure><h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git mv &lt;oldfileName&gt; &lt;newFileName&gt;</span></span><br></pre></td></tr></table></figure><p>Git 并不跟踪文件移动操作。如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。要在 Git 中对文件改名，执行<code>git mv</code>实际上相当于</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mv old new</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm old</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add new</span></span><br></pre></td></tr></table></figure><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br></pre></td></tr></table></figure><p>默认不用任何参数，<code>git log</code> 会按提交时间列出所有的更新信息。<br>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">    commit ca82a6dff817ec66f44342007202690a93763949   #SHA-1校验和</span><br><span class="line">    Author: Scott Chacon &lt;schacon@gee-mail.com&gt;       #作者&lt;邮箱&gt;</span><br><span class="line">    Date: Mon Mar 17 21:52:11 2008 -0700              #时间</span><br><span class="line"></span><br><span class="line">    changed the version number                        #提交说明</span><br></pre></td></tr></table></figure><p><strong>选项</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> &lt;option&gt;</span></span><br><span class="line">  -p    #开显示每次提交的内容差异</span><br><span class="line">  --stat  #仅显示简要的增改行数统计</span><br><span class="line">  --shortstat #只显示 --stat 中最后的行数修改添加移除统计。</span><br><span class="line">  --name-only #仅在提交信息后显示已修改的文件清单。</span><br><span class="line">  --name-status #显示新增、修改、删除的文件清单。</span><br><span class="line">  --abbrev-commit #仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</span><br><span class="line">  --relative-date #使用较短的相对时间显示（比如，“2 weeks ago”）。</span><br><span class="line">  --graph 显示 ASCII #图形表示的分支合并历史。</span><br><span class="line">  --pretty #使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</span><br></pre></td></tr></table></figure><h3 id="限制输出长度"><a href="#限制输出长度" class="headerlink" title="限制输出长度"></a>限制输出长度</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> &lt;option&gt;</span></span><br><span class="line">  -(n) #仅显示最近的 n 条提交</span><br><span class="line">  --since, --after #仅显示指定时间之后的提交。</span><br><span class="line">  --until, --before #仅显示指定时间之前的提交。</span><br><span class="line">  --author #仅显示指定作者相关的提交。</span><br><span class="line">  --committer #仅显示指定提交者相关的提交。</span><br></pre></td></tr></table></figure><h3 id="使用图形化工具查阅提交历史"><a href="#使用图形化工具查阅提交历史" class="headerlink" title="使用图形化工具查阅提交历史"></a>使用图形化工具查阅提交历史</h3><p>随 Git 一同发布的 gitk 相当于 git log 命令的可视化版本。</p><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><p>任何已经提交到 Git 的都可以被恢复。你可能失去的数据，仅限于没有提交过的，对 Git 来说它们就像从未存在过一样。</p><h3 id="修改最后一次提交"><a href="#修改最后一次提交" class="headerlink" title="修改最后一次提交"></a>修改最后一次提交</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果我们提交后发现有个文件改错或没有加，将修改过的文件通过<span class="string">&quot;git add&quot;</span>后执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改上一次commit的提交信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m &lt;message&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend &lt;file1&gt; &lt;file2&gt; ...</span> </span><br></pre></td></tr></table></figure><p>也就是说，在执行<code>git commit</code>之后暂存区为空，此时若再次执行<code>git commit --amend</code>判断为修改上次的提交信息；此时若<code>git add</code>新文件到暂存区，执行此命令相当于添加到上次提交。</p><h3 id="取消已经暂存的文件"><a href="#取消已经暂存的文件" class="headerlink" title="取消已经暂存的文件"></a>取消已经暂存的文件</h3><p>（staged -&gt; modified）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset HEAD &lt;file&gt;</span></span><br></pre></td></tr></table></figure><p>文件从暂存区回到已修改未暂存状态。</p><h3 id="取消对文件的修改"><a href="#取消对文件的修改" class="headerlink" title="取消对文件的修改"></a>取消对文件的修改</h3><p>（modified -&gt; unmodified）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- &lt;file&gt;</span></span><br></pre></td></tr></table></figure><h3 id="文件操作总结"><a href="#文件操作总结" class="headerlink" title="文件操作总结"></a>文件操作总结</h3><p><img src="/images/Git/file-summary.png" alt="file-summary.png"></p><h1 id="Git远程仓库"><a href="#Git远程仓库" class="headerlink" title="Git远程仓库"></a>Git远程仓库</h1><p>Git 要求每个远程主机都必须指定一个主机名。</p><h2 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote</span></span><br></pre></td></tr></table></figure><p>查看每个远程库的简短名字。Git 默认使用“origin”这个名字来标识你所克隆的原始仓库。  </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br></pre></td></tr></table></figure><p>加上<kbd>-v</kbd>选项，显示对应的克隆地址。</p><h2 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add &lt;shortname&gt; &lt;url&gt;</span></span><br></pre></td></tr></table></figure><p><kbd>&lt;shortname></kbd>即自定义远程主机名<remote-name>，在<code>git remote</code>中显示，</p><h2 id="从远程仓库抓取数据"><a href="#从远程仓库抓取数据" class="headerlink" title="从远程仓库抓取数据"></a>从远程仓库抓取数据</h2><p><strong>git fetch</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch add &lt;remote-name&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch add &lt;remote-name&gt; &lt;branch-name&gt;  <span class="comment">#指定分支</span></span></span><br></pre></td></tr></table></figure><ul><li>抓取所有本地仓库没有的数据。但只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支。  </li><li>通常用来查看其他人的进程，因为它取回的代码对本地代码没有影响。  </li><li>指定分支所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。  </li><li>类似的，<code>git fetch origin</code>会抓取上次<code>clone</code>以来的别人提交的更新。  </li><li>如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。</li></ul><p><strong>git pull</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull &lt;remote-name&gt; &lt;remote-branch-name&gt;:&lt;local-branch-name&gt;</span></span><br></pre></td></tr></table></figure><ul><li>取回远程主机某个分支的更新，再与本地的指定分支合并。  </li><li>如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。  </li><li>如果是与当前分支合并，则冒号后面的部分可以省略。  </li><li>等同于先<code>git fetch</code>再<code>git merge</code>。  </li><li>如果远程主机删除了某个分支，默认情况下，<code>git pull</code> 不会在拉取远程分支的时删除对应的本地分支。这是为了防止由于其他人操作了远程主机，导致<code>git pull</code>不知不觉删除了本地分支。除非加上参数 <kbd>-p</kbd> 就会在本地删除远程已经删除的分支。</li></ul><h2 id="推送数据到远程仓库"><a href="#推送数据到远程仓库" class="headerlink" title="推送数据到远程仓库"></a>推送数据到远程仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;remote-name&gt; &lt;local-branch-name&gt;:&lt;remote-branch-name&gt;</span></span><br></pre></td></tr></table></figure><ul><li>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。  </li><li>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。<br>将本地仓库中的数据推送到远程仓库，只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。</li><li>如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</li><li>如果是新建分支第一次<code>git push</code>，会提示：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fatal: The current branch dev1 has no upstream branch.</span><br><span class="line">　　To push the current branch and set the remote as upstream, use</span><br><span class="line">　　git push --set-upstream origin dev1</span><br></pre></td></tr></table></figure><p>输入这行命令，然后输入用户名和密码就成功了，以后的push就只需要输入<code>git push origin</code>。</p><ul><li>如果当前分支只有一个追踪分支，那么主机名都可以省略。</li><li>如果当前分支与多个主机存在追踪关系，则可以使用<kbd>-u</kbd>选项指定一个默认主机，这样后面就可以不加任何参数使用<code>git push</code>。</li><li>如果不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用<kbd>--all</kbd>选项。</li><li>如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做<code>git pull</code>合并差异，然后再推送到远程主机。这时如果你一定要推送，可以使用<kbd>--force</kbd>选项。<br>结果导致远程主机上更新的版本被覆盖。</li></ul><h2 id="查看远程仓库信息"><a href="#查看远程仓库信息" class="headerlink" title="查看远程仓库信息"></a>查看远程仓库信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote show &lt;remote-name&gt;</span></span><br></pre></td></tr></table></figure><p>例如：  </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote show origin</span></span><br><span class="line">    * remote origin</span><br><span class="line">    URL: git@github.com:defunkt/github.git</span><br><span class="line">    Remote branch merged with &#x27;git pull&#x27; while on branch issues     # git pull 时将自动合并的分支</span><br><span class="line">    issues</span><br><span class="line">    Remote branch merged with &#x27;git pull&#x27; while on branch master     # git pull 时将自动合并的分支</span><br><span class="line">    master</span><br><span class="line">    New remote branches (next fetch will store in remotes/origin)   # 还没有同步到本地的远端分支</span><br><span class="line">    caching               </span><br><span class="line">    Stale tracking branches (use &#x27;git remote prune&#x27;)    #已同步到本地的远端分支在远端服务器上已被删除</span><br><span class="line">    libwalker</span><br><span class="line">    walker2</span><br><span class="line">    Tracked remote branches</span><br><span class="line">    acl</span><br><span class="line">    apiv2</span><br><span class="line">    dashboard2</span><br><span class="line">    issues</span><br><span class="line">    master</span><br><span class="line">    postgres</span><br><span class="line">    Local branch pushed with &#x27;git push&#x27;     # git push 缺省推送的分支</span><br><span class="line">    master:master         </span><br></pre></td></tr></table></figure><h2 id="远程仓库的删除和重命名"><a href="#远程仓库的删除和重命名" class="headerlink" title="远程仓库的删除和重命名"></a>远程仓库的删除和重命名</h2><h3 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote rename pb paul</span></span><br></pre></td></tr></table></figure><p>修改的是某个远程仓库在本地的简称，分支名也会发生变化。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote rm &lt;remote-name&gt;</span></span><br></pre></td></tr></table></figure><h1 id="版本标签"><a href="#版本标签" class="headerlink" title="版本标签"></a>版本标签</h1><h2 id="显示已有标签"><a href="#显示已有标签" class="headerlink" title="显示已有标签"></a>显示已有标签</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> $ git tag -l <span class="string">&#x27;&lt;tag-name&gt;&#x27;</span>    <span class="comment">#显示指定版本</span></span></span><br></pre></td></tr></table></figure><p>按照字母顺序排列。</p><h2 id="新建标签"><a href="#新建标签" class="headerlink" title="新建标签"></a>新建标签</h2><p>Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用；而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息。</p><p>建议一般使用含附注型的标签，临时性加注标签用轻量级标签。</p><h3 id="含附注的标签"><a href="#含附注的标签" class="headerlink" title="含附注的标签"></a>含附注的标签</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -a &lt;tag-name&gt; -m &lt;message&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show <span class="string">&#x27;&lt;tag-name&gt;&#x27;</span>    <span class="comment">#查看相应标签的版本信息</span></span></span><br></pre></td></tr></table></figure><p><kbd>-a</kbd>指定标签名，<kbd>-m</kbd>指定对应的标签说明，<code>git show</code>可以显示出。</p><h3 id="轻量级标签"><a href="#轻量级标签" class="headerlink" title="轻量级标签"></a>轻量级标签</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag &lt;tag-name&gt;</span></span><br></pre></td></tr></table></figure><p>没有选项。</p><h3 id="签署标签"><a href="#签署标签" class="headerlink" title="签署标签"></a>签署标签</h3><p>如果你有自己的私钥，还可以用 GPG 来签署标签，只需要把之前的 <kbd>-a</kbd> 改为 <kbd>-s</kbd> 即可。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -s &lt;tag-name&gt; -m &lt;message&gt;</span></span><br></pre></td></tr></table></figure><h3 id="验证标签"><a href="#验证标签" class="headerlink" title="验证标签"></a>验证标签</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -v &lt;tag-name&gt;</span></span><br></pre></td></tr></table></figure><p>验证已经签署的标签，会调用 GPG 来验证签名，所以需要有签署者的公钥，存放在 keyring 中，才能验证，否则报错<code>gpg: Can&#39;t check signature: public key not found</code>。</p><h2 id="后期加注标签"><a href="#后期加注标签" class="headerlink" title="后期加注标签"></a>后期加注标签</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -a &lt;tag-name&gt; &lt;SHA-1&gt;</span></span><br></pre></td></tr></table></figure><p>只要在打标签的时候跟上对应提交对象的校验和（或前几位字符）即可。<br>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v1.2 9fceb02</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show v1.2</span></span><br><span class="line">  version 1.2</span><br><span class="line">    commit 9fceb02d0ae598e95dc970b74767f19372d61af8</span><br><span class="line">    Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt;</span><br><span class="line">    Date: Sun Apr 27 20:43:35 2008 -0700</span><br><span class="line"></span><br><span class="line">    updated rakefile</span><br></pre></td></tr></table></figure><h2 id="分享标签"><a href="#分享标签" class="headerlink" title="分享标签"></a>分享标签</h2><p>默认情况下，<code>git push</code> 并不会把标签传送到远端服务器上</p><ul><li>使用<kbd>--tags</kbd>选项一次推送所有本地新增的标签上去</li><li>通过显式命令才能分享标签到远端仓库。  </li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin --tags</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin [tag-name]</span></span><br></pre></td></tr></table></figure><h1 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h1><p>使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。</p><h2 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h2><p>在 Git 中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针、作者等附属信息、零个或多个指向该提交对象的父对象指针。首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。</p><p>举例：对于三个文件暂存后，Git 嫁给你当前版本的快照（blob类型）连同每个文件的额SHA-1保存至仓库。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add README test.rb LICENSE</span></span><br><span class="line">    $ git commit -m &#x27;initial commit of my project&#x27;</span><br></pre></td></tr></table></figure><p>现在仓库中有五个对象：</p><ul><li>三个 blob 对象：表示文件快照内容</li><li>tree 对象：记录着目录树内容及其中各个文件对应的 blob 对象索引的</li><li>commit 对象：指向 tree 对象（根目录）的索引和其他提交信息元数据。在需要的时候重现此次快照。<br><img src="/images/Git/singleObj.png" alt="singleObj.png"></li></ul><p>作些修改后再次提交，那么这次的提交对象会包含一个指向上次提交对象的指针（parent 对象）。两次提交后：<br><img src="images/Git/multiObj.png" alt="multiObj.png"></p><p>Git 中的分支，其实本质上仅仅是个指向 commit 对象的可变指针。Git 会使用 <kbd>master</kbd> 作为分支的默认名字。在若干次提交后，你其实已经有了一个指向最后一次提交对象的 <kbd>master</kbd> 分支，它在每次提交的时候都会自动向前移动。<br><img src="images/Git/masterHistory.png" alt="masterHistory.png"></p><h2 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch &lt;branch-name&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>git branch testing</code>在当前 commit 对象上新建一个分支指针<kbd>testing</kbd>：<br><img src="images/Git/newBranch.png" alt="newBranch.png"></p><h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><p>HEAD 是一个指向你正在工作中的本地分支的指针，即当前分支。</p><p>运行 <code>git branch</code> 命令，仅仅是建立了一个新的分支，但不会自动切换到这个分支中去，所以依然还在 <kbd>master</kbd> 分支里工作：</p><p><img src="images/Git/headMaster.png" alt="headMaster.png"></p><h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout &lt;branch-name&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b &lt;branch-name&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>git checkout testing</code>切换分支<kbd>testing</kbd>：<br><img src="images/Git/checkout.png" alt="checkout.png"></p><p>或者运行 <code>git checkout</code> 并加上 <kbd>-b</kbd> 参数，新建并切换到该分支。</p><p>提交之后：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim test.rb</span></span><br><span class="line">    $ git commit -a -m &#x27;made a change&#x27;</span><br></pre></td></tr></table></figure><p><img src="images/Git/headTesting.png" alt="headTesting.png"><br>提交后 HEAD 随<kbd>testing</kbd>分支一起向前移动，，而 <kbd>master</kbd> 分支仍然指向原先 <code>git checkout</code> 时所在的 commit 对象。</p><p>如果此时执行<code>git checkout master</code>，切回<kbd>master</kbd>分支：</p><p><img src="images/Git/masterHistory.png" alt="masterHistory.png"><br>做了两件事：</p><ul><li>HEAD 指针移回到 <kbd>master</kbd> 分支</li><li>工作目录中的文件换成了 master 分支所指向的快照内容（较旧的进度）<br>它的主要作用是将 testing 分支里作出的修改暂时取消，这样你就可以向另一个方向进行开发。</li></ul><p>此时如果提交新文件，即：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim test.rb</span></span><br><span class="line">    $ git commit -a -m &#x27;made other changes&#x27;</span><br></pre></td></tr></table></figure><p><img src="images/Git/branchHistory.png" alt="branchHistory.png"></p><p><strong>Git 中的分支实际上仅是一个包含所指对象校验和（40 个字符长度 SHA-1 字串）的文件，Git 的实现与项目复杂度无关，并且每次提交都记录了 parent 对象，所以 Git 分支操作非常廉价。</strong></p><blockquote><p>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：<br>你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！<br>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：<br>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：<br>所以Git合并分支也很快！就改改指针，工作区内容也不变！<br>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支。</p></blockquote><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge iss53</span></span><br></pre></td></tr></table></figure><p>回到 <kbd>master</kbd> 分支，运行 <code>git merge</code> 命令指定要合并进来的分支<kbd>iss53</kbd></p><h2 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h2><p>如果在不同的分支中都修改了同一个文件的同一部分，Git 就无法干净地把两者合到一起（逻辑上说，这种问题只能由人来裁决）。结果如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge iss53</span></span><br><span class="line">    Auto-merging index.html</span><br><span class="line">    CONFLICT (content): Merge conflict in index.html</span><br><span class="line">    Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>Git 做了合并但没有提交，等待解决冲突。可以用 <code>git status</code> 查看合并时发生冲突的文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash"> unmerged: index.html</span></span><br></pre></td></tr></table></figure><p>任何包含未解决冲突的文件都会以未合并<strong>unmerged</strong>的状态列出。Git 会在有冲突的文件里加入标准的冲突解决标记：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line">    &lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class="line">    =======</span><br><span class="line">    &lt;div id=&quot;footer&quot;&gt;</span><br><span class="line">    please contact us at support@github.com</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></pre></td></tr></table></figure><p>可以看到 <kbd>=======</kbd> 隔开的上半部分，是 HEAD（当前分支）中的内容，下半部分是在 <kbd>iss53</kbd> 分支中的内容。</p><p>解决办法是删除上面的内容（包括’=’’&lt;’’&gt;’），自行决定怎么写。之后运行<code>git add</code>和<code>git status</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash"> modified: index.html</span></span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure><p>确认冲突已解决，标记为<strong>modified</strong>，再<code>git commit</code>提交。</p><p>也可以使用相关可视化工具解决冲突，运行<code>git mergetool</code>。</p><h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d &lt;branch-name&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">强制删除</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -D &lt;branch-name&gt;</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程分支，分支必须完全合并在其上游分支，或者在HEAD上没有设置上游</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete &lt;branch-name&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -dr &lt;remote-name/branch-name&gt;</span></span><br></pre></td></tr></table></figure><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><strong>工作流程</strong></p><ol><li>开发某个网站为</li><li>实现某个新的需求，创建一个分支。</li><li>在这个分支上开展工作。</li></ol><p>假设此时突然有个很严重的问题需要紧急修补，那么：</p><ol><li>返回到原先已经发布到生产服务器上的分支。</li><li>为这次紧急修补建立一个新分支，并在其中修复问题。</li><li>通过测试后，回到生产服务器所在的分支，将修补分支合并进来，然后再推送到生产服务器上。</li><li>切换到之前实现新需求的分支，继续工作。</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建iss53并切换</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b iss53</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 遇问题切回master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时工作区和之前 master 提交时完全一样</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建紧急修补分支 hotfix</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b <span class="string">&#x27;hotfix&#x27;</span></span></span><br></pre></td></tr></table></figure><p>Git 的好处：  </p><ul><li>不需要同时发布这个补丁和 iss53 里作出的修改</li><li>不需要在创建和发布该补丁到服务器之前花费大力气来复原这些修改</li></ul><p>切换分支时需要留心你的暂存区或者工作目录里<strong>还没有提交的修改</strong>，它会产生冲突从而阻止切换，最好保持一个清洁的工作区域（也可以通过 stashing 和 commit amending 绕过这种问题）。</p><p><img src="images/Git/hotfixSuccess.png" alt="hotfixSuccess.png.png"></p><p>修改、测试之后回到 <kbd>master</kbd> 分支并把 <kbd>hotfix</kbd> 合并：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge hotfix</span></span><br></pre></td></tr></table></figure><p>请注意，合并时出现了“Fast forward”的提示。由于当前 <kbd>master</kbd> 分支所在的提交对象是要并入的 <kbd>hotfix</kbd> 分支的直接上游，Git 只需把 <kbd>master</kbd> 分支指针直接右移。换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为<strong>快进</strong>（Fast forward）。</p><p><kbd>hotfix</kbd>分支完成历史使命之后可以删掉，回到正常的 iss53 正常工作：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d hotfix</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout iss53</span></span><br></pre></td></tr></table></figure><p><img src="images/Git/normalWork.png" alt="normalWork.png"></p><p>需求#53开发完之后，合并<kbd>master</kbd>和<kbd>iss53</kbd>分支：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge iss53</span></span><br></pre></td></tr></table></figure><p>这次合并操作的底层实现，并不同于之前 <kbd>hotfix</kbd> 的并入方式。因为这次你的开发历史是从更早的地方开始分叉的。由于当前 <kbd>master</kbd> 分支所指向的提交对象（C4）并不是 <kbd>iss53</kbd> 分支的直接祖先，Git 不得不进行一些额外处理。就此例而言，Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算：</p><p><img src="images/Git/merge3.png" alt="merge3.png"></p><p>这次，Git 没有简单地把分支指针右移，而是对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（C6）（见图 3-17）。这个提交对象比较特殊，它有两个祖先（C4 和 C5）。</p><p>值得一提的是 Git 可以自己裁决哪个共同祖先才是最佳合并基础；这和 CVS 或 Subversion（1.5 以后的版本）不同，它们需要开发者手工指定合并基础。所以此特性让 Git 的合并操作比其他系统都要简单不少。</p><p><img src="images/Git/mergeAutoCommit.png" alt="mergeAutoCommit.png"></p><p>此时<kbd>iss53</kbd>没用了，可以删除。</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p><strong>查看所有分支</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">    iss53</span><br><span class="line">    * master</span><br><span class="line">    testing</span><br></pre></td></tr></table></figure><p><code>git branch</code> 命令不加参数列出所有分支。 <kbd>master</kbd> 分支前的 <kbd>*</kbd> 字符表示当前所在的分支。也就是说如果现在提交更新，<kbd>master</kbd> 分支将随着开发进度前移。</p><p><strong>查看各分支最后一个 commit 对象的信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -v</span></span><br></pre></td></tr></table></figure><p><strong>查看与HEAD已合并/或未合并分支</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看已并入当前分支的==哪些分支是当前分支的直接上游</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --merged</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看尚未合并的</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --no-merged</span></span><br></pre></td></tr></table></figure><p>对于已合并的，可以用<code>git branch -d</code>直接删除，不会有损失。<br>对于已合并的，用<code>git branch -d</code>删除会报错，因为这样做会丢失数据，除非<kbd>-D</kbd>强制删除。</p><h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p>用<kbd>remote-name/remote-branch-name</kbd>描述远程分支，区别于本地分支。</p><p>在第一次<code>git clone</code>之后，下载的数据命名为<kbd>origin/master</kbd>，无法修改。之后 Git 创建属于本地的 <kbd>master</kbd> 分支，二者都指向远程<kbd>origin</kbd>的<kbd>master</kbd>分支。<br><img src="images/Git/remoteBranch1.png" alt="remoteBranch1.png"></p><p>如果在本地 <kbd>master</kbd> 分支做了些改动，在本地的提交历史正朝向不同方向发展，与此同时，其他人向 git.ourcompany.com 推送了他们的更新，服务器上的 <kbd>master</kbd> 分支就会向前推进。不过只要不和服务器通讯，本地的 <kbd>origin/master</kbd> 指针仍然保持原位不会移动。<br><img src="images/Git/remoteBranch2.png" alt="remoteBranch2.png"></p><p>可以运行 <code>git fetch origin</code> 来同步远程服务器上的数据到本地。从 origin 上获取尚未拥有的数据，更新你本地的数据库，然后把 <kbd>origin/master</kbd> 的指针移到最新位置。<br><img src="images/Git/remoteBranch3.png" alt="remoteBranch3.png"></p><p>假设，还有另一个仅供你的敏捷开发小组使用的内部服务器 git.team1.ourcompany.com。加为当前项目的远程分支之一，并命名为 teamone。</p><p>现在可以用 <code>git fetch teamone</code> 来获取小组服务器上你还没有的数据了。由于当前该服务器上的内容是你 <kbd>origin</kbd> 服务器上的子集，Git 不会下载任何数据，而只是简单地创建一个名为 <kbd>teamone/master</kbd> 的远程分支，指向 teamone 服务器上 <kbd>master</kbd> 分支所在的提交对象 <kbd>31b8e</kbd>。<br><img src="images/Git/remoteBranch4.png" alt="remoteBranch4.png"></p><p><kbd>master</kbd>并不是多么神秘复杂的东西，分清楚远程的别人的<kbd>origin/master</kbd>、本地的别人的<kbd>origin/master</kbd>、本地的自己的<kbd>master</kbd>就可以了。</p><h2 id="推送本地分支"><a href="#推送本地分支" class="headerlink" title="推送本地分支"></a>推送本地分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;remote-name&gt; &lt;branch-name&gt;</span></span><br></pre></td></tr></table></figure><p>要想和其他人分享某个本地分支，你需要把它推送到一个你拥有<strong>写权限</strong>的远程仓库。你创建的本地分支不会因为你的写入操作而被自动同步到你引入的远程服务器上，你需要明确地执行推送分支的操作。</p><p><code>git push origin serverfix:serverfix</code>意思是“上传我本地的 <kbd>serverfix</kbd> 分支到远程仓库中去，仍旧称它为 <kbd>serverfix</kbd> 分支”。通过此语法，你可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫作 <kbd>awesomebranch</kbd>，可以用 <code>git push origin serverfix:awesomebranch</code> 来推送数据。</p><h2 id="跟踪远程分支"><a href="#跟踪远程分支" class="headerlink" title="跟踪远程分支"></a>跟踪远程分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b &lt;branch-name&gt; &lt;remote-name/branch-name&gt;</span></span><br></pre></td></tr></table></figure><p>从远程分支 <code>checkout</code> 出来的本地分支，称为<strong>跟踪分支</strong> (tracking branch)。跟踪分支是一种和某个远程分支有直接联系的本地分支。在跟踪分支里输入 <code>git push</code>，Git 会自行推断应该向哪个服务器的哪个分支推送数据。</p><h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;remote-name&gt; :&lt;branch-name&gt;</span></span><br></pre></td></tr></table></figure><p>对于<code>git push &lt;remote-name&gt; &lt;local-branch-name&gt;:&lt;remote-branch-name&gt;</code> 语法，如果省略 <local-branch-name>，那就等于是在说“在这里提取空白然后把它变成<remote-branch-name>”。</p><h2 id="分支衍合"><a href="#分支衍合" class="headerlink" title="分支衍合"></a>分支衍合</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout &lt;rebase-branch-name&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rebase &lt;master-branch-name&gt;</span></span><br></pre></td></tr></table></figure><p>把一个分支中的修改整合到另一个分支有两种办法：<code>merge</code> 和 <code>rebase</code>。<br><strong>merge</strong><br><img src="images/Git/merge.png" alt="merge.png"></p><p><strong>rebase</strong><br>还有可以把在 C3 里产生的变化补丁在 C4 的基础上重新打一遍，这种操作叫做衍合（rebase）。即把在一个分支里提交的改变移到另一个分支里重放一遍。</p><p>原理是回到两个分支最近的共同祖先，根据当前分支（也就是要进行衍合的分支 <kbd>experiment</kbd>）后续的历次提交对象（这里只有一个 C3），生成一系列文件补丁，然后以基底分支（也就是主干分支 <kbd>master</kbd>）最后一个提交对象（C4）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（C3’），从而改写 <kbd>experiment</kbd> 的提交历史，使它成为 <kbd>master</kbd> 分支的直接下游：<br><img src="images/Git/rebase.png" alt="rebase.png"></p><p>再进行快进合并：<br><img src="images/Git/speedMerge.png" alt="speedMerge.png"></p><p>现在的 C3’ 对应的快照，其实和普通的三方合并，即 C5 对应的快照内容一模一样，结果没有任何区别，只不过提交历史不同。但衍合能产生一个更为整洁的提交历史，仿佛所有修改都是在一根线上先后进行的。</p><p>一般我们使用衍合的目的，是想要得到一个能在远程分支上干净应用的补丁。项目志愿开发者通过衍合提交，维护者就不需要做任何整合工作。实际上是把解决分支补丁同最新主干代码之间冲突的责任，化转为由提交补丁的人来解决。</p><p>衍合是按照每行的修改次序重演一遍修改，而合并是把最终结果合在一起。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://git-scm.com/docs">Git官方参考文档</a></li><li><a href="http://git.oschina.net/progit/">Pro Git（中文版）</a></li><li><a href="https://www.cnblogs.com/syp172654682/p/7689328.html">深入浅出Git教程</a></li><li><a href="https://www.cnblogs.com/yaozhongxiao/p/3811130.html">Git图解剖析</a></li><li><a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的官方网站</a></li><li><a href="https://www.runoob.com/git/">菜鸟教程</a></li><li><a href="https://www.cnblogs.com/kevingrace/p/5690241.html">Git忽略提交规则 - .gitignore配置运维总结</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Git是目前世界上最先进的分布式版本控制系统（没有之一）。&lt;/p&gt;</summary>
    
    
    
    <category term="Tool" scheme="https://memorykk.cn/categories/Tool/"/>
    
    
    <category term="Git" scheme="https://memorykk.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>记一次博客接入Gitalk出现403问题的解决过程</title>
    <link href="https://memorykk.cn/gitalk-403.html"/>
    <id>https://memorykk.cn/gitalk-403.html</id>
    <published>2021-02-14T01:44:16.000Z</published>
    <updated>2021-02-19T08:45:30.462Z</updated>
    
    <content type="html"><![CDATA[<p>小站的评论系统始终无法接入 Gitalk，提示 403 Error</p><span id="more"></span><hr><p><strong>目录</strong></p><ul><li><a href="#%E9%97%AE%E9%A2%98">问题</a></li><li><a href="#%E6%88%91%E7%9A%84%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B">我的解决过程</a></li><li><a href="#%E5%85%B6%E4%BB%96%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B">其他解决过程</a><ul><li><a href="#%E8%B5%B7%E5%9B%A0">起因</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E7%BB%8F%E9%AA%8C">经验</a></li></ul></li><li><a href="#%E9%83%A8%E7%BD%B2%E8%87%AA%E5%B7%B1%E7%9A%84CORSproxy">部署自己的 CORSproxy</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li></ul><hr><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>最近博客接入 Gitalk 评论系统时，始终报错 403，不知所以，无奈转至 LeanCloud 的 valine comment，但 valine 的风格总让人感觉不够优雅 ╯︿╰。</p><p>报错界面：<img src="/images/gitalk-403/no-issue.PNG" class="" title="no-issue" alt="no-issue"></p><p>点击 <kbd>使用 GitHub 登录</kbd> 之后，显示 Error：<img src="/images/gitalk-403/403.PNG" class="" title="403" alt="403"></p><h1 id="我的解决过程"><a href="#我的解决过程" class="headerlink" title="我的解决过程"></a>我的解决过程</h1><ol><li><p>打开 <kbd>F12</kbd> 控制台，刷新页面，查看出错的 Header：<img src="/images/gitalk-403/f12.PNG" class="" title="f12" alt="f12"></p></li><li><p>触及到知识盲区了。这个 URL 尽管没见过，但两个地址套起来的形式很有特点，习惯性地打开前面的<a href="https://cors-anywhere.herokuapp.com/">链接</a>，展示如下：<img src="/images/gitalk-403/core.PNG" class="" title="core" alt="core"></p></li></ol><p>大意是：CORS Anywhere 这是个实现跨域请求的 Demo，单击按钮临时解锁对演示的访问。</p><p>So，我被加锁了？</p><ol start="3"><li>打开<a href="https://github.com/Rob--W/cors-anywhere/issues/301">提示的参考链接</a>，这个 CORS Anywhere 的作者说：</li></ol><blockquote><p>Public demo server (cors-anywhere.herokuapp.com) will be very limited by January 2021, 31st #301<br>The user (developer) must visit a page at cors-anywhere.herokuapp.com to temporarily unlock the demo for their browser. This allows developers to try out the functionality, to help with deciding on self-hosting or looking for alternatives.</p></blockquote><p>意思是 CORS Anywhere 这个 Demo 被滥用，从 2021/1/31 开始限制，用户必须访问<a href="cors-anywhere.herokuapp.com">页面</a><strong>临时</strong>解锁。</p><ol start="4"><li><p>虽然这只是个临时解决方案，但当时没想太多，能用就行。<img src="/images/gitalk-403/requestTemp.PNG" class="" title="requestTemp" alt="requestTemp"></p></li><li><p>Gitalk 也确实正常工作了。</p></li></ol><h1 id="其他解决过程"><a href="#其他解决过程" class="headerlink" title="其他解决过程"></a>其他解决过程</h1><p>在 GitHub 上寻找相关 Issues 时看见这位大神的解决过程，自愧不如，经原作者同意之后搬运过来，特别是解决思路让我很受启发。以下是原文：</p><hr><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>我的博客最近刚换上了 hexo 框架，于是评论功能就换成了 Gitalk。但最近发现登录功能不好用了，点击使用 GitHub 登录总是失败。</p><p>就点击这个按钮的时候，始终登录不上去：</p><p><img src="https://qiniu.cuiqingcai.com/n79m6.png" alt="image-20210212223917778"></p><p>于是我就想着手解决一下这个问题。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里就记录一下我在排查过程中碰到的一些坑和解决思路。</p><p>首先，登录失败的问题，第一时间应该去排查的就是网络请求，打开控制台，查看 Network 面板，出现类似的结果：</p><p><img src="https://qiniu.cuiqingcai.com/4d8sw.png" alt="image-20210212224407613"></p><p>网络请求直接 403 了，拿不到 token 了，于是就登录不上了。</p><p>观察下，这个链接 cors-anywhere 似乎是用来解决跨域限制的，后面还跟了一个 GitHub 的 Access Token 获取地址，那没跑了，前面这个就是一个反向代理，后面是真实的请求 URL。</p><p>OK，看着这个也没啥思路啊，然后接着怎么办？</p><p>那就接着去搜这个 cors-anywhere.herokuapp.com，因为 herokuapp 很眼熟嘛，就是一个公用的网址 Host 平台，类似于 AWS、Azure 之类的，那么前面这个可能包含某些信息。万一是开源的那就好办了。</p><p>接着搜，cors-anywhere，然后就搜到了这个：<a href="https://github.com/Rob--W/cors-anywhere">https://github.com/Rob–W/cors-anywhere</a></p><p>介绍如下：</p><blockquote><p><strong>CORS Anywhere</strong> is a NodeJS proxy which adds CORS headers to the proxied request.</p><p>The url to proxy is literally taken from the path, validated and proxied. The protocol part of the proxied URI is optional, and defaults to “http”. If port 443 is specified, the protocol defaults to “https”.</p><p>This package does not put any restrictions on the http methods or headers, except for cookies. Requesting <a href="http://www.w3.org/TR/cors/#user-credentials">user credentials</a> is disallowed. The app can be configured to require a header for proxying a request, for example to avoid a direct visit from the browser.</p></blockquote><p>真是一个开源框架，和我猜的一样，就是一个解决跨域问题而生的反向代理。</p><p>然后我就在它的 README 中看到了这个：</p><p><img src="https://qiniu.cuiqingcai.com/e9xla.png" alt="image-20210212224946845"></p><p>好家伙，这不就是我刚才用到的链接吗？</p><p>那肯定是这个玩意出了什么毛病。</p><p>咋看呢？这个果断就是找 Issue 了：</p><p><img src="https://qiniu.cuiqingcai.com/yyu6t.png" alt="image-20210212225114466"></p><p>一看，太明显了：</p><blockquote><p>PSA: Public demo server (cors-anywhere.herokuapp.com) will be very limited by January 2021, 31st</p></blockquote><p>意思就是从今年 1.31 开始这个网站的访问会受限，点进去看看：</p><blockquote><p>The demo server of CORS Anywhere (cors-anywhere.herokuapp.com) is meant to be a demo of this project. But abuse has become so common that the platform where the demo is hosted (Heroku) has asked me to shut down the server, despite efforts to counter the abuse (rate limits in <a href="https://github.com/Rob--W/cors-anywhere/issues/45">#45</a> and <a href="https://github.com/Rob--W/cors-anywhere/issues/164">#164</a>, and blocking other forms of requests). Downtime becomes increasingly frequent (e.g. recently <a href="https://github.com/Rob--W/cors-anywhere/issues/300">#300</a>, <a href="https://github.com/Rob--W/cors-anywhere/issues/299">#299</a>, <a href="https://github.com/Rob--W/cors-anywhere/issues/295">#295</a>, <a href="https://github.com/Rob--W/cors-anywhere/issues/294">#294</a>, <a href="https://github.com/Rob--W/cors-anywhere/issues/287">#287</a>) due to abuse and its popularity.</p><p>To counter this, I will make the following changes:</p><ol><li> The rate limit will decrease from 200 (<a href="https://github.com/Rob--W/cors-anywhere/issues/164">#164</a>) per hour to 50 per hour.</li><li> By January 31st, 2021, cors-anywhere.herokuapp.com will stop serving as an open proxy.</li><li> From February 1st. 2021, cors-anywhere.herokuapp.com will only serve requests after the visitor has completed a challenge: The user (developer) must visit a page at cors-anywhere.herokuapp.com to temporarily unlock the demo for their browser. This allows developers to try out the functionality, to help with deciding on self-hosting or looking for alternatives.</li></ol></blockquote><p>好吧，意思就是说这个网站本来是演示用的，但是现在已经被滥用了，然后从 1.31 开始用户手动必须手动先访问这个网站获取临时的访问权限，然后才能使用。另外推荐开发者自己来维护一个网站。</p><p>接着下面的评论第一个就更滑稽了：</p><p><img src="https://qiniu.cuiqingcai.com/7d55t.png" alt="image-20210212225414735"></p><p>这个人直接艾特了 gitalk，哈哈哈，因为 Gitalk 就如刚才所说的那样，也用了这个。</p><p>那就顺便去 Gitalk <a href="https://github.com/gitalk/gitalk%EF%BC%8C%E9%80%9B%E4%B8%80%E4%B8%8B">https://github.com/gitalk/gitalk，逛一下</a> issue，看看是不是也有人遇到了同样的问题，果不其然了：</p><p><img src="https://qiniu.cuiqingcai.com/s7bn5.png" alt="image-20210212225919986"></p><p>最近几个 issue 都是关于 403 的，真热闹。</p><p>点进去看看，有个大收获，里面有个好心人说：</p><blockquote><p>这次直接去嫖了一个 CORS proxy,把 gitalk.js 的 6794 行改为 proxy: ‘<a href="https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access_token">https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access_token</a>‘, 就可以了。具体能用多久我也没普，且用且珍惜。</p></blockquote><p>真是得来全不费功夫，本来还想着自己部署着，这次那就换了就行了。</p><p>然而，这样不行，得需要改 gitalk.js 的源码，并不太好吧。</p><p>好，这时候就遇到了一个问题，要修改某些开源软件的源码应该怎么办？</p><p>首选的思路当然不是硬改，改了之后还要自己 host 一个新的 js 文件，那显然是很费精力的。</p><p>其实一半程序在编写的时候应该是预留一些接口和配置的，我们应该能很轻易地通过某些配置就能实现某些配置的复写。</p><p>那就接着看看吧，既然要改，那就得先看看 Gitalk 是怎么用的吧。</p><p>看文档，Gitalk 调用方式如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">const gitalk = new Gitalk(&#123;  </span><br><span class="line"> clientID: &#x27;GitHub Application Client ID&#x27;,  </span><br><span class="line"> clientSecret: &#x27;GitHub Application Client Secret&#x27;,  </span><br><span class="line"> repo: &#x27;GitHub repo&#x27;, // The repository of store comments,  </span><br><span class="line"> owner: &#x27;GitHub repo owner&#x27;,  </span><br><span class="line"> admin: \[&#x27;GitHub repo owner and collaborators, only these guys can initialize github issues&#x27;\],  </span><br><span class="line"> id: location.pathname, // Ensure uniqueness and length less than 50  </span><br><span class="line"> distractionFreeMode: false // Facebook-like distraction free mode  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gitalk.render(&#x27;gitalk-container&#x27;)</span><br></pre></td></tr></table></figure><p>看来这个在声明的时候是有参数的，那刚才 URL 配置没看到在哪里配啊，既然如此，那就看看 Gitalk 这个对象支持多少参数吧。</p><p>接着就去找 Gitalk 的构造参数说明，找到这么一个：</p><ul><li>proxy：<code>String</code></li></ul><p>Default: <code>https://cors-anywhere.herokuapp.com/https://github.com/login/oauth/access_token</code>.</p><p>果然找到了，所以这里如果我们要修改，那就改 proxy 参数就行了，初始化 Gitalk 的时候复写掉 proxy 就行。</p><p>OK，基本思路有了，那我怎么改到我的源码里呢？</p><p>我的博客是基于 Hexo 的 Next 主题的，根据经验，Gitalk 是 Next 主题自带的，所以 Gitalk 的声明应该就在 Next 主题源码里面。</p><p>那怎么找呢？</p><p>这时候就需要借助于一些搜索技巧了，搜什么？既然要用 Gitalk，那一定有刚才初始化的调用，那就搜 Gitalk 这个关键字就行了。另外还需要缩小一下搜索范围。</p><p>于是我就把范围限定到了 next 主题目录，搜索 Gitalk。</p><p><img src="https://qiniu.cuiqingcai.com/ey8tq.png" alt="image-20210212230931998"></p><p>简直不要太舒服，一搜就有了，文件是 themes/next/layout/_third-party/comments/gitalk.swig。</p><p>这里我们只需要把 proxy 参数加上不就行了，值是什么呢？仿照写就行了，配置风格保持统一，那就加一条：</p><p>1</p><p>proxy : ‘‘,</p><p>OK，那这个配置的值很明显是主题配置文件，那就把配置文件里面加上 proxy 这个参数就好了。</p><p>找到 themes/next/_config.yml，添加行：</p><p>1</p><p>proxy: <a href="https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access/_token">https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access\_token</a></p><p>结果如下：</p><p><img src="https://qiniu.cuiqingcai.com/nnb1f.png" alt="image-20210212231224403"></p><p>好了，大功告成！</p><p>重新部署 Hexo，现在评论又能重新使用了，问题就解决了！</p><p>测试地址：<a href="https://cuiqingcai.com/message/%EF%BC%8C%E5%A4%A7%E5%AE%B6%E6%9D%A5%E7%BB%99%E6%88%91%E7%95%99%E8%A8%80%E5%90%A7%EF%BD%9E">https://cuiqingcai.com/message/，大家来给我留言吧～</a></p><p>好了，这就是我排查问题的整个过程，做一下记录。</p><h2 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h2><p>另外，其实这篇文章的用意不仅仅是单纯解决这个问题，因为这个问题大家可能并没有遇到过，因此这个解决方案仅仅是给极少数遇到这个问题的朋友提供的。</p><p>但是，这并不代表这篇文章没有价值，因为其中有的思路是通用的，在这里稍微做一下总结，希望对大家有帮助：</p><ul><li>当遇到网页功能异常的时候，排查问题就主要看两个——控制台、网络请求，这里面往往能找到主要问题。</li><li>结合一些基本知识进行合理的推断，比如刚才我就推断了 cors- anywhere 的作用并结合 herokuapp 推断这个可能还会是个公用的服务。</li><li>当碰到没有思路或者不确定的时候，去谷歌它！不要百度，另外还可以在 GitHub 或者 Gitee 上搜。</li><li>如果找到对应的 GitHub 仓库，Issue 区往往能找到一些有效答案，比如刚才我就在 Issue 区找到了一个可替代的 cors 网站。</li><li>修改代码功能的时候要想着尽量复写，也就是 overwrite，而不是直接改，前者更具有灵活性，而且某些情况下会省去一些麻烦。</li><li>复写的时候去找一些参数配置，比如找一些初始化参数、默认参数配置，看看能否实现改写的需求。</li><li>找不到入口的时候善用全局搜索功能，比如刚才 Gitalk 找哪里调用的时候，就直接全局搜索。</li><li>根据功能限制某些搜索范围，比如刚才我就知道 Gitalk 这个功能是 Next 主题提供的，所以我就直接限制搜索范围是 Next 主题的源码。</li><li>以上步骤多尝试，熟能生巧。</li></ul><hr><h1 id="部署自己的-CORSproxy"><a href="#部署自己的-CORSproxy" class="headerlink" title="部署自己的 CORSproxy"></a>部署自己的 CORSproxy</h1><p>就在我以为一切都要结束的时候，我看到了这个评论，兴趣来了！</p><img src="/images/gitalk-403/baipiao.PNG" class="" title="baipiao" alt="baipiao"><p>参考步骤：</p><ol><li><a href="https://dash.cloudflare.com/">注册 CloudFlare 账号</a></li><li><a href="https://workers.cloudflare.com/">building Worker</a></li><li><a href="https://github.com/Zibri/cloudflare-cors-anywhere">上传代码</a></li></ol><p>然而我卡在了第一步，DNS 设置 CF 的名称服务器一直验证不通过。。。</p><img src="/images/gitalk-403/cfCheck.PNG" class="" width="50" height="50" title="cfCheck" alt="cfCheck"><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://cuiqingcai.com/30010.html">Gitalk 评论登录 403 问题解决</a> 精觅-崔庆才的个人站点.</li><li><a href="https://github.com/Rob--W/cors-anywhere/issues/301">PSA: Public demo server (cors-anywhere.herokuapp.com) will be very limited by January 2021, 31st #301</a></li><li><a href="https://github.com/gitalk/gitalk/issues/428">使用 Github 登录后，提示 403 错误 #428</a></li><li><a href="https://github.com/Zibri/cloudflare-cors-anywhere">cloudflare-cors-anywhere</a></li><li><a href="https://blog.csdn.net/u012424449/article/details/103068412">一分钟教程：利用 cloudflare worker 搭建在线代理—-jsproxy</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;小站的评论系统始终无法接入 Gitalk，提示 403 Error&lt;/p&gt;</summary>
    
    
    
    <category term="Log" scheme="https://memorykk.cn/categories/Log/"/>
    
    
    <category term="Gitalk" scheme="https://memorykk.cn/tags/Gitalk/"/>
    
  </entry>
  
  <entry>
    <title>Hexo中Markdown语法失效问题</title>
    <link href="https://memorykk.cn/Hexo-Markdown-nonsupport.html"/>
    <id>https://memorykk.cn/Hexo-Markdown-nonsupport.html</id>
    <published>2021-02-13T06:20:06.000Z</published>
    <updated>2021-02-19T06:11:39.188Z</updated>
    
    <content type="html"><![CDATA[<p>在Hexo站上用Markdown写博时发现好多语法失效问题，记录一下</p><span id="more"></span><hr><p><strong>目录</strong></p><ul><li><a href="#1-%E8%A1%A8%E6%A0%BC%E7%9B%B4%E6%8E%A5%E4%BB%A5%E6%BA%90%E7%A0%81%E6%98%BE%E7%A4%BA%E6%97%A0%E6%B8%B2%E6%9F%93">1.表格直接以源码显示无渲染</a></li><li><a href="#2-lt-kbd-gt-%E6%97%A0%E6%A0%B7%E5%BC%8F">2.&lt;kbd&gt;无样式</a></li><li><a href="#3-%E6%8F%92%E5%85%A5-lt-table-gt-%E4%B8%8D%E6%B8%B2%E6%9F%93">3.插入&lt;table&gt;不渲染</a></li><li><a href="#4-%E6%8F%92%E5%85%A5HTML%E6%A0%87%E7%AD%BE%E4%BA%A7%E7%94%9F%E5%A4%A7%E9%87%8F%E6%8D%A2%E8%A1%8C">4.插入HTML标签产生大量换行</a></li><li><a href="#5-%E7%9B%AE%E5%BD%95%E8%B7%B3%E8%BD%AC%E6%97%A0%E5%8F%8D%E5%BA%94">5.目录跳转无反应</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul><hr><h2 id="1-表格直接以源码显示无渲染"><a href="#1-表格直接以源码显示无渲染" class="headerlink" title="1.表格直接以源码显示无渲染"></a>1.表格直接以源码显示无渲染</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>| 左对齐 | 右对齐 | 居中对齐 |<br>| :—-| —-: | :——: |<br>| 单元格aaaaaaaaaa | 单aaaaaaaaaaaaaa元格 | 单元aaaaaaaaaaa格 |<br>| 单元格 | 单元格 | 单元格 |<br>| 单 | 单 | 单 |  </p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul><li>表格和正文之间空两行。  </li><li>Markdown中生成的表格十分简洁，这倒也符合快速的特点，如果想自定义样式，通过嵌入css实现，例如本例。  </li><li>我使用的Hacker主题，通用样式文件存放在themes\Hacker\source\css\base\normalize.css，对这种通用性的追加即可，其他主题同理。</li></ul><table><thead><tr><th align="left">居中对齐</th><th align="right">对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单</td><td align="right">单</td><td align="center">单</td></tr></tbody></table><h3 id="待解决"><a href="#待解决" class="headerlink" title="待解决"></a>待解决</h3><p>  表格正常显示之后，对齐方式却不生效，网上没找到和我一样问题的，不过这个需求也不大，或许只能通过css解决。</p><h2 id="2-lt-kbd-gt-无样式"><a href="#2-lt-kbd-gt-无样式" class="headerlink" title="2.&lt;kbd&gt;无样式"></a>2.&lt;kbd&gt;无样式</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>比如这个kbd标签，Ctrl ，看起来很不明显有没有，大概率本来就这样，但是我一开始希望它是这样：<block style="display:inline-block;"><img src="/images/Hexo-Markdown-nonsupport/ctrl.PNG" class="" width="50" height="50" title="ctrl" alt="ctrl"></block></p><blockquote><p>提示: &lt;kbd&gt; 标签已废弃，不推荐使用，但是可以通过CSS实现丰富的效果。<br>——<a href="https://www.runoob.com/tags/tag-kbd.html">HTML&lt;kbd&gt;标签</a></p></blockquote><h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><p>因为我感觉这个会很常用，但我给它加了css样式，还不错。<kbd>Ctrl</kbd></p><h2 id="3-插入-lt-table-gt-不渲染"><a href="#3-插入-lt-table-gt-不渲染" class="headerlink" title="3.插入&lt;table&gt;不渲染"></a>3.插入&lt;table&gt;不渲染</h2><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>我在HTML里面测试好table，再将整个&lt;table&gt;&lt;/table&gt;粘贴到VSC的md文件中，但是这时HTML标签不渲染，直接以源码显示。</p><h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><ul><li>先在md中手写&lt;table&gt;&lt;/table&gt;这两个标签，再将table里面的内容粘过去，不要开始和结束标签。</li><li>或者可能是HTML代码中有空行！</li></ul><h2 id="4-插入HTML标签产生大量换行"><a href="#4-插入HTML标签产生大量换行" class="headerlink" title="4.插入HTML标签产生大量换行"></a>4.插入HTML标签产生大量换行</h2><h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><p>插入HTML标签产生大量换行</p><h3 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h3><p>将HTML标签之间的空格删除，也就是写到一行中。</p><h2 id="5-目录跳转无反应"><a href="#5-目录跳转无反应" class="headerlink" title="5.目录跳转无反应"></a>5.目录跳转无反应</h2><h3 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h3><p>因为本主题（或是别的问题）不会生成文章目录结构，所以我一般写完后用MarkdownAllinOne生成目录，但是点击无反应，不跳转。</p><h3 id="解决-4"><a href="#解决-4" class="headerlink" title="解决"></a>解决</h3><ul><li><p>首先标题里不能有符号<br>如果标题为”&amp;总结”，但MarkdownAllinOne生成目录自动链接到”#总结”，Hexo渲染出的HTML源码却是：</p><p><code>&lt;h2 id=&quot;amp-总结&quot;&gt;&lt;a href=&quot;#amp-总结&quot; class=&quot;headerlink&quot; title=&quot;&amp;amp;总结&quot;&gt;&lt;/a&gt;&amp;amp;总结&lt;/h2&gt;</code></p><p>这样看来，”#amp-总结”才是正确跳转。</p></li><li><p>若大小写原因，关闭MarkdownAllinOne扩展的自动转换小写选项<br>去<kbd>扩展设置</kbd>里关闭。  </p><p><img src="/images/Hexo-Markdown-nonsupport/mdPlugin1.PNG" alt="mdPlugin2.PNG"></p><p><em><strong>（！这不是必须的，只是为了方便，顺便关闭自动更新目录）</strong></em></p><p><img src="/images/Hexo-Markdown-nonsupport/mdPlugin2.PNG" alt="mdPlugin1.PNG"></p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关键还得搞清楚Hexo生成的是静态页面这个大方向，然后根据自己想法发挥。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Hexo站上用Markdown写博时发现好多语法失效问题，记录一下&lt;/p&gt;</summary>
    
    
    
    <category term="Log" scheme="https://memorykk.cn/categories/Log/"/>
    
    
    <category term="Hexo" scheme="https://memorykk.cn/tags/Hexo/"/>
    
    <category term="Markdown" scheme="https://memorykk.cn/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Markdown</title>
    <link href="https://memorykk.cn/Markdown.html"/>
    <id>https://memorykk.cn/Markdown.html</id>
    <published>2021-02-13T02:52:04.000Z</published>
    <updated>2021-02-13T11:47:47.155Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown是一种轻量级标记语言，以纯文本格式快速编写文档。</p><span id="more"></span><ul><li>Markdown编写的文档后缀为 .md、.markdown，可以导出HTML、Word、图像、PDF、Epub等多种格式的文档。  </li><li>Hexo、github等支持使用markdown编辑器编写文章，刚好边学边练。</li><li>可以通过css的方式，美化Hexo元素，嵌入style 标签，在生成html时，style标签也随之写入到html页面中，产生自定义效果。</li></ul><hr><p><strong>目录</strong></p><ul><li><a href="#markdown%E8%AF%AD%E6%B3%95">Markdown语法</a><ul><li><a href="#%E6%A0%87%E9%A2%98">标题</a></li><li><a href="#%E5%AD%97%E4%BD%93">字体</a></li><li><a href="#%E6%8D%A2%E8%A1%8C">换行</a></li><li><a href="#%E5%88%86%E9%9A%94%E7%BA%BF">分隔线</a></li><li><a href="#%E8%84%9A%E6%B3%A8">脚注</a></li><li><a href="#%E5%88%97%E8%A1%A8">列表</a></li><li><a href="#%E5%8C%BA%E5%9D%97">区块</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li><li><a href="#%E9%93%BE%E6%8E%A5">链接</a></li><li><a href="#%E5%9B%BE%E7%89%87">图片</a></li><li><a href="#%E8%A1%A8%E6%A0%BC">表格</a></li><li><a href="#%E6%94%AF%E6%8C%81%E7%9A%84html%E5%85%83%E7%B4%A0">支持的HTML元素</a></li><li><a href="#%E8%BD%AC%E4%B9%89">转义</a></li><li><a href="#%E5%85%AC%E5%BC%8F">公式</a></li><li><a href="#%E7%94%BB%E5%9B%BE">画图</a></li></ul></li><li><a href="#markdown%E5%B7%A5%E5%85%B7">Markdown工具</a></li><li><a href="#%E6%8E%A8%E8%8D%90">推荐</a></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><hr><h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用<kbd>#</kbd>标记标题，1-6个<kbd>#</kbd>标识1-6级标题。<br><em>（markdown语法中的关键字之后一般要加一个空格）</em><br>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><ul><li>斜体<br>使用一个<kbd>*</kbd>包起来</li><li>加粗<br>使用两个<kbd>*</kbd>包起来</li><li>斜体加粗<br>使用三个<kbd>*</kbd>包起来</li><li>删除线<br>使用两个<kbd>~</kbd>包起来</li><li>下划线<br>使用HTML的<kbd>&lt;u>&lt;/u></kbd>包起来</li></ul><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*这是倾斜的文字*</span></span><br><span class="line"><span class="strong">**这是加粗的文字**</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*这是斜体加粗的文字<span class="strong">**<span class="emphasis">*</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">~~这是加删除线的文字~~</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>这是加下划线的文字<span class="xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span></span></span></span></span><br></pre></td></tr></table></figure><p>效果如下：<br><em>这是倾斜的文字</em><br><strong>这是加粗的文字</strong><br><em><strong>这是斜体加粗的文字</strong></em><br><del>这是加删除线的文字</del><br><u>这是加下划线的文字</u></p><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>markdown源文件中的回车不会换行，必须使用<kbd>两个空格+回车</kbd>或者<kbd>两个回车</kbd>。</p><p>示例 <em>（注意第一段之后的空格）</em>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一段  </span><br><span class="line">第二段</span><br><span class="line"></span><br><span class="line">第三段</span><br></pre></td></tr></table></figure><p>效果如下：</p><p>第一段<br>第二段</p><p>第三段</p><h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p>在一行中用三个以上的<kbd>*</kbd>、<kbd>-</kbd>、<kbd>_</kbd>来建分隔线，显示效果一致，行内不能有其他东西，但可以在行内插入空格。</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="strong"><span class="emphasis">---</span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong">__<span class="emphasis">_</span></span></span></span></span><br></pre></td></tr></table></figure><p>效果如下：</p><hr><hr><hr><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a><del>脚注</del></h2><p><strong>！貌似无法使用</strong><br>脚注是对文本的补充说明，鼠标悬停即可查看，使用<kbd>[^要注明的文本]</kbd>，在之后任意位置重复<kbd>[^要注明的文本]:补充内容</kbd>。</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Welcome To [^Memorykk&#x27;s Blog]</span><br><span class="line">[<span class="symbol">^Memorykk&#x27;s Blog</span>]: <span class="link">https://memorykk.cn</span></span><br></pre></td></tr></table></figure><p>效果如下：<br>Welcome To [^ Memorykk ]<br>[^ Memorykk ]: <a href="https://memorykk.cn/">https://memorykk.cn</a><br>参考：<img src="https://www.runoob.com/wp-content/uploads/2019/03/md5.gif" alt="参考示例"></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表使用<kbd>*</kbd>、<kbd>+</kbd>、<kbd>-</kbd>标记，追加列表内容，三者无差异。</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> 第一项</span><br><span class="line"><span class="bullet">+</span> 第二项</span><br><span class="line"><span class="bullet">-</span> 第三项</span><br></pre></td></tr></table></figure><p>效果如下：  </p><ul><li>第一项</li></ul><ul><li>第二项</li></ul><ul><li>第三项</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表使用数字+<kbd>.</kbd>标记。</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一项</span><br><span class="line"><span class="bullet">2.</span> 第二项</span><br></pre></td></tr></table></figure><p>效果如下：  </p><ol><li>第一项</li><li>第二项</li></ol><h3 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h3><p>子列表的选项前加四个空格即可。</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一项</span><br><span class="line"><span class="bullet">    *</span> 元素1</span><br><span class="line"><span class="bullet">    *</span> 元素2</span><br><span class="line"><span class="bullet">2.</span> 第二项</span><br><span class="line"><span class="bullet">    -</span> 元素3</span><br><span class="line"><span class="bullet">    -</span> 元素4</span><br></pre></td></tr></table></figure><p>效果如下：  </p><blockquote><ol><li>第一项<ul><li>元素1</li><li>元素2</li></ul></li><li>第二项<ul><li>元素3</li><li>元素4</li></ul></li></ol></blockquote><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>区块使用<kbd>></kbd>标记，追加区块内容。<br>区块支持嵌套，一个<kbd>></kbd>为最外层，两个<kbd>></kbd>为第一层嵌套，以此类推。<br>另外，区块可与列表等随意嵌套。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 1. 第一项</span></span><br><span class="line"><span class="quote">&gt;     <span class="emphasis">* 元素1</span></span></span><br><span class="line"><span class="quote"><span class="emphasis">&gt;     *</span> 元素2</span></span><br><span class="line"><span class="bullet">2.</span> 第二项</span><br><span class="line"><span class="code">    &gt; - 元素3</span></span><br><span class="line"><span class="code">    &gt; - 元素4</span></span><br></pre></td></tr></table></figure><p>效果如下：  </p><blockquote><ol><li>第一项<ul><li>元素1</li><li>元素2</li></ul></li><li>第二项<ul><li>元素3</li><li>元素4</li></ul></li></ol></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="单行代码"><a href="#单行代码" class="headerlink" title="单行代码"></a>单行代码</h3><p>使用一个<kbd>`</kbd>将代码包起来。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">`System.out.println(&quot;Hello World!&quot;);`</span></span><br></pre></td></tr></table></figure><p>效果如下：<br><code>System.out.println(&quot;Hello World!&quot;);</code></p><h3 id="多行代码"><a href="#多行代码" class="headerlink" title="多行代码"></a>多行代码</h3><p>使用六个<kbd>`</kbd>将代码包起来，前三个<kbd>`</kbd>接代码语言，也可不指定。</p><p>示例：<em>（为了防止编辑器转义，在前后加了前后括号，实际使用中不能写哦~）</em></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">（<span class="code">```java</span></span><br><span class="line"><span class="code">System.out.println(&quot;Hello&quot;);</span></span><br><span class="line"><span class="code">System.out.println(&quot;World&quot;);</span></span><br><span class="line"><span class="code">System.out.println(&quot;!&quot;);</span></span><br><span class="line"><span class="code">```）</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;!&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="普通链接"><a href="#普通链接" class="headerlink" title="普通链接"></a>普通链接</h3><p>使用<kbd>[链接名称]</kbd><kbd>(链接地址)</kbd>或者直接<kbd><链接地址></kbd>标记。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">Memorykk&#x27;s Blog</span>](<span class="link">https://memorykk.cn</span>)  </span><br><span class="line"><span class="xml">&lt;https://www.memorykkk.cn&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：<br><a href="https://memorykk.cn/">Memorykk’s Blog</a><br><a href="https://www.memorykkk.cn/">https://www.memorykkk.cn</a></p><h3 id="高级链接"><a href="#高级链接" class="headerlink" title="高级链接"></a>高级链接</h3><p>通过变量来设置一个链接，变量赋值在文档末尾。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这个链接赋给变量1：[<span class="string">Memorykk&#x27;s Blog</span>][<span class="symbol">1</span>]</span><br><span class="line">这个链接赋给变量google：[<span class="string">GOOGLE</span>][<span class="symbol">google</span>]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">1</span>]: <span class="link">https://memorykk.cn</span></span><br><span class="line">[<span class="symbol">google</span>]: <span class="link">https://www.google.com</span></span><br></pre></td></tr></table></figure><p>效果如下：<br>这个链接赋给变量1：<a href="https://memorykk.cn/">Memorykk’s Blog</a><br>这个链接赋给变量google：<a href="https://www.google.com/">GOOGLE</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>使用<kbd>![alt文本]</kbd><kbd>(图片链接 "可选标题")</kbd>标记。<br>markdown不支持指定宽高，可使用HTML &lt;img&gt;标签标记。<br>可以制作图片链接</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">Github.ico</span>](<span class="link">https://github.githubassets.com/favicons/favicon.svg</span>)</span><br></pre></td></tr></table></figure><p>效果如下：<br><img src="https://github.githubassets.com/favicons/favicon.svg" alt="Github.ico"></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>使用<kbd>|</kbd>标记单元格，使用<kbd>-</kbd>分隔表头和其他行，还可设置对其方式：</p><ul><li><kbd>-:</kbd>设置内容和标题栏居右对齐。</li><li><kbd>:-</kbd>设置内容和标题栏居左对齐。</li><li><kbd>:-:</kbd>设置内容和标题栏居中对齐。  </li></ul><hr><ul><li>:之间多余的空格会被忽略</li><li>的数量至少一个</li><li>内容和|之间多余的空格会被忽略</li></ul><p>示例：<em>（但是本页并未生效，Hexo的问题？）</em></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :------| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单 | 单 | 单 |</span><br></pre></td></tr></table></figure><p>效果如下：  </p><p><img src="/images/Markdown/table.PNG" alt="table.PNG"></p><h2 id="支持的HTML元素"><a href="#支持的HTML元素" class="headerlink" title="支持的HTML元素"></a>支持的HTML元素</h2><p>直接在文档里面用 HTML 撰写。<br>目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等。</p><h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符反斜杠<kbd>\</kbd>。<br>目前支持的特殊字符：<br><kbd>\</kbd>、<kbd>`</kbd>、<kbd>*</kbd>、<kbd>_</kbd>、<kbd>{}</kbd>、<kbd>[]</kbd>、<kbd>()</kbd>、<kbd>#</kbd>、<kbd>+</kbd>、<kbd>-</kbd>、<kbd>.</kbd>、<kbd>!</kbd>、<kbd>HTML元素</kbd>。</p><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>使用两个<kbd>$</kbd>包裹 TeX 或 LaTeX 格式的数学公式。<br>提交后会根据需要加载 Mathjax 对数学公式进行渲染。</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\lim<span class="emphasis">_&#123;x \to 0&#125; \frac&#123;3x^2 +7x^3&#125;&#123;x^2 +5x^4&#125; = 3</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><p>效果如下：<br>$$<br>\lim_{x \to 0} \frac{3x^2 +7x^3}{x^2 +5x^4} = 3<br>$$</p><h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><p>参考 <a href="https://www.runoob.com/markdown/md-advance.html">菜鸟教程</a></p><h1 id="Markdown工具"><a href="#Markdown工具" class="headerlink" title="Markdown工具"></a>Markdown工具</h1><p>目前我使用的是Visual Studio Code，默认支持markdown编辑以及即时预览，配合插件十分好用：  </p><ul><li><a href="https://marketplace.visualstudio.com/items?itemName=bierner.markdown-preview-github-styles">Markdown Preview Github Styling</a>：预览您的Markdown在Github上呈现的样子</li><li><a href="https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one">Markdown All in One</a>Markdown所需的全部功能（键盘快捷键、目录、自动预览等）</li></ul><h1 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h1><p>  <a href="Hexo-Markdown-nonsupport.html">Hexo中Markdown语法失效问题</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.runoob.com/markdown">Markdown教程</a></li><li><a href="https://www.jianshu.com/p/191d1e21f7ed">Markdown基本语法</a></li><li><a href="https://javahikers.github.io/2019/05/04/markdown-simple-to-use/">markdown简明使用方法</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Markdown是一种轻量级标记语言，以纯文本格式快速编写文档。&lt;/p&gt;</summary>
    
    
    
    <category term="Tool" scheme="https://memorykk.cn/categories/Tool/"/>
    
    
    <category term="Markdown" scheme="https://memorykk.cn/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://memorykk.cn/hello-world.html"/>
    <id>https://memorykk.cn/hello-world.html</id>
    <published>2021-02-11T15:59:59.000Z</published>
    <updated>2021-02-12T12:09:08.216Z</updated>
    
    <content type="html"><![CDATA[<p>照例写个HelloWorld占好位置。</p><span id="more"></span><p>这里是正文。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;照例写个HelloWorld占好位置。&lt;/p&gt;</summary>
    
    
    
    <category term="Fragment" scheme="https://memorykk.cn/categories/Fragment/"/>
    
    
    <category term="Hexo" scheme="https://memorykk.cn/tags/Hexo/"/>
    
  </entry>
  
</feed>
