<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Memorykk</title>
  
  <subtitle>never too late to learn</subtitle>
  <link href="https://memorykk.cn/atom.xml" rel="self"/>
  
  <link href="https://memorykk.cn/"/>
  <updated>2021-03-26T09:46:03.181Z</updated>
  <id>https://memorykk.cn/</id>
  
  <author>
    <name>Memorykk</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统笔记</title>
    <link href="https://memorykk.cn/os-interview.html"/>
    <id>https://memorykk.cn/os-interview.html</id>
    <published>2021-03-24T10:10:19.000Z</published>
    <updated>2021-03-26T09:46:03.181Z</updated>
    
    <content type="html"><![CDATA[<p>概述、启动中断异常和系统调用、连续内存分配、非连续内存分配、虚拟内存、页面置换算法、进程、处理器调度、同步互斥问题、死锁问题。</p><p>4万字，247张图，80页，超长总结。</p><span id="more"></span><hr><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0">1. 操作系统概述</a><ul><li><a href="#1-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8">1.1. 操作系统的启动</a></li><li><a href="#1-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84">1.2. 操作系统的结构</a></li></ul></li><li><a href="#2-%E5%90%AF%E5%8A%A8%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">2. 启动、中断、异常和系统调用</a><ul><li><a href="#2-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8">2.1. 操作系统的启动</a></li><li><a href="#2-2-%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">2.2. 中断、异常、和系统调用</a></li></ul></li><li><a href="#3-%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">3. 连续内存分配</a><ul><li><a href="#3-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E5%86%85%E5%AD%98%E5%88%86%E5%B1%82%E4%BD%93%E7%B3%BB">3.1. 计算机体系结构及内存分层体系</a></li><li><a href="#3-2-%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8E%8B%E7%BC%A9%E5%BC%8F%E4%B8%8E%E4%BA%A4%E6%8D%A2%E5%BC%8F%E7%A2%8E%E7%89%87%E6%95%B4%E7%90%86">3.2. 连续内存分配：压缩式与交换式碎片整理</a></li></ul></li><li><a href="#4-%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">4. 非连续内存分配</a><ul><li><a href="#4-1-%E5%88%86%E6%AE%B5">4.1. 分段</a></li><li><a href="#4-2-%E5%88%86%E9%A1%B5">4.2. 分页</a></li><li><a href="#4-3-%E9%A1%B5%E8%A1%A8TLB">4.3. 页表、TLB</a></li><li><a href="#4-4-%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8">4.4. 多级页表</a></li><li><a href="#4-5-%E5%8F%8D%E5%90%91%E9%A1%B5%E8%A1%A8">4.5. 反向页表</a></li></ul></li><li><a href="#5-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">5. 虚拟内存</a><ul><li><a href="#5-1-%E8%B5%B7%E5%9B%A0">5.1. 起因</a></li><li><a href="#5-2-%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF">5.2. 覆盖技术</a></li><li><a href="#5-3-%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF">5.3. 交换技术</a></li><li><a href="#5-4-%E8%99%9A%E5%AD%98%E6%8A%80%E6%9C%AF">5.4. 虚存技术</a></li></ul></li><li><a href="#6-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">6. 页面置换算法</a><ul><li><a href="#6-1-%E6%9C%80%E4%BC%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">6.1. 最优页面置换算法</a></li><li><a href="#6-2-%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%AE%97%E6%B3%95">6.2. 先进先出算法</a></li><li><a href="#6-3-%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95">6.3. 最近最久未使用算法</a></li><li><a href="#6-4-%E6%97%B6%E9%92%9F%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">6.4. 时钟页面置换算法</a></li><li><a href="#6-5-%E4%BA%8C%E6%AC%A1%E6%9C%BA%E4%BC%9A%E6%B3%95">6.5. 二次机会法</a></li><li><a href="#6-6-%E6%9C%80%E4%B8%8D%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95">6.6. 最不常用算法</a></li><li><a href="#6-7-BELADY%E7%8E%B0%E8%B1%A1%E6%AF%94%E8%BE%83">6.7. BELADY现象、比较</a></li><li><a href="#6-8-%E9%97%AE%E9%A2%98%E5%B7%A5%E4%BD%9C%E9%9B%86%E6%A8%A1%E5%9E%8B">6.8. 问题、工作集模型</a></li><li><a href="#6-9-%E7%BC%BA%E9%A1%B5%E7%8E%87%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">6.9. 缺页率页面置换算法</a></li><li><a href="#6-1-0-%E6%8A%96%E5%8A%A8%E9%97%AE%E9%A2%98">6.10. 抖动问题</a></li></ul></li><li><a href="#7-%E8%BF%9B%E7%A8%8B">7. 进程</a><ul><li><a href="#7-1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89">7.1. 进程的定义</a></li><li><a href="#7-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90">7.2. 进程的组成</a></li><li><a href="#7-3-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9">7.3. 进程的特点</a></li><li><a href="#7-4-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84">7.4. 进程控制结构</a></li><li><a href="#7-5-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E6%9C%9F%E7%AE%A1%E7%90%86">7.5. 进程的生命期管理</a></li><li><a href="#7-6-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%E6%A8%A1%E5%9E%8B">7.6. 进程状态变化模型</a></li><li><a href="#7-7-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8C%82%E8%B5%B7">7.7. 进程的挂起</a></li><li><a href="#7-8-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B">7.8. 为什么使用线程</a></li><li><a href="#7-9-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B">7.9. 什么是线程</a></li><li><a href="#7-1-0-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0">7.10. 线程的实现</a></li><li><a href="#7-1-1-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2">7.11. 上下文切换</a></li><li><a href="#7-1-2-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B">7.12. 进程控制—创建进程</a></li><li><a href="#7-1-3-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B">7.13. 进程控制—加载和执行过程</a></li><li><a href="#7-1-4-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%AD%89%E5%BE%85%E5%92%8C%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B">7.14. 进程控制—等待和终止进程</a></li></ul></li><li><a href="#8-%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6">8. 处理器调度</a><ul><li><a href="#8-1-%E8%83%8C%E6%99%AF">8.1. 背景</a></li><li><a href="#8-2-%E8%B0%83%E5%BA%A6%E5%8E%9F%E5%88%99">8.2. 调度原则</a></li><li><a href="#8-3-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">8.3. 调度算法</a></li><li><a href="#8-4-%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6">8.4. 实时调度</a></li></ul></li><li><a href="#9-%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98">9. 同步互斥问题</a><ul><li><a href="#9-1-%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86">9.1. 背景知识</a></li><li><a href="#9-2-%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5PART1">9.2. 一些概念PART1</a></li><li><a href="#9-3-%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5PART2">9.3. 一些概念PART2</a></li><li><a href="#9-4-%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5PART3">9.4. 一些概念PART3</a></li><li><a href="#9-5-%E4%B8%B4%E7%95%8C%E5%8C%BA">9.5. 临界区</a></li><li><a href="#9-6-%E7%A6%81%E7%94%A8%E7%A1%AC%E4%BB%B6%E4%B8%AD%E6%96%AD">9.6. 禁用硬件中断</a></li><li><a href="#9-7-%E5%9F%BA%E4%BA%8E%E8%BD%AF%E4%BB%B6%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">9.7. 基于软件的解决方案</a></li><li><a href="#9-8-%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84%E6%8A%BD%E8%B1%A1--%E5%9F%BA%E4%BA%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C">9.8. 更高级的抽象 — 基于原子操作</a></li></ul></li><li><a href="#1-0-%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%A8%8B">10. 信号量与管程</a><ul><li><a href="#1-0-1-%E8%83%8C%E6%99%AF">10.1. 背景</a></li><li><a href="#1-0-2-%E4%BF%A1%E5%8F%B7%E9%87%8F">10.2. 信号量</a></li><li><a href="#1-0-3-%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8">10.3. 信号量的使用</a></li><li><a href="#1-0-4-%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0">10.4. 信号量的实现</a></li><li><a href="#1-0-5-%E7%AE%A1%E7%A8%8B">10.5. 管程</a></li><li><a href="#1-0-6-%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%981----%E8%AF%BB%E8%80%85%E4%BC%98%E5%85%88%E8%AF%BB%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98">10.6. 经典同步问题1—-读者优先读写者问题</a></li><li><a href="#1-0-7-%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%981%E5%86%99%E8%80%85%E4%BC%98%E5%85%88%E8%AF%BB%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98">10.7. 经典同步问题1—写者优先读写者问题</a></li><li><a href="#1-0-8-%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%982%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98">10.8. 经典同步问题2—哲学家就餐问题</a></li></ul></li><li><a href="#1-1-%E6%AD%BB%E9%94%81">11. 死锁</a><ul><li><a href="#1-1-1-%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98">11.1. 死锁问题</a></li><li><a href="#1-1-2-%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B">11.2. 系统模型</a></li><li><a href="#1-1-3-%E6%AD%BB%E9%94%81%E7%9A%84%E7%89%B9%E5%BE%81">11.3. 死锁的特征</a></li><li><a href="#1-1-4-%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86%E5%8A%9E%E6%B3%95">11.4. 死锁处理办法</a></li><li><a href="#1-1-5-%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2%E5%92%8C%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D">11.5. 死锁预防和死锁避免</a></li><li><a href="#1-1-6-%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E5%92%8C%E6%AD%BB%E9%94%81%E6%81%A2%E5%A4%8D">11.6. 死锁检测和死锁恢复</a></li><li><a href="#1-1-7-IPC%E6%A6%82%E8%BF%B0">11.7. IPC概述</a></li><li><a href="#1-1-8-%E4%BF%A1%E5%8F%B7%E7%AE%A1%E9%81%93%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98">11.8. 信号，管道，消息队列和共享内存</a><!-- /TOC --></li></ul></li></ul><hr><h1 id="1-操作系统概述"><a href="#1-操作系统概述" class="headerlink" title="1. 操作系统概述"></a>1. 操作系统概述</h1><h2 id="1-1-操作系统的启动"><a href="#1-1-操作系统的启动" class="headerlink" title="1.1. 操作系统的启动"></a>1.1. 操作系统的启动</h2><p>用户角度：操作系统是一个控制软件</p><ul><li>管理应用程序</li><li>为应用程序提供服务</li><li>杀死应用程序</li><li>资源管理</li><li>管理外设/分配资源</li></ul><ol><li>在操作系统下，进程&lt;-&gt;CPU, 文件&lt;-&gt;磁盘，地址空间&lt;-&gt;内存。</li><li>操作系统的架构层次：硬件之上，应用软件之下(为应用软件提供服务支持)。</li><li>Linux，Windows界面属于外壳shell(与User交互)，而不是内核kernel，而kernel是研究重点，在shell之下。</li><li>Kernel包括：</li></ol><ul><li>CPU调度器</li><li>物理内存管理</li><li>虚拟内存管理</li><li>文件系统管理</li><li>中断处理和IO设备驱动 (底层硬件)</li></ul><ol start="5"><li>OS Kernel的特征：</li></ol><ul><li>并发(指一段时间内多个程序运行；而并行是指一个时间点上多个程序运行，要求多个CPU):计算机系统中同时存在多个运行的程序，需要OS管理和调度</li><li>共享：“同时”访问 或 互斥共享</li><li>虚拟：利用多道程序设计技术，让每一个用户都觉得有一个计算机专门为他服务</li><li>异步：程序的执行不是一步到底的，而是走走停停，向前推进的速度不可预知<br>但只要运行环境相同，OS要保证程序运行的结果也相同</li></ul><h2 id="1-2-操作系统的结构"><a href="#1-2-操作系统的结构" class="headerlink" title="1.2. 操作系统的结构"></a>1.2. 操作系统的结构</h2><ol><li>简单的操作系统：MS-DOS 不分模块的单体内核 (内部通过函数调用访问,缺点，复杂，紧耦合，易受攻击)</li><li>微内核，尽可能把内核功能移植到用户空间，缺点性能低。</li><li>外核，内核分为一块，一块负责和硬件打交道，另一部分和应用打交道。</li><li>虚拟机,VMs(虚拟机)-&gt;VMM(虚拟机监视器)-&gt;物理机硬件，多操作系统共享硬件资源。</li></ol><h1 id="2-启动、中断、异常和系统调用"><a href="#2-启动、中断、异常和系统调用" class="headerlink" title="2. 启动、中断、异常和系统调用"></a>2. 启动、中断、异常和系统调用</h1><h2 id="2-1-操作系统的启动"><a href="#2-1-操作系统的启动" class="headerlink" title="2.1. 操作系统的启动"></a>2.1. 操作系统的启动</h2><ol><li>CPU, I/O, 内存通过总线连接。</li><li>DISK:存放OS；<br>BIOS：基本I/O处理系统( basic I/O system); Bootloader: 加载OS到内存中。</li><li>当电脑通电时，段寄存器CS和指令寄存器IP能够确定一个内存地址，例如CS:IP = 0xf000:fff0.</li><li>POST(加电自检)，寻找显卡和执行BIOS。(显示器，键盘…是否正常)。</li><li>步骤：</li></ol><ul><li>BIOS: 将Bootloader从磁盘的磁盘的引导扇区(512字节)加载到0x7c00；跳转到CS:IP=0000:7c00的内存区域(以便下一步)</li><li>Bootloader：将操作系统的代码和数据从硬盘加载到内存中；跳转到操作系统的起始地址。</li></ul><p><img src="/images/os-interview/osStart"></p><ol start="6"><li><p>系统调用：(来源于应用程序)应用程序主动向操作系统发出服务请求。</p></li><li><p>异常：(来源于不良的应用程序)非法指令或其它花的处理状态(e.g.内存出错)。</p></li><li><p>中断：(来源于外设)来自不同的硬件设备的计时器和网络的中断。</p></li><li><p>为什么应用程序不能直接访问硬件而是通过操作系统？</p></li></ol><ul><li>计算机运行时，内核是被信任的第三方。</li><li>只有内核可以执行特权指令。</li><li>为了方便应用程序。</li></ul><ol start="10"><li><p>讨论的问题：操作系统如何设计和实现中断/异常和系统调用；他们三者的区别和特点。</p></li><li><p>产生的源头</p></li></ol><ul><li>中断：外设(键盘/鼠标/网卡/声卡/显卡，可以产生各种事件)</li><li>异常：应用程序意想不到的行为(e.g.异常，恶意程序，应用程序需要的资源未得到满足)</li><li>系统调用(system call)：应用程序请求操作提供服务(e.g.打开/关闭/读写文件，发送网络包)</li></ul><ol start="12"><li>处理时间</li></ol><ul><li>中断：异步；</li><li>异常：同步；</li><li>系统调用：同步或异步。</li></ul><ol start="13"><li>响应</li></ol><ul><li>中断：持续，对用户应用程序时透明的</li><li>异常：杀死或者重新执行意想不到的应用程序指令</li><li>系统调用：等待和持续</li></ul><h2 id="2-2-中断、异常、和系统调用"><a href="#2-2-中断、异常、和系统调用" class="headerlink" title="2.2. 中断、异常、和系统调用"></a>2.2. 中断、异常、和系统调用</h2><p>中断和异常的处理机制<br>中断是外设的事件<br>异常是内部迫使cpu访问一些被中断和异常服务访问的功能</p><p>中断和异常都一个硬件的处理过程和软件的处理过程，两者和在一起才构成操作系统的具体服务。<br>将中断和异常编号容易区分，每一个编号有一个对应的地址。<br>这些中断号会构成一个表，当发生中断或者是异常的时候，只需要去查找这个表，就可以容易查找到对应是哪一个。</p><p>中断的处理过程：（包括软件和硬件）<br>硬件：设置中断标记[cpu初始化]</p><ol><li>将内部、外部事件设置中断标记</li><li>中断事件的ID<br>软件：</li><li>保存当前的处理状态。便于后续从打断的点继续完成。</li><li>中断服务程序处理</li><li>清楚中断标记</li><li>恢复之前保存的处理状态</li></ol><p>异常的处理过程：（异常也会有一个异常的编号）</p><ol><li>保存现场</li><li>异常处理</li></ol><ul><li>杀死产生了异常的程序</li><li>重新执行异常指令，重新执行这个指令，程序可以继续的执行。</li></ul><ol start="3"><li>恢复现场</li></ol><p>系统调用：<br>程序访问主要是通过高层次的API接口，而不是直接进行系统调用。</p><p>这些API定义了可以提供哪些系统调用</p><p>通常情况下，与每个系统调用相关的序号<br>系统调用接口根据这些序号来维护表的索引。<br>系统调用接口调用内核态中预期的系统调用<br>并返回系统调用的状态和其他任何返回值<br>用户不需要知道系统调用是如何实现的</p><ul><li>只需要获取API和了解操作新系统将什么作为返回结果</li><li>操作系统接口的细节大部分都隐藏在API中</li><li>通过运行程序支持的库来管理（用包含编译器的库来创建函数集）<br>两个概念：用户态和内核态</li></ul><p>用户态：<br>应用程序在执行的过程中，cpu所处于的一个特权级的状态，其特权级特别低，不能访问某些特殊的机器指令和io<br>内核态：<br>操作系统运行过程中cpu所处于的一个状态，cpu可以执行任何的一条特权指令和io，可以完全的控制这个计算机系统<br><strong>ps</strong>当一个应用程序调用一个系统调用的时候，会完成从用户态到内核态的转换，从而使控制权从应用程序交到了操作系统来。操作系统就是可以对系统调用识别来完成具体的服务。</p><p>函数的调用和系统调用的区别：<br>函数的调用只是简单的在一个栈空间里完成函数的调用和返回。而在系统调用过程中，由于应用程序和内核都有各自的堆栈，所以这回涉及到一个堆栈的切换，还会涉及特权级的转换，从用户态转换到内核态。这个是有消耗的，但是会换来安全和可靠。</p><p>跨越操作系统边界的开销：</p><ol><li>建立中断、异常、系统调用号与对应服务例程映射关系的初始化开销，并且会有一个映射的表，需要对这个表进行维护。</li><li>操作系统有自己堆栈，需要对这个堆栈进行维护有消耗。（当然，应用程序也有自己的堆栈）</li><li>操作系统不信任应用程序，会对参数进行检查，会有一个时间是上的开销。</li><li>数据的内存拷贝，从内核到用户空间，会有一个拷贝的开销。</li></ol><h1 id="3-连续内存分配"><a href="#3-连续内存分配" class="headerlink" title="3. 连续内存分配"></a>3. 连续内存分配</h1><h2 id="3-1-计算机体系结构及内存分层体系"><a href="#3-1-计算机体系结构及内存分层体系" class="headerlink" title="3.1. 计算机体系结构及内存分层体系"></a>3.1. 计算机体系结构及内存分层体系</h2><p>计算机体系结构/内存分层体系内容：</p><ul><li>计算机系统结构</li><li>内存分层体系</li><li>在操作系统的内存管理范例</li></ul><p>一、计算机系统结构主要包含了三大内容：</p><ul><li>cpu：完成对整个程序的控制</li><li>内存：放置了程序的代码和管理的数据</li><li>外设：配合程序发挥更大的作用</li></ul><p><img src="/images/os-interview/os31.png"></p><p>二、内存的层次机构：cpu要访问的指令和数据所处的位置在什么地方</p><p><img src="/images/os-interview/os32.png"></p><p>cpu寄存器，cache：都是处于cpu内部，速度很快，容量很少，可以放的数据有限<br>主存，物理内存：容量大，但是速度小<br>硬盘：需要永久保存的数据就放在硬盘中，掉电也不会丢失，速度更慢，但是容量更大</p><p>三、操作系统到底要完成的重点事情</p><p><img src="/images/os-interview/os33.png"></p><ul><li>可以抽象出来，只需要考虑连续的地址空间，而不需要考虑细节</li><li>保护进程空间，有一个隔离的机制，避免应用程序破坏别人</li><li>进程空间的通信，共享的空间，使数据的传递安全，有效的</li><li>让正在运行的程序，放在内存汇总，让暂时不需要的访问的数据可以临时的放在硬盘中。（例如p4）</li></ul><p>四、两种不同的空间<br>主存硬盘的物理地址空间<br>运行程序锁看见的空间是逻辑地址空间</p><p>五、在操作系统中管理内存的不同方法<br>程序重定位，分段，分页，虚拟内存，按需分页虚拟内存<br>ps：其实现高度依赖于硬件，必须知道内存架构，MMU（内存管理单元）：硬件组件负责处理cpu的内存访问请求。</p><p>3.2地址空间与地址生成<br>涉及到几点：</p><ul><li>地址空间定义</li><li>地址生成</li><li>地址的安全检查</li></ul><p>一、地址空间的定义</p><ul><li>物理地址空间—与硬件直接对于（例如内存条所代表的主存）</li><li>逻辑地址空间—程序所看见的地址空间</li></ul><p><img src="/images/os-interview/os34.png"></p><p>像这条指令一样，其具体的映射关系，需要操作系统来处理的</p><p>二、逻辑地址生成</p><p><img src="/images/os-interview/os35.png"></p><p>执行文件放在内存中去，还是一个逻辑的地址</p><p>三、完成逻辑地址到物理地址的映射过程</p><p><img src="/images/os-interview/os36.png"></p><p>当cpu需要执行这条指令的过程如下：</p><ul><li>ALU运算器需要这条指令的内容</li><li>cpu里面的mmu（内存管理单元）查找逻辑地址的映射表，找出逻辑地址和物理地址之间的映射</li><li>cpu控制器会从总线发送物理地址的内存内容的请求（就是指令的内容）</li><li>主存会把总线拿到的物理地址内存的内容传给cpu<br>其中，操作系统的作用是建立起逻辑地址和物理地址之间的映射。</li></ul><p>四、地址的安全监测的过程</p><p><img src="/images/os-interview/os37.png"></p><p>操作系统的另一个目标是放在内存中的程序相互之间不能互相的干扰</p><ul><li>操作系统首先要确保每一个程序可以有效的访问地址空间。（包括起始地址和地址的长度）。</li><li>map会指出逻辑地址是否满足映射关系，然后就去到相应的物理地址，将指令数据取回来。</li><li>如果不满足，cpu将会产生一个memory异常（内存访问异常）</li></ul><p>3.3连续内存的分配：内存碎片与分区的动态分配<br>连续内存分配所涉及的问题：<br>内存碎片问题<br>分区的动态分配（第一分配，最佳适配，最差适配）<br>压缩式碎片整理<br>交换式碎片整理</p><p>一、内存碎片问题<br>可以理解为当给一个运行的程序分配一个空间之后，会出现一些无法进一步利用的空间。<br>1.外部碎片：分配单元之间无法利用的空间<br>2.内部碎片：运行的程序无法对所分配好的空间进一步的使用</p><p><img src="/images/os-interview/os38.png"></p><p>二、分区的动态分配<br>什么时候需要分配连续的内存：<br>1.当一个程序准许运行在内存中时候，需要在内存中分配一个连续的区间<br>2.分配一个连续的内存切间给运行的程序以访问数据</p><p><img src="/images/os-interview/os39.png"></p><p>操作系统中会有一些数据结构和算法对空余的内存空间进行有效的管理。<br>以下有三个简单的内存分配的算法。</p><ul><li>首次适配（first fit）</li><li>最优适配（best fit）</li><li>最差适配（worst fit）</li></ul><p>以下分别做简单的介绍：</p><ul><li>首次适配算法（first fit）–第一个内存块</li></ul><p><img src="/images/os-interview/os310.png"></p><p>基本原理和实现：<br>需求：<br>按地址排序的空闲块列表（从0地址开始），分配需要寻找一个合适的分区重分配需要检查，看是否自由分区能合并于相邻的空闲分区（若有）。<br>优点：<br>简单，并且容易产生更大的空闲块（没有被破坏），向这地址空间的结尾<br>缺点：<br>容易产生外碎片，两个空闲块的空间因为比较小，就可以不会被使用，并且随着时间这个特性会加剧。</p><ul><li>最优适配算法（best fit）–最适合分配请求的size</li></ul><p><img src="/images/os-interview/os311.png"></p><p>基本原理和实现：</p><ul><li><p>按尺寸排列空闲块列表</p></li><li><p>分配需要寻找一个合适的分区</p></li><li><p>重分配需要搜索及合并于相邻的空闲分区（若有）<br>优点：<br>对于大多数小内存分配的情况比较合适，比较简单。避免了分割大的空闲块，并且最小化外部碎片产生的尺寸<br>缺点：<br>将外碎片分配得比较细，重分配慢，而且容易产生很多没用的微小碎片（不怎么好）</p></li><li><p>最差适配算法（worst fit）—与请求差距最大的size分配</p></li></ul><p><img src="/images/os-interview/os312.png"></p><p>大块变成了小块，小块进行保留<br>基本原理和实现：</p><ul><li>按差距的尺寸最大进行排列空闲块列表</li><li>分配很快（获得更大的分区）</li><li>重分配需要合并相邻的空间分区（若有），然后调整空闲块列表<br>优点：<br>假如分配是中等尺寸效果最好<br>缺点：<br>易于破坏大的空闲块以致于大分区无法被分配</li></ul><p>小结：应用请求的需求是随机的和可变的，这些算法都不可能满足全部的应用请求的。</p><h2 id="3-2-连续内存分配：压缩式与交换式碎片整理"><a href="#3-2-连续内存分配：压缩式与交换式碎片整理" class="headerlink" title="3.2. 连续内存分配：压缩式与交换式碎片整理"></a>3.2. 连续内存分配：压缩式与交换式碎片整理</h2><p>以下两种方法减少碎片的产生<br>1.压缩式碎片整理<br>2.交互式碎片整理</p><p>一、压缩式（compression）碎片整理<br>重置程序以合并孔洞<br>要求所有程序是动态可重置的<br>内存拷贝前思考两个问题：</p><ul><li>什么时候考虑内存的重定位是合适的<br>当程序处于等待的状态之中可以开始内存的重定位</li><li>考虑开销大不大<br>仅仅利用软件的移动实现开销是很大的</li></ul><p><img src="/images/os-interview/os313.png"></p><p>二、交换式（swap）碎片整理</p><p><img src="/images/os-interview/os314.png"></p><p>考虑几个问题</p><ul><li>考虑将那一个程序拷贝到磁盘中去？</li><li>什么时候做这个换入和换出的操作？</li><li>换入换出的开销？</li></ul><h1 id="4-非连续内存分配"><a href="#4-非连续内存分配" class="headerlink" title="4. 非连续内存分配"></a>4. 非连续内存分配</h1><h2 id="4-1-分段"><a href="#4-1-分段" class="headerlink" title="4.1. 分段"></a>4.1. 分段</h2><p>分段的管理机制分为两点：</p><ul><li>在分段情况下，内存地址空间如何寻址的问题</li><li>如何去实现分段的寻址方案</li></ul><p>一、分段<br>计算机程序是由各种各样的段来存储的</p><p><img src="/images/os-interview/41.png"></p><p>分段：更好的分离和共享</p><p><img src="/images/os-interview/42.png"></p><p>通过分段，可以有效的隔离开来，相应的分离出来，更加有效进行管理，分配和保护。这中间需要一种映射机制来实现相关联。</p><p><img src="/images/os-interview/43.png"></p><p>映射之后：位置不一样，大小也不一样</p><p>二、段的访问机制<br>将一个一维的地址分成两块：<br>一个是段号的寻址，另一个是偏移的寻址</p><p><img src="/images/os-interview/44.png"></p><p>段号+段内偏移何合在一起就形成了一段机制来寻址的方式。<br>分两种情况：</p><ul><li>段寄存器+地址寄存器实现方案（x86）</li><li>将段和段内偏移合在一起，单地址实现方案</li></ul><p>三、将段的映射机制映射起来</p><p><img src="/images/os-interview/45.png"></p><p>过程：<br>1、通过段号找到段所在物理内存的起始地址<br>2、但是这个映射关系需要存储–段表，段表中存储中逻辑地址的段号和物理地址的段号的映射关系。<br>3、段表中存储着两个重要的信息：一个是段表的起始地址，另外一个是段长度的限制，两者合在一起就形成了一个物理地址。<br>4、 这样形成了物理地址之后，根据这个地址来查找在物理内存的位置，然后把相应的数据取出来，交给cpu做进一步的处理</p><p>段表有操作系统来建立，此时段机制就可以正常的工作了。<br>而且段机制用得比较少，现在大多数的cpu用的是分页机制。</p><h2 id="4-2-分页"><a href="#4-2-分页" class="headerlink" title="4.2. 分页"></a>4.2. 分页</h2><p>两个内容：</p><ul><li>分页地址空间</li><li>页寻址方案</li></ul><p>段需要一个段号和段内的偏移，而页也一样，需要页号和页内的偏移。<br>主要区别在于在段的机制里面，段的尺寸是可变的，而分页机制中页的大小是固定的，这个是最大的区别。</p><p>一、页的分类</p><p>划分物理内存至固定大小的帧<br>大小是2的幂，eg：512,4096（4k）,8192<br>划分逻辑地址空间至相同大小的页<br>大小是2的幂，eg：512,4096,8192<br>ps：页的大小是不变的，这样便于硬件对其实现</p><p>页帧（frame）是物理页<br>页（page）逻辑页</p><p>我们需要建立一个逻辑页地址和物理页地址的一个映射关系。<br>建立方案：转换逻辑地址为物理地址（page to frame）</p><ul><li>页表</li><li>MMU（内存管理单元）/TLB（块表）</li></ul><p>二、页帧（frame）—物理地址<br>定义：物理内存的组织和布局方式<br>页帧也有两部分组成：</p><ul><li>页帧号（frame number）</li><li>页帧偏移（frame offset）</li></ul><p><img src="/images/os-interview/46.png"></p><p>页帧号占 F 位，页帧本身的大小占 S 位<br>在整个的寻址空间中有 2^F 这么多个页帧的个数<br>页帧而每一页的总大小是 2^S</p><p><img src="/images/os-interview/47.png"></p><p>解析：<br>一帧包含了9位，所以没一页帧的大小都是2 ^9 这么大小，而页帧号是3，所以代表了有3个这么大的一个页，所以也就是2^9 * 3，最后，再加上偏移量o，为6，所以最后的结果是 2^9 * 3 + 6 = 1542.<br>所以地址就是0x1542</p><p>三、页（page）—逻辑地址<br>和页帧的区别是其页号和页帧号的szie大小可能不一样。但是每一个页的大小和每一个页帧的大小都是一样的。</p><p><img src="/images/os-interview/48.png"></p><p>其逻辑地址的计算方法与页帧的计算方法是一样的。</p><p>四、地址的转换</p><p><img src="/images/os-interview/49.png"></p><p>过程如下：<br>1、首先cpu会去寻址（逻辑地址或者是物理地址），这个地址会分为另两个内容，一个是offect偏移量，一个是页号。<br>2、将也号作为一个索引，查一个页表（Page table），其实以页号为索引的一向内容，可以根据其查找出页帧号。而且还有知道其基地址，就形成了页帧号和页帧偏移量大小的物理地址。（所以页的偏移大小和页帧的偏移大小是一样的）<br>3、这样就知道了对应的物理地址的所在位置。这个整个的大致过程。<br>ps：其中page table是操作系统在内存初始化的时候建立起来的。</p><p><img src="/images/os-interview/410.png"></p><h2 id="4-3-页表、TLB"><a href="#4-3-页表、TLB" class="headerlink" title="4.3. 页表、TLB"></a>4.3. 页表、TLB</h2><p>一、页表的结构</p><p><img src="/images/os-interview/411.png"></p><p>在页表中，有一系列的属性，eg：可读可写，是否存在等等…</p><p>二、页表的地址转换的例子</p><p>逻辑地址空间和物理地址空间大小是不对等的，但是每一个页内的偏移都是相等的。<br>其中，resident 位为0 代表 内存不存在，为1表示存在。如果cpu访问了为0的地址，这是会产生一个异常，就是内存访问异常。</p><p>如图所示：<br>页为（4,0）的逻辑地址，由于resident = 0，所以真是的物理内存不存在<br>页为（3，1024）的逻辑地址，由于resident = 1，地址存在，查表可知，frame物理地址的页帧号是4，偏移量与页的偏移量相同，一样为1023，所以结果地址便为（4,1023）<br>（页表的建立过程是有操作系统完成的）</p><p>三、分页机制的性能问题<br>1、空间的代价问题<br>2、时间的开销问题<br>（希望时间越短越好，效率越大越好）</p><p>问题一：页表可能非常大<br>64位机器如果每页是1k，那么一个页表的大小会是多少呢？<br>问题二：页表可能开销大<br>每一个应用程序都要生成一个自己的页表，开销比较大</p><p>如何处理？</p><ul><li>缓存（Caching）<br>将一些常用的数据缓存到黎cpu非常近的地方，提高访问的速度</li><li>间接（Indirection）访问<br>通过间接的方法，将一个很大的空间，拆分为一个很小的空间。通过多级的页表机制，可以缓解页表占用空间过大的问题。</li></ul><p>时间问题 —TLB<br>缓存近期访问的页帧转换表项</p><p><img src="/images/os-interview/412.png"></p><p>TLB是一个特殊的区域，位于CPU的内部。<br>Key和Value两个形成了TLB的表相，而这个表相是由相关存储器来实现的，这个是一种快速查询的存储器，速度很快，可以并发的查找，但是容量是有限的。所以可以将一些经常使用的页表项放在TLB中。可以通过查询TLB，避免了一次页表的访问。<br>当出现TLB访问不到的情况，这个情况叫做TLB miss，这是cpu就不得不查页表。<br>而对于TLB miss这个情况，将新的页帧加载到TLB中，部分是有cpu硬件来完成的，而部分是有操作系统完成的，也就是两种情况都存在。</p><h2 id="4-4-多级页表"><a href="#4-4-多级页表" class="headerlink" title="4.4. 多级页表"></a>4.4. 多级页表</h2><p>一、空间问题 — 二级页表解决</p><p><img src="/images/os-interview/413.png"></p><p>一级页表里面存储的是二级页表的地址，二级页表知道之后就会知道frame number页帧号。<br>通过这种方式可以极大的减少空间的消耗，因为如果一级页表中的resident = 0的话。就没有必要再二级页表中添加其索引的，比单级页表大大的减小了空间的开销。</p><p>二、多级页表<br>多级页表可以表示一个更大的地址空间，形成一个树状的结构。这个是以时间换取空间，但是时间问题也可以通过TLB方法来解决。</p><p><img src="/images/os-interview/414.png"></p><h2 id="4-5-反向页表"><a href="#4-5-反向页表" class="headerlink" title="4.5. 反向页表"></a>4.5. 反向页表</h2><p>一、反向页表：<br>以物理地址的页帧号（frame number）方向查找逻辑页的页号（page number）</p><p><img src="/images/os-interview/415.png"></p><p>这样使得寄存器的容量，只与物理地址空间的大小相关，与逻辑地址空间大小无关。</p><p>但是有一个主要的问题：如何将页号和页帧号建立起一个映射关系。<br>页存储器方案的权衡：<br>优点：</p><ul><li>转换表的大小相对于物理内存来说很小</li><li>转换表的大小跟逻辑地址空间的大小无关<br>缺点：</li><li>需要的信息对调了，既根据帧号可找到页号</li><li>如何转换回来？既根据页号找到帧号</li><li>在需要在反向表中搜索想要的页号</li></ul><p>二、关联存储器方案<br>可以并行的查找页号所对应的帧号，其key是他的页号，value是页帧号</p><p><img src="/images/os-interview/416.png"></p><p>存在的问题：</p><ul><li>设计成本太大，硬件处理很复杂</li><li>内存访问的开销问题</li><li>大量的关联内存非常昂贵，难以在单个时钟周期内完成且耗电</li></ul><p>三、基于哈希（hash）计算的反向页表<br>只需要建立好一个哈希的函数，输入一个值，就会得到一个输出。而输入的值是page number，输出的值是frame number。<br>为了能提高加速，需要硬件的加速。<br>为了提高效率，加一个PID的标识</p><p><img src="/images/os-interview/417.png"></p><p>可以有效的缓解完成映射的开销。</p><p>在反向页表中通过哈希算法来搜索一个页对应的帧号</p><ul><li>对页号做哈希计算，为了在“帧表”（每一帧用于一个表项）中获取对应的帧号</li><li>页i被放置在表中f(i)位置，其中f是设定的哈希函数</li><li>为了查找页i，执行下列操作：<br>计算哈希函数f(i)并且使用它作为页寄存器表的索引，获取对应的页寄存器，检查寄存器标签是否包含i，如果包含，则代表成功，否则失败。</li></ul><h1 id="5-虚拟内存"><a href="#5-虚拟内存" class="headerlink" title="5. 虚拟内存"></a>5. 虚拟内存</h1><h2 id="5-1-起因"><a href="#5-1-起因" class="headerlink" title="5.1. 起因"></a>5.1. 起因</h2><p>理想中的存储器：<br>更大，更快，更便宜的非易性存储器</p><p><img src="/images/os-interview/51.png"></p><p>硬盘的速度远远的慢于内存的执行。<br>磁带比硬盘的存储容量更加的庞大。<br>现有的物理内存掉电之后数据还是会丢失的。</p><p><img src="/images/os-interview/52.png"></p><p><img src="/images/os-interview/53.png"></p><p>以上设计了三种技术：</p><ul><li>手动覆盖技术：只把指令和数据保存在内存中</li><li>自动交换技术：将程序导出内存到硬盘上</li><li>虚拟内存技术（前两种是虚拟内存还没出现的情况下诞生的）：以更小的力度把数据导出导入到内存中来，充分的利用了内存空间的手段</li></ul><h2 id="5-2-覆盖技术"><a href="#5-2-覆盖技术" class="headerlink" title="5.2. 覆盖技术"></a>5.2. 覆盖技术</h2><p>一、覆盖技术的基础<br>目标：<br>是在较小的可用内存中运行较大（相对而言的）的程序。常用与多道程序系统，与分区存储管理配合使用。<br>原理：<br>把程序按照其自身的逻辑结构，划分为若干个功能上相对独立的程序模块，那些不会同时执行的模块共享同一块内存区域，按时间先后来运行。</p><p>必要部分（常用功能）的代码和数据常驻内存；<br>可选部分（不常用内存）在其他程序模块中实现，平时存放在外存中，在需要用到时才装入内存；<br>不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖，既这些模块共有一个分区。<br>二、应用例子<br>例子一：</p><p><img src="/images/os-interview/54.png"></p><ul><li>bc是对等的，相互之间不会调用，所以分在一个区；A调用b的时候，c是不会执行的，所以只需要将b放在内存中即可。</li><li>def也是对等的，相互之间也不会调用，所以也分在一个区；当C调用e的时候，df通用是不会被调用的，所以也只需要将e放在内存中即可。</li></ul><p>例子二：</p><p><img src="/images/os-interview/55.png"></p><p>所以覆盖技术是可以有多种方式选择的。</p><p>三、覆盖技术的优缺点<br>优点：<br>将一个大程序可以放在一个很小的内存里面通过交换技术执行。</p><p>缺点：</p><ul><li>由程序员来把一个大的程序划分为若干个小功能模块，并确定各个模块之间的覆盖技术，费时费力，增加了编程的复杂度。</li><li>覆盖模块从外存装入内存，实际上是以时间延长来换取空间节省</li></ul><h2 id="5-3-交换技术"><a href="#5-3-交换技术" class="headerlink" title="5.3. 交换技术"></a>5.3. 交换技术</h2><p>一、交换技术的基础<br>目标：<br>多道程序在内存中时，让正在运行的程序或需要运行的程序获得更多的内存资源。<br>方法：</p><ul><li>可将暂时不能运行的程序送到外存，从而获得空闲内存空间</li><li>操作系统把一个进程的整个地址空间的内容保存到外存中（换出swap out），而将外存中的某个进程的地址空间读入到内存中（换入swap in）。换入换出内容的大小为整个程序的地址空间。</li></ul><p>这个换入换出的交换技术是操作系统内存管理的重要组成部分。</p><p><img src="/images/os-interview/56.png"></p><p>二、交换技术实现的几个问题：</p><ul><li>交换时机的确定：何时小发生交换？只当内存空间不够或有不够危险的时候才换出。</li><li>交换区的大小：必须足够大以存放所以用户进程的所有内存映射的拷贝；必须能对这些内存映像进行直接存取。</li><li>程序换入时的重定位：换出后再换入的内存位置一定要在原来的位置上吗，寻址可能会出现问题？最好采用动态地址映射的方法，建好页表就行。<br>ps：交换技术是可以由操作系统来完成的，对于程序员来说是透明的。<br>三、小结–覆盖与交换的比较</li><li>覆盖只能发生在那些相互之间没有调用关系的程序模块之间，因此程序员必须给出程序内的各个模块之间的逻辑覆盖结构。</li><li>交换技术是以内存中的程序大小为单位来进行的，它不需要程序员给出各个模块之间的逻辑覆盖结构。换言之，交换发生在内存中程序与管理程序或操作系统之间，而覆盖则发生在运行程序内部。</li></ul><h2 id="5-4-虚存技术"><a href="#5-4-虚存技术" class="headerlink" title="5.4. 虚存技术"></a>5.4. 虚存技术</h2><p>（虚拟内存管理技术）<br>一、前诉<br>在内存不够用的情形下，可以采用覆盖技术和交换技术，但是：<br>覆盖技术：需要程序员自己把整个程序划分为若干个小的功能模块，并确定各个模块之间的覆盖关系，增加了程序员的负担；<br>交换技术：以进程作为交换的单位，需要把进程的整个地址空间都换进换出，增加了处理器的开销。<br>希望通过一种更好的办法，能够充分的解决交换技术和覆盖技术出现的问题。</p><p>二、虚拟内存的基础<br>目标：</p><ul><li>像覆盖技术那样，不是把程序的所有内容都放在内存中，因而能够运行比当前的空闲内存空间还要大的程序。但做得更好，由操作系统自动来完成，无须程序员的干涉；</li><li>像交换技术那样，能够实现进程在内存与外存之间的交换，因而获得更多的空闲内存空间。但做得更好，只对进程的部分内容在内存和外存之间进行交换。</li></ul><p><img src="/images/os-interview/57.png"></p><p>二、虚拟技术–程序的局部性原理<br>定义：<br>程序的局部性原理（principle of locality），指程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定的区域，这个可以表现为：</p><p>时间局部性：一条指令的一次执行和下次执行，一个数据的一次访问和下一次访问都集中在一个较短时期内。<br>空间局部性：当前指令和邻近的几条指令，当前访问的数据和邻近的几个数据都集中在一个较小区域内。<br>程序的局部性原理表明，从理论上说，虚拟存储技术是能够实现的，而且在实现了以后应该是能够取得一个满意的效果。访问的速度更快，并且可以提供一个很多的空间。<br>三、程序局部性的例子</p><p><img src="/images/os-interview/58.png"></p><p>可见：程序1是按照行来访问的，而程序2的按照列来访问的</p><p><img src="/images/os-interview/59.png"></p><p>结果分析：<br>由于程序1的没相邻的两次访问的地址差距较大，不满足时间局部性和空间局部性，所以会产生多次的缺页中断，对系统的开销较大。而程序2两个数据是相邻的，具有良好的时间局部性和空间局部性。<br>如果程序不具有局部性，这个高效的机制就很难的实现。</p><p>四、虚存技术的大致流程<br>前提：<br>操作系统有了硬件支持分段/分页机制，在此内存管理基础之上来实现一个以页或者是段为单位的虚存管理。<br>过程：</p><ul><li>在装入程序的时候，不必将所有的程序和数据装入内存中去，而只需将当前需要执行的部分的代码数据放在相关的段或者是页中，这样可以是的一小部分的代码放在内存中去了。</li><li>在程序执行过程中，如果需要执行的指令或访问的数据尚未在内存中（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序。</li><li>另一方面。操作系统将内存中暂时不使用的页面或段调出保存在外存上，从而腾出更多空闲空间存放将要装入的程序以及将要调入的页面或段。</li></ul><p>如图所示：程序只有少部分在内存中，而大部分都是在外存中存储。</p><p><img src="/images/os-interview/510.png"></p><p>五、虚拟内存的基本特征</p><ul><li>较大的用户空间：<br>通过把物理内存与外存结合，提供给用户的虚拟内存空间通常大于实际的物理内存，既实现了这两者的分离。如32位的虚拟地址理论上可以访问4GB，而可能计算机上仅有256M的物理内存，但硬盘的容量大于4GB</li><li>部分交换：<br>与交换技术相比较，虚拟存储的调入和调出是对部分虚拟地址空间进行的，其每次的换入换出是非常规整的，要么是段或者是页。不需要将整个程序交换出去。力度更小，但是效率更高。</li><li>不连续性：<br>物理内存分配不连续，虚拟地址空间使用也是不连续的。本来所有的数据都是连续的放在虚拟内存中的，但是操作系统要把某些数据换出去，而造成的不连续。操作系统会弥补好，正常的访问。</li></ul><p>六、虚拟内存技术的具体实现<br>基于页式虚拟内存管理，与前诉的一样。</p><p><img src="/images/os-interview/511.png"></p><p>大部分虚拟存储系统都采用虚拟页式存储管理技术，既在页式存储管理的基础上，增加请求调页和页面置换功能。<br>基本思路：</p><ul><li>当一个用户程序要调入内存运行时，不是将该程序的所以页面都装入内存，而是只装入部分的页面，就可以启动程序运行。</li><li>在运行的过程中，如果发现要运行的程序或要访问数据不在内存，则向系统发出缺页中断请求，系统在处理这个中断时，将外存中相应的页面调入内存，使得该程序能够继续运行。</li></ul><p>七、页表表项的设定</p><p><img src="/images/os-interview/512.png"></p><p>驻留位：表示该页是在内存还是外存。如果该位等于1，表示该页位于内存当中，既该页表项是有效的，可以使用；如果改为为0，表示该页当前还在外存当中，如果访问该页表项，将导致缺页中断。<br>保护位：表示允许对该页做何种类型的访问，如只读，可读写，可执行等。<br>修改位：表面此页面在内存中是否被修改过，当系统回收该物理页面时，根据此位来决定是否把他的内容写回外存。位为0就表示数据一样的，不需要写回外存中。<br>访问位：如果该页面被访问过（包括读操作或写操作），则设定词尾，用于页面的置换算法。<br>示例：</p><p><img src="/images/os-interview/513.png"></p><p>（左边是虚存页表的映射关系，每一个页表项有4K的物理页，X代表驻留位为0，如果是一个具体的数，就代表驻留位为1，映射关系有效。）</p><p>示例1：<br>MOV REG, 0 //将0地址的内容赋值给一个寄存器<br>可以看见，0地址是在最底下，有一个2，这表示驻留位是1，且页帧号是2。而一个页的大小是4096,既4k，所以2*4k为8k。也就是所将对应的8k的地址8192的内容给寄存器。<br>MOV REG, 0 ———&gt; MOV REG, 8192</p><p>示例2：<br>MOV REG, 32780<br>可以看见32780对应的页表项是32k，其驻留位的设置是0，没有对应的一个页帧号，意味着访问这一页会产生缺页（缺页异常）<br>MOV REG, 32780 ———&gt; MOV REG, 缺页中断</p><p>八、缺页中断处理过程</p><p><img src="/images/os-interview/514.png"></p><p>当cpu执行一条指令load一个内存地址，如果这个内存地址没有一个对应的关系，也就是说没有一个存在位，这时就会产生一个缺页异常，接来下操作系统就会完成一些列缺页中断的处理：</p><ul><li>如果在内存中有空闲的物理页面，则分配一空闲的物理页帧f，然后转第4步；否者转第2步。</li><li>采用某种页面置换算法，选择一个将被替换的物理页帧f，他所对应的逻辑页为q。如果该页在内存期间被修改过，则需把他写回外存。</li><li>对q所对应的页表项进行修改，把驻留位置置0。</li><li>将需要访问的页p装入到物理页面f当中。也就是把页所需要访问的地址对应的硬盘中的数据，以页为单位，从硬盘读到内存中去，读到刚分配到的那个内存地址。</li><li>修改p所对应的页表项的内容，把驻留位置1，把物理页帧号置为f。</li><li>重新运行被中断的指令。</li></ul><p>九、后备存储（Backing Store）<br>在何处保存未被映射的页？<br>能够简单地识别在二级存储器中的页<br>交换空间（磁盘或者文件）：特殊格式，用于存储未被映射的页面<br>概念：<br>一个虚拟地址空间的页面可以被映射到一个文件（在二级存储中）中的某个位置<br>代码段：映射到可执行二进制文件<br>动态加载的共享程序段：映射到动态调用的库文件<br>其他段：可能被映射到交换文件（swap file）</p><p>有了这个后背存储/二级存储，可以充分保证了虚存空间的有效性。</p><p>十、虚拟内存性能<br>为了便于理解分页的开销，使用有效存储器访问时间effective memory access</p><p><img src="/images/os-interview/515.png"></p><p>其实取决参数p，如果p足够小，就可以使平均的执行时间接近10nm，但是如果程序有局部性特点，就表面产生缺页的次数会很少，这是效率就会很高。</p><h1 id="6-页面置换算法"><a href="#6-页面置换算法" class="headerlink" title="6. 页面置换算法"></a>6. 页面置换算法</h1><p>1、局部页面置换算法</p><p>最优页面置换算法（OPT、optimal）<br>先进先出算法（FIFO）<br>最近最久未使用算法（LRU,Least Recently Used）<br>时钟页面置换算法（Clock）<br>最不常用算法（LFU，Least Frequently Used）<br>Belady现象<br>LRU、FIFO和Clock的比较<br>2、全局页面置换算法</p><p>工作集模型<br>工作集页置换算法<br>缺页率置换算法<br>功能：<br>当缺页中断发生，需要调入新的页面而内存已满时，选择内存当中哪个物理页面被置换。</p><p>目标：<br>尽可能地减少页面的换进换出次数（既缺页中断的次数）。具体来说，把未来不再使用的或短期内较少使用的页面换出，通常只能在局部性原理指导下依据过去的统计数据来进行预测。</p><p>页面锁定（frame locking）：<br>用于描述必须常驻内存的操作系统的关键部分或时间关键（time-critical）的应用程序。实现的方法是L在页表中添加锁定标志位（lock bit）。使其不在页面置换算法范围之内，也就说不会被换入换出。</p><p><img src="/images/os-interview/61.png"></p><p>通常只需要考虑页号，因为偏移号一般不起作用。只保留页号。基于这个list来设计各种的页面替换算法。<br>通过模拟一个页面置换的行为并且记录产生页缺失数的数量。一般情况下，产生的缺页次数越少，性能就越高。</p><h2 id="6-1-最优页面置换算法"><a href="#6-1-最优页面置换算法" class="headerlink" title="6.1. 最优页面置换算法"></a>6.1. 最优页面置换算法</h2><p>一、基础<br>基本思路：<br>当一个缺页中断发生时，对于保存在内存当中的每一个逻辑页面，计算在它的下一次访问之前，还需要等待多长时间，从中选择等待时间最长的那个，作为被置换的页面。</p><p>结论：</p><p>这只是一个理想的情况，在实际系统中是无法实现的，因为操作系统无从知道每一个页面要等待多长时间以后才会再次被访问。<br>可用作其他算法的性能评价的依据（在一个模拟器上运行某个程序，并记录每一次的页面访问情况，在第二遍运行时即可使用最优算法。然后以此为基础，评价其他的算法。）<br>二、示例</p><p><img src="/images/os-interview/62.png"></p><p>在上帝视角中，可以看出由于d是最长时间没有被使用，所以d将会被e所替换，如上所示。</p><h2 id="6-2-先进先出算法"><a href="#6-2-先进先出算法" class="headerlink" title="6.2. 先进先出算法"></a>6.2. 先进先出算法</h2><p>一、基础<br>先进先出算法（First-In First-Out，FIFO）：<br>1、基本思路：<br>选择在内存中驻留时间最长的页面并淘汰之。具体来说，系统维护着一个链表，记录了所有位于内存当中的逻辑页面。从链表的排列顺序来看，链首页面的驻留时间最长，链尾页面的驻留时间最短。当发生一个缺页中断时，把链首页面淘汰出局，并把新的页面添加到链表的末尾。</p><p>2、评价：<br>性能较差，调出的页面有可能是经常要访问的页面，并且有Belady现象（给的物理页帧越多，产生缺少的次数越大）。FIFO算法很少单独使用。</p><p>二、示例</p><p><img src="/images/os-interview/63.png"></p><p>实现简单，但是产生的缺页次数比较多</p><h2 id="6-3-最近最久未使用算法"><a href="#6-3-最近最久未使用算法" class="headerlink" title="6.3. 最近最久未使用算法"></a>6.3. 最近最久未使用算法</h2><p>一、基础<br>最近最久未使用算法（LRU,Least Recently Used）<br>1、基本思路：<br>当一个缺页中断发生时，选择最久未使用的那个页面，并淘汰之。</p><p>2、评价：<br>它是对最优页面置换算法的一个近似，其依据是程序的局部性原理，既在最近一小段时间（最近几条指令）内，如果某些页面被频繁地访问，那么在将来的一小段时间内。他们还可能会再一次地频繁地访问。反过来说，如果在过去某些页面长时间未被访问，那么在将来他们还可能会长时间地得不到访问。也就是根据过去推算出未来。</p><p>二、示例</p><p><img src="/images/os-interview/64.png"></p><p>LRU算法需要记录各个页面使用时间的先后顺序。<br>开销比较大。两种可能的实现方法是：<br>方法一：<br>系统维护一个页面链表，最近各个使用过的页面作为首节点，最久未使用的页面作为尾节点。每一次访问内存时，找到相应的页面，把它从链表中摘下来，在移动到链表之首。每次缺页中断发生时，也就是没有这个页表，所以会把新的页表查到链表头，然后淘汰链表末尾的页面。</p><p>方法二：<br>设置一个活动页面栈，当访问某页时，将此页号压入栈顶，然后考察栈内是否有与页面相同的页号，若有则抽出。然后压入栈顶。当需要淘汰一个页面时，总是选择栈底的页面，它就是最久未使用的。</p><p><img src="/images/os-interview/65.png"></p><p>效果比较好，但是系统的开销比较大</p><h2 id="6-4-时钟页面置换算法"><a href="#6-4-时钟页面置换算法" class="headerlink" title="6.4. 时钟页面置换算法"></a>6.4. 时钟页面置换算法</h2><p>一、基础<br>Clock页面置换算法，LRU的近视，对FIFO的一种改进<br>1、基本思路</p><ul><li>需要用到页表项当中的访问位，当一个页面被装入内存时，把该位初始化为0。然后如果这个页面被访问（读/写），则把该位置置1。</li><li>把各个页面组织形成环形链表（类似钟表面），把指针指向最老的页面（最先进来）。</li><li>当发生一个缺页中断时，考察指针所指向的最老页面。若它的访问位为0，立即淘汰；若访问位为1，则把该位置为0，然后指针往下移动一格。如此下去，直到找到被淘汰的页面，然后把指针移动到它的下一格。</li></ul><p>二、具体实现</p><p><img src="/images/os-interview/66.png"></p><p>resident bit：存在位，代表是否存在。如果是1，代表在物理内存是存在的，表示映射的关系是正常的。如果是0，就不能正常的映射。<br>used bit：如果是1代表当前的页被访问过一次，硬件支持将其置为1。（这个位可以硬件自动的操作，同时也可以由软件操作）<br>frame number：页帧号<br>时钟页面置换算法的依据就是第二个位——used bit</p><p>三、示例</p><p><img src="/images/os-interview/67.png"></p><p>其中的置1操作是由硬件自动实现的。<br>替换的情况是产生缺页中断时候才会执行的。如果本来就有此内存，则指针是不需要向下移动寻找最老页面。也就是说如果存在，则指针保持不动，只需要置1操作既可。</p><h2 id="6-5-二次机会法"><a href="#6-5-二次机会法" class="headerlink" title="6.5. 二次机会法"></a>6.5. 二次机会法</h2><p>一、基础</p><p><img src="/images/os-interview/68.png"></p><p>resident bit：存在位，代表是否存在。如果是1，代表在物理内存是存在的，表示映射的关系是正常的。如果是0，就不能正常的映射<br>used bit：如果是1代表当前的页被访问过一次，硬件支持将其置为1。（这个位可以硬件自动的操作，同时也可以由软件操作）<br>dirty bit：如果执行了一个写操作，那么这个位会置为1；如果只是读操作，那么这个位是0。这个bit的设置也是由硬件来完成的。<br>当某一个运行的程序，对某一页进行访问之后。</p><p>如果是写操作，硬件会将used bit和dirty bit都置为1.<br>如果是读操作。硬件会将used bit置为1，而dirty bit还是0.<br>这个bit可以区分读和写，但是对我们的置换算法有什么帮助呢？<br>解析：</p><p>因为我们的算法是换入换出算法，所以如果当应用程序对内存进行读操作的时候，这个内存与磁盘的内容是一样的，所以只需要将其释放掉就可以了，不需要进行换入换出的操作。<br>而如果应用程序对内存进行了写操作的时候，这时表面与磁盘的内容不一样，替换的时候就需要把内容换入换出。<br>这时，两个bit都用上了，来减少硬盘的访问也就是减少写回操作的次数。</p><p><img src="/images/os-interview/69.png"></p><p>由于used=1，dirty=1的页会循环两次才会被替换出去，所以很形象生动的称之为二次机会法。<br>通过这种方式，可以把经常使用dirty bit的这个页有更多的机会留着内存中来。而不会被换到内存中去。对硬盘的访问次数也会减少。</p><p>二、示例<br>带有w表示对此页进行的是写操作而不是读操作，读操作是不带w<br>此时考虑两个位，used bit和dirty bit</p><p><img src="/images/os-interview/610.png"></p><p>比较接近LRU算法，优先的把只读的页换出去了，对于可写的页减少了换出去的概率，对于可以减少回写的概率。</p><h2 id="6-6-最不常用算法"><a href="#6-6-最不常用算法" class="headerlink" title="6.6. 最不常用算法"></a>6.6. 最不常用算法</h2><p>一、基础<br>最不常用算法（Least Frequently Used，LFU）<br>基本思路：<br>当一个缺页中断发生时，选着访问次数最少的那个页面，并淘汰之。被访问的次数也会很少。</p><p>实现方法：<br>对每个页面设置一个访问计数器，每当一个页面被访问时，该页面的访问计数器加1。每当反生缺页中断时，淘汰计数器最小的那个页面。</p><p>问题：<br>增加计数器会消耗硬件资源，会浪费空间，而选择次数最少的那个意味在要遍历整个链表，耗费时间，实现比较费时费力。而且当一个页面在进程开始的时使用得很多，但是以后就不再使用了，LFU还是会保留。（根据该点的解决方法：定时的把次数寄存器右移一位）</p><p>LRU和LFU的区别：<br>LRU考察的是多久未访问，时间越短越好；而LFU考察的是访问的次数或频度，访问次数越多越好。</p><p>二、示例</p><p><img src="/images/os-interview/611.png"></p><p>以上操作是将访问次数最多的替换出去。</p><h2 id="6-7-Belady现象、比较"><a href="#6-7-Belady现象、比较" class="headerlink" title="6.7. Belady现象、比较"></a>6.7. Belady现象、比较</h2><p>一、Belady现象<br>（Belady是一个科学家的名字，不必纠结）<br>定义：<br>在采用FIFO算法时，有时会出现分配的物理页面数增加，缺页率反而提高的异常现象。</p><p>Belady现象的原因：<br>FIFO算法的置换特征与进程访问内存的动态特征是矛盾的，与置换算法的目标是不一致的（既替换较少使用的页面），因此，被它替换出去的页面并不一定是进程不会访问的。</p><p>二、Belady现象示例<br>1、当分3个物理页的情况—出现9次中断缺失</p><p><img src="/images/os-interview/612.png"></p><p>2、当分4个物理页的情况—出现10次中断缺失</p><p><img src="/images/os-interview/613.png"></p><p>结果：<br>出现了物理页，给了更多的物理页，但是出现页缺失的情况更多</p><p>相比之下，LRU算法是符合预期情况的，给的硬件资源越多，产生中断页缺失的情况就会越少。</p><p><img src="/images/os-interview/614.png"></p><p>原因：<br>LRU算法满足某种栈的属性，而FIFO算法不满足某种栈的属性，所以会导致Belady现象。</p><p>三、LRU、FIFO、Clock的比较<br>1、性质的比较</p><p><img src="/images/os-interview/615.png"></p><p>2、性能的比较</p><p><img src="/images/os-interview/616.png"></p><h2 id="6-8-问题、工作集模型"><a href="#6-8-问题、工作集模型" class="headerlink" title="6.8. 问题、工作集模型"></a>6.8. 问题、工作集模型</h2><p>局部页面置换算法都是针对一个正在运行的程序来讲的，但是操作系统支持多个应用程序。</p><p><img src="/images/os-interview/617.png"></p><p>以上可见，只是仅仅增加了一个物理页帧，就对整个页面置换算法造成很大的效果影响。如果对一个程序固定一个物理页帧，其实是在某一个程度上限制了这个程序产生缺页的特点。因为其对物理内存的需求是动态可变的。<br>而前面所诉的前提是物理页帧是假设为固定的。这样就限制了灵活性。但是可以根据不同的运行阶段，动态分配调整物理页帧的大小，这点就是全局页面置换算法要考虑的问题。</p><p>一、工作集模型<br>前面介绍的各种页面置换算法都是基于一个前提的，既程序的局部性原理。</p><p>如果局部性原理不成立，那么各种页面置换算法就没有什么分别，也没有什么意义。例如：假设进程对逻辑页面的访问顺序是1,2,3,4,5,6,7,8,9…,即单调递增，那么在物理页面数有限的前提下，不管采用何种置换算法，每次的页面访问都必然导致缺页中断。<br>如果局部性原理是成立的，那么如何来证明它的存在，如何来对它进行定量地分析？这就是工作集模型。<br>1、工作集的定义：<br>一个进程当前正在使用的逻辑页面集合，可以用一个二元函数W(t，△)来表示。<br>二元函数W(t，△) 其中参数如下：</p><p><img src="/images/os-interview/618.png"></p><p>例子：</p><p><img src="/images/os-interview/619.png"></p><p>这表明t2具有良好的局部性，t1有一定的局部性，但是整体的局部性不如t2的效果好。</p><p>2、工作集大小的变化：<br>进程开始执行后，随着访问新页面逐步建立较稳定的工作集。当内存访问的局部性区域的位置大致稳定时，工作集带下也大致稳定；局部性区域的位置改变时，工作集快速扩张和收缩过渡到下一个稳定值。</p><p><img src="/images/os-interview/619.png"></p><p>二、常驻集模型<br>常驻集是指在当前时刻，进程实际驻留在内存当中的页面集合。</p><p>工作集是进程运行过程中固有的性质，而常驻集取决于系统分配给进程的物理页面数目（物理空间的大小），以及所采用的页面置换算法。来决定到底把哪些页面放在内存中来。<br>常驻集是当前运行的程序访问的页在哪些在内存中；而工作集指的是程序运行中所需要访问的页是哪些，这表示有些页是不在内存中的，只有部分页是在内存中的。<br>如果一个进程的整个工作集读在内存当中，既常驻集属于工作集，那么进程将很顺利地进行运行，而不会造成太多的缺页中断（直到工作集发生剧烈变动，从而过渡到另一个状态）。<br>当进程常驻集的大小达到某个数目之后，再给它分配更多的物理页面，缺页率也不会明显下降，可以给其他运行的程序，使总的缺页比较少。<br>6.9两个全局置换算法<br>一、工作集页置换算法<br>1、基本思想<br>有一个size，代表了其过去形成工作集的大小。窗口里面的页是当前时间内被访问到的页。随着时间的挪动平移，如果某一个不在这个时间的窗口之内，这个页也会被丢到，而并不是说要等到缺页的时候才会丢页。也就是这个页不属于这个窗口了，就会被替换。</p><p>2、示例</p><p><img src="/images/os-interview/620.png"></p><p>结果如下：<br>1—-edac—-abcd 6—-dbce—-bcde<br>2—-dacc—-acd 7—-bcec—-bce<br>3—-accd—-acd 8—-cece—-ce<br>4—-ccdb—-bcd 9—-ecea—-ace<br>5—-cdbc—-bcd 10—cead—-acde</p><p>分析：<br>并不是因为缺页而丢弃，而是因为不在这个窗口当中的所以老页都会被换出去。这样可以确保物理内存中有足够的页存在，可以减少页面置换降低，这个是站着整个系统层面上看的。</p><h2 id="6-9-缺页率页面置换算法"><a href="#6-9-缺页率页面置换算法" class="headerlink" title="6.9. 缺页率页面置换算法"></a>6.9. 缺页率页面置换算法</h2><p>1、可变分配策略：<br>常驻集大小可变。例如：每个进程在刚开始运行的时候，先根据程序大小给它分配一定数目的物理页面，然后在进程运行过程中，再动态地调整常驻集的大小。根据缺页率来改变，缺页率高，可以增加常驻集；缺页率降低，可以减小常驻集。<br>缺页率算法（PFF，page fault frequency）</p><p>2、缺页率<br>定义：<br>表示“缺页次数/内存访问次数”（比率）或“缺页的平均时间间隔的倒数”。</p><p>影响缺页率的因素：</p><p>页面置换算法<br>分配给进程的物理页面数目<br>页面本身的大小<br>程序的编写方法</p><p><img src="/images/os-interview/621.png"></p><p>使整个系统保持一个平衡，使所有的程序到保持一个较低的缺页率。</p><p>一个交替的工作集计算明确的试图最小化页缺失</p><p>当缺页率高的时候-增加工作集<br>当缺页率低的时候-减少工作集<br>3、算法的实现</p><p><img src="/images/os-interview/622.png"></p><p>4、示例</p><p><img src="/images/os-interview/623.png"></p><p>分析：<br>当前的阈值是2，也就是如果两次产生中断的时间大于2的话，话增加工作；而如果中断的时间小于等于2的话，就会动态的减少工作集。</p><p>在时间1时刻，产生一个缺失中断。<br>在时间4时刻，由于没有b，所以也产生了一次缺失中断。并且，由于1-4之间的时刻大于2，所以会动态的去除在这段时刻中没有读取的页，也是就是ae，所以此时只有bcd三个工作页。<br>在时间6时刻，由于没有e，产生了一次缺失中断。并且，由于4-6之间的时刻等于2，所以会动态的增加所需要的页。<br>在时间9时刻，由于没有页a，所以产生了一次缺失中断。并且，由于6-9之间的时刻大于2，所以也会动态的去除在这段时间中没有读取的页，也就是bd，因为这段时间只有ec的页需要操作，此时就只有ace三个工作页。<br>5、小结<br>这两个算法是根据工作集的大小动态的调整的，前面只是满的时候才调整，这个是他们之间的主要区别。所有对于操作系统而言，为了应对多个应用程序，采用全局的页面置换算法更加的合适。</p><h2 id="6-10-抖动问题"><a href="#6-10-抖动问题" class="headerlink" title="6.10. 抖动问题"></a>6.10. 抖动问题</h2><p>抖动问题是对工作集和常驻集做进一步的讲解。<br>1、抖动的定义<br>如果分配给一个进程的物理页面太少，不能包含整个的工作集，既常驻集属于工作集，那么进程将会造成很多的缺页中断，需要频繁地在内存与外存之间替换页面，从而使进程的运行速度变得很慢，将这种状态称为“抖动”。</p><p>2、产生抖动的原因<br>随着驻留内存的进程的数目增加，分配给每个进程的物理页面数不断减小，缺页率不断上升。所以操作系统要选择一个适当的进程数目和进程需要的帧数，以便在并发水平和缺页率之间达到一个平衡。</p><p>3、解决<br>当运行的程序过多时，cpu要执行多次的换入换出换出io操作，而导致程序没有执行，导致cpu的利用率降低，造成了电脑的卡顿。</p><p><img src="/images/os-interview/624.png"></p><p>蓝线的比值越大，表示缺页的频率很低，cpu利用率较高。（其中页缺失的服务时间是不变的）<br>当平均页缺失时间 = 页缺失服务时间 的时候，这时候的效率就接近最完美的点。</p><h1 id="7-进程"><a href="#7-进程" class="headerlink" title="7. 进程"></a>7. 进程</h1><h2 id="7-1-进程的定义"><a href="#7-1-进程的定义" class="headerlink" title="7.1. 进程的定义"></a>7.1. 进程的定义</h2><p>在某种程度上， 可以将应用程序看成是一个进程，其将会消耗耕种各样的计算机资源。</p><p>定义：<br>一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。</p><p>只有当操作系统把执行程序调入到我们的内存之后，让这个程序可以执行起来。（能够让通过cpu对这个程序执行一条条的指令，读取数据完成一定的功能）。也就是静态的执行程序，通过cpu变成一个动态的执行过程，而这个动态的执行过程就是进程。<br>整个的功能是由程序的代码决定的。</p><h2 id="7-2-进程的组成"><a href="#7-2-进程的组成" class="headerlink" title="7.2. 进程的组成"></a>7.2. 进程的组成</h2><p>1、一个进程应该包括</p><p>程序的代码<br>程序处理的数据<br>程序计数器中的值，指示下一条将运行的指令<br>一组通用的寄存器的当前值，堆，栈<br>一组系统资源（如打开的文件）<br>总之，进程包含了正在运行的一个程序的所以状态信息。</p><p>2、进程与程序的联系</p><p>程序是产生进程的基础<br>程序是静态的代码，代码限制了进程完成是什么样的功能<br>程序的每次运行构成不同的进程<br>程序多次运行过程中输入的数据不一样，产生的结果是不一样的，所以构成了不一样的进程<br>进程是程序功能的体现<br>尽管输出可能不同，但是这个程序的功能是一样的<br>通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序。<br>进程和程序之间是一个多对多的关系。<br>3、进程与程序的区别</p><p>进程是动态的，程序是静态的；程序是有序代码的集合；进程是程序的执行，进程有核心态/用户态。<br>进程是暂时的，程序是永久的；进程是一个状态变化的过程，程序可长久保存。<br>进程与程序的组成不同；进程的组成包括程序、数据和进程控制块（既进程状态信息）<br>一个很有趣进程与cpu的类比：</p><p><img src="/images/os-interview/71.png"></p><p>cpu在工作中会存在切换处理不同程序的</p><h2 id="7-3-进程的特点"><a href="#7-3-进程的特点" class="headerlink" title="7.3. 进程的特点"></a>7.3. 进程的特点</h2><p>动态性：可动态地创建，结束进程；<br>并发性：进程间可以被独立调度并占有处理机运行；（并发与并行的区别，前者是可以为1个cpu，后者必须要多个cpu）<br>独立性：不同进程的工作不互相影响，也就是进程不会破坏代码数据的正常执行。（页表的支持）<br>制约性：因访问共享数据/资源或进程间同步而产生制约</p><p><img src="/images/os-interview/72.png"></p><p>a–体现了动态性 / b–体现了独立性 / c–体现了制约性<br>描述进程的数据结构：进程控制块（Process Control Block，PCB）<br>操作系统为每一个进程都维护了一个PCB，用来保存与该进程有关的各种状态信息和需要资源的情况等等。</p><h2 id="7-4-进程控制结构"><a href="#7-4-进程控制结构" class="headerlink" title="7.4. 进程控制结构"></a>7.4. 进程控制结构</h2><p>1、进程控制块：操作系统管理控制进程运行所用的信息集合。</p><p>操作系统用PCB来描述进程的基本情况以及运行变化的过程，PCB是进程存在的唯一标志，如果进程消失了那么其对应的PCB也会消失，是一一对应的关系。<br>2、使用进程控制块</p><p>进程的创建：为该进程生产一个PCB；<br>进程的终止：回收它的PCB；<br>进程的组织管理：通过对PCB的组织管理来实现；<br>问题：PCB具体包含什么信息？如何组织的？进程的状态转换…?</p><p>3、PCB包含的信息</p><ul><li>进程标识信息。<br>如本进程的标识（进程号，执行的次数…），本进程的产生者标识（父进程标识）；用户标识。</li><li>处理机状态信息保存区<br>保存进程的运行现场信息：</li></ul><p>用户可见寄存器：用户程序可以使用的数据，地址等寄存器。<br>控制和状态寄存器：如程序计数器（PC），程序状态字（PSW）<br>栈指针：过程调用/系统调用/中断处理和返回时需要用到它。找到当前运行的位置。</p><ul><li>进程控制信息<br>操作系统需要对这个进程进行管理和控制调度和</li></ul><p>调度和状态信息：用于操作系统调度进程并占用处理机使用。<br>进程间通信信息：为支持进程间与通信相关的各种标识，信号，信件等。这些信息存在接受方的进程控制块中<br>存储管理信息：包含有指向本进程映射存储空间的数据结构。<br>进程所用资源：说明有进程打开、使用的系统资源，如打开的文件等。<br>有关数据结构连接信息：进程可以连接到一个进程队列中，或连接到相关的其他进程的PCB<br>4、PCB的组织方式</p><p><img src="/images/os-interview/73.png"></p><p>链表：同一状态的进程其PCB称一链表，多个状态对应多个不同的链表。各个状态的进程形成不同的链表：就绪链表，阻塞链表。<br>索引表：同一个状态的进程归入一个index表（由index指向PCB），多个状态对应多个不同的index表。各个状态的进行形成不同的索引表：就绪索引表、阻塞索引表<br>一般来说会采取链表，因为进程的控制是动态的插入和删除的，所以链表组织方式比较方便，而索引开销比较大。当然如果一开始就固定住了进程的数目，索引也不失为一个选择。</p><p>以上是围绕进程静态部分说明，组成，特点等等。<br>一下是围绕进程动态的状态特点说明，有3个方面的内容：</p><p>进程的生命周期管理<br>进程状态变化模型<br>进程挂起模型</p><h2 id="7-5-进程的生命期管理"><a href="#7-5-进程的生命期管理" class="headerlink" title="7.5. 进程的生命期管理"></a>7.5. 进程的生命期管理</h2><p>进程的生命是指进程的创建到结束这么一整个的生命期。<br>进程的生命期管理有以下几个时期：</p><p>进程创建<br>进程运行：正在占用cpu，执行这个进程<br>进程等待：由于某种特殊原因需要等待<br>进程唤醒：当等待的条件满足，需要唤醒<br>进程结束<br>1、进程创建<br>引起进程创建的3个主要事件：</p><ul><li>系统初始化时</li><li>用户请求创建一个新进程</li><li>正在运行的进程执行了创建进程的系统调用<br>但是创建了新的进程不一定可以执行。</li></ul><p>2、进程运行<br>内核选择一个就绪的进程，让它占用处理机并执行<br>就绪态—–&gt;执行态</p><p><img src="/images/os-interview/74.png"></p><p>其中涉及两个问题：</p><ul><li>为何选择？</li><li>如何选择？（涉及调度算法）</li></ul><p>3、进程等待<br>在以下情况下，进程等待（阻塞）:</p><p>请求并等待系统服务，无法马上完成</p><ul><li>启动某种操作，无法马上完成</li><li>需要的数据没有到达</li></ul><p><img src="/images/os-interview/75.png"></p><p>ps：进程等待事件的发起是有自己发起的。因为进程只能自己阻塞自己，因为只有进程自身才能知道何时需要等待某种事件的发生。<br>4、进程唤醒<br>唤醒进程的原因：</p><ul><li> 被阻塞进程需要的资源可被满足</li><li> 被阻塞进程等待的事件到达</li><li> 将该进程的PCB插入到就绪队列</li></ul><p><img src="/images/os-interview/76.png"></p><p>ps：进程只能被别的进程或者操作系统唤醒</p><p>5、进程结束<br>在以下四种情况下，进程结束</p><ul><li>正常退出（自愿的）</li><li>错误退出（自愿的）</li><li>致命错误（操作系统强制性的）</li><li>被其他进程所杀（强制性的）</li></ul><p><img src="/images/os-interview/77.png"></p><h2 id="7-6-进程状态变化模型"><a href="#7-6-进程状态变化模型" class="headerlink" title="7.6. 进程状态变化模型"></a>7.6. 进程状态变化模型</h2><p>1、进程的三种基本状态：<br>进程在生命结束前处于且仅处于三种基本状态之一，不同系统设置的进程状态数目不同。</p><ul><li>运行状态（Running）：当一个进程正在处理机上运行时。</li><li>就绪状态（Ready）：一个进程获得了除处理机之外的一切所需资源。一旦得到处理机即可运行。</li><li>等待状态（又称阻塞状态Blocked）：一个进程正在等待某一事件而暂停运行时。如等待某资源，等待输入/输出完成。</li></ul><p>2、三状态变化图：</p><p><img src="/images/os-interview/78.png"></p><p>进程其他的基本状态：</p><p>创建状态（New）：一个进程正在被创建，还没被转到就绪状态之前的状态。<br>结束状态（Exit）：一个进程正在从系统中消失时的状态，这是因为进程结束或由于其他原因所导致。<br>3、五状态变化图：</p><p><img src="/images/os-interview/79.png"></p><p>就绪态的出现是由于调度机制的存在。</p><p>4、可能的状态变化如下：</p><p>NULL-&gt;New: 一个新进程被产生出来执行一个程序。<br>New-&gt;Ready: 当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态。（不会持续很久，也就只是一个PCB的初始化。）<br>Ready-&gt;Running ：处于就绪状态的进程被进程调度程序选中后，就分配到处理机上来运行。<br>Running-&gt;Exit ：当进程表示它已经完成或出现错误，当前运行进程会有操作系统作结束处理。<br>Running-&gt;Ready ：处于运行状态的进程在其运行过程中，由于分配给它的处理机时间片用完而让出处理机。（操作系统完成）<br>Runing-&gt;Blocked ：当进程请求某样东西切必须等待时。（例如等待一个定时器的到达，读写文件，因为过程比较慢）<br>Blocked-&gt;Ready ：当进程要等待某事件到来时，它从阻塞状态变到就绪状态。（同样由操纵系统完成）</p><h2 id="7-7-进程的挂起"><a href="#7-7-进程的挂起" class="headerlink" title="7.7. 进程的挂起"></a>7.7. 进程的挂起</h2><p>进程挂起和进程阻塞的不一样的。<br>进程在挂起状态意味着进程没有占有内存空间。处于挂起状态的进程影像在磁盘上。</p><p>1、挂起状态</p><ul><li>阻塞挂起状态（Blocked-suspend）：进程在外存并等待某事件的出现；</li><li>就绪挂起状态（Ready-suspend）：进程在外存，但只要进入内存，即可运行。</li></ul><p>2、与挂起中相关的状态转换<br>挂起（Suspend）：把一个进程从内存转到外存；可能有以下几种情况：</p><ul><li>阻塞到阻塞挂起：没有进程处于就绪状态或就绪进程要求更多内存资源时，会进行这种转换，以提高新进程或运行就绪进程；</li><li>就绪到就绪挂起：当有高优先级阻塞（系统认为会很快就绪的）进程和低优先级就绪进程时，系统会选择挂起低优先级就绪进程；</li><li>运行到就绪挂起：对抢先式分时系统，当有高优先级阻塞挂起进程因事件出现（空间不够）而进入就绪挂起，系统可能会把运行进程转到就绪挂起状态。</li></ul><p>在外存时的状态转换：<br>阻塞挂起到就绪挂起：当有阻塞挂起进程相关事件出现时（也就是条件满足），系统会把阻塞挂起进程转换到就绪挂起进程。</p><p>解挂/激活（Activate）：把一个进程从外存转到内存；可能有以下几种情况：</p><ul><li>就绪挂起到就绪：没有就绪进程或挂起就绪进程优先级高于就绪进程时，会进行这种转换。</li><li>阻塞挂起到阻塞：当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起（系统认为会很快出现所等待的事件）进程转换为阻塞进程。</li></ul><p>问题：操作系统怎么通过PCB的定义的进程状态来管理PCB，帮助完成进程的调度过程？</p><p><img src="/images/os-interview/710.png"></p><p>以进程为基本结构的os，选择某一个进程变成某一种状态都是有操作系统来完成的。最底层为CPU调度程序（包括中断处理等）。上面一层为一组各式各样的进程。</p><p>3、状态队列<br>状态队列是操作系统管理进程的一个很重要的数据结构</p><ul><li>由操作系统来维护一组队列，用来表示系统当中所以进程的当前状态；</li><li>不同的状态分别用不同的队列来表示（就绪队列，各种类型的阻塞队列）；</li><li>每个进程的PCB都根据它的状态加入到相应的队列当中，当一个进程的状态发生变化时，它的PCB从一个状态队列中脱离出来，加入到另外一个队列。</li></ul><p>4、状态表示方法</p><p><img src="/images/os-interview/711.png"></p><p>要注意，如果事件1只能满足一个进程，那么只能把这一个进程从阻塞态变成就绪态。如果事件1产生之后，所以等待事件1的进程都等到满足，那么这些进程都会挂到就绪队列里面去。</p><p>线程管理：<br>很久之前，操作系统一直以进程作为独立运行的基本单位，直到80年代中期，人们有提出了更小独立运行的基本单位—线程。</p><ul><li>为什么使用线程？</li><li>什么是线程</li><li>线程的实现</li><li>多线程编程接口举例</li></ul><h2 id="7-8-为什么使用线程"><a href="#7-8-为什么使用线程" class="headerlink" title="7.8. 为什么使用线程"></a>7.8. 为什么使用线程</h2><p>例子：</p><p><img src="/images/os-interview/712.png"></p><p>1、单进程的实现方法</p><p><img src="/images/os-interview/713.png"></p><p>可能出现的问题：</p><ul><li>播放出来的声音能否连续？</li><li>各个函数之间不是并发执行，影响资源的使用效率。</li></ul><p>2、多进程的实现方法</p><p><img src="/images/os-interview/714.png"></p><p>可能出现的问题：</p><ul><li>进程之前如何通信，共享数据？</li><li>维护进程的系统开销比较大：<br>创建进程时，分配资源，建立PCB；撤销进程时，回收资源，撤销PCB；进程切换时，保存当前进程的状态信息。</li></ul><p>根据以上问题，提出一个新的实体，满足一下特性：</p><ul><li>实体之间可以并发地执行；</li><li>实体之间共享相同的地址空间；</li></ul><p>这个实体就是：线程（Thread）</p><h2 id="7-9-什么是线程"><a href="#7-9-什么是线程" class="headerlink" title="7.9. 什么是线程"></a>7.9. 什么是线程</h2><p>1、定义：进程当中的一条执行流程</p><p>2、从两个方面来重新理解进程</p><ul><li>从资源组合的角度：<br>进程把一组相关的资源组合起来，构成了一个资源平台（环境），包括地址空间（代码段，数据段）、打开的文件等各种资源；</li><li>从运行的角度：<br>代码在这个资源平台上的一条执行流程（线程）。</li></ul><p><img src="/images/os-interview/715.png"></p><p>ps：进程中的堆，代码段，数据段是线程所共享的内容。而各自又有独特的内容，比如所堆栈，程序计数器，寄存器（不同的执行留和控制流）。所以其有独立拥有的部分，也有公有的部分。</p><p>3、线程 = 进程 - 共享资源<br>线程的优点：</p><ul><li>一个进程中可以同时存在多个线程</li><li>各个线程之间可以并发地执行</li><li>各个线程之间可以共享地址空间和文件等资源</li></ul><p>线程的缺点：<br>一个线程奔溃，会导致其所属进程的所以线程奔溃，安全没有一定的保障。</p><p>4、不同操作系统对线程的支持</p><p><img src="/images/os-interview/716.png"></p><p>5、线程所需的资源</p><p><img src="/images/os-interview/717.png"></p><p>6、线程与进程的比较</p><ul><li>进程是资源分配单位，线程是CPU调度；</li><li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；</li><li>线程同样具有就绪、阻塞和执行三种基本状态，同样具有状态之间的转换关系；</li><li>线程能减少并发执行的时间和空间开销；</li></ul><p>线程的创建时间比进程短；<br>线程的终止时间比进程短；<br>同一进程内的线程切换时间比进程短；<br>由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信。<br>（切换进程的时候，需要把页表也切换掉，切换页表的开销比较大，因为硬件的信息无效，需要重新加载）</p><h2 id="7-10-线程的实现"><a href="#7-10-线程的实现" class="headerlink" title="7.10. 线程的实现"></a>7.10. 线程的实现</h2><p>主要有三种线程的实现方式：</p><ul><li>用户线程：在用户空间实现；</li><li>内核线程：在内核中实现；</li><li>轻量级进程：在内核汇总实现，支持用户线程</li></ul><p>用户线程：操作系统看不到的线程称为用户线程<br>内核线程：操作系统管理起来（能够看见）的线程称为内核线程</p><p>1、用户线程与内核线程的对应关系</p><ul><li>多对一</li></ul><p><img src="/images/os-interview/718.png"></p><ul><li>一对一</li></ul><p><img src="/images/os-interview/719.png"></p><ul><li>多对多</li></ul><p><img src="/images/os-interview/720.png"></p><p>2、用户进程</p><p><img src="/images/os-interview/721.png"></p><p>线程控制块（TCB）是在库里面实现的，对于操作系统而言，其看不见TCB，只能看见进程的信息，但是进程里面的线程信息，是有线程管理的库来实现的。<br>在用户空间实现的线程机制，它不依赖与操作系统的内核，由一组用户级的线程库函数来完成线程的管理，包括进程的创建，终止，同步和调度等。</p><p>由于用户线程的维护由相应进程来完成（通过线程库函数），不需要操作系统内核了解用户线程的存在，可用于不支持线程技术的多进程操作系统；<br>每个进程都需要它自己私有的线程控制块（TCB）列表，用来跟踪记录它的各个线程的状态信息（PC，栈指针，寄存器），TCB由线程库函数来维护；<br>用户线程的切换也是由线程库函数来完成，无需用户态/核心态切换，所以速度特别快；<br>允许每个进程拥有自定义的线程调度算法。<br>否则如果进程被操作系统调度为阻塞态，则其下的所有线程都无法允许。</p><p>用户线程的缺点：</p><ul><li>阻塞性的系统调用如何实现？如果一个线程发起系统调用而阻塞，则整个进程在等待。因为操作系统只能看见进程，所以这个进程阻塞，旗下所以的线程都会阻塞。</li><li>当一个线程开始执行后，除非它主动地交出CPU的使用权，否则它所在的进程当中的其他线程将无法运行。</li><li>由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会较慢。</li></ul><p>3、内核线程<br>（操作系统看得见，TCB是放在内核里面的）</p><p><img src="/images/os-interview/722.png"></p><p>内核线程是指在操作系统的内核当中实现的一种线程机制，由操作系统的内核来完成线程的创建，终止和管理。</p><p>在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息（PCB和TCB）；<br>线程的创建，终止和切换都是通过系统调用/内核函数的方式来进行，由内核来完成，因此系统开销较大；<br>在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不影响其他内核线程的运行；<br>时间片分配给线程，多线程的进程获得更多的cpu时间；<br>Windows NT和Windows 200/XP支持内核线程<br>4、轻量级进程（LightWeight Process）<br>它是内核支持的用户线程，一个进程可有一个或多个轻量级进程，每个轻量级进程有一个单独的内核线程来支持，（Solaris/Linux）</p><p><img src="/images/os-interview/723.png"></p><h2 id="7-11-上下文切换"><a href="#7-11-上下文切换" class="headerlink" title="7.11. 上下文切换"></a>7.11. 上下文切换</h2><p>1、定义：停止当前运行的进程（从运行状态改变成其他状态）并且调度其他进程（转变成运行状态的）的过程，称为进程的上下文切换（Compress）</p><p>必须在切换之前存储许多部分的进程上下文<br>必须能够在之后恢复他们，所以进程不能显示它曾经被暂停过<br>必须快速（上下文准换是非常频繁的）<br>进程的上下文切换所具体切换的进程所用到的寄存器，使用要关注cpu有哪些寄存器（PC程序计数器，SP堆栈指针）。而在做进程切换的时候，需要将这新信息保存到进程控制块的某一个地方上。</p><p>2、切换的过程</p><p><img src="/images/os-interview/724.png"></p><p>所用的信息都是和硬件紧密相连的，所用一般是使用汇编代码来完成编写。</p><p>操作系统为活跃进程准备了进程控制块（PCB）<br>操作系统将进程控制块（PCB）放置在一个合适的队列里</p><p>就绪队列<br>等待I/O队列（每个设备的队列）<br>僵尸队列</p><p><img src="/images/os-interview/725.png"></p><h2 id="7-12-进程控制—创建进程"><a href="#7-12-进程控制—创建进程" class="headerlink" title="7.12. 进程控制—创建进程"></a>7.12. 进程控制—创建进程</h2><p>window系统下：</p><p><img src="/images/os-interview/726.png"></p><p>linux系统下：</p><p><img src="/images/os-interview/727.png"></p><p>fork（）创建一个继承的子进程</p><p>复制父进程的所有变量和内存<br>复制父进程的所以CPU寄存器（有一个寄存器除外）<br>fork（）的返回值</p><p>子进程的fork()返回0<br>父进程的fork()返回子进程标识符<br>fork()返回值可方便后续使用，子进程可使用getpid()获取PID<br>父子进程的主要区别—-childPID不一样：</p><p><img src="/images/os-interview/728.png"></p><h2 id="7-13-进程控制—加载和执行过程"><a href="#7-13-进程控制—加载和执行过程" class="headerlink" title="7.13. 进程控制—加载和执行过程"></a>7.13. 进程控制—加载和执行过程</h2><p>系统调用exec()加载程序取代当前运行的进程</p><p><img src="/images/os-interview/79.png"></p><p>其中：<br>exec是准备执行一个新的程序，所以当成功的执行了exec之后，后面的printf函数是不会执行到的。<br>wait(pid); wait返回了，表示子进程就结束了。</p><p>当执行exec的时候，代码数据都复制了一份，但是PID没有变化。但是执行的代码改变了，也就是另外程序的执行过程，如下所示。</p><p><img src="/images/os-interview/730.png"></p><p>执行exec之后，程序的整个控制流会放生完全的变化</p><p><img src="/images/os-interview/731.png"></p><ul><li>exec()调用允许一个进程“加载”一个不同的程序并且在main开始执行(事实上_start，系统调用)</li><li>它允许1一个进程指定参数的数量(argc)和它字符串参数数组(argv)</li><li>代码段，数据段，stack（栈）&amp;heap（堆）都会被覆盖</li></ul><p>fork()的简单实现</p><p>对子进程分配内存<br>复制父进程的内存和CPU寄存器到子进程里<br>在99%的情况里，我们在调用fork()之后调用exec()</p><p>在fork()操作中内存复制是没有作业的<br>子进程将可能关闭打开的文件和链接<br>对于此情况需要一个优化：<br>vfork(),vfork只是复制了一小部分的进程的内容，绝大多数的内容都没有被复制。但是这会使系统调用变成两个fork，增加了编程人员的开销。</p><p>另一个优化：<br>通过虚存管理科员实现一个高效的fork实现机制。也就是（Copy on Write，COW）技术，就是写的时候再进行复制。<br>当父进程创建子进程的时候，如果采用COW技术时，我们在做实际的子进程地址空间复制的时候并没有真是的复制，只是复制了父进程所需要的元数据—页表等等，实现按需写的情况来复制不同的页。</p><h2 id="7-14-进程控制—等待和终止进程"><a href="#7-14-进程控制—等待和终止进程" class="headerlink" title="7.14. 进程控制—等待和终止进程"></a>7.14. 进程控制—等待和终止进程</h2><p>wait()系统调用是被父进程用来等待子进程的结束</p><p>父进程先与子进程死亡—子进程为孤儿进程<br>子进程已经死亡，但父进程还没来得及回收—子进程为僵尸进程<br>状态转换图：</p><p><img src="/images/os-interview/732.png"></p><p>ps：执行exec的时候，程序有可能会处于不同的状态。<br>因为在执行exec有两个步骤，一个是加载执行程序，二个是运行执行程序。加载的时候，所需要的时间比较长，所以会处于阻塞状态。</p><h1 id="8-处理器调度"><a href="#8-处理器调度" class="headerlink" title="8. 处理器调度"></a>8. 处理器调度</h1><h2 id="8-1-背景"><a href="#8-1-背景" class="headerlink" title="8.1. 背景"></a>8.1. 背景</h2><p>1、上下文切换：</p><p>切换CPU的当前任务，从一个进程/线程到另一个<br>保存当前进程/线程在PCB/TCP中的执行上下文（CPU状态）<br>读取下一个进程/线程的上下文<br>2、CPU调度<br>从就绪队列中挑选一个进程/线程作为CPU将要运行的下一个进程/线程<br>调度程序：挑选进程/线程的内核函数（通过一些调度策略）<br>什么时候进程调度？调度算法实现</p><p>问题：在进程/线程的生命周期中的什么时候进行调度？</p><p><img src="/images/os-interview/80.png"></p><p>3、内核运行调度程序的条件（满足一条即可）</p><ul><li>一个进程从运行状态切换到等待状态</li><li>一个进程被终结了</li></ul><p>4、是否可以抢占<br>不可抢占：</p><p>调度程序必须等待事情结束<br>可以抢占：（常用，针对用户态的）</p><p>调度程序在中断被响应后执行<br>当前的进程从运行切换到就绪，或者一个进程从等待切换到就绪<br>当前运行的进程可以被换出<br>抢占使得系统程序更加的灵活和高效。</p><h2 id="8-2-调度原则"><a href="#8-2-调度原则" class="headerlink" title="8.2. 调度原则"></a>8.2. 调度原则</h2><p>根据什么原则去选择一个进程去执行，这个就是调度的原则<br>1、执行模型<br>程序在CPU突发和I/O中交替</p><p>每个调度决定都是关于在下一个CPU突发时将哪个动作交给CPU<br>在时间分片机制下，线程可能在结束当前CPU突发前被迫放弃CPU<br>2、评价的指标</p><ul><li>CPU利用率：CPU处于忙碌状态所占时间的百分比</li></ul><p>cpu利用率越高，可以认为当前系统的效率比较好。进程调度进行得好。</p><ul><li>吞吐量：在单位时间内完成的进程数量</li></ul><p>吞吐量越高，说明进程的效率越好。当然希望当操作系统跑一堆进程时，吞吐率都很高。</p><ul><li>周转时间：一个进程从初始化到结束，包括所有等待时间所花费的时间。</li></ul><p>周转时间越断越好。</p><ul><li>等待时间：进程在就绪队列中的总时间</li></ul><p>指的是出于就绪态的时间越短，就越快被cpu执行</p><ul><li>响应时间：从一个请求被提交到产生第一次响应所花费的总时间</li></ul><p>同样也是越短越好<br>以上可以对cpu调度的指标有一个分析。</p><p>人们通常都需要“更快”的服务<br>什么是更快：</p><p>传输文件时的高带宽<br>玩游戏时的低延迟<br>这两个因素是独立的<br>和水管类比：</p><p>低延迟：喝水的时候想要一代开水龙头水就流出来<br>高带宽：给游泳池充水时希望从水龙头里同时流出大量的水，并且不介意是否存在延迟<br>3、算法需达到的效果</p><ul><li>减少响应时间<br>及时处理用户的输出并且尽快将输出提供给用户</li><li>减少平均响应时间的波动<br>在交互系统中，可虞可预测性比高差异低平均更重要</li><li>增加吞吐量–两个方面<br>减少开销（操作系统开销，上下文切换）<br>系统资源的高效利用（CPU,I/O设备）</li><li>减少等待时间<br>减少每个进程的等待时间</li></ul><p>其实很难满足以上的全部效果，只能泽中或者在特定场合中选择某种特定效果。</p><p>4、公平性<br>公平的定义：</p><p>保证每个进程都占用相同的cpu时间<br>保证每个进程都等待相同的时间<br>公平通常会增加平均响应时间</p><h2 id="8-3-调度算法"><a href="#8-3-调度算法" class="headerlink" title="8.3. 调度算法"></a>8.3. 调度算法</h2><p>调度算法有三类：</p><ul><li>通常操作系统设计的基本调度算法</li><li>嵌入式设备实时的调度算法</li><li>针对多处理器的调度算法与考虑</li></ul><p>一、常用系统的调用算法</p><p>FCFS （先来先服务） （First Come， First Served）<br>SPN（SJF）SRT (短进程优先（短作业优先）剩余时间优先) Shortest Process Next(Shortest Job<br>First) Shortest Remaining Time<br>HRRN (最高响应比优先) Highest Response Ratio Next<br>Round Robin （轮循） 使用时间切片和抢占来轮流执行任务<br>Multilevel Feedback Queues （多级反馈队列） 优先级队列中的轮循<br>Fair Share Scheduling （公平共享调度）<br>二、先来先服务调度（FCFS）</p><p><img src="/images/os-interview/81.png"></p><p>如图所示，如果前面的进程越长，后面的进程等待的时间就越长，从而会影响整个系统的周转时间。</p><p>优点：<br>简单</p><p>缺点：</p><ul><li>平均等待时间波动较大，平均的周转时间也会比较大</li><li>花费时间少的任务可能排在花费时间长的任务后面，没有考虑抢占</li><li>可能导致I/O和CPU之间的重叠处理（cpu密集型进程会导致I/O设备闲置时，I/O密集型进程也在等待）</li></ul><p>三、短任务优先算法</p><p><img src="/images/os-interview/82.png"></p><p>当一个更短时间进程来了之后，有两种策略：</p><ul><li>不理，将这个时间更短的程序排在前面，但是继续执行本来在执行的进程，这种是非抢占性的。（SPN）</li><li>将这个时间更短的程序与正在执行的程序剩余所需要执行的时间进行比较，如果跟多，这打断正在执行的程序，这种是可抢占的。（SRT）</li></ul><p>优点：<br>平均等待时间最短</p><p><img src="/images/os-interview/83.png"></p><p>缺点：</p><ul><li>可能导致饥饿</li></ul><p>连续的短任务流会使长任务饥饿<br>短时间可用时的任何长任务的CPU时间都会增加平均等待时间</p><ul><li>需要预知未来</li></ul><p>怎么预估下一个CPU突发的持续时间<br>简单的解决方法：询问用户<br>如果用户欺骗就杀死进程<br>如果用户不知道就采用预估方法<br>根据过去，预测未来，大致的预测方法如下：</p><p><img src="/images/os-interview/84.png"></p><p>结果大致的相同</p><p><img src="/images/os-interview/85.png"></p><p>四、最高响应比优先算法<br>在SPN调度的基础上改进</p><p><img src="/images/os-interview/86.png"></p><p>R值越高表示等待的时间越长，就会优先的调度这种进程。</p><p>优点：<br>充分的考虑到了进程的等待时间，所有之前的饥饿现象会得到有效的化解。</p><p>缺点：</p><ul><li>不可抢占</li><li>依然需要知道执行的时间是多长，所以还是要预估</li></ul><p>五、轮循算法<br>各个cpu轮流占用cpu去执行，在叫做量子(或时间切片)的离散单元中分配处理器，时间片结束后，切换到下一个准备好的进程。</p><p><img src="/images/os-interview/87.png"></p><p>每一个进程都有机会去被cpu执行</p><p>例子：</p><p><img src="/images/os-interview/88.png"></p><p>可见，轮流算法的平均等待时间是比较大的。</p><p>特点：</p><ul><li>会比较到的切换时间，进程上下文的切换，确保公平</li><li>时间片太大（有可能退化为先来先服务）</li></ul><p>等待时间过长<br>极限情况退化成FCFS</p><ul><li>时间片太小（切换过于频繁）</li></ul><p>吞吐量由于大量的上下文切换开销收到影响<br>目标：</p><p>选择一个合适的时间量子<br>经验规则：维持上下文切换开销处于1%以内，这样的情况下99%的时间都是在<br>进程的执行过程中</p><p>与先来先服务算法 进行比较：</p><p><img src="/images/os-interview/89.png"></p><p>六、多级反馈队列<br>首先完成高优先级的进程，待其完成了所以的任务之后，再去完成第优先级的进程，这样通过分层不同级别的队列，可以实现调度的区分，使得调度的策略更加的合适。<br>而且进程在不同阶段的特点是不同的，所以调度算法可以考虑到进程各阶段的特点来调整其在队列中的级别。这个就是多级反馈队列可以体现。</p><p><img src="/images/os-interview/810.png"></p><p>特点：</p><ul><li>时间量子大小随优先级级别增加而增加</li><li>如果任务在当前的时间量子中没有完成，则降到下一个优先级</li><li>能够区分进程在动态执行过程中动态的调整进程优先级，使得IO密集型的任务可以很快的执行，而CPU密集型的任务放在优先级较低位置。</li></ul><p><img src="/images/os-interview/811.png"></p><p>七、公平共享调度<br>FFS控制用户对系统资源的访问</p><p>一些用户组比其他组更重要<br>保证不重要的组无法垄断资源<br>未使用的资源按照每个组所分配的资源比例来分配<br>没有达到资源使用率目标的组获得更高的优先级</p><p>八、小结</p><ul><li>FCFS先来先服务</li></ul><p>不公平，平均等待时间较差</p><ul><li>SPN/SRT段进程优先</li></ul><p>不公平，但是平均等待时间最小<br>需要精确预测计算时间<br>可能导致饥饿</p><ul><li>HRRN最好响应比优先</li></ul><p>基于SPN调度改进（考虑了等待时间）<br>不可抢占</p><ul><li>Round Robin轮循</li></ul><p>公平，但是平均等待时间较差<br>每一个进程有固定的时间片，但是上下文开销较大</p><ul><li>MLFQ舵机反馈对列</li></ul><p>和SPN类似<br>动态调整进程优先级</p><ul><li>公平共享调度</li></ul><p>公平是第一要素</p><h2 id="8-4-实时调度"><a href="#8-4-实时调度" class="headerlink" title="8.4. 实时调度"></a>8.4. 实时调度</h2><p>面向的是实时的系统，更多的是工业控制（火车，机床等等）<br>1、定义<br>正确性依赖于其时间和功能两个方面的一种操作系统</p><p>2、性能指标</p><ul><li>时间约束的及时性（deadlines）</li><li>速度和平均性能相对不重要</li></ul><p>3、主要特征<br>时间约束的可预测性</p><p>4、分类</p><ul><li>强实时系统<br>需要在保证的时间内完成重要的任务，必须完成</li><li>弱实时系统<br>要求重要的进程的优先级更高，尽量完成，并非必须</li></ul><p><img src="/images/os-interview/812.png"></p><p>Released ：让进程处于就绪态的时间<br>Execution time：执行时间<br>Absolute deadline：绝对的截止时间，任务的执行不可以操作这个时间<br>Relative deadline：相对截止时间，因为任务是间隔的，一段时间完成一个任务</p><p><img src="/images/os-interview/813.png"></p><p>（周期是5，执行的时间就是蓝色的区域）</p><p>5、特点<br>硬时限：</p><p>如果错过了最后的期限，可能会发生灾难性或非常严重的后果<br>必须验证：在最坏的情况下也能够满足时限<br>保证确定性<br>软时限：</p><p>理想情况下，时限应该被最大满足。如果有时限没有被满足，那么就相应地降低要求<br>尽量大努力去保证<br>表示一个实时系统是否能够满足deadline要求</p><p>决定实时任务执行的顺序<br>静态优先级调度<br>动态优先级调度<br>6、实时系统中的两类调度算法：</p><ul><li>RM（Rate Monotonic）速率单调调度</li></ul><p>最接静态优先级调度<br>通过周期安排优先级<br>周期越短优先级越高<br>执行周期最短的任务</p><ul><li>EDF（Earliest Deadline First）最早期限调度</li></ul><p>最佳的动态优先级调度<br>Deadline越早优先级越高<br>执行Deadline最早的任务<br>8.5多处理器调度与优先级反转<br>一、多处理器调度<br>1、多处理器的cpu调度更加复杂</p><p>多个相同的单处理器组成一个多处理器<br>负载平衡状态<br>2、对称多处理器（SMP）</p><p>每个处理器运行自己的调度程序<br>需要在调度程序中同步</p><p><img src="/images/os-interview/814.png"></p><p>二、优先级反转<br>出现的原因：<br>T1的执行时间受制于T2的执行时间，因为T2抢占了T3的cpu时间去执行，而T1的执行有必须等待T3处理完共享内容，所以T1的执行时间被T2延长了。从而导致T1不能及时的完成其任务，导致系统处于不稳定状态而重启。</p><p><img src="/images/os-interview/815.png"></p><p>特点：<br>可以发生在任何基于优先级的可抢占的调度机制中。<br>当系统内的环境强制性使高优先级任务等待低优先级任务时发生。</p><p>解决方法：<br>1、优先级继承（将问题发生时，提升T3的优先级）<br>低优先级继承高优先级任务的优先级依赖于他们共享的资源</p><p><img src="/images/os-interview/816.png"></p><p>2、天花板优先级</p><ul><li>“资源”的优先级和“所有可以锁定该资源的任务中优先级最高的那个任务”的优先级相同。</li><li>除非优先级高于系统中所有被锁定的资源的优先级上限，否则任务尝试执行临界区的时候会被阻塞</li><li>持有最高优先级上限信号量锁的任务，会继承被该锁所阻塞的任务的优先级</li></ul><h1 id="9-同步互斥问题"><a href="#9-同步互斥问题" class="headerlink" title="9. 同步互斥问题"></a>9. 同步互斥问题</h1><h2 id="9-1-背景知识"><a href="#9-1-背景知识" class="headerlink" title="9.1. 背景知识"></a>9.1. 背景知识</h2><p>1、如果资源处理不当，可能会出现一些意想不到的情况，合作的风险<br>独立的线程：</p><p>不和其他线程共享资源或状态<br>确定性-&gt;输入状态决定结果<br>可重现-&gt;能够重现起始条件<br>调度顺序不重要<br>合作线程：</p><p>在多喝线程中共享状态<br>不确定性<br>不可重现（不可重复性）<br>这些不确定性和不可重复以意味着bug可能是间歇性发生的，也就是合作是有风险的。</p><p>2、为什么要合作</p><ul><li>共享资源<br>资源是需要共享的，因为进程可能要访问同一个文件。</li><li>加速<br>通过并行和并发，可以提高系统的效率，实现更有效的资源的利用。相当于把一个大的任务，拆分成多个小的任务，每个任务通过并行的执行提高系统的性能。</li><li>模块化<br>在设计时将一个大的工作，变成一个小的工作，使之具有模块化，使系统便于扩展。</li></ul><p>3、问题出现的原因<br>例子：</p><p><img src="/images/os-interview/91.png"></p><p>以上四条汇编指令的意思是：</p><ul><li>把next_pid赋值给寄存器1（Reg1）</li><li>再把这个寄存器1存到了new_pid这个内存单元的去。此时new_pid就具有了next_pid这个值。</li><li>寄存器1加一操作。</li><li>完成next_pid的值增加了一个1的操作。<br>总的实现过程：<br>先把new_pid = next_pid，然后next_pid再加1.</li></ul><p>但是，如果这时有两个进程，就会出现意想不到的情况：</p><p><img src="/images/os-interview/92.png"></p><p>问题产生的原因：<br>在第二次进程的上下文切换时候，进程1的寄存器恢复之后依然100的值，是的next的值无法更新称为102。最终产生了切换使得最终的结果不是想要的结果。这是一种典型的异常现象。</p><h2 id="9-2-一些概念part1"><a href="#9-2-一些概念part1" class="headerlink" title="9.2. 一些概念part1"></a>9.2. 一些概念part1</h2><p>由于上述产生的异常现象（称之为竞态条件Race Condition），这就是为什么要引入同步互斥这些机制的原因，就是要解决这种不确定性的问题。</p><p>1、系统缺陷：结果依赖于并发执行或者事件的顺序/时间<br>不确定性<br>不可重现</p><p>2、怎样避免竞态？<br>让指令不被打断（比如上述的四条机器指令不被打断）</p><p>3、不被打断的方法：原子操作（Atomic Operation）—不可被打断操作<br>原子操作是指一次不存在任何中断或者失败的执行</p><p>该执行成功结束<br>或者根本没有执行<br>并且不应该发现任何部分执行的状态<br>实际上操作往往不是原子的</p><p>有些看上去是原子操作，实际不是<br>连x++这样简单的语句，实际上是由3条指令造成的<br>有时候甚至连条单条机器指令都不是原子的<br>例子：</p><p><img src="/images/os-interview/93.png"></p><p>所以需要后续的同步机制，确保或者是A赢或者是B赢。</p><p>4、一些基本概念</p><p>临界区（Critical section）<br>临界区是指进程中的一段需要访问共享资源并且当另一个进程处于相应代码区域时便不会被执行的代码区域。简单来说，就是访问共享资源的那段代码就是临界区。</p><p>互斥（Mutual exclusion）<br>当一个进程处于临界区并访问共享资源时，没有其他进程会处于临界区并且访问任何相同的共享资源。</p><p>死锁（Dead lock）<br>两个或以上的进程，在互相等待完成特定任务，而最终没法将自身任务进行下去。</p><p>饥饿（Starvation）<br>一个可执行的进程，被调度器持续忽略，以至于虽然处于可执行状态却不被执行</p><h2 id="9-3-一些概念part2"><a href="#9-3-一些概念part2" class="headerlink" title="9.3. 一些概念part2"></a>9.3. 一些概念part2</h2><p>1、一个有趣的类比：</p><p><img src="/images/os-interview/94.png"></p><p>2、解决的方法和概念</p><p><img src="/images/os-interview/95.png"></p><p>3、更好的解决方法（轻量级）</p><p><img src="/images/os-interview/96.png"></p><p>但是由于进程上下文切换的原因，问题还是会存在。</p><p><img src="/images/os-interview/97.png"></p><p>如果只是将Note往前面提简单的挪动一下还是不会解决问题，变成谁都不会去买面包了。</p><p><img src="/images/os-interview/98.png"></p><h2 id="9-4-一些概念part3"><a href="#9-4-一些概念part3" class="headerlink" title="9.4. 一些概念part3"></a>9.4. 一些概念part3</h2><p>1、再换一个方法</p><p><img src="/images/os-interview/99.png"></p><p>结果还是有问题的。</p><p><img src="/images/os-interview/910.png"></p><p>需要确保在任何情况下，只有一个进程在临界区中执行，其他的进程需要在外面等待。</p><p>一个更加合理的方案解析过程：</p><p><img src="/images/os-interview/911.png"></p><p><img src="/images/os-interview/912.png"></p><p><img src="/images/os-interview/913.png"></p><p>程序是有效的，但是导致代码不一样了。</p><p>最终的解决方案：<br>为每一个线程保护了一段“临界区”代码。使用临界区的思想，问题就可以较好的解决。其是讲前诉方法的一个抽象。<br>有了临界区的代码之后，就可以确保任何时候只有一个进程在临界区中执行，切其他进程在外面等待，知道临界区中的进程离开，其他进程中的一个会进入临界区去执行。这个是比较合理的一个实现。</p><h2 id="9-5-临界区"><a href="#9-5-临界区" class="headerlink" title="9.5. 临界区"></a>9.5. 临界区</h2><p>在临界区中执行所拥有的属性：<br>1、互斥：同一个时间临界区中最多存在一个线程<br>2、前进（Progress）：如果一个线程想要进入临界区，那么它最终会成功，不会一直的死等。<br>3、有限等待：如果一个线程i处于入口区，那么在i的请求被接受之前，其他线程进入临界区的时间是有限制的。如果是无限等待，就会出现饥饿状态，是Progress前进状态的一种进一步补充。<br>4、忙等（可选属性）：如果一个进程在等待进入临界区，那么在它可以进入之前会被挂起。</p><p>基于这些属性，设计一些方法对临界区进行保护：<br>方法一：禁用硬件中断<br>方法二：基于软件的解决方法<br>方法三：更高级的抽象（基于硬件原子操作的指令）</p><h2 id="9-6-禁用硬件中断"><a href="#9-6-禁用硬件中断" class="headerlink" title="9.6. 禁用硬件中断"></a>9.6. 禁用硬件中断</h2><p>一、基本实现<br>没有中断，也就是没有了上下文切换，因此没有并发。</p><p>硬件将中断处理延迟到中断被启用之后<br>大多数现代计算机体系结构都提供指令来完成<br>进入临界区时禁用中断，离开临界区时开启中断。这个方法是可以解决问题的。</p><p>二、缺点<br>1、一旦中断被禁用，线程就无法被停止</p><ul><li>整个系统都会为你停下来</li><li>可能导致其他线程处于饥饿状态</li></ul><p>2、要是临界区可以任意长<br>无法限制响应中断所需的时间（可能存在硬件影响）</p><p>需要注意：<br>执行这种课屏蔽中断的指令，只是把自身的响应中断的能力屏蔽了，并不意味着也将其他cpu的响应中断能力屏蔽，所以其实其他的cpu还是可以继续产生中断，所以在多cpu的情况下是无法解决互斥问题的。</p><h2 id="9-7-基于软件的解决方案"><a href="#9-7-基于软件的解决方案" class="headerlink" title="9.7. 基于软件的解决方案"></a>9.7. 基于软件的解决方案</h2><p>一、思考方案<br>1、思考方案一：<br>某一个进程，它想进入临界区，其有一个顺序（次序），根据这个次序决定谁会进入这个临界区。</p><p>方法如下所示：</p><p><img src="/images/os-interview/915.png"></p><p>假设这个线程的次序是0，那么当turn=0时，才去继续下面的执行临界区代码，否者在while循环中一直打转。条件满足时，改变使得turn=1。<br>而进程1的代码也是类似的，只是while循环中的判断条件是不等于0，下面的turn=0.</p><p>这个程序的弊端是：<br>必须进程1执行一次临界区，进程0执行一次临界区，然后两个交替执行，才能保证两继续的执行。一旦其中的一个进程不愿意再做这个事情，那按照之前的属性，其他进程先进去就应该能够进去，但是在这种模式下，就无法完成这个前进的属性。</p><p>2、思考方案二：<br>前面表示了一个turn是不够表示，所以接下来使用一个小数组flag[2]来表示这个进程是否想进入临界区。</p><p>flag[0] = 1 //表示进程0想进入临界区执行<br>flag[0] = 1 //表示进程1想进入临界区执行<br>方法1如下所示：</p><p><img src="/images/os-interview/916.png"></p><p>但是这个代码是有问题的，不能满足互斥这个属性。<br>因为在初始的时候，两个进程都不会想进入临界区，所以两个flag都会赋值为0，表面没有这个需求。这样就是的两个进程都会跳出这个循环，然后都会将直接复制为，想要进入临界区，也就出现了多买面包的想象。</p><p>方法2如下所示：</p><p><img src="/images/os-interview/917.png"></p><p>满足了互斥，但是倘若两个线程都赋值了1，出现上下文切换的时候，都无法跳出这个循环，也就是出现是死锁的情况。</p><p>可见，互斥的解决并没有想象的那么简单~~~</p><p>二、正确实现<br>1、正确的接法<br>将以上的两种思考都综合起来使用。三个变量共同的作用。</p><p><img src="/images/os-interview/918.png"></p><p>算法如下：</p><p><img src="/images/os-interview/919.png"></p><p>该算法可以满足互斥，前进和有限等待三个属性。<br>反证法来证明：<br>假定，现在两个进程都进入了临界区，都在执行临界区代码，但是turn只是一个值的，所以总会有一个线程会跳出循环的。</p><p>2、另外一种算法<br>所需的变量空间相同，但是更加的复杂</p><p><img src="/images/os-interview/920.png"></p><p>三、拓展<br>1、n进程解决方法1 （E&amp;M算法）<br>除了了针对两个进程之外，还可以拓展到n个进程如何保证互斥。</p><p><img src="/images/os-interview/921.png"></p><p>大致的思路：<br>对于进程i而言，对于其前面的进程而言，如果有进程想进入临界区，或者已经进入了临界区，那么i进程就必须等待。而对于i进程后面的进程，必须要等待i进程执行之后在进入临界区。这样就可以通过一个循环的方式完成n个进程有序的进入临界区。</p><p>2、n进程解决方法2（Bakery算法）<br>大致思路如下：</p><p><img src="/images/os-interview/922.png"></p><p>四、总结</p><ul><li>即使是针对两个进程的解决竞态的实现还是比较复杂的。</li><li>需要忙等待，浪费cpu时间。</li><li>没有硬件包装的情况下无真正的软件解决方案。对硬件的1需求比较低（只需要load操作和store是原子操作即可）</li></ul><h2 id="9-8-更高级的抽象-—-基于原子操作"><a href="#9-8-更高级的抽象-—-基于原子操作" class="headerlink" title="9.8. 更高级的抽象 — 基于原子操作"></a>9.8. 更高级的抽象 — 基于原子操作</h2><p>软件的处理比较复杂有没有更加简单的实现方法？<br>一、基础</p><p><img src="/images/os-interview/923.png"></p><p><img src="/images/os-interview/924.png"></p><p><img src="/images/os-interview/925.png"></p><p>使用了一些特殊的操作：<br>1、Test-and-Set测试和置位<br>（一条机器指令，但是完成了读写操作两条指令的功能）<br>从内存中读取值<br>测试该值是否为1（然后返回真或假）<br>内存值设置为1</p><p>2、交换<br>（交换内存中的两个值）</p><p>只要计算机系统提供了这两条的其中一条指令就可以很容易的完成互斥的问题。</p><p>二、解决的方法<br>1、Test-and-Set方式</p><p><img src="/images/os-interview/926.png"></p><p>解决忙等的情况：先让其睡眠，在加一步唤醒操作</p><p><img src="/images/os-interview/927.png"></p><p>两者的区别：</p><p>忙等：不需要上下文切换，但是利用率低，适用与临界区执行时间短的情况。<br>不忙等：需要上下文切换，上下文切换开销比较大大，适用于临界区很长，远远大于上下文切换所需要的开销。<br>2、交换的方式</p><p><img src="/images/os-interview/928.png"></p><p>解析：<br>1)当一个进程想要进入临界区的时候，key=1，而且lock的初始值是0，所以当执行到while循环的时候，由于执行了交换，交换执行的过程不会被打断进行上下文切换的操作，而后lock的变成了1，而key变成了0.所以会退出循环，执行临界区的代码。<br>2)需要注意的是，当进入临界区的时候，load已经是1，当其他进程进入临界区执行的时候，load是1，而key也是1，交换之后还是1，一直会循环的等待，进入不了临界区。知道进入临界区的进程，退出临界区之后，完成一个将load变成0的操作。其他等待的进程才会继续执行exchange。</p><p>三、采用这种原子操作的特点<br>1、优点</p><ul><li>简单并且容易证明</li><li>适用于单处理器或者共享主存的多处理器中任意数量的进程</li><li>可以很容易拓展n个进程，可以用于支持多临界区</li><li>开销比较小</li></ul><p>2、缺点</p><ul><li>忙等待消耗处理器时间</li><li>当进程离开临界区并且多个进程在等待的时候可能导致饥饿现象</li><li>出现死锁的情况（例子：如果一个低优先级的进程拥有临界区并且一个高优先级进程也需求，那么高优先级进程会获得处理器并且等待临界区 — 需要用优先级反转的方式进行处理）</li></ul><p>四、总结<br>1、锁是更高级的编程抽象</p><p>互斥可以使用锁来实现<br>通常需要一定等级的硬件支持<br>2、常用的三种实现方法</p><p>禁用中断（仅限于单处理器）<br>软件方法（复杂）<br>原子操作指令（但处理器或多处理器均可）—更常用<br>3、可选的实现内容</p><p>有忙等待<br>无忙等待</p><h1 id="10-信号量与管程"><a href="#10-信号量与管程" class="headerlink" title="10. 信号量与管程"></a>10. 信号量与管程</h1><h2 id="10-1-背景"><a href="#10-1-背景" class="headerlink" title="10.1. 背景"></a>10.1. 背景</h2><p>利用信号量和管程解决同步互斥的问题</p><p>1、并发问题：竞争条件（竞态条件）</p><p>多程序并发存在大的问题<br>2、同步</p><ul><li>线程共享公共数据的协调条件</li><li>包括互斥与条件同步</li><li>互斥：在同一时间只有一个线程可以执行临界区</li></ul><p>3、解决同步问题正确比较难</p><ul><li>需要高层次的编程抽象（如：锁）</li><li>从底层硬件支持编译</li></ul><p>解决的过程图如下所示：</p><p><img src="/images/os-interview/101.png"></p><h2 id="10-2-信号量"><a href="#10-2-信号量" class="headerlink" title="10.2. 信号量"></a>10.2. 信号量</h2><p>（与信号灯有类似之处）<br>1、抽象数据类型</p><ul><li>一个整形（sem），两个原子操作</li><li>p操作：sem减一</li></ul><p>如果信号量sem&lt;0，认为执行p操作的进程需要睡眠<br>如果信号量sem&gt;0，认为执行p操作的进程可以继续执行，可以进入临界区<br>如果挡住了，就不能执行后续的程序，起到了一个阻挡的作用。</p><ul><li>v操作：sem加一</li></ul><p>如果信号量sem&lt;=0，认为当前的进程等待在这一个信号量上面，然后会唤醒这个进程（一个或多个）<br>2、信号量的图解机制</p><p><img src="/images/os-interview/102.png"></p><p>如果再来一个列车，信号量就不够了，直到一个列车离开了这个临界区之后，会执行一个v操作，而进入临界区之前会执行一个p操作。</p><p><img src="/images/os-interview/103.png"></p><p>离开这个临界区执行v操作之后，这个进程将道空出来之后，还会通知等待的列车去执行</p><p><img src="/images/os-interview/104.png"></p><p>3、由来</p><p><img src="/images/os-interview/105.png"></p><h2 id="10-3-信号量的使用"><a href="#10-3-信号量的使用" class="headerlink" title="10.3. 信号量的使用"></a>10.3. 信号量的使用</h2><p>一、基础<br>1、属性</p><ul><li><p>信号量是整数（有符号数）<br>一开始通常会设定为一个大于0的数，所以一开始执行p操作不会被阻塞。但是多次执行p操作之后，执行p操作的进程就会等待在上面。这时需要起床进程执行v操作，然后唤醒等在这个上面的进程。（如果只能唤醒一个进程，一般是唤醒第一个等待的进程，FIFO对列）</p></li><li><p>信号量是被保护的变量</p></li></ul><p>初始化完成后，唯一改变一个信号量的值的办法是通过p操作或者是v操作<br>操作必须是原子</p><ul><li><p>p操作（信号量减一操作）能够阻塞，v操作（信号量加一操作）不会阻塞</p></li><li><p>假定信号量是公平的</p></li></ul><p>没有线程被阻塞在p操作仍然阻塞如果v操作被无限频繁地调用（在同一个信号量）<br>在实践中，FIFO经常被使用<br>2、两种类型信号量</p><ul><li>二进制信号量：可以是0或1（与前面的lock达到同样的效果）</li><li>一般/计数信号量：可取任何非负值</li><li>两者互相表现（给定一个可以实现另一个）</li></ul><p>3、信号量可以用在两个方面</p><ul><li>互斥</li><li>条件同步（调度约束–一个线程等待另一个线程的事件发生）</li></ul><p>二、信号量的使用<br>1、思想介绍</p><ul><li>用二进制信号量实现的互斥</li></ul><p><img src="/images/os-interview/106.png"></p><p>解析：<br>一开始要设置一个初始值，为了模仿lock操作，实质了初始值为1。然后在临界区之前，作一个信号量的p操作，在临界区执行之后，作一个信号量的v操作。这个就是二进制信号量的最常用法，完全可以代替前面的lock操作。</p><ul><li>用二进制信号量完成同步操作</li></ul><p><img src="/images/os-interview/107.png"></p><ul><li>其他复杂的问题<br>一个线程等待另一个线程处理事情<br>比如生产东西或消费东西<br>互斥（锁机制）是不够的</li></ul><p><img src="/images/os-interview/108.png"></p><p>2、正确性要求：</p><ul><li>buffer是有限的</li><li>任何一个时间只能有一个线程操作缓冲区（互斥）<br>允许一个或多个生产者往buffer中写数据，但是这时候不允许消费者读数据<br>允许一个或多个消费者往buffer中读数据，但是这时候不允许生产者写数据</li><li>当缓冲区为空时，消费者要休眠，消费者必须等待生产者（调度/同步约束）</li><li>当缓冲区已满时，生产者必须等待消费者（调度/同步约束）</li></ul><p>3、使用分析<br>每个约束用一个单独的信号量</p><ul><li>二进制信号量互斥</li></ul><p>对buffer做添加或者取出的保障</p><ul><li>一般信号量fullBuffers</li></ul><p>代表一开始buffer的数据多少，如果为0，则表示一开始的buffer是空的</p><ul><li>一般信号量emptyBuffers</li></ul><p>代表当前生产者可以往这个buffer塞多少个数据<br>以上两个技术信号量用于同步操作，当buffer还有空间时，应唤醒生产者继续生产。</p><p>4、代码操作</p><ul><li>数据可初始化如下：</li></ul><p><img src="/images/os-interview/109.png"></p><ul><li>生产者的操作：</li></ul><p><img src="/images/os-interview/1010.png"></p><p>调用这个函数实现生产者不停的添加数据</p><ul><li><p>消费者的操作：<br>调用这个函数实现消费者不停的取出数据</p></li><li><p>解决互斥同步总实现代码分析</p></li></ul><p><img src="/images/os-interview/1011.png"></p><p>解析：</p><ul><li>对于生产者来说，由于一开始的buffer设置允许塞进的数据是n，所以生产者可以往下执行。进行buffer的生产操作。</li><li>但是在生产之前，需要对mutex进程减操作，使之为0。。生产操作完成之后，将mutex加1操作。这次就保证了buffer的互斥问题，确保之间只有一个线程可以执行。两个操作确保了add buffer是一个互斥的操作，确保互斥性。</li><li>互斥操作完成之后，在将fullbuffer进行一个v操作，加1，提醒生产者可以正常的消费。</li><li>而对消费者来说，fullbuffer一开始初始值为0，所以是没有数据的。消费者不可能取到数据，所以在等待。所以刚刚生产者唤醒了消费者，和生产者fullbuffer的v操作相匹配。而后进行互斥的取数据操作</li><li>取出数据之后，会将emptybuffer进行v操作，表示唤醒生产者可以继续生产，也就是生产的进程可以继续执行。</li></ul><p>以上就运用了互斥机制和同步机制来实现了一个完成的消费者和生产者的问题。需要注意好初值的确定。</p><p>问题：p，v操作的顺序有影响吗？<br>v操作是加一操作，所以没有影响<br>p操作是减一操作，会导致阻塞，所以会产生严重的影响，比如死锁的情况</p><h2 id="10-4-信号量的实现"><a href="#10-4-信号量的实现" class="headerlink" title="10.4. 信号量的实现"></a>10.4. 信号量的实现</h2><p>不仅要会用信号量，还需要知道信号量使用的细节<br>1、伪代码实现</p><p><img src="/images/os-interview/1012.png"></p><p>2、需要注意的问题</p><ul><li>信号量的双用途</li></ul><p>互斥和条件同步<br>但等待条件是独立的互斥</p><ul><li>读/开发代码比较困难</li></ul><p>程序员必须非常精彩信号量</p><ul><li>容易出错</li></ul><p>使用的信号量已经被另一个线程占用<br>忘记释放信号量</p><ul><li>不能处理死锁问题</li></ul><h2 id="10-5-管程"><a href="#10-5-管程" class="headerlink" title="10.5. 管程"></a>10.5. 管程</h2><p>管程的抽象程度更高，更加容易的来完成相应的同步互斥的问题。<br>一、基础<br>1、目的：分离互斥和条件同步的关注<br>（一开始是完成编程语言的设计，而不是操作系统的设计的，所以其整体上是针对语言的并发机制来完成的）</p><p>2、什么是管程（moniter）<br>管程是包含了一系列的共享变量以及针对这些这些变量函数的一个组合或模块。其包括：</p><p>一个锁：指定临界区（确保互斥性，只能有一个线程）<br>0或者多个条件变量：等待/通知信号量用于管理并发访问共享数据<br>3、一般方法</p><p>收集在对象/模块中的相关共享数据<br>定义方法来访问共享数据<br>大致的结构图：</p><p><img src="/images/os-interview/1013.png"></p><p>一开始，所有进程在右上角的排队队列中，排队完后进行wait()操作，等到signal()操作唤醒后，执行这个进程的代码。</p><p>分析：</p><p><img src="/images/os-interview/1014.png"></p><p>实现：</p><p><img src="/images/os-interview/1015.png"></p><p>解析：</p><ul><li>这里的numwaiting代表的是当前等待线程的个数，而之前的sem是代表信号量的个数。</li><li>信号量的实现v操作和c操作是一定会执行的，也就是一定会执行加一操作或者是减一操作。</li><li>而这里的wait操作是会做加操作，而signal里面，不一定要做减操作。</li><li>这里在wait函数中，还没有require lock就要release（lock）的原因下面再进行讲解。</li><li>release(lock)之后，会做一次schedule(),表示会选择下一次线程去执行，因为本身这个线程已经处于睡眠状态了。</li><li>schedule()完毕再做一个require(lock)的操作，这里又是为什么？这里的release和require和之前的有所不同，下面讲解。</li><li>signal函数是作唤醒的操作，从等待队列里面取出一个线程唤醒，与之前的schedule()是对应的。wakeup(t)是对schedule的进一步触动机制。最后waiting再进行减减操作。</li><li>如果等待队列为0，则啥操作也不做这里的numwaiting代表的是当前等待线程的个数，而之前的sem是代表信号量的个数。</li></ul><p>二、使用<br>1、对管程进行初始化</p><p><img src="/images/os-interview/1016.png"></p><p>需要注意：</p><ul><li>lock变量是保证互斥的操作。</li><li>condition条件变量，这里有两个条件变量，一个是buffer满，一个是buffer空，也就是</li><li>count中记录了buffer中的空闲情况，count=0，表面buffer是空的，如果buffer是n，表面buffer是满的。</li></ul><p>2、互斥机制<br>生产者是Deposit()，消费者是Remove()。</p><p><img src="/images/os-interview/1017.png"></p><p>需要注意：</p><ul><li>这里不仅仅要对buffer做操作，响应的还要在count中记录下来。</li><li>信号量互斥的实现是仅仅靠着这个buffer的，而这里的互斥是在函数的头和尾。</li><li>buffer空了消费者会去睡眠，而buffer满了生产者会去睡眠。</li></ul><p>为什么？ —–这是管程的定义来决定的<br>·因为管程定义，进入管程的时候，只有一个线程可以进去，才能执行管程所管理的所以函数。而既然这图中的两个函数是属于管程管理的两个访问共享变量的函数，就要确保其互斥性和唯一性。所以一进入这个函数就是互斥的。</p><p>3、同步机制</p><ul><li>生产者的buffer未满操作<br>如何实现：buffer空了消费者会去睡眠，而buffer满了生产者会去睡眠的过程？</li></ul><p><img src="/images/os-interview/1018.png"></p><p>当buffer满的时候，也就是count=n，这时候会作一个 notfull.wait(&amp;lock)操作。notfull是一个条件变量，不需要有一个初始值。notfull.wait(&amp;lock)就表示当前已经满了，我需要睡眠，同时还带有一个lock。而这个lock就是管程的lock。</p><ul><li>小插曲<br>这时先解释前面的问题：为什么是先relase再require一个锁呢？</li></ul><p><img src="/images/os-interview/1019.png"></p><p>解析：<br>release(lock)：实际上说让当前的生产者释放到这个锁，这使得其他的线程才有可能进入管程去执行。因为这时候生产者要休眠了，所以必须要把这把锁释放。而其释放是由于之前其有一个lock-&gt;Acquire(),已经获得了这个锁。所以在wait操作一定要释放，不然所以等待的线程都在等待，系统会停滞。<br>一旦将来被唤醒了，也意味着可以继续从schedule中继续往下执行，再去完成一次require(lock)。一旦获取了lock之后，就会跳出wait操作，看看count是否等于n。</p><ul><li>消费者的buffer未满操作</li></ul><p><img src="/images/os-interview/1020.png"></p><p>而在notfull的另一边，需要有一个唤醒机制，所以消费者这边会有一个notfull.signal()操作。一旦count做了一个减减操作，buffer满了消费了一个操作，这是buffer句未满了，所以需要去进行唤醒，去唤醒正在等待在这上面的线程。</p><ul><li>消费者的buffer为空操作与生产者的buffer非空唤醒操作</li></ul><p><img src="/images/os-interview/1021.png"></p><p>这消费者这边，buffer空的时候，也同样会有一个while操作，会判断count是否等于0，如果是会作一个notempty的wait操作，直到生产有一个notempty.signal的信号唤醒才可以继续去执行。两者合在一起就是完整的管程来解决生产者消费者的问题。</p><ul><li>总的实现与和信号量的代码比较<br>管程实现：</li></ul><p><img src="/images/os-interview/1022.png"></p><p><img src="/images/os-interview/1023.png"></p><p>信号量实现：</p><p><img src="/images/os-interview/1024.png"></p><p>两者相比，可以看出，与信号量实现的总体功能是一样的，但是实现的细节不一样。</p><p>三、两种特别的方式<br>问题：<br>管程实现生产者消费者问题中，还需要注意到一点，当线程在管程中执行时，如果线程这时候要执行针对某一个条件变量的signal唤醒操作之后。这时候，是执行等待在这个条件变量上的线程？还是发出唤醒的线程执行完毕后再让那个等待的线程执行？</p><p>1、两种方法</p><ul><li>Hoare方法（比较完美）<br>一旦发出了signal操作之后，就应该让等待的线程继续执行，而其自身去睡眠。直到等待的线程执行了release之后，这个线程才能继续执行。</li></ul><p>特点：比较直观，但是实现起来比较困难</p><p>执行的流程如下：</p><p><img src="/images/os-interview/1025.png"></p><ul><li>Hansen方法：<br>当发出了signal操作之后，不一定要马上放出对cpu的控制权，而是等发出signal的线程执行完release操作之后才转移cpu控制权。</li></ul><p>特点：实现起来比较容易</p><p>执行的流程如下：</p><p><img src="/images/os-interview/1026.png"></p><p>2、比较<br>Hoare的while操作可以用if操作来实现，而Hansen的不行，这是唤醒机制不同而造成的。</p><p><img src="/images/os-interview/1027.png"></p><ul><li><p>对于Hansen来说，其并没有马上让等待在这上面的线程执行，所以其必须要做relseae才能释放，所以这时会存在多个被唤醒的线程，抢这个继续执行的count。所以当选择自己的时候，count已经不为n了，所以要循环的查询。</p></li><li><p>对于Hoare来说，执行之后会马上的转移cpu、控制权，而这时只要一个线程被唤醒，不存在多个的问题。而其一定可以往下执行，因为count一定不为n。</p></li></ul><p>四、总结</p><p><img src="/images/os-interview/1028.png"></p><p><img src="/images/os-interview/1029.png"></p><h2 id="10-6-经典同步问题1—-读者优先读写者问题"><a href="#10-6-经典同步问题1—-读者优先读写者问题" class="headerlink" title="10.6. 经典同步问题1—-读者优先读写者问题"></a>10.6. 经典同步问题1—-读者优先读写者问题</h2><p>一、读者写者问题<br>1、动机：共享数据的访问</p><p>2、两种类型的使用者</p><ul><li>读者：不需要修改数据</li><li>写者：读取和修改数据</li></ul><p>3、问题的约束</p><ul><li>允许同一时间有多个读者，但在任何时候只有一个写者</li><li>当没有写者时读者才能访问数据</li><li>当没有读者和写者时写者才能访问数据</li><li>在任何时候只能有一个线程可以操作共享变量</li><li>读者优先，不按时间顺序</li></ul><p>4、共享数据的设计</p><ul><li>数据集</li><li>信号量CountMutex初始化为1<br>保证count的读写是互斥的</li><li>信号量WriteMutex初始化为1<br>保证写者的互斥保护，因为只允许一个写操作</li><li>整数Rcount初始化1<br>当前读者的数量，因为可以有多个读者同时操作</li></ul><p>二、实现的过程</p><p><img src="/images/os-interview/1030.png"></p><p>sem_wait：就是p操作，也就是减一操作<br>sem_post：就是v操作，也就是加一操作<br>1、写者的互斥保证</p><p><img src="/images/os-interview/1031.png"></p><p>分析：<br>包起来之后确保只有一个线程可以进行写操作。且一旦写者在写，读者就不能读，只能等待。而当读者在读数据的时候，写者也不能写数据。完成了读者写者的互斥操作与写者与写者的互斥操作。<br>但是没有体现可以允许多个读者读数据</p><p>2、多读者体现</p><p><img src="/images/os-interview/1032.png"></p><p>分析：</p><ul><li>rcount=0，代表当时没有读者，所以只要没有写者，就可以继续的执行。</li><li>但是当如果rount！=0的时候，表明当前已经有读者线程在读数据了，也意味着接下来的操作，写者是一定进不来的，rcount++操作完成读就好。</li><li>当读完的时候，如果rcount=0，也就是说读者已经读完了，这时外面可能存在写者，所以要唤醒。</li></ul><p>3、多读者的互斥</p><p><img src="/images/os-interview/1033.png"></p><p>分析：<br>确保不会存在多个读者同时对rcount进行操作，也就是保证rcount数据的互斥性。</p><p>4、完整的读者优先的读者写者问题</p><p><img src="/images/os-interview/1034.png"></p><p>三、读者优先与写者优先的区别：</p><p><img src="/images/os-interview/1035.png"></p><h2 id="10-7-经典同步问题1—写者优先读写者问题"><a href="#10-7-经典同步问题1—写者优先读写者问题" class="headerlink" title="10.7. 经典同步问题1—写者优先读写者问题"></a>10.7. 经典同步问题1—写者优先读写者问题</h2><p>利用管程实现写者优先的读者写者问题<br>一、基础<br>1、方法构思</p><p><img src="/images/os-interview/1036.png"></p><p>需要注意：</p><ul><li>读者进行读操作时要注意当前是否有写者（两类：正在写数据的写者和正在等待的写者），这两类写者只要有一个存在，那么读者就需要等待。都不存在才有机会进行读操作。</li><li>读完之后，检测是否有写者正在等待，其有责任去唤醒。</li><li>当当前有读者正在读的读者或者正在写的写者时，需要等待。（正在等待的读者不需等待，写者优先）</li><li>写操作之后，唤醒正在等待的写者或者正在等待的读者。</li></ul><p>2、数据结构</p><p><img src="/images/os-interview/1037.png"></p><p>AR：当前处于读数据库读者的个数<br>AW：当前正在写的个数<br>WR：当前正在等待读者的个数<br>WW：当前正在等待写者的个数<br>oktoread：表示当前可以去读<br>oktowrite：表示当前可以去写<br>lock：确保只有一个函数进入管程去执行<br>二、实现<br>1、读者的具体实现</p><p><img src="/images/os-interview/1038.png"></p><p>解析：</p><ul><li>因为读者读数据的时候，要确保没有正在写的写者和正在等待的写者（写者优先），所以while语句中判断的依据是（AW+WW）&gt;0的时候，都需要等待，并且不断记录被等待的读者，也就是WR++。等到没有写者的时候，被唤醒，其中一个等待的读者可以继续执行，并且WR–。</li><li>当完成读数据库的操作时，正在读的读者减一操作。并且当此时已经没有读者而且正在有等待的写者时，进行唤醒写者的操作。但是当还有读者的时候，为了保证读写的互斥，就没有必要唤醒写者了。</li></ul><p>2、写者的具体实现</p><p><img src="/images/os-interview/1039.png"></p><p>解析：</p><ul><li>当一个写者想写数据的时候，首先进行判断当前有无正在读的读者或者是正在写的写，等待的不需考虑。若没有时，说明可以有机会被唤醒去执行后面的操作。否者继续等待，直到被唤醒，然后等待的写者++。</li><li>当写完数据时，正在写的写者减一操作（其实我认为AW只有01两个取值，有正在写的写者，或者没有正在写的写者），此时表面没有正在写的写者，而当有等待的写者，既去唤醒其中的一个写者执行。否则，当有正在等待的读者时，去唤醒全部的读者。</li><li>需要注意，signal是唤醒等待在这个条件变量上的一个，而broadcast是唤醒等待在这个条件变量上面的全部。</li></ul><h2 id="10-8-经典同步问题2—哲学家就餐问题"><a href="#10-8-经典同步问题2—哲学家就餐问题" class="headerlink" title="10.8. 经典同步问题2—哲学家就餐问题"></a>10.8. 经典同步问题2—哲学家就餐问题</h2><p>一、基础与尝试<br>1、问题描述</p><p><img src="/images/os-interview/1040.png"></p><p>拿叉子，减一的p操作<br>放叉子，加一的v操作<br>2、尝试解决（可以跳过）<br>方案一：</p><p><img src="/images/os-interview/1041.png"></p><p>结果：会导致死锁，谁都拿不了右边的叉子</p><p>方案二：</p><p><img src="/images/os-interview/1042.png"></p><p>结果：会重复过程</p><p>方案三：等待随机的时间</p><p><img src="/images/os-interview/1043.png"></p><p>结果：等待时间随机变化，可行，但非万全之策。可能等待时间长的哲学家一直在等待。</p><p>方案四：<br>使用信号量的互斥锁来保护</p><p><img src="/images/os-interview/1044.png"></p><p>结果：<br>互斥访问可以实现不会出现死锁的情况，但是每次只允许一个人进餐。本来可以并行两个哲学家同时吃饭，这与问题项背，效率较低。<br>其将就餐（而不是叉子）看成是必须互斥访问的临界资源，因此回造成（叉子）资源的浪费。</p><p>二、实现思路<br>1、不同的思考</p><ul><li>哲学家维度</li></ul><p><img src="/images/os-interview/1045.png"></p><ul><li>计算机维度</li></ul><p><img src="/images/os-interview/1046.png"></p><p>2、编写</p><ul><li>思路</li></ul><p><img src="/images/os-interview/1047.png"></p><ul><li>数据结构</li></ul><p><img src="/images/os-interview/1048.png"></p><ul><li>操作方法</li></ul><p><img src="/images/os-interview/1049.png"></p><p>3、具体的实现</p><ul><li>函数take_forks的定义</li></ul><p><img src="/images/os-interview/1050.png"></p><p>需要注意：<br>hungry的状态需要互斥保护<br>拿两把叉子的过程其实也是在互斥的保护之中</p><ul><li>函数test_take_left_right_forks的定义</li></ul><p><img src="/images/os-interview/1051.png"></p><p>分析：</p><ul><li>首先确保自己是出于饥饿状态的，然后判断两旁的人是否是出于eatting状态，如果都不是，意味两边都有叉子，就可以吃饭了。</li><li>可以看出，两把叉子到手，没有一个具体的变量来体现，而是说用状态来表示（因为拿一把叉子是没有意义的）。</li><li>而在前面赋初值的时候，s[i]的初值是0，v操作之后，自身编变成了1，也就是自己通知自己可以吃饭了。</li></ul><p>问题：为什么会通知自己吃饭？<br>因为在take_forks函数的最后，会有一个p操作，加1之后会减1操作，所以这里的p操作不会被阻塞。只是使得同步信号量加一操作之后，使这里的减一操作不会被阻塞。</p><ul><li>函数put_forks的定义<br>功能：把两把叉子放回原处，并在需要的时候去唤醒左岭右舍</li></ul><p><img src="/images/os-interview/1052.png"></p><p>需要注意：<br>这里查看自己的左邻居能否进餐的时候，还有看自己左邻居的左邻居的状态。如果自己左邻居的左邻居的状态是进餐状态，这左邻居不可能进餐。自己的右邻居同理。</p><ul><li>程序设计的思考过程<br>以一般的思路分许问题，写出一个伪代码，再将伪代码变成程序。<br>在这个过程中要设定好变量（同步和互斥的机制）<br>逐步细化的方式实现这个处理的过程，一般来说是会匹配的（p操作和v操作）</li></ul><h1 id="11-死锁"><a href="#11-死锁" class="headerlink" title="11. 死锁"></a>11. 死锁</h1><h2 id="11-1-死锁问题"><a href="#11-1-死锁问题" class="headerlink" title="11.1. 死锁问题"></a>11.1. 死锁问题</h2><p>1、死锁现象</p><p><img src="/images/os-interview/111.png"></p><p><img src="/images/os-interview/112.png"></p><p>出现的原因：进程并发运行</p><h2 id="11-2-系统模型"><a href="#11-2-系统模型" class="headerlink" title="11.2. 系统模型"></a>11.2. 系统模型</h2><p>1、资源概念</p><p><img src="/images/os-interview/113.png"></p><p>资源一旦是被使用状态，则其他的进程就不应该运用这个资源，有互斥性，如果没有互斥性，就不会产生死锁。<br>进程使用资源的有限的，资源恢复到空闲的情况。<br>2、可重复使用的资源</p><ul><li>在一个时间只能一个进程使用且不能删除</li><li>进程获得资源，后来释放有其他进程重用</li><li>处理器，io通道，主和副存储器，设备和数据结构，如文件，数据库和信号量都可以看作是资源的一种形式</li><li>如果每个进程拥有一个资源并且请求其他资源，死锁可能发生</li></ul><p>3、如何使用资源</p><ul><li>创建和销毁进行资源管理，内存管理</li><li>在op缓冲区中的中断，信号，消息，信息</li><li>如果接受消息阻塞可能会发生死锁</li><li>可能少见的组合事件会引起死锁</li><li>存在进程管理和调度的过程</li></ul><p>4、资源分配图</p><p><img src="/images/os-interview/114.png"></p><p>pi-&gt;rj：表示进程i需要j的资源<br>rj-&gt;pi：表示资源i被j所使用</p><p><img src="/images/os-interview/115.png"></p><p>5、死锁的判断</p><ul><li>情况一</li></ul><p><img src="/images/os-interview/116.png"></p><p>不会产生死锁</p><ul><li>情况二</li></ul><p><img src="/images/os-interview/117.png"></p><p>会产生死锁，这个图形成了一个环状的结构（一个大环和小环）</p><ul><li>情况三</li></ul><p><img src="/images/os-interview/118.png"></p><p>有环状的资源分配图没有死锁</p><p>总结：<br>死锁一定有环，但是有环不一样产生死锁</p><p><img src="/images/os-interview/119.png"></p><h2 id="11-3-死锁的特征"><a href="#11-3-死锁的特征" class="headerlink" title="11.3. 死锁的特征"></a>11.3. 死锁的特征</h2><p>这个是死锁出现的四个特征：</p><p><img src="/images/os-interview/1110.png"></p><p>需要注意：这四个特征出现并不意味着死锁的出现</p><p><img src="/images/os-interview/1111.png"></p><p>右图的p2和p4不满足持有并等待资源，所以不满足这四个特征，所以不是死锁。</p><h2 id="11-4-死锁处理办法"><a href="#11-4-死锁处理办法" class="headerlink" title="11.4. 死锁处理办法"></a>11.4. 死锁处理办法</h2><p><img src="/images/os-interview/1112.png"></p><p>以上的四个方法的约束一个比一个弱，死锁预防的约束最强，而死锁恢复的约束最差。</p><p>方法一：确保系统永远不会进入死锁状态<br>操作系统的功能会被限制，应用系统无法重复的利用cpu执行开销也很大</p><p>方法二：运行系统进入死锁状态，然后恢复<br>但是判断死锁的开销非常大</p><p>方法三：忽略这个问题，假装系统中从来没有发生死锁；用于绝大多数的操作系统。<br>靠假设来忽略这个问题，实际操作的常用方法</p><h2 id="11-5-死锁预防和死锁避免"><a href="#11-5-死锁预防和死锁避免" class="headerlink" title="11.5. 死锁预防和死锁避免"></a>11.5. 死锁预防和死锁避免</h2><p>1、死锁的预防 —- 让死锁不会出现<br>思路：只要将前诉的四个资源打破其中的一个，那么久不会出现死锁。</p><p><img src="/images/os-interview/1113.png"></p><p>针对死锁的四个必要条件，打破死锁进行一开始预防：</p><ul><li>互斥<br>本来资源是互斥的，通过使资源不互斥。</li><li>占用并等待<br>将条件变大，拿资源就拿全部的资源才去执行，否者不能资源去睡眠，这样就不会存在死锁。但是不同的执行过程中，需要的资源不同，导致一直占用资源但是没有使用，所以会导致系统资源的利用率低。</li><li>不抢占<br>直接将进程kill掉，也就将资源抢占过来了，但是手段比较的暴力，不合理。</li><li>循环等待<br>死锁的出现会出现一个环，打破这个环可以实现死锁的预防。如果对资源类型进行排序，进程按资源顺序进行申请，也就是资源只能往上进行申请，这样就不会形成循环的圈。但是前提是要讲资源排好序，但是资源利用还是不合理的。</li></ul><p>2、死锁避免<br>比上诉的约束条件放松一点<br>思路：当进程在申请资源的过程中，然后判断这个申请合不合理，如果会存在死锁的概率，就会拒绝这个请求。</p><p>需要注意：<br>其中，不安全状态不一定对导致死锁状态，所以不安全状态是包含着死锁状态，我们需要的是安全状态。将是否会形成环来作为判断依据。</p><p>问题：什么是安全状态？<br>针对所有的进程，存在一个时间序列，按照这个序列执行，先后顺序执行，所以的进程都可以正常的等待所需要的资源，正常的结束。</p><p><img src="/images/os-interview/1114.png"></p><p>要避免进入unsafe空间。而在safe状态不会出现一个环。</p><p><img src="/images/os-interview/1115.png"></p><p>11.6银行家算法<br>一、基础<br>1、算法的背景</p><p><img src="/images/os-interview/1116.png"></p><p>2、前提基础</p><p><img src="/images/os-interview/1117.png"></p><p>很重要的判断：safe还是unsafe</p><p>二、算法设计<br>1、数据结构的设计</p><ul><li>n = 进程数量</li><li>m = 资源类型数量<br>（其中，每一个资源类型还要一个量）</li><li>Max（某种类型的总需求量）：nxm矩阵。<br>如果Max[i，j] = k，表示进程Pi最多请求资源类型Rj的k个示例<br>（可以知道其整个生命周期中共需要该类多少个资源）</li></ul><p><img src="/images/os-interview/1118.png"></p><p>其中存在一条关系式：</p><p><img src="/images/os-interview/1119.png"></p><p>2、初始化</p><p><img src="/images/os-interview/1120.png"></p><p>3、操作</p><p><img src="/images/os-interview/1121.png"></p><p>执行之后：</p><p>可申请的资源变少，变少了request<br>已分配的资源变多，变多了request<br>还需要的资源变少，变少了request<br>根据返回值做出改变：</p><p><img src="/images/os-interview/1122.png"></p><p>以上就是银行家算法的一个大致思路。</p><p>三、示例<br>第一个例子<br>1、首先系统和进程所拥有的资源如下图所示</p><p><img src="/images/os-interview/1123.png"></p><p>需要注意：</p><p>Max：所有进程需要资源的情况<br>Need：当前进程需要进程的情况<br>Available：系统还剩下资源的情况<br>Allocation：当前进程已经拥有的资源<br>Resource：当前系统中总资源的个数<br>2、可见，p2可以满足情况，执行后可返回其所占有的资源</p><p><img src="/images/os-interview/1124.png"></p><p>3、回收资源之后，按照顺序，p1所需要的资源是可以满足的，可以执行</p><p><img src="/images/os-interview/1125.png"></p><p>4、p1执行完之后，对资源进行回收，接下来剩下的两个进程偶读可以满足要求。可以随便选一个，比如p3，然后再选择p4.</p><p><img src="/images/os-interview/1126.png"></p><p>结论：<br>所以，这样我们就已经找到了一个序列，如果按照p2-p1-p3-p4这个顺序去执行，就可以实现所以的进程都可以正常的执行并结束，其所需要的资源都可以得到满足。这个就是安全的执行序列，safe。</p><p>第二个例子：</p><p><img src="/images/os-interview/1127.png"></p><p>如果一开始p1提出了一个101请求，执行之后</p><p><img src="/images/os-interview/1128.png"></p><p>此时系统所剩余的资源为011，此时不能满足任何的其他进程，会进入一个unsafe的状态。<br>所以，一开始银行家算法是不会接受p1的101的请求的。</p><p>总结：<br>银行家算法的思路是判断当前的资源分配操作是否安全的，如果安全则可以执行，如果不安全就不能分配出去。</p><h2 id="11-6-死锁检测和死锁恢复"><a href="#11-6-死锁检测和死锁恢复" class="headerlink" title="11.6. 死锁检测和死锁恢复"></a>11.6. 死锁检测和死锁恢复</h2><p>一、基础<br>1、背景<br>死锁的检测又将条件放宽了一点。</p><p>前面的死锁避免是既是不会导致死锁的现象方法，但是如果会出现不安全状态，也不会执行。<br>这里的死锁检测允许系统进入unsafe状态，在某一个状态判断当前的系统是否出现死锁，如果是，就启动恢复机制；如果没有，就继续执行，将死锁的检测放在了系统运行中，更往后了。<br>2、死锁检测的大致思路</p><p>允许系统进入死锁状态<br>死锁检测算法<br>恢复机制<br>3、检测原理</p><ul><li>将资源分配图中资源的节点简化，只留下进程。从而将资源分配图，变成进程等待图。然后再判断这个等待图是否具有环。有环就代表有可能死锁。</li></ul><p><img src="/images/os-interview/1128.png"></p><ul><li>死锁检测算法</li></ul><p><img src="/images/os-interview/1129.png"></p><p>死锁检测算法，定期的执行对操作系统运行比较大，更多是起调试的作用。而已银行家算法需要提前知道进程未来所需要的资源，这个是比较难实现的，只能去预估。</p><p>二、示例<br>1、例子一</p><p><img src="/images/os-interview/1130.png"></p><p>2、例子二</p><p><img src="/images/os-interview/1131.png"></p><p>结果：<br>没有一个进程的需求可以得到满足，死锁会检测出一个环，与银行家算法是比较类似的。</p><p>三、算法是使用</p><p><img src="/images/os-interview/1132.png"></p><p>四、死锁的恢复</p><p><img src="/images/os-interview/1134.png"></p><p>都存在某种程度上的强制性和不合理性。所以死锁恢复是最后的手段。</p><p><img src="/images/os-interview/1135.png"></p><h2 id="11-7-IPC概述"><a href="#11-7-IPC概述" class="headerlink" title="11.7. IPC概述"></a>11.7. IPC概述</h2><p>一、基础<br>IPC的意思就是进程间通信<br>1、问题：为什么要进行进程间通信？<br>进程之间可能要完成一个大的任务，这需要一定的数据的沟通和信息的传递，保存进程独立性的通信，保证其可以有效的沟通。</p><p>2、IPC提供2个操作<br>send message<br>receive message</p><p>3、通信的前提<br>在他们之间建立通信链路<br>通过send/receive交换消息</p><p>4、通信链路实现<br>物理（例如共享内存，硬件总线）<br>逻辑（例如，逻辑属性）</p><p>二、间接通信与直接通信</p><p><img src="/images/os-interview/1136.png"></p><ul><li>直接通信</li></ul><p><img src="/images/os-interview/1137.png"></p><ul><li>间接通信</li></ul><p><img src="/images/os-interview/1138.png"></p><p><img src="/images/os-interview/1139.png"></p><p>主需要关注在哪里收数据或者将数据丢到哪里去就行了。一般是os中的共享数据。</p><p>三、阻塞或是非阻塞的</p><p><img src="/images/os-interview/1140.png"></p><h2 id="11-8-信号，管道，消息队列和共享内存"><a href="#11-8-信号，管道，消息队列和共享内存" class="headerlink" title="11.8. 信号，管道，消息队列和共享内存"></a>11.8. 信号，管道，消息队列和共享内存</h2><p>（这里只是作简单的介绍，没有涉及具体的实现方法）<br>1、数据的缓冲</p><p><img src="/images/os-interview/1141.png"></p><p>需要注意：<br>无论是哪种情况，当缓冲中没有数据的时候，接收方都必须等待数据的到来</p><p>一、信号<br>1、介绍</p><p><img src="/images/os-interview/1142.png"></p><p>关注某一种信号，发生了某一种响应之后，可以编写特定的处理函数。效率比较高。<br>处理完之后，会回到被打断的函数重新的实现。</p><p>2、如何实现</p><p><img src="/images/os-interview/1143.png"></p><p>应用程序针对某种新号作定点处理，要完成的操作是：</p><ul><li>开始的时候，要针对某种信号的handle，把这个作为系统调用发给操作系统。操作系统就知道当这个进程发出某种信号就会跳转到预先编写的处理函数中。</li><li> 操作系统将系统调用返回用户空间的堆栈进行修改，使得本来是返回调用语句的后条执行变成到这个信号处理函数的入口，同时在把信号处理函数的之后的地址作为栈帧的返回地址。所以要修改应用程序的堆栈。</li></ul><p>二、管道<br>管道是用来实现数据的交换。其以文件的操作。<br>思路：将一个文件的输出，重定向到令一个文件的输入，这样就可以完成一系列的操作。（重定向符为“&gt;”）</p><p><img src="/images/os-interview/1144.png"></p><p>如何实现：<br>shell进程收到了这条命令之后，会创建两个进程，ls进程和more进程。同时将ls的输出到一个管道中，而不是屏幕上（内存中的一个buffer）。而对于more，不是从键盘接受信息，而是从管道中接受数据，这样就完成了输入输出的重定向功能。这样就完成了分页显示目录的功能。（存在阻塞现象）</p><p>特点：</p><ul><li>管道是通过父进程帮子进程建立好的一个通道，如果没有父子关系，这样就不能正常工作了。</li><li>管道的数据是一种字节流。</li><li>有bufffer满和buffer空的限制</li></ul><p>三、消息队列</p><p><img src="/images/os-interview/1145.png"></p><p>特点：</p><ul><li>数据是结构化的数据，而不是字节流，传进去的是一个有意义的数据结构</li><li>可以实现多个互不相关的进程完成数据交换</li></ul><p>四、共享内存<br>上面两种都是间接通信。共享内存是直接通信的方式。<br>（通过内核，读写内存，实现进程的数据的交换）</p><p><img src="/images/os-interview/1146.png"></p><p>共享内存的实现机制：</p><p><img src="/images/os-interview/1147.png"></p><h1 id="面试总结"><a href="#面试总结" class="headerlink" title="面试总结"></a>面试总结</h1><h2 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h2><p>计算机系统中的两类程序：系统程序和应用程序，为了保证系统程序不被应用程序有意或无意地破坏，为计算机设置了两种状态：</p><ul><li>系统态(也称为管态或核心态)，操作系统在系统态运行——运行操作系统程序</li><li>用户态(也称为目态)，应用程序只能在用户态运行——运行用户程序</li></ul><p>将 CPU 的指令集分为特权指令和非特权指令两类：</p><ul><li><p>特权指令——在内核态时运行的指令<br>对内存空间的访问范围基本不受限制，不仅能访问用户存储空间，也能访问系统存储空间，<br>特权指令只允许操作系统使用，不允许应用程序使用，否则会引起系统混乱。<br>特权指令：启动IO、内存清零、修改程序状态字、设置时钟、允许/禁止中断、停机；</p></li><li><p>非特权指令——在用户态时运行的指令<br>一般应用程序所使用的都是非特权指令，它只能完成一般性的操作和任务，不能对系统中的硬件和软件直接进行访问，其对内存的访问范围也局限于用户空间。<br>非特权指令：控制转移、算术运算、访管指令、取数指令</p></li></ul><p><strong>UNIX</strong> 系统把进程的执行状态分为两种:</p><ul><li>用户态执行，表示进程正处于用户状态中执行；</li><li>核心态执行，表示一个应用进程执行系统调用后，或 I/O 中断、时钟中断后，进程便处于核心态执行。</li></ul><p>差别在于：</p><ul><li>处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所占有的处理机是可被抢占的；</li><li>而处于核心态执行中的进程，则能访问所有的内存空间和对象，且所占用的处理机是不允许被抢占的。 </li></ul><p><strong>注意</strong></p><p>用户态切换到内核态的唯一途径——&gt;中断/异常/陷入/系统调用（就是陷入指令）<br>内核态切换到用户态的途径——&gt;设置程序状态字</p><p>注意一条特殊的指令——陷入指令（又称为访管指令，因为内核态也被称为管理态，访管就是访问管理态）。该指令给用户提供接口，用于调用操作系统的服务。</p><h2 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h2><p>缓冲区溢出是指当计算机向缓冲区内填充数据时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</p><p><strong>危害</strong><br>而缓冲区溢出中，最为危险的是堆栈溢出，因为入侵者可以利用堆栈溢出，在函数返回时改变返回程序的地址，让其跳转到任意地址；<br>带来的危害一种是程序崩溃导致拒绝服务，另外一种就是跳转并且执行一段恶意代码，比如得到shell，然后为所欲为。通过往程序的缓冲区写超出其长度的内容，造成缓冲区的溢出，从而破坏程序的堆栈，使程序转而执行其它指令，以达到攻击的目的。</p><p>造成缓冲区溢出的主原因是程序中没有仔细检查用户输入的参数。</p><h2 id="中断与轮询"><a href="#中断与轮询" class="headerlink" title="中断与轮询"></a>中断与轮询</h2><ul><li><p>中断是指在计算机执行期间，系统内发生任何非寻常的或非预期的急需处理事件，使得CPU暂时中断当前正在执行的程序而转去执行相应的事件处理程序。待处理完毕后又返回原来被中断处继续执行或调度新的进程执行的过程。<br>中断和轮询的特点</p></li><li><p>对I/O设备的程序轮询的方式，是早期的计算机系统对I/O设备的一种管理方式。它定时对各种设备轮流询问一遍有无处理要求。轮流询问之后，有要求的，则加以处理。在处理I/O设备的要求之后，处理机返回继续工作。尽管轮询需要时间，但轮询要比I/O设备的速度要快得多，所以一般不会发生不能及时处理的问题。当然，再快的处理机，能处理的输入输出设备的数量也是有一定限度的。而且，程序轮询毕竟占据了CPU相当一部分处理时间，因此，程序轮询是一种效率较低的方式，在现代计算机系统中已很少应用。</p></li></ul><p>轮询——效率低，等待时间很长，CPU利用率不高。<br>中断——容易遗漏一些问题，CPU利用率高。</p><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>资源的共享有两种方式：互斥共享和同时访问。<br>临界资源：一次仅允许一个进程使用的资源，包括硬件和软件<br>临界区：每个进程中访问临界资源的那段程序。每次只准许一个进程进入临界区，进入后不允许其他进程进入。</p><ol><li>如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入；</li><li>任何时候，处于临界区内的进程不可多于一个。如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待；</li><li>进入临界区的进程要在有限时间内退出，以便其它进程能及时进入自己的临界区；</li><li>如果进程不能进入自己的临界区，则应让出CPU，避免进程出现“忙等”现象。</li></ol><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul><li><p>进程是具有一定功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源调度和分配的一个独立单位。</p></li><li><p>线程是进程的实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。</p></li><li><p>资源分配给进程，同一进程的所有线程共享该进程的所有资源。 同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量</p></li><li><p>处理机分给线程，即真正在处理机上运行的是线程</p></li><li><p>进程是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</p></li><li><p>线程是CPU调度和分派的基本单位，用于保证程序的 实时性，实现进程内部的并发；</p></li><li><p>一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在；</p></li><li><p>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。</p></li><li><p>通信方式不同。线程之间的通信比较方便，同一进程下的线程共享数据（比如全局变量，静态变量）。而进程之间的通信只能通过进程通信的方式进行</p></li></ul><h2 id="程序与进程的区别"><a href="#程序与进程的区别" class="headerlink" title="程序与进程的区别"></a>程序与进程的区别</h2><ul><li>进程是一个动态概念，而程序是一个静态概念。</li><li>进程具有并行特征，而程序不反映执行所以没有并行特征</li><li>进程是竞争计算机系统资源的基本单位，而程序不反映执行也就不会竞争计算机系统资源</li><li>不同的进程可以包含同一程序，只要该程序所对应的数据集不同。</li></ul><h2 id="进程和线程的上下文切换代价"><a href="#进程和线程的上下文切换代价" class="headerlink" title="进程和线程的上下文切换代价"></a>进程和线程的上下文切换代价</h2><p>进程切换分两步：</p><ul><li>切换页目录以使用新的地址空间（进程）</li><li>切换内核栈和硬件上下文（进程、线程）</li></ul><p>切换的性能消耗：</p><ul><li>线程上下文切换虚拟内存空间依然是相同的，但是进程切换是不同的。这两种上下文切换的处理都是通过操作系统内核来完成的。</li><li>上下文的切换会扰乱处理器的缓存机制。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（processor’s Translation Lookaside Buffer (TLB)）或者相当的神马东西会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题。<h2 id="进程同步的原则"><a href="#进程同步的原则" class="headerlink" title="进程同步的原则"></a>进程同步的原则</h2></li><li>空闲让进；</li><li>忙则等待（保证对临界区的互斥访问）；</li><li>有限等待（有限代表有限的时间，避免死等）；</li><li>让权等待（当进程不能进入自己的临界区时，应该释放处理机，以免陷入忙等状态）</li></ul><p>死等状态：<br>进程在有限时间内根本不能进入临界区，而一直在尝试进入，陷入一种无结果的等待状态。<br>（没有进入临界区的正在等待的某进程根本无法获得临界资源而进入进程，这种等待是无结果的，是死等状态）-&gt; 这个时候应该放弃这个无结果的事情，保证自己等待的时间是有限的</p><p>忙等状态：<br>当一个进程正处在某临界区内，任何试图进入其临界区的进程都必须进入代码连续循环，陷入忙等状态。连续测试一个变量直到某个值出现为止，称为忙等。<br>（没有进入临界区的正在等待的某进程不断的在测试循环代码段中的变量的值，占着处理机而不释放，这是一种忙等状态）-&gt; 这个时候应该释放处理机让给其他进程</p><p>有限等待：对要求访问临界资源的进程，应保证有限时间内能进入自己的临界区，以免陷入“死等”状态（受惠的是进程自己）</p><p>让权等待：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”状态（受惠的是其他进程）</p><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>在OS中引入进程后，一方面使系统的吞吐量和资源的利用率得到提升，另一方面也使得系统变得复杂，如果没有合理的方式对进程进行妥善的管理，必然会引起进程对系统资源的无序竞争，使系统变得混乱；为了实现对并发进程的有效管理，在多道程序系统中引入了同步机制，常见的同步机制有：硬件同步机制、信号量机制、管程机制等，利用它们确保程序执行的可再现性；</p><h3 id="硬件同步机制"><a href="#硬件同步机制" class="headerlink" title="硬件同步机制"></a>硬件同步机制</h3><p>通常计算机会提供一些特殊的硬件指令，允许对一个字中的内容进行检测和修正，或者对两个字的内容进行交换；对临界区的管理，可以视为对“锁”的管理：当“锁”开的时候，就允许进入，然后把“锁”关上；当“锁”关上的时候，就只能在外面等待；显然，对“锁”的检测（相当于进入区代码）和打开“锁”（相当于临界区）的操作必须是连续的；常见的硬件同步机制有：</p><p><strong>关中断</strong></p><p>是实现互斥的最简单方法之一。在进入锁检测之前，关闭中断，直到完成锁检测并上锁之后才打开中断。这样，进程在临界区执行期间，计算机系统不响应中断，从而不会引发调度，自然不会发生进程或者线程切换。但是关中断的方法有许多缺点：</p><ul><li>滥用关中断权利，可能会造成严重后果；</li><li>关中断时间过长，会影响系统效率，限制处理器交叉执行程序的能力；</li><li>关中断的方法不适合多CPU系统；</li></ul><p><strong>Test-and-Set</strong></p><p>TS指令的一般描述如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean TS(boolean *lock)&#123;</span><br><span class="line">    boolean old;</span><br><span class="line">    old&#x3D;*lock;</span><br><span class="line">    *lock&#x3D;true;</span><br><span class="line">    return old;</span><br><span class="line">&#125;</span><br><span class="line">相应的进入区代码为：</span><br><span class="line">while(TS(&amp;lock));</span><br></pre></td></tr></table></figure><p>TS指令中，当lock为false时，就将其设置为true，然后返回false;当lock为true时，就返回true；返回false表示资源可用；返回true表示资源不可用；</p><p>上面这段代码实现的功能：如果lock为false，那么设置它为true，但是要返回false；如果lock为true，不做改变，那么仍旧返回true；但实际上，它是这么做的：不论lock是什么，都把它设置为true。而返回它原来的值；</p><p><strong>Swap</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Swap(boolean* lock,boolean* key)&#123;</span><br><span class="line">    boolean temp&#x3D;*lock;</span><br><span class="line">    *lock&#x3D;*key;</span><br><span class="line">    *key&#x3D;temp;</span><br><span class="line">&#125;</span><br><span class="line">相应的进入区代码为：</span><br><span class="line">key&#x3D;true;</span><br><span class="line">do&#123;</span><br><span class="line">    Swap(&amp;lock,&amp;key);</span><br><span class="line">&#125;while(key!&#x3D;false);</span><br><span class="line">&#x2F;&#x2F;进入临界区</span><br></pre></td></tr></table></figure><p>Swap指令中，do-while循环中的退出条件是key为false ；而key为false 意味着lock为false，表示资源可用；当lock为true的时候，key就为true；那么循环就会一直进行下去；</p><p>利用TS机制和Swap机制，都会让进程处于忙等状态，并不符合同步机制的要求；（准确的说，不是实现不了同步，而是效率不高，不太高效~）</p><h3 id="信号量同步机制"><a href="#信号量同步机制" class="headerlink" title="信号量同步机制"></a>信号量同步机制</h3><p>信号量同步机制由Dijkstra（很厉害的大神，单源最短路劲算法就是他提出的）；信号量机制已被广泛应用到单处理机和多处理机系统以及计算机网络中；</p><p><strong>整型信号量</strong></p><p>整型信号量S表示资源数目，除初始化外，仅能通过两个标准的原子操作进行修改：wait(S)和signal(S)；这两个操作长期以来也别称为P、V操作；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wait(S)&#123;</span><br><span class="line">    while(S&lt;&#x3D;0);</span><br><span class="line">    S--；</span><br><span class="line">&#125;</span><br><span class="line">signal(S)&#123;</span><br><span class="line">    S++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实问题就是，wait和signal两个原子操作仍旧会产生“忙等”——进程不断测试，一直问，你说烦不烦？</p><p><strong>记录型信号量</strong></p><p>记录型信号量机制是一种不存在忙等现象的进程同步机制；但是采取了让权等待策略后，就会有多个进程等待访问统一资源的情况，于是还需要把这些进城组织起来，于是除了S用来表示资源的数量外，还需要一个指针；这也是记录型信号量的名称来源：使用了记录型的数据结构；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">    int value;</span><br><span class="line">    sturct process_control_block *list;</span><br><span class="line">&#125;semaphore;</span><br><span class="line">wait(semaphore *S)&#123;</span><br><span class="line">    S-&gt;value--;</span><br><span class="line">    if(S-&gt;value&lt;0)&#123;</span><br><span class="line">        block(S-&gt;list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">signal(semaphore *S)&#123;</span><br><span class="line">    S-&gt;value++;</span><br><span class="line">    if(S-&gt;value&lt;&#x3D;0)&#123;</span><br><span class="line">        wakeup(S-&gt;list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记录型信号量中，value不仅指示资源的数量，由于每次wait操作value都会递减，所以value的值会反映出等待资源的进程有多少个。在signal中，value经过自增后，如果还&lt;=0，说明还有进程在等待该资源，所以需要wakeup一个进程。</p><p><strong>AND型信号量</strong></p><p>前面所述的进程互斥问题针对的是多个并发进程共享一个临界资源的情况，但是如果<strong>多个进程共享多个资源</strong>时仍旧采取这样单个的分配方法，就有可能发生死锁现象；为了避免这样的现象，提出来AND型信号量：将进程在整个运行过程中需要的所有资源，要么一次性全部分配给进程，然后使用完后再一起释放。要么一个都不分配，这样便可以避免死锁现象。wait和signal操作要做出相应改变。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Swait(S1,S2,S3,S4,S5....)&#123;</span><br><span class="line">while(true)&#123;</span><br><span class="line">        if(S1&gt;&#x3D;1&amp;&amp;S2&gt;&#x3D;1...)&#123;</span><br><span class="line">       for(i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">            Si--;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">            &#x2F;&#x2F;找到第一个小于等于0的Si,然后将进程放置到与其相关的等待队列中</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Ssignal(S1,S2...Sn)&#123;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        for(i&#x3D;0;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">            Si++;</span><br><span class="line">            &#x2F;&#x2F;唤醒一个等待Si资源的进程——该进程将进入Swait中的while循环里继续判断其他资源是否可用。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>信号量集</strong></p><p>前面介绍的几种信号量同步机制都是对某一资源进行一个单位的申请和释放。当一次需要N个的时候，就需要进行N次请求，这不但低效而且容易发生死锁情况；还有些情况下，为了保证系统的安全性，当所申请的资源低于某个值时，就需要停止对该类资源的分配。解决办法就是当进程申请某类临界资源时，都必须测试资源的数量，判断是否大于可分配的下限值，然后决定是否分配；</p><p>基于上述提到的两点问题，需要对AND信号量机制加以扩充，对进程所申请的所有资源以及每类资源不同的资源需求量，再一次PV原语操作中完成申请和释放。对信号量Si的测试值不再是1，而是ti。当Si&lt;=ti时就不再分配；同时，进程需要传递给wait方法每类资源所需要的数目，由此形成一般化的“信号量集”机制；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Swait(S1,t1,d1....Sn,tn,dn);表示对Si类资源的需求是di个，当Si的数量小于ti时就不再分配；</span><br><span class="line">Ssignal(S1,d1....Sn,dn);表示归还Si类资源的数目是di个；</span><br></pre></td></tr></table></figure><p>特殊的，Swait(S,d,d)表示信号量集中只有一个信号量；它允许每次申请d个资源，当资源数量小于d时不予分配；</p><p>Swait(S,1,1)表示普通的一般记录型信号量；</p><p><strong>信号量的应用</strong></p><p>实现进程互斥：基本操作；<br>实现前驱关系：当进程A中的X1操作结束后才进行进程B中的X2操作，像这种需求即为前驱关系。可以设置一种虚拟的资源S，并设置其状态为不可用，然后在X1的后面加上signal(S)，在X2语句前加上wait（S），以此实现这种执行顺序上的控制；</p><h3 id="管程机制"><a href="#管程机制" class="headerlink" title="管程机制"></a>管程机制</h3><p>信号量机制虽然是一种既方便又实用的进程同步机制，但是要访问临界资源的进程需要自备同步操作wait（S）和signal(S)，这就使得对共享资源进行访问的代码遍布各个进程，不利于系统管理，还增加系统死锁的风险；管程机制是一种解决该问题的方法；</p><p>操作系统的作用之一就是实现对计算机系统资源的抽象，管程机制使用少量的信息和对该资源所执行的操作来表征该资源，所以共享系统资源就变为了共享数据结构，并将对这些共享数据结构的操作定义为一组过程。进程对共享资源的申请、释放和其他操作必须通过这组过程。代表共享资源的数据结构以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序共同构成了一个操作系统的资源管理模块，我们称之为管程；</p><p>管程由四部分组成：名称、局部于管程的共享数据结构说明、对该数据结构进行操作的一组过程、对局部于管程的共享数据结构设置初始值的语句；</p><p>所有进程访问临界资源时，都只能通过管程间接访问，而管程每次只准许一个进程进入管程，从而实现互斥。管程体现了面向对象程序设计的思想；具有：模块化，即管程是一个独立的基本单位，可单独编译；抽象数据类型，不仅有数据还有对数据的操作；信息隐蔽，管程中的数据结构只能被管程中的过程访问，这些过程也是在管程内部定义的，而管程之外的进程只需调用而无需了解其内部的具体实现细节。（这样，原来遍布系统的共享资源的访问代码，就集中到管程中啦）；</p><p><strong>管程和进程的对比</strong></p><p>两者都定义了各自的数据结构，但是管程定义的数据结构是对公用资源的抽象，进程定义的是私有数据结构PCB；<br>两者都有对各自数据结构的操作，但是管程的操作是为了实现同步和初始化，进程是由顺序程序执行有关操作；<br>进程的目的是在于实现系统的并发，而管程的目的是解决共享资源的互斥访问；<br>进程是主动工作的，管程需要被其他程序使用，属于被动工作的；<br>进程有动态性，管程是操作系统中的一个资源管理模块；</p><p>管程中还有一个比较重要的概念就是条件变量。当一个进程进入了管程但在管程中被阻塞或者挂起，此时该进程需要释放对管程的占有，并且根据阻塞或者挂起的原因，也就是条件变量，进入相应的等待队列，等待其他进程的唤醒。条件变量x具有两种操作：x.wait()和x.signal()；</p><p>x.wait()：正在调用管程的进程因x条件而需要被挂起或者阻塞，则调用x.wait()将自己插入到条件变量x的等待队列上并释放管程，直到x条件变化；</p><p>x.signal()：正在调用管程的进程发现x条件发生了变化，重新启动一个因x而阻塞的进程，如果有多个进程因x而阻塞，也只能选择一个；</p><p>如果进程Q因为x条件而处于阻塞状态，当P调用管程时，执行了x.signal()操作后，Q重新启动，此时P和Q到底谁来继续拥有管程呢？答案是两者均可；</p><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程通信，是指进程之间的信息交换（信息量少则一个状态或数值，多者则是成千上万个字节）。因此，对于用信号量进行的进程间的互斥和同步，由于其所交换的信息量少而被归结为低级通信</p><p>所谓高级进程通信指：用户可以利用操作系统所提供的一组通信命令传送大量数据的一种通信方式。操作系统隐藏了进程通信的实现细节。或者说，通信过程对用户是透明的</p><p>高级通信机制可归结为三大类：</p><ul><li><p>共享存储器系统（存储器中划分的共享存储区）；实际操作中对应的是“剪贴板”（windows剪贴板实际上是系统维护管理的一块内存区域）的通信方式。</p></li><li><p>消息传递系统（进程间的数据交换以消息（message）为单位，当今最流行的微内核操作系统中，微内核与服务器之间的通信，无一例外地都采用了消息传递机制。应用举例：邮槽（MailSlot）是基于广播通信体系设计出来的，它采用无连接的不可靠的数据传输。邮槽是一种单向通信机制，创建邮槽的服务器进程读取数据，打开邮槽的客户机进程写入数据</p></li><li><p>管道通信系统（管道即：连接读写进程以实现他们之间通信的共享文件（pipe文件，类似先进先出的队列，由一个进程写，另一进程读））。实际操作中，管道分为：匿名管道、命名管道。</p><ul><li>匿名管道是一个未命名的、单向管道，通过父进程和一个子进程之间传输数据。匿名管道只能实现本地机器上两个进程之间的通信，而不能实现跨网络的通信。</li><li>命名管道不仅可以在本机上实现两个进程间的通信，还可以跨网络实现两个进程间的通信</li></ul></li><li><p>管道：管道是单向的、先进先出的、无结构的、固定大小的字节流，它把一个进程的标准输出和另一个进程的标准输入连接在一起。写进程在管道的尾端写入数据，读进程在管道的道端读出数据。数据读出后将从管道中移走，其它读进程都不能再读到这些数据。管道提供了简单的流控制机制。进程试图读空管道时，在有数据写入管道前，进程将一直阻塞。同样地，管道已经满时，进程再试图写管道，在其它进程从管道中移走数据之前，写进程将一直阻塞。管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；</p></li><li><p>信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生，调用特定的函数处理；</p></li><li><p>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其它进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段</p></li><li><p>消息队列：是一个在系统内核中用来保存消 息的队列，它在系统内核中是以消息链表的形式出现的。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点</p></li><li><p>共享内存：共享内存允许两个或多个进程访问同一个逻辑内存。这一段内存可以被两个或两个以上的进程映射至自身的地址空间中，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取读出，从而实现了进程间的通信。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。共享内存是最快的IPC方式，它是针对其它进程间通信方式运行效率低而专门设计的。它往往与其它通信机制（如信号量）配合使用，来实现进程间的同步和通信</p></li><li><p>套接字：套接字也是一种进程间通信机制，与其它通信机制不同的是，它可用于网络中不同机器间的进程通信</p></li></ul><h2 id="线程同步的方式"><a href="#线程同步的方式" class="headerlink" title="线程同步的方式"></a>线程同步的方式</h2><ul><li>互斥量 Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</li><li>信号量 Semphare：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</li><li>事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3>　　在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。<h3 id="死锁产生的四个必要条件"><a href="#死锁产生的四个必要条件" class="headerlink" title="死锁产生的四个必要条件"></a>死锁产生的四个必要条件</h3></li><li>互斥：至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他申请使用该资源，那么申请进程必须等到该资源被释放为止；</li><li>占有并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有；</li><li>非抢占：进程不能被抢占，即资源只能被进程在完成任务后自愿释放</li><li>循环等待：若干进程之间形成一种头尾相接的环形等待资源关系<h3 id="死锁的处理"><a href="#死锁的处理" class="headerlink" title="死锁的处理"></a>死锁的处理</h3>　　解决死锁的基本方法主要有 预防死锁、避免死锁、检测死锁、解除死锁 、鸵鸟策略 等。</li></ul><ol><li>死锁预防<br>　　<br>　　死锁预防的基本思想是 只要确保死锁发生的四个必要条件中至少有一个不成立，就能预防死锁的发生，具体方法包括：</li></ol><ul><li>打破互斥条件：允许进程同时访问某些资源。但是，有些资源是不能被多个进程所共享的，这是由资源本身属性所决定的，因此，这种办法通常并无实用价值。</li><li>打破占有并等待条件：可以实行资源预先分配策略(进程在运行前一次性向系统申请它所需要的全部资源，若所需全部资源得不到满足，则不分配任何资源，此进程暂不运行；只有当系统能满足当前进程所需的全部资源时，才一次性将所申请资源全部分配给该线程)或者只允许进程在没有占用资源时才可以申请资源（一个进程可申请一些资源并使用它们，但是在当前进程申请更多资源之前，它必须全部释放当前所占有的资源）。但是这种策略也存在一些缺点：在很多情况下，无法预知一个进程执行前所需的全部资源，因为进程是动态执行的，不可预知的；同时，会降低资源利用率，导致降低了进程的并发性。</li><li>打破非抢占条件：允许进程强行从占有者哪里夺取某些资源。也就是说，但一个进程占有了一部分资源，在其申请新的资源且得不到满足时，它必须释放所有占有的资源以便让其它线程使用。这种预防死锁的方式实现起来困难，会降低系统性能。</li><li>打破循环等待条件：实行资源有序分配策略。对所有资源排序编号，所有进程对资源的请求必须严格按资源序号递增的顺序提出，即只有占用了小号资源才能申请大号资源，这样就不回产生环路，预防死锁的发生。</li></ul><ol start="2"><li>死锁避免　<br>　　动态地检测资源分配状态，以确保系统处于安全状态，只有处于安全状态时才会进行资源的分配。所谓安全状态是指：即使所有进程突然请求需要的所有资源，也能存在某种对进程的资源分配顺序，使得每一个进程运行完毕。</li><li>死锁检测<br>检测有向图是否存在环；或者使用类似死锁避免的检测算法。</li><li>死锁解除<br>　　死锁解除的常用两种方法为进程终止和资源抢占。所谓进程终止是指简单地终止一个或多个进程以打破循环等待，包括两种方式：终止所有死锁进程和一次只终止一个进程直到取消死锁循环为止；所谓资源抢占是指从一个或多个死锁进程那里抢占一个或多个资源，此时必须考虑三个问题：</li></ol><ul><li>利用抢占：挂起某些进程，并抢占它的资源。但应防止某些进程被长时间挂起而处于饥饿状态；</li><li>利用回滚：让某些进程回退到足以解除死锁的地步，进程回退时自愿释放资源。要求系统保持进程的历史信息，设置还原点；</li><li>利用杀死进程：强制杀死某些进程直到死锁解除为止，可以按照优先级进行。<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2></li><li>就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源；</li><li>运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数；</li><li>阻塞状态： 进程等待某种条件，在条件满足之前无法执行；<br><img src="/images/os-interview/i1.jpg"></li></ul><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>　　在 Java虚拟机 中，线程从最初的创建到最终的消亡，要经历若干个状态：创建(new)、就绪(runnable/start)、运行(running)、阻塞(blocked)、等待(waiting)、时间等待(time waiting) 和 消亡(dead/terminated)。在给定的时间点上，一个线程只能处于一种状态，各状态的含义如下图所示：<br>　　　　　　　　　　<br>　　线程各状态之间的转换如下：<br><img src="/images/os-interview/i2.jpg"></p><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p><strong>调度种类</strong></p><ul><li>高级调度：(High-Level Scheduling)又称为作业调度，它决定把后备作业调入内存运行</li><li>中级调度：(Intermediate-Level Scheduling)交换调度。又称为在虚拟存储器中引入，在内、外存对换区进行进程对换</li><li>低级调度：(Low-Level Scheduling)又称为进程调度，它决定就绪队列的某进程获得CPU</li><li>线程调度</li></ul><p><strong>非抢占式调度与抢占式调度</strong></p><ul><li>非抢占式：分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生进程调度进程调度某事件而阻塞时，才把处理机分配给另一个进程</li><li>抢占式：操作系统将正在运行的进程强行暂停，由调度程序将CPU分配给其他就绪进程的调度方式</li></ul><p><strong>调度算法</strong></p><ul><li>FIFO或First Come, First Served (FCFS)先来先服务</li></ul><p>调度的顺序就是任务到达就绪队列的顺序<br>公平、简单(FIFO队列)、非抢占、不适合交互式<br>未考虑任务特性，平均等待时间可以缩短</p><ul><li>Shortest Job First (SJF)</li></ul><p>最短的作业(CPU区间长度最小)最先调度<br>SJF可以保证最小的平均等待时间，但难以知道下一个CPU区间长度</p><ul><li>Shortest Remaining Job First (SRJF)</li></ul><p>SJF的可抢占版本，比SJF更有优势<br>SJF(SRJF): 如何知道下一CPU区间大小？根据历史进行预测: 指数平均法</p><ul><li>优先权调度</li></ul><p>每个任务关联一个优先权，调度优先权最高的任务<br>注意：优先权太低的任务一直就绪，得不到运行，出现“饥饿”现象</p><ul><li>Round-Robin(RR)轮转调度算法</li></ul><p>设置一个时间片，按时间片来轮转调度（“轮叫”算法）<br>优点: 定时有响应，等待时间较短；缺点: 上下文切换次数较多<br>时间片太大，响应时间太长；吞吐量变小，周转时间变长；当时间片过长时，退化为FCFS</p><ul><li>多级队列调度</li></ul><p>按照一定的规则建立多个进程队列，一个进程根据自身属性被永久地分配到一个队列中。<br>不同的队列有固定的优先级（高优先级有抢占权）<br>不同的队列可以给不同的时间片和采用不同的调度方法<br>存在问题1：没法区分I/O bound和CPU bound<br>存在问题2：也存在一定程度的“饥饿”现象</p><ul><li>多级反馈队列</li></ul><p>在多级队列的基础上，任务可以在队列之间移动，更细致的区分任务<br>可以根据“享用”CPU时间多少来移动队列，阻止“饥饿”<br>最通用的调度算法，多数OS都使用该方法或其变形，如UNIX、Windows等<br>若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。</p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><ol><li>内存的发展历程<br>　　没有内存抽象(单进程，除去操作系统所用的内存之外，全部给用户程序使用) —&gt; 有内存抽象（多进程，进程独立的地址空间，交换技术(内存大小不可能容纳下所有并发执行的进程)—&gt; 连续内存分配(固定大小分区(多道程序的程度受限)，可变分区(首次适应，最佳适应，最差适应)，碎片) —&gt; 不连续内存分配（分段，分页，段页式，虚拟内存）</li><li>虚拟内存<br>　　虚拟内存允许执行进程不必完全在内存中。虚拟内存的基本思想是：每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页(Page)，每个页都是一段连续的地址。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。这样，对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上，如图5所示。<br>注意，请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。</li></ol><p><img src="/images/os-interview/i3.jpg">　　<br>　　由图5可以看出，虚拟内存实际上可以比物理内存大。当访问虚拟内存时，会访问MMU（内存管理单元）去匹配对应的物理地址（比如图5的0，1，2）。如果虚拟内存的页并不存在于物理内存中（如图5的3,4），会产生缺页中断，从磁盘中取得缺的页放入内存，如果内存已满，还会根据某种算法将磁盘中的页换出。<br>3. 虚拟内存的应用与优点<br>　　虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。虚拟内存的使用可以带来以下好处：</p><ul><li>在内存中可以保留多个进程，系统并发度提高</li><li>解除了用户与内存之间的紧密约束，进程可以比内存的全部空间还大</li></ul><ol start="4"><li>抖动<br>　　抖动本质上是指频繁的页调度行为，具体来讲，进程发生缺页中断，这时，必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此，会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸（抖动）。<br>　　内存颠簸的解决策略包括：<br>如果是因为页面替换策略失误，可以修改替换算法来解决这个问题；<br>如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量；<br>否则，还剩下两个办法：终止该进程或增加物理内存容量。</li></ol><h2 id="分页和分段"><a href="#分页和分段" class="headerlink" title="分页和分段"></a>分页和分段</h2><p>　　段式存储管理是一种符合用户视角的内存分配管理方案。在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）<br>　　页式存储管理方案是一种用户视角内存与物理内存相分离的内存分配管理方案。在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的帧，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）。<br><strong>区别</strong></p><ul><li>目的不同：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息；</li><li>大小不同：页的大小固定且由系统决定，而段的长度却不固定，由其所完成的功能决定；</li><li>地址空间不同： 段向用户提供二维地址空间；页向用户提供的是一维地址空间；</li><li>信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；</li><li>内存碎片：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。</li></ul><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘中来腾出空间。页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p><ul><li>最佳页面置换算法OPT（Optimal replacement algorithm）：置换以后不需要或者最远的将来才需要的页面，是一种理论上的算法，是最优策略；</li><li>先进先出FIFO：置换在内存中驻留时间最长的页面。缺点：有可能将那些经常被访问的页面也被换出，从而使缺页率升高；</li><li>二次机会算法SCR：按FIFO选择某一页面，若其访问位为1，给第二次机会，并将访问位置0；</li><li>时钟算法 Clock：SCR中需要将页面在链表中移动（第二次机会的时候要将这个页面从链表头移到链表尾），时钟算法使用环形链表，再使用一个指针指向最老的页面，避免了移动页面的开销；</li><li>最近未使用算法NRU（Not Recently Used）：检查访问位R、修改位M，优先置换R=M=0，其次是（R=0, M=1）；</li><li>最近最少使用算法LRU（Least Recently Used）：置换出未使用时间最长的一页；实现方式：维护时间戳，或者维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</li><li>最不经常使用算法NFU：置换出访问次数最少的页面<h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2></li><li>时间上的局部性：最近被访问的页在不久的将来还会被访问；</li><li>空间上的局部性：内存中被访问的页周围的页也很可能被访问。</li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://blog.csdn.net/weixin_44751294?spm=1001.2014.3001.5509">CSDN-Clichong</a></li><li><a href="https://blog.csdn.net/justloveyou_/article/details/78304294">面试/笔试第二弹 —— 操作系统面试问题集锦</a></li><li><a href="https://blog.csdn.net/qq_41371349/article/details/108042666">【操作系统】死等状态、忙等状态、有限等待、让权等待</a></li><li><a href="https://zhuanlan.zhihu.com/p/86629244">操作系统面试题目总结</a></li><li><a href="https://blog.csdn.net/qq_29996285/article/details/88078906">面试考点——用户态和内核态的区别</a></li><li><a href="https://blog.csdn.net/slx3320612540/article/details/80726305">操作系统之进程同步和通信——进程同步的基本概念及其实现方式、进程通信及其实现方式</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;概述、启动中断异常和系统调用、连续内存分配、非连续内存分配、虚拟内存、页面置换算法、进程、处理器调度、同步互斥问题、死锁问题。&lt;/p&gt;
&lt;p&gt;4万字，247张图，80页，超长总结。&lt;/p&gt;</summary>
    
    
    
    <category term="Study" scheme="https://memorykk.cn/categories/Study/"/>
    
    
    <category term="OS" scheme="https://memorykk.cn/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统引论</title>
    <link href="https://memorykk.cn/os.html"/>
    <id>https://memorykk.cn/os.html</id>
    <published>2021-03-16T07:34:23.000Z</published>
    <updated>2021-03-24T11:35:58.044Z</updated>
    
    <content type="html"><![CDATA[<p>准备的书太拉跨，不准备继续总结了</p><span id="more"></span><hr><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA">1. 操作系统引论</a><ul><li><a href="#1-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9B%AE%E6%A0%87">1.1. 操作系统的目标</a></li><li><a href="#1-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8">1.2. 操作系统的作用</a></li><li><a href="#1-3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B">1.3. 操作系统的发展过程</a><ul><li><a href="#1-3-1-%E6%9C%AA%E9%85%8D%E7%BD%AE%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F">1.3.1. 未配置操作系统的计算机系统</a><ul><li><a href="#1-3-1-1-%E4%BA%BA%E5%B7%A5%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F">1.3.1.1. 人工操作方式</a></li><li><a href="#1-3-1-2-%E8%84%B1%E6%9C%BA%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%96%B9%E5%BC%8F">1.3.1.2. 脱机输入输出方式</a></li></ul></li><li><a href="#1-3-2-%E5%8D%95%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F">1.3.2. 单道批处理系统</a></li><li><a href="#1-3-3-%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F">1.3.3. 多道批处理系统</a></li><li><a href="#1-3-4-%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F">1.3.4. 分时系统</a></li><li><a href="#1-3-5-%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F">1.3.5. 实时系统</a></li><li><a href="#1-3-6-%E5%BE%AE%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">1.3.6. 微机操作系统</a></li></ul></li><li><a href="#1-4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7">1.4. 操作系统的基本特性</a><ul><li><a href="#1-4-1-%E5%B9%B6%E5%8F%91">1.4.1. 并发</a></li><li><a href="#1-4-2-%E5%85%B1%E4%BA%AB">1.4.2. 共享</a></li><li><a href="#1-4-3-%E8%99%9A%E6%8B%9F">1.4.3. 虚拟</a></li><li><a href="#1-4-4-%E5%BC%82%E6%AD%A5">1.4.4. 异步</a></li></ul></li><li><a href="#1-5-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD">1.5. 操作系统的主要功能</a><ul><li><a href="#1-5-1-%E5%A4%84%E7%90%86%E6%9C%BA%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD">1.5.1. 处理机管理功能</a></li><li><a href="#1-5-2-%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD">1.5.2. 存储器管理功能</a></li><li><a href="#1-5-3-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD">1.5.3. 设备管理功能</a></li><li><a href="#1-5-4-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD">1.5.4. 文件管理功能</a></li><li><a href="#1-5-5-OS%E4%B8%8E%E7%94%A8%E6%88%B7%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8E%A5%E5%8F%A3">1.5.5. OS与用户之间的接口</a></li><li><a href="#1-5-6-%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%96%B0%E5%8A%9F%E8%83%BD">1.5.6. 现代操作系统的新功能</a></li></ul></li><li><a href="#1-6-OS%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">1.6. OS结构设计</a><ul><li><a href="#1-6-1-%E4%BC%A0%E7%BB%9FOS%E7%BB%93%E6%9E%84">1.6.1. 传统OS结构</a><ul><li><a href="#1-6-1-1-%E6%97%A0%E7%BB%93%E6%9E%84OS">1.6.1.1. 无结构OS</a></li><li><a href="#1-6-1-2-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BB%93%E6%9E%84OS">1.6.1.2. 模块化结构OS</a></li><li><a href="#1-6-1-3-%E5%88%86%E5%B1%82%E5%BC%8F%E7%BB%93%E6%9E%84OS">1.6.1.3. 分层式结构OS</a></li></ul></li><li><a href="#1-6-2-%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%BC%8F">1.6.2. 客户服务器模式</a></li><li><a href="#1-6-3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%8A%80%E6%9C%AF">1.6.3. 面向对象的程序设计技术</a></li><li><a href="#1-6-4-%E5%BE%AE%E5%86%85%E6%A0%B8OS%E7%BB%93%E6%9E%84">1.6.4. 微内核OS结构</a><ul><li><a href="#1-6-4-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.6.4.1. 基本概念</a></li><li><a href="#1-6-4-2-%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD">1.6.4.2. 基本功能</a></li><li><a href="#1-6-4-3-%E4%BC%98%E7%BC%BA%E7%82%B9">1.6.4.3. 优缺点</a></li></ul></li></ul></li></ul></li><li><a href="#2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6">2. 进程的描述与控制</a><ul><li><a href="#2-1-%E5%89%8D%E8%B6%8B%E5%9B%BE%E5%92%8C%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C">2.1. 前趋图和程序执行</a><ul><li><a href="#2-1-1-%E5%89%8D%E8%B6%8B%E5%9B%BE">2.1.1. 前趋图</a></li><li><a href="#2-1-2-%E7%A8%8B%E5%BA%8F%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C">2.1.2. 程序顺序执行</a></li><li><a href="#2-1-3-%E7%A8%8B%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C">2.1.3. 程序并发执行</a></li></ul></li><li><a href="#2-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0">2.2. 进程的描述</a><ul><li><a href="#2-2-1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89">2.2.1. 进程的定义</a></li><li><a href="#2-2-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81">2.2.2. 进程的特征</a></li></ul></li><li><a href="#2-3-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E5%8F%8A%E8%BD%AC%E6%8D%A2">2.3. 进程的基本状态及转换</a><ul><li><a href="#2-3-1-%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81">2.3.1. 三种基本状态</a></li><li><a href="#2-3-2-%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2">2.3.2. 状态转换</a></li><li><a href="#2-3-3-%E5%88%9B%E5%BB%BA%E7%8A%B6%E6%80%81%E5%92%8C%E7%BB%88%E6%AD%A2%E7%8A%B6%E6%80%81">2.3.3. 创建状态和终止状态</a></li></ul></li><li><a href="#2-4-%E6%8C%82%E8%B5%B7%E6%93%8D%E4%BD%9C">2.4. 挂起操作</a><!-- /TOC --></li></ul></li></ul><hr><h1 id="1-操作系统引论"><a href="#1-操作系统引论" class="headerlink" title="1. 操作系统引论"></a>1. 操作系统引论</h1><p>操作系统是一组能有效地组织和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序的集合。</p><h2 id="1-1-操作系统的目标"><a href="#1-1-操作系统的目标" class="headerlink" title="1.1. 操作系统的目标"></a>1.1. 操作系统的目标</h2><ul><li>方便性：裸机上难以使用；</li><li>有效性：<strong>提高资源利用率，提高系统吞吐量</strong>；</li><li>可扩充性：适应硬件、体系结构发展；</li><li>开放性：软硬件的兼容性。</li></ul><h2 id="1-2-操作系统的作用"><a href="#1-2-操作系统的作用" class="headerlink" title="1.2. 操作系统的作用"></a>1.2. 操作系统的作用</h2><ul><li>OS作为用户与计算机硬件系统之间的接口。三种使用方式：系统调用、命令、图形窗口；</li><li>OS作为计算机系统资源的管理者。资源分四类：<ul><li>处理机：分配和控制处理机：</li><li>存储器：内存的分配与回收；</li><li>I/O设备：I/O设备的分配与操纵；</li><li>文件：文件的存取、共享、保护；</li></ul></li><li>OS实现了对计算机资源的抽象。通过I/O设备管理软件、文件系统、窗口等多层次抽象，使裸机称为更强的虚机器。不仅实现了功能，而且隐藏了细节。</li></ul><h2 id="1-3-操作系统的发展过程"><a href="#1-3-操作系统的发展过程" class="headerlink" title="1.3. 操作系统的发展过程"></a>1.3. 操作系统的发展过程</h2><h3 id="1-3-1-未配置操作系统的计算机系统"><a href="#1-3-1-未配置操作系统的计算机系统" class="headerlink" title="1.3.1. 未配置操作系统的计算机系统"></a>1.3.1. 未配置操作系统的计算机系统</h3><h4 id="1-3-1-1-人工操作方式"><a href="#1-3-1-1-人工操作方式" class="headerlink" title="1.3.1.1. 人工操作方式"></a>1.3.1.1. 人工操作方式</h4><p>早期的操作方式是由程序员将事先已穿孔的纸带（或卡片），装入纸带输入机（或卡片输入机），再启动它们将纸带（或卡片）上的程序和数据输入计算机，然后启动计算机运行。仅当程序运行完毕并取走计算结果后，才允许下一个用户上机。这种人工操作方式有以下两方面的缺点：</p><ol><li>用户独占全机，即一台计算机的全部资源由上机用户所独占。</li><li>CPU等待人工操作。当用户进行装带（卡）、卸带（卡）等人工操作时，CPU及内存等资源是空闲的。</li></ol><h4 id="1-3-1-2-脱机输入输出方式"><a href="#1-3-1-2-脱机输入输出方式" class="headerlink" title="1.3.1.2. 脱机输入输出方式"></a>1.3.1.2. 脱机输入输出方式</h4><p>为了解决人机矛盾及CPU和I/O设备之间速度不匹配的矛盾，出现了脱机IO技术。该技术是事先将装有用户程序和数据的纸带装入纸带输入机，在一台外围机的控制下，把纸带（卡片）上的数据（程序）输入到磁带上。当CPU需要这些程序和数据时，再从磁带上高速地调入内存。</p><p><img src="/images/os/offLine.png"></p><p>由于程序和数据的输入和输出都是在外围机的控制下完成的，或者说，它们是在脱离主机的情况下进行的，故称为脱机输入输出方式。反之，把在主机的直接控制下进行输入输出的方式称为联机输入/输出方式。<br>优点是：</p><ul><li>减少了CPU的空闲时间：外围机操作并不占用主机时间；</li><li>提高了I/O速度。</li></ul><h3 id="1-3-2-单道批处理系统"><a href="#1-3-2-单道批处理系统" class="headerlink" title="1.3.2. 单道批处理系统"></a>1.3.2. 单道批处理系统</h3><p><strong>处理过程</strong><br>为实现对作业的连续处理，先把一批作业以脱机方式输入到磁带上，配上监督程序。首先由监督程序将磁带上的第一个作业装入内存，并把运行控制权交给该作业；当该作业处理完成时，又把控制权交还给监督程序，再由监督程序把磁带上的第二个作业调入内存。计算机系统就这样自动地一个作业紧接一个作业地进行处理，直至磁带上的所有作业全部完成，这样便形成了早期的批处理系统。虽然系统对作业的处理是成批进行的，但在内存中始终只保持一道作业，故称为单道批处理系统。</p><p><img src="/images/os/simpleBatchProcess.png"></p><p>旨在解决人机矛盾和CPU与IO设备速度不匹配矛盾的过程中形成的，提高系统资源的利用率和系统吞吐量。</p><p><strong>缺点</strong><br>系统中的资源得不到充分的利用。因为在内存中仅有一道程序，每逢该程序在运行中发出I/O请求后，CPU便处于等待状态，必须在其I/O完成后才继续运行。又因I/O设备的低速性，更使CPU的利用率显著降低。</p><h3 id="1-3-3-多道批处理系统"><a href="#1-3-3-多道批处理系统" class="headerlink" title="1.3.3. 多道批处理系统"></a>1.3.3. 多道批处理系统</h3><p><strong>处理过程</strong><br>用户所提交的作业先存放在外存上，并排成一个队列，称为“后备队列”。然后由作业调度程序按一定的算法，从后备队列中选择若干个作业调入内存，使它们共享CPU和系统中的各种资源。由于同时在内存中装有若干道程序，这样便可以在运行程序A时，利用其因I/O操作而暂停执行时的CPU空档时间，再调度另一道程序B运行，同样可以利用程序B在I/O操作时的CPU空档时间，再调度程序C运行，使多道程序交替地运行，这样便可以保持CPU处于忙碌状态。</p><p><img src="/images/os/multiBatchProcess.png"></p><p><strong>优缺点</strong></p><ul><li>资源利用率高。引入多道批处理能使多道程序交替运行，以保持CPU处于忙碌状态；在内存中装入多道程序可提高内存的利用率；此外还可以提高IO设备的利用率。</li><li>系统吞吐量大。能提高系统吞吐量的主要原因可归结为：①CPU和其它资源保持“忙碌”状态；仅当作业完成时或运行不下去时才进行切换，系统开销小。</li><li>平均周转时间长。由于作业要排队依次进行处理，因而作业的周转时间较长，通常需几个小时，甚至几天。</li><li>无交互能力。用户一旦把作业提交给系统后，直至作业完成，用户都不能调试修改。</li></ul><p><strong>需要解决的问题</strong></p><ul><li>处理机争用问题。既要能满足各道程序运行的需要，又要能提高处理机的利用率。</li><li>内存分配和保护问题。系统应能为每道程序分配必要的内存空间，使它们“各得其所”，且不会因某道程序出现异常情况而破坏其它程序。</li><li>I/O设备分配问题。系统应采取适当的策略来分配系统中的IO设备，以达到既能方便用户对设备的使用，又能提高设备利用率的目的。</li><li>文件的组织和管理问题。系统应能有效地组织存放在系统中的大量的程序和数据，使它们既便于用户使用，又能保证数据的安全性。</li><li>作业管理问题。系统中存在着各种作业（应用程序），系统应能对系统中所有的作业进行合理的组织，以满足这些作业用户的不同要求</li><li>用户与系统的接口问题。为使用户能方便的使用操作系统，OS还应提供用户与操作系统之间的接口。</li></ul><h3 id="1-3-4-分时系统"><a href="#1-3-4-分时系统" class="headerlink" title="1.3.4. 分时系统"></a>1.3.4. 分时系统</h3><p>为了满足人机交互和共享主机的需求。OS能提供终端，系统及时接收处理命令。</p><ul><li>及时接收：配置多路卡，实现分时多路复用；</li><li>及时处理：<ul><li>作业直接进入内存；</li><li>采用轮转运行方式。设置时间片避免一个作业长期独占CPU。</li></ul></li></ul><p><strong>特征</strong><br>多路性、独立性、及时性、交互性。</p><h3 id="1-3-5-实时系统"><a href="#1-3-5-实时系统" class="headerlink" title="1.3.5. 实时系统"></a>1.3.5. 实时系统</h3><p>“实时计算”，则可以定义为这样一类计算：系统的正确性，不仅由计算的逻辑结果来确定，而且还取决于产生结果的时间。实时系统最主要的特征，是将时间作为关键参数。</p><p><strong>实时任务的类型</strong></p><ul><li><p>周期性</p></li><li><p>非周期性：开始截止时间和完成截止时间</p></li><li><p>硬实时任务：必须</p></li><li><p>软实时任务：不严格</p></li></ul><p><strong>实时系统与分时系统特征的比较</strong></p><ol><li>多路性。分时系统中表现为系统按分时原则为多个终端用户服务：实时控制指系统周期性地对多路现场信息进行采集；</li><li>独立性。分时系统每个终端在与系统交互时彼此相互独立互不干扰；实时系统中对信息的采集和对对象的控制也都是彼此互不干扰的</li><li>及时性。分时系统对实时性的要求是依据人所能接受的等待时间确定的；实时控制系统的实时性则是以控制对象所要求的截止时间来确定的。<br>（4）交互性。实时系统交互性仅限于访问系统中某些特定的专用服务程序；分时系统能向终端用户提供数据处理、资源共享等服务。<br>（5）可靠性。分时系统要求系统可靠，实时系统要求系统高度可靠。</li></ol><h3 id="1-3-6-微机操作系统"><a href="#1-3-6-微机操作系统" class="headerlink" title="1.3.6. 微机操作系统"></a>1.3.6. 微机操作系统</h3><ul><li>单用户单任务操作系统：MS-DOS</li><li>单用户多任务操作系统：windows</li><li>多用户多任务操作系统：unix，linux</li></ul><h2 id="1-4-操作系统的基本特性"><a href="#1-4-操作系统的基本特性" class="headerlink" title="1.4. 操作系统的基本特性"></a>1.4. 操作系统的基本特性</h2><h3 id="1-4-1-并发"><a href="#1-4-1-并发" class="headerlink" title="1.4.1. 并发"></a>1.4.1. 并发</h3><ol><li>并行与并发</li></ol><p>并行性是指两个或多个事件在同一时刻发生。而并发性是指两个或多个事件在同一时间间隔内发生。在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。</p><ol start="2"><li>引入进程<br>在一个未引入进程的系统中，在程序执行IO操作时，计算程序也不能执行。但在为计算程序和IO程序分别建立一个进程后，这两个进程便可并发执行。若对内存中的多个程序都分别建立一个进程，它们就可以并发执行，这样便能极大地提高系统资源的利用率，增加系统的吞吐量。</li></ol><p>所谓进程，是指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。多个进程之间可以并发执行和交换信息。</p><h3 id="1-4-2-共享"><a href="#1-4-2-共享" class="headerlink" title="1.4.2. 共享"></a>1.4.2. 共享</h3><p>OS环境下的资源共享或称为资源复用，是指系统中的资源可供内存中多个并发执行的进程共同使用。这里在宏观上既限定了时间（进程在内存期间），也限定了地点（内存）。</p><ol><li><p>互斥共享方式：进程A要访问某资源时，必须先提出请求。若此时该资源空闲，系统便可将之分配给请求进程A使用。<br>把这种在一段时间内只允许一个进程访问的资源，称为临界资源（或独占资源）。</p></li><li><p>同时访问方式<br>系统中还有另一类资源，允许在一段时间内由多个进程“同时”对它们进行访问。这里所谓的“同时”，在单处理机环境下是宏观意义上的，而在微观上，这些进程对该资源的访问是交替进行的。例如磁盘。</p></li></ol><p>并发和共享是多用户（多任务）OS的两个最基本的特征。它们又是互为存在的条件。即方面资源共享是以进程的并发执行为条件的，若系统不允许并发执行也就不存在资源共享问题；另一方面，若系统不能对资源共享实施有效管理，以协调好诸进程对共享资源的访问，也必然会影响到诸进程间并发执行的程度，甚至根本无法并发执行。</p><h3 id="1-4-3-虚拟"><a href="#1-4-3-虚拟" class="headerlink" title="1.4.3. 虚拟"></a>1.4.3. 虚拟</h3><ol><li>时分复用技术：虚拟处理机技术：虚拟设备技术。</li><li>空分复用技术：利用存储器的空闲空间分区域存放和运行其它的多道程序，以此来提高内存的利用率，但并不能实现在逻辑上扩大存储器容量的功能，还必须引入<strong>虚拟存储技术</strong>才能达到此目的。虚拟存储技术在本质上是实现内存的分时复用，即它可以通过分时复用内存的方式，使一道程序仅在远小于它的内存空间中运行。</li></ol><h3 id="1-4-4-异步"><a href="#1-4-4-异步" class="headerlink" title="1.4.4. 异步"></a>1.4.4. 异步</h3><p>进程是以人们不可预知的速度向前推进的，此即进程的异步性。</p><h2 id="1-5-操作系统的主要功能"><a href="#1-5-操作系统的主要功能" class="headerlink" title="1.5. 操作系统的主要功能"></a>1.5. 操作系统的主要功能</h2><h3 id="1-5-1-处理机管理功能"><a href="#1-5-1-处理机管理功能" class="headerlink" title="1.5.1. 处理机管理功能"></a>1.5.1. 处理机管理功能</h3><ul><li>进程控制：为作业创建进程、撤消（终止）已结束的进程，以及控制进程在运行过程中的状态转换；</li><li>进程同步：为多个进程（含线程）的运行进行协调<ul><li>进程互斥方式：诸进程在对临界资源进行访问</li><li>进程同步方式：指在相互合作去完成共同任务的诸进程间，由同步机构对它们的执行次序加以协调。例如锁。</li></ul></li><li>进程通信：通常在相互合作的进程之间采用直接通信方式，即由源进程利用发送命令直接将消息挂到目标进程的消息队列上，以后由目标进程利用接收命令从其消息队列中取出消息。</li><li>调度：<ul><li>作业调度：后备队列调入内存</li><li>进程调度：就绪队列分配处理机</li></ul></li></ul><h3 id="1-5-2-存储器管理功能"><a href="#1-5-2-存储器管理功能" class="headerlink" title="1.5.2. 存储器管理功能"></a>1.5.2. 存储器管理功能</h3><ul><li>内存分配；<ul><li>静态分配：装入时确定；</li><li>动态分配：允许运行中申请。</li></ul></li><li>内存保护：<ul><li>程序之间的内存空间不干扰；</li><li>用户程序和OS程序数据不干扰。</li></ul></li><li>地址映射：将程序地址空间中的逻辑地址转物理地址。</li><li>内存扩充：借助虚拟存储技术：<ul><li>请求调入功能：装入部分数据便可运行，中途调入；</li><li>置换功能：将暂时不用的程序和数据调至硬盘。</li></ul></li></ul><h3 id="1-5-3-设备管理功能"><a href="#1-5-3-设备管理功能" class="headerlink" title="1.5.3. 设备管理功能"></a>1.5.3. 设备管理功能</h3><ul><li>缓冲管理：缓和CPU与I/O设备速度不匹配的的矛盾，常见的缓冲区机制：单缓冲、双缓冲机制、公用缓冲池机制</li><li>设备分配：根据用户进程的IO请求、系统现有资源情况以及按照某种设备分配策略，为之分配其所需的设备。使用完后由系统回收。</li><li>设备处理：设备驱动程序。CPU向设备控制器发出I/O命令，完成指定的I/O操作；由CPU接收中断请求并给予迅速的响应和相应的处理。</li></ul><h3 id="1-5-4-文件管理功能"><a href="#1-5-4-文件管理功能" class="headerlink" title="1.5.4. 文件管理功能"></a>1.5.4. 文件管理功能</h3><ul><li>文件存储空间的管理：为每个文件分配外存空间，回收。</li><li>目录管理：按名存取，目录查询，文件共享。</li><li>文件的读写管理：利用文件指针从外存检索文件。</li><li>文件保护：存取控制。</li></ul><h3 id="1-5-5-OS与用户之间的接口"><a href="#1-5-5-OS与用户之间的接口" class="headerlink" title="1.5.5. OS与用户之间的接口"></a>1.5.5. OS与用户之间的接口</h3><ul><li>用户接口：直接或间接控制作业的命令接口<ul><li>联机用户接口：为联机用户提供的，包括一组键盘操作命令及命令解释程序；</li><li>脱机用户接口：为批处理作业的用户提供的。把需要对作业进行的控制和干预的命令事先写在作业说明书上，提交系统；</li><li>图形用户接口。</li></ul></li><li>程序接口：为用户程序访问系统资源而设置，是用户程序取得操作系统服务的唯一途径。它是由一组系统调用组成的，每一个系统调用都是一个能完成特定功能的子程序。早期的系统调用都是用汇编语言提供的，只有在用汇编语言书写的程序中才能直接使用系统调用。但在高级语言中，往往提供了与各系统调用一一对应的库函数这样。</li></ul><h3 id="1-5-6-现代操作系统的新功能"><a href="#1-5-6-现代操作系统的新功能" class="headerlink" title="1.5.6. 现代操作系统的新功能"></a>1.5.6. 现代操作系统的新功能</h3><ul><li>系统安全</li><li>网络功能</li><li>多媒体</li></ul><h2 id="1-6-OS结构设计"><a href="#1-6-OS结构设计" class="headerlink" title="1.6. OS结构设计"></a>1.6. OS结构设计</h2><h3 id="1-6-1-传统OS结构"><a href="#1-6-1-传统OS结构" class="headerlink" title="1.6.1. 传统OS结构"></a>1.6.1. 传统OS结构</h3><h4 id="1-6-1-1-无结构OS"><a href="#1-6-1-1-无结构OS" class="headerlink" title="1.6.1.1. 无结构OS"></a>1.6.1.1. 无结构OS</h4><p>在早期开发操作系统时，设计者只是把他的注意力放在功能的实现和获得高的效率上，缺乏首尾一致的设计思想。此时的OS是为数众多的一组过程的集合，每个过程可以任意地相互调用其它过程，致使操作系统内部既复杂又混乱，因此，这种OS是无结构的，也有人把它称为整体系统结构</p><h4 id="1-6-1-2-模块化结构OS"><a href="#1-6-1-2-模块化结构OS" class="headerlink" title="1.6.1.2. 模块化结构OS"></a>1.6.1.2. 模块化结构OS</h4><p>模块化程序设计技术是20世纪60年代出现的一种结构化程序设计技术。该技术“模块化”的原则来控制大型软件的复杂度。OS不再是由众多的过程直接构成的，而是按其功能精心地划分为若干个具有一定独立性和大小的模块。每个模块具有某方面的管理功能，并仔细地规定好各模块间的接口，使各模块之间能通过接口实现交互。这种设计方法称为模块-接口法。</p><p>模块的独立性要符合高内聚、低耦合的原则。</p><p>缺点：</p><ul><li>在OS设计时，对各模块间的接口规定很难满足在模块设计完成后对接口的实际需求。</li><li>各模块的设计齐头并进，无法寻找一个可靠的决定顺序，造成各种决定的“无序性”，这将使程序人员很难做到“设计中的每一步决定”都是建立在可靠的基础上，因此模块-接口法又被称为“无序模块法”。</li></ul><h4 id="1-6-1-3-分层式结构OS"><a href="#1-6-1-3-分层式结构OS" class="headerlink" title="1.6.1.3. 分层式结构OS"></a>1.6.1.3. 分层式结构OS</h4><p>为了将模块-接口法中“决定顺序”的无序性变为有序性，引入了有序分层法，分层法的设计任务是，在目标系统An和裸机系统（又称宿主系统）A0之间，铺设若干个层次的软件A1、A2、A3、…、An-1，使An通过An-1、An-2、…、A2、A1层，最终能在A0上运行。<br>在操作系统中，常采用自底向上法来铺设这些中间层。</p><p>自底向上的分层设计的基本原则是：每一步设计都建立在可靠的基础上。</p><p>优点：</p><ul><li>易保证系统的正确性和可靠性。</li><li>易扩充和易维护性。</li></ul><p>缺点：</p><p>分层结构的主要缺点是系统效率降低。由于层次结构是分层单向依赖的，必须在每层之间都建立层次间的通信机制，OS每执行一个功能，通常要自上而下地穿越多个层次，这无疑会增加系统的通信开销，从而导致系统效率的降低。</p><h3 id="1-6-2-客户服务器模式"><a href="#1-6-2-客户服务器模式" class="headerlink" title="1.6.2. 客户服务器模式"></a>1.6.2. 客户服务器模式</h3><p><strong>组成</strong></p><ul><li>客户机：每台客户机都是一个自主计算机，具有一定的处理能力。</li><li>服务器：通常是一台规模较大的机器，应能为网上所有的用户提供一种或多种服务。平时它一直处于工作状态，被动地等待来自客户机的请求。</li><li>网络系统：是用于连接所有客户机和服务器，实现它们之间通信和网络资源共享的系统。</li></ul><p><strong>优点</strong></p><ul><li>数据的分布处理和存储。由于客户机具有相当强的处理和存储能力，可进行本地处理和数据的分布存储，摆脱主机瓶颈。</li><li>便于集中管理。较好地保障系统重要数据的“可靠”和“安全”。</li><li>灵活性和可扩充性。理论上，客户机和服务器的数量不受限制，可以配置多种类型的客户机和服务器。</li><li>易于改编应用软件。在客户服务器模式中，对于客户机程序的修改和增删，比传统集中模式要容易得多，必要时也允许由客户进行修改。</li></ul><p><strong>缺点</strong></p><p>基本客户/服务器模式的不足之处是存在着不可靠性和瓶颈问题。在系统仅有一个服务器时，一旦服务器故障，将导致整个网络瘫痪。当服务器在重负荷下工作时，会因忙不过来而显著地延长对用户请求的响应时间。如果在网络中配置多个服务器，并采取相应的安全措施，则这种不足可加以改善。</p><h3 id="1-6-3-面向对象的程序设计技术"><a href="#1-6-3-面向对象的程序设计技术" class="headerlink" title="1.6.3. 面向对象的程序设计技术"></a>1.6.3. 面向对象的程序设计技术</h3><p>略。</p><h3 id="1-6-4-微内核OS结构"><a href="#1-6-4-微内核OS结构" class="headerlink" title="1.6.4. 微内核OS结构"></a>1.6.4. 微内核OS结构</h3><p>有效地支持多处理机运行，适用于分布式系统环境。</p><h4 id="1-6-4-1-基本概念"><a href="#1-6-4-1-基本概念" class="headerlink" title="1.6.4.1. 基本概念"></a>1.6.4.1. 基本概念</h4><ul><li>足够小的内核：实现核心功能，并非完整功能；</li><li>基于C/S模式：核心之外的功能通过进程实现，运行在用户态，CS借助微内核的消息传递机制实现信息交互；</li></ul><p><img src="/images/os/kernelcs.png"></p><ul><li>应用“机制与策略分离”原理；<blockquote><p>所谓机制是指实现某一功能的具体执行机构，策略则是在机制的基础上借助于某些参数和算法来实现该功能的优化，或达到不同的功能目标。通常，机制处于一个系统的基层，而策略则处于系统的高层。在传统的OS中，将机制放在OS的内核的较低层，把策略放在内核的较高层次中。而在微内核操作系统中，通常将机制放在OS的微内核中。正因为如此，才有可能将内核做得很小。<br>例如，为实现进程（线程）调度功能，须在进程管理中设置一个或多个进程（线程）优先级队列，能将指定优先级进程（线程）从所在队列中取出，并将其投入执行。由于这一部分属于调度功能的机制部分，应将它放入微内核中。而对于用户（进程）如何进行分类，以及其优先级的确认方式或原则，则都是属于策略问题。可将它们放入微内核外的进程线程）管理服务器中。<br>由于进程（线程）之间的通信功能是微内核OS最基本的功能，被频繁使用，因此几乎所有的微内核OS都是将进程（线程）之间的通信功能放入微内核中。此外，还将进程的切换、线程的调度，以及多处理机之间的同步等功能也放入微内核中。</p></blockquote></li><li>采用面向对象技术；</li></ul><h4 id="1-6-4-2-基本功能"><a href="#1-6-4-2-基本功能" class="headerlink" title="1.6.4.2. 基本功能"></a>1.6.4.2. 基本功能</h4><p>要注意，特指的是微内核功能，而微内核实现的是使用最频繁的、最核心的功能，还可将一些功能一分为二，核心放入内核，绝大部分核外实现。</p><ul><li>进程（线程）管理：应用“机制与策略分离”原理实现；</li><li>低级存储器管理；</li><li>中断和陷入处理；</li></ul><h4 id="1-6-4-3-优缺点"><a href="#1-6-4-3-优缺点" class="headerlink" title="1.6.4.3. 优缺点"></a>1.6.4.3. 优缺点</h4><p><strong>优点</strong></p><ul><li>可扩展性：开发新的软硬件只需在核外增加专用服务器；</li><li>可靠性：严格测试而成；精简的API；服务器运行在用户态，出错不会影响内核和其他服务器；</li><li>可移植性强：所有与特定CPU和MO设备硬件有关的代码均放在内核和内核下面的硬件隐藏层中，而各种服务器均与硬件平台无关；</li><li>支持分布式：广泛使用消息传递通信机制，有一张进程和服务器的标识符与它们所驻留的机器之间的映射表；</li><li>面向对象技术。</li></ul><p><strong>缺点</strong></p><p>OS运行效率降低。</p><p>原因：效率降低最主要的原因是，在完成一次客户对操作系统提出的服务请求时，需要利用消息实现多次交互和进行用户/内核模式与上下文的多次切换。然而，在早期的OS中，用户进程在请求取得OS服务时，一般只需进行两次上下文的切换：一次是在执行系统调用后由用户态转向系统态时；另一次是在系统完成用户请求的服务后，由系统态返回用户态时。</p><p>在微内核OS中，由于客户和服务器、服务器和服务器之间的通信都需通过微内核，致使同样的服务请求至少需要进行四次上下文切换。</p><ul><li>客户发送请求消息给内核，以请求取得某服务器特定的服务；第二次是发生在由</li><li>内核把客户的请求消息发往服务器：</li><li>服务器完成客户请求后，把响应消息发送到内核；</li><li>内核将响应消息发送给客户。</li></ul><p><img src="/images/os/miniKernlPeoblem.png"></p><p>实际上更多，应为服务器不一定靠自身独立完成功能。</p><p>为了改善运行效率，可以重新把一些常用的操作系统基本功能由服务器移入微内核中，但这又会使微内核的容量明显地增大。</p><h1 id="2-进程的描述与控制"><a href="#2-进程的描述与控制" class="headerlink" title="2. 进程的描述与控制"></a>2. 进程的描述与控制</h1><h2 id="2-1-前趋图和程序执行"><a href="#2-1-前趋图和程序执行" class="headerlink" title="2.1. 前趋图和程序执行"></a>2.1. 前趋图和程序执行</h2><h3 id="2-1-1-前趋图"><a href="#2-1-1-前趋图" class="headerlink" title="2.1.1. 前趋图"></a>2.1.1. 前趋图</h3><p>为了能更好地描述程序的顺序和并发执行情况,我们先介绍用于描述程序执行先后顺序的前趋图。所谓前趋图是指一个有向无循环图,它用于描述进程之间执行的先后顺序。图中的每个结点可用来表示一个进程或程序段,乃至一条语句,结点间的有向边则表示两个结点之间存在的偏序或前趋关系进程(或程序之间的前趋关系可用“→”来表示,如果进程P和P存在着前趋关系,写成P1→P2,表示在P2开始执行之前P1必须完成。</p><h3 id="2-1-2-程序顺序执行"><a href="#2-1-2-程序顺序执行" class="headerlink" title="2.1.2. 程序顺序执行"></a>2.1.2. 程序顺序执行</h3><p>单道程序系统。<br>通常,一个应用程序由若干个程序段组成,每一个程序段完成特定的功能,它们在执行时,都需要按照某种先后次序顺序执行,仅当前一程序段执行完后,才运行后一程序段。</p><p><strong>特征</strong></p><ul><li>顺序性：指处理机严格地按照程序所规定的顺序执行,即每一操作必须在下一个操作开始之前结東；</li><li>封闭性：指程序在封闭的环境下运行,即程序运行时独占全机资源,资源的状态(除初始状态外)只有本程序才能改变它,程序一旦开始执行,其执行结果不受外界因素影响；</li><li>可再现性:指只要程序执行时的环境和初始条件相同,当程序重复执行时,不论它是从头到尾不停顿地执行,还是“停停走走”地执行,都可获得相同的结果。</li></ul><h3 id="2-1-3-程序并发执行"><a href="#2-1-3-程序并发执行" class="headerlink" title="2.1.3. 程序并发执行"></a>2.1.3. 程序并发执行</h3><p>多道程序技术。<br>只有在不存在前趋关系的程序之间才有可能并发执行,否则无法并发执行。</p><p>对于具有下述四条语句的程序段:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S1:a:&#x3D;x+2</span><br><span class="line">S2:b:&#x3D;y+4</span><br><span class="line">S3:c:&#x3D;a+b</span><br><span class="line">S4:d:&#x3D;c+b</span><br></pre></td></tr></table></figure><p>可以看出:S3必须在a和b被赋值后方能执行:S4必须在S3之后执行;但S1和S2则可以并发执行,因为它们彼此互不依赖。</p><p><strong>特征</strong></p><ul><li>间断性。程序在并发执行时,由于它们共享系统资源,以及为完成同一项任务而相互合作,致使在这些并发执行的程序之间形成了相互制约的关系。</li><li>失去封闭性。当系统中存在着多个可以并发执行的程序时,系统中的各种资源将为它们所共享,而这些资源的状态也由这些程序来改变,致使其中任一程序在运行时,其环境都必然会受到其它程序的影响。</li><li>不可再现性。程序在并发执行时,由于失去了封闭性,也将导致其又失去可再现性。</li></ul><h2 id="2-2-进程的描述"><a href="#2-2-进程的描述" class="headerlink" title="2.2. 进程的描述"></a>2.2. 进程的描述</h2><h3 id="2-2-1-进程的定义"><a href="#2-2-1-进程的定义" class="headerlink" title="2.2.1. 进程的定义"></a>2.2.1. 进程的定义</h3><p>为了使参与并发执行的每个程序(含数据)都能独立地运行,在操作系统中必须为之配置一个专门的数据结构,称为进程控制块( Process Control block,PCB)。系统利用PCB来描述进程的基本情况和活动过程,进而控制和管理进程。这样,由程序段、相关的数据段和pCB三部分便构成了进程实体(又称进程映像)。一般情况下,我们把进程实体就简称为进程。</p><p>传统OS中的进程定义为:“进程是进程实体的运行过程,是系统进行资源分配和调度的一个独立单位。”</p><h3 id="2-2-2-进程的特征"><a href="#2-2-2-进程的特征" class="headerlink" title="2.2.2. 进程的特征"></a>2.2.2. 进程的特征</h3><ul><li>动态性：进程的实质是进程实体的执行过程,进程实体有一定的生命期,而程序则只是一组有序指令的集合,并存放于某种介质上,其本身并不具有活动的含义,因而是静态的。</li><li>并发性。是指多个进程实体同存于内存中,且能在一段时间内同时运行。引入进<br>程的目的也正是为了使其进程实体能和其它进程实体并发执行。程序(没有建立PCB)是不能参与并发执行的。</li><li>独立性。在传统的OS中,独立性是指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。凡未建立PCB的程序都不能作为一个独立的单位参与运行。</li><li>异步性,是指进程是按异步方式运行的,即按各自独立的、不可预知的速度向前推进。正是源于此因,才导致了传统意义上的程序若参与并发执行,会产生其结果的不可再现性。</li></ul><h2 id="2-3-进程的基本状态及转换"><a href="#2-3-进程的基本状态及转换" class="headerlink" title="2.3. 进程的基本状态及转换"></a>2.3. 进程的基本状态及转换</h2><h3 id="2-3-1-三种基本状态"><a href="#2-3-1-三种基本状态" class="headerlink" title="2.3.1. 三种基本状态"></a>2.3.1. 三种基本状态</h3><ul><li>就绪( Ready)状态。进程已处于准备好运行的状态,即进程已分配到除CPU以外的所有必要资源后,只要再获得CPU,便可立即执行。如果系统中有许多处于就绪状态的进程,通常将它们按一定的策略(如优先级策略)排成一个队列,称该队列为就绪队列。</li><li>执行( Running)状态。进程已获得CPU,其程序正在执行的状态。对任何个时刻而言,在单处理机系统中,只有一个进程处于执行状态,而在多处理机系统中,则有多个进程处于执行状态；</li><li>阻塞( Block)状态。正在执行的进程由于发生某事件暂时无法继续执行时的状态,亦即进程的执行受到阻塞。此时引起进程调度,OS把处理机分配给另一个就绪进程,而让受阻进程处于暂停状态,一般将这种暂停状态称为阻塞状态,有时也称为等待状态或封锁状态。通常系统将处于阻塞状态的进程也排成一个队列,称该队列为阻塞队列。</li></ul><h3 id="2-3-2-状态转换"><a href="#2-3-2-状态转换" class="headerlink" title="2.3.2. 状态转换"></a>2.3.2. 状态转换</h3><p><img src="/images/os/3status.png"></p><h3 id="2-3-3-创建状态和终止状态"><a href="#2-3-3-创建状态和终止状态" class="headerlink" title="2.3.3. 创建状态和终止状态"></a>2.3.3. 创建状态和终止状态</h3><ul><li>创建状态：如果进程所需的资源尚不能得到满足,创建工作尚未完成,进程不能被调度运行,于是把此时进程所处的状态称为创建状态。</li></ul><p>当其获得了所需的资源以及对其PCB的初始化工作完成后,便可由创建状态转入就绪状态</p><ul><li>终止状态：进当一个进程到达了自然结束点,或是出现了无法克服的错误,或是被操作系统所终结,或是被其他有终止权的进程所终结,它将进入终止状态。进入终止状态。</li></ul><p>进入终止态的进程以后不能再执行,但在操作系统中依然保留一个记录,其中保存状态码和一些计时统计数据,供其他进程收集。一旦其他进程完成了对其信息的提取之后,操作系统将删除该进程,即将其PCB清零,并将该空白PCB返还系统。</p><p><img src="/images/os/5status.png"></p><h2 id="2-4-挂起操作"><a href="#2-4-挂起操作" class="headerlink" title="2.4. 挂起操作"></a>2.4. 挂起操作</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;准备的书太拉跨，不准备继续总结了&lt;/p&gt;</summary>
    
    
    
    <category term="Study" scheme="https://memorykk.cn/categories/Study/"/>
    
    
    <category term="OS" scheme="https://memorykk.cn/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://memorykk.cn/network-basic.html"/>
    <id>https://memorykk.cn/network-basic.html</id>
    <published>2021-03-14T03:39:36.000Z</published>
    <updated>2021-03-16T07:17:42.382Z</updated>
    
    <content type="html"><![CDATA[<p>概述、物理层、数据链路层、网络层、运输层、应用层。</p><p>70页、5万字，超长总结。</p><span id="more"></span><hr><p><strong>目录</strong></p><!-- TOC --><ul><li><a href="#1-%E6%A6%82%E8%BF%B0">1. 概述</a><ul><li><a href="#1-1-%E4%BA%92%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0">1.1. 互联网概述</a></li><li><a href="#1-2-%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E7%BB%84%E6%88%90">1.2. 互联网的组成</a><ul><li><a href="#1-2-1-%E8%BE%B9%E7%BC%98%E9%83%A8%E5%88%86">1.2.1. 边缘部分</a><ul><li><a href="#1-2-1-1-%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%B9%E5%BC%8F">1.2.1.1. 客户-服务器方式</a></li><li><a href="#1-2-1-2-%E5%AF%B9%E7%AD%89%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F">1.2.1.2. 对等连接方式</a></li></ul></li><li><a href="#1-2-2-%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86">1.2.2. 核心部分</a><ul><li><a href="#1-2-2-1-%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2">1.2.2.1. 电路交换</a></li><li><a href="#1-2-2-2-%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2">1.2.2.2. 分组交换</a></li><li><a href="#1-2-2-3-%E6%8A%A5%E6%96%87%E4%BA%A4%E6%8D%A2">1.2.2.3. 报文交换</a></li></ul></li></ul></li><li><a href="#1-3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87">1.3. 计算机网络的性能指标</a><ul><li><a href="#1-3-1-%E9%80%9F%E7%8E%87">1.3.1. 速率</a></li><li><a href="#1-3-2-%E5%B8%A6%E5%AE%BD">1.3.2. 带宽</a></li><li><a href="#1-3-3-%E5%90%9E%E5%90%90%E9%87%8F">1.3.3. 吞吐量</a></li><li><a href="#1-3-4-%E6%97%B6%E5%BB%B6">1.3.4. 时延</a></li><li><a href="#1-3-5-%E6%97%B6%E5%BB%B6%E5%B8%A6%E5%AE%BD%E7%A7%AF">1.3.5. 时延带宽积</a></li><li><a href="#1-3-6-%E5%BE%80%E8%BF%94%E6%97%B6%E9%97%B4RTT">1.3.6. 往返时间RTT</a></li><li><a href="#1-3-7-%E5%88%A9%E7%94%A8%E7%8E%87">1.3.7. 利用率</a></li></ul></li><li><a href="#1-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">1.4. 计算机网络体系结构</a><ul><li><a href="#1-4-1-OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B">1.4.1. OSI七层模型</a><ul><li><a href="#1-4-1-1-%E7%89%A9%E7%90%86%E5%B1%82">1.4.1.1. 物理层</a></li><li><a href="#1-4-1-2-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">1.4.1.2. 数据链路层</a></li><li><a href="#1-4-1-3-%E7%BD%91%E7%BB%9C%E5%B1%82">1.4.1.3. 网络层</a></li><li><a href="#1-4-1-4-%E4%BC%A0%E8%BE%93%E5%B1%82">1.4.1.4. 传输层</a></li><li><a href="#1-4-1-5-%E4%BC%9A%E8%AF%9D%E5%B1%82">1.4.1.5. 会话层</a></li><li><a href="#1-4-1-6-%E8%A1%A8%E7%A4%BA%E5%B1%82">1.4.1.6. 表示层</a></li><li><a href="#1-4-1-7-%E5%BA%94%E7%94%A8%E5%B1%82">1.4.1.7. 应用层</a></li></ul></li><li><a href="#1-4-2-%E6%80%BB%E7%BB%93">1.4.2. 总结</a></li></ul></li></ul></li><li><a href="#2-%E7%89%A9%E7%90%86%E5%B1%82">2. 物理层</a><ul><li><a href="#2-1-%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1">2.1. 数据通信</a><ul><li><a href="#2-1-1-%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F">2.1.1. 数据通信系统</a></li><li><a href="#2-1-2-%E4%BF%A1%E9%81%93">2.1.2. 信道</a></li><li><a href="#2-1-3-%E4%BF%A1%E9%81%93%E7%9A%84%E6%9E%81%E9%99%90%E5%AE%B9%E9%87%8F">2.1.3. 信道的极限容量</a></li></ul></li><li><a href="#2-2-%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B%E7%9A%84%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93">2.2. 物理层下的传输媒体</a></li><li><a href="#2-3-%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF">2.3. 信道复用技术</a></li><li><a href="#2-4-%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF">2.4. 宽带接入技术</a></li></ul></li><li><a href="#3-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">3. 数据链路层</a><ul><li><a href="#3-1-%E4%BD%BF%E7%94%A8%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93">3.1. 使用点对点信道</a><ul><li><a href="#3-1-1-%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98">3.1.1. 三个基本问题</a><ul><li><a href="#3-1-1-1-%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7">3.1.1.1. 封装成帧</a></li><li><a href="#3-1-1-2-%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93">3.1.1.2. 透明传输</a></li><li><a href="#3-1-1-3-%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B">3.1.1.3. 差错检测</a></li></ul></li><li><a href="#3-1-2-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP">3.1.2. 点对点协议PPP</a><ul><li><a href="#3-1-2-1-%E5%8D%8F%E8%AE%AE%E7%BB%84%E6%88%90">3.1.2.1. 协议组成</a></li><li><a href="#3-1-2-2-PPP%E5%B8%A7%E6%A0%BC%E5%BC%8F">3.1.2.2. PPP帧格式</a></li><li><a href="#3-1-2-3-PPP%E5%8D%8F%E8%AE%AE%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81">3.1.2.3. PPP协议工作状态</a></li></ul></li></ul></li><li><a href="#3-2-%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93">3.2. 使用广播信道</a><ul><li><a href="#3-2-1-%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">3.2.1. 局域网的数据链路层</a><ul><li><a href="#3-2-1-1-%E4%BB%A5%E5%A4%AA%E7%BD%91%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%A0%87%E5%87%86">3.2.1.1. 以太网的两个标准</a></li><li><a href="#3-2-1-2-%E9%80%82%E9%85%8D%E5%99%A8">3.2.1.2. 适配器</a></li></ul></li><li><a href="#3-2-2-CSMACD%E5%8D%8F%E8%AE%AE">3.2.2. CSMA/CD协议</a></li><li><a href="#3-2-3-%E4%BD%BF%E7%94%A8%E9%9B%86%E7%BA%BF%E5%99%A8%E7%9A%84%E6%98%9F%E5%BD%A2%E6%8B%93%E6%89%91">3.2.3. 使用集线器的星形拓扑</a></li><li><a href="#3-2-4-%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87">3.2.4. 信道利用率</a></li><li><a href="#3-2-5-MAC%E5%B1%82">3.2.5. MAC层</a><ul><li><a href="#3-2-5-1-MAC%E5%9C%B0%E5%9D%80">3.2.5.1. MAC地址</a></li><li><a href="#3-2-5-2-MAC%E5%B8%A7%E7%9A%84%E6%A0%BC%E5%BC%8F">3.2.5.2. MAC帧的格式</a></li></ul></li><li><a href="#3-2-6-%E6%89%A9%E5%B1%95%E7%9A%84%E4%BB%A5%E5%A4%AA%E7%BD%91">3.2.6. 扩展的以太网</a><ul><li><a href="#3-2-6-1-%E7%89%A9%E7%90%86%E5%B1%82%E6%89%A9%E5%B1%95">3.2.6.1. 物理层扩展</a></li><li><a href="#3-2-6-2-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%89%A9%E5%B1%95">3.2.6.2. 数据链路层扩展</a><ul><li><a href="#3-2-6-2-1-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%89%B9%E7%82%B9">3.2.6.2.1. 交换机特点</a></li><li><a href="#3-2-6-2-2-%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB">3.2.6.2.2. 路由器与交换机的主要区别</a></li><li><a href="#3-2-6-2-3-%E4%BB%A5%E5%A4%AA%E7%BD%91%E7%9A%84%E8%87%AA%E5%AD%A6%E4%B9%A0%E5%8A%9F%E8%83%BD">3.2.6.2.3. 以太网的自学习功能</a></li></ul></li></ul></li></ul></li></ul></li><li><a href="#4-%E7%BD%91%E7%BB%9C%E5%B1%82">4. 网络层</a><ul><li><a href="#4-1-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1">4.1. 网络层提供的两种服务</a></li><li><a href="#4-2-%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AEIP">4.2. 网际协议IP</a><ul><li><a href="#4-2-1-%E5%88%86%E7%B1%BB%E7%9A%84IP%E5%9C%B0%E5%9D%80">4.2.1. 分类的IP地址</a><ul><li><a href="#4-2-1-1-IP%E5%9C%B0%E5%9D%80%E7%9A%84%E8%A1%A8%E7%A4%BA">4.2.1.1. IP地址的表示</a></li><li><a href="#4-2-1-2-%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%89%E7%B1%BBIP%E5%9C%B0%E5%9D%80">4.2.1.2. 常见的三类IP地址</a></li></ul></li><li><a href="#4-2-2-%E7%A7%81%E6%9C%89%E5%9C%B0%E5%9D%80">4.2.2. 私有地址</a></li><li><a href="#4-2-3-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2NAT">4.2.3. 网络地址转换NAT</a></li><li><a href="#4-2-4-DHCP%E5%8D%8F%E8%AE%AE">4.2.4. DHCP协议</a></li><li><a href="#4-2-5-IP%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%9C%B0%E5%9D%80">4.2.5. IP地址与硬件地址</a></li><li><a href="#4-2-6-%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AEARP">4.2.6. 地址解析协议ARP</a><ul><li><a href="#4-2-6-1-%E5%90%8C%E4%B8%80%E5%B1%80%E5%9F%9F%E7%BD%91">4.2.6.1. 同一局域网</a></li><li><a href="#4-2-6-2-%E4%B8%8D%E5%9C%A8%E5%90%8C%E4%B8%80%E5%B1%80%E5%9F%9F%E7%BD%91">4.2.6.2. 不在同一局域网</a></li></ul></li><li><a href="#4-2-7-%E9%80%86%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AERARP">4.2.7. 逆地址解析协议RARP</a></li><li><a href="#4-2-8-IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E6%A0%BC%E5%BC%8F">4.2.8. IP数据报的格式</a></li><li><a href="#4-2-9-IP%E5%B1%82%E8%BD%AC%E5%8F%91%E5%88%86%E7%BB%84%E7%9A%84%E6%B5%81%E7%A8%8B">4.2.9. IP层转发分组的流程</a></li></ul></li><li><a href="#4-3-%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91%E5%92%8C%E6%9E%84%E9%80%A0%E8%B6%85%E7%BD%91">4.3. 划分子网和构造超网</a><ul><li><a href="#4-3-1-%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91">4.3.1. 划分子网</a><ul><li><a href="#4-3-1-1-%E4%B8%89%E7%BA%A7IP%E5%9C%B0%E5%9D%80">4.3.1.1. 三级IP地址</a></li><li><a href="#4-3-1-2-%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81">4.3.1.2. 子网掩码</a></li><li><a href="#4-3-1-3-%E4%BD%BF%E7%94%A8%E5%AD%90%E7%BD%91%E7%9A%84%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91">4.3.1.3. 使用子网的分组转发</a></li></ul></li><li><a href="#4-3-2-%E6%9E%84%E9%80%A0%E8%B6%85%E7%BD%91">4.3.2. 构造超网</a><ul><li><a href="#4-3-2-1-%E7%BD%91%E7%BB%9C%E5%89%8D%E7%BC%80">4.3.2.1. 网络前缀</a></li></ul></li></ul></li><li><a href="#4-4-ICMP%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE">4.4. ICMP网际控制报文协议</a></li><li><a href="#4-5-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE">4.5. 路由选择协议</a><ul><li><a href="#4-5-1-%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AERIP">4.5.1. 内部网关协议RIP</a><ul><li><a href="#4-5-1-1-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">4.5.1.1. 工作原理</a></li><li><a href="#4-5-1-2-%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E7%AE%97%E6%B3%95">4.5.1.2. 距离向量算法</a></li></ul></li><li><a href="#4-5-2-%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AEOSPF">4.5.2. 内部网关协议OSPF</a></li><li><a href="#4-5-3-%E5%A4%96%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AEBGP">4.5.3. 外部网关协议BGP</a></li></ul></li></ul></li><li><a href="#5-%E8%BF%90%E8%BE%93%E5%B1%82">5. 运输层</a><ul><li><a href="#5-1-%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0">5.1. 协议概述</a><ul><li><a href="#5-1-1-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1">5.1.1. 进程之间的通信</a></li><li><a href="#5-1-2-%E4%B8%A4%E4%B8%AA%E4%B8%BB%E8%A6%81%E5%8D%8F%E8%AE%AE">5.1.2. 两个主要协议</a></li><li><a href="#5-1-3-%E7%AB%AF%E5%8F%A3">5.1.3. 端口</a></li></ul></li><li><a href="#5-2-%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AEUDP">5.2. 用户数据报协议UDP</a></li><li><a href="#5-3-%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AETCP%E6%A6%82%E8%BF%B0">5.3. 传输控制协议TCP概述</a><ul><li><a href="#5-3-1-TCP%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9">5.3.1. TCP的主要特点</a></li><li><a href="#5-3-2-TCP%E7%9A%84%E8%BF%9E%E6%8E%A5">5.3.2. TCP的连接</a></li></ul></li><li><a href="#5-4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">5.4. 可靠传输的工作原理</a><ul><li><a href="#5-4-1-%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE">5.4.1. 停止等待协议</a><ul><li><a href="#5-4-1-1-%E6%97%A0%E5%B7%AE%E9%94%99%E6%83%85%E5%86%B5">5.4.1.1. 无差错情况</a></li><li><a href="#5-4-1-2-%E5%87%BA%E7%8E%B0%E5%B7%AE%E9%94%99">5.4.1.2. 出现差错</a></li><li><a href="#5-4-1-3-%E7%A1%AE%E8%AE%A4%E4%B8%A2%E5%A4%B1%E5%92%8C%E7%A1%AE%E8%AE%A4%E8%BF%9F%E5%88%B0">5.4.1.3. 确认丢失和确认迟到</a></li><li><a href="#5-4-1-4-%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87">5.4.1.4. 信道利用率</a></li></ul></li><li><a href="#5-4-2-%E8%BF%9E%E7%BB%ADARQ%E5%8D%8F%E8%AE%AE">5.4.2. 连续ARQ协议</a></li></ul></li><li><a href="#5-5-TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E6%A0%BC%E5%BC%8F">5.5. TCP报文段格式</a></li><li><a href="#5-6-TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0">5.6. TCP可靠传输的实现</a><ul><li><a href="#5-6-1-%E4%BB%A5%E5%AD%97%E8%8A%82%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">5.6.1. 以字节为单位的滑动窗口</a></li><li><a href="#5-6-2-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E7%9A%84%E9%80%89%E6%8B%A9">5.6.2. 超时重传时间的选择</a></li><li><a href="#5-6-3-%E9%80%89%E6%8B%A9%E7%A1%AE%E8%AE%A4SACK">5.6.3. 选择确认SACK</a></li></ul></li><li><a href="#5-7-TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">5.7. TCP的流量控制</a><ul><li><a href="#5-7-1-%E5%88%A9%E7%94%A8%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">5.7.1. 利用滑动窗口实现流量控制</a></li><li><a href="#5-7-2-TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E6%95%88%E7%8E%87">5.7.2. TCP的传输效率</a></li></ul></li><li><a href="#5-8-TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">5.8. TCP的拥塞控制</a><ul><li><a href="#5-8-1-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E4%B8%80%E8%88%AC%E5%8E%9F%E7%90%86">5.8.1. 拥塞控制的一般原理</a></li><li><a href="#5-8-2-TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95">5.8.2. TCP的拥塞控制方法</a><ul><li><a href="#5-8-2-1-%E6%85%A2%E5%BC%80%E5%A7%8B">5.8.2.1. 慢开始</a></li><li><a href="#5-8-2-2-%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D">5.8.2.2. 拥塞避免</a></li><li><a href="#5-8-2-3-%E5%BF%AB%E9%87%8D%E4%BC%A0">5.8.2.3. 快重传</a></li><li><a href="#5-8-2-4-%E5%BF%AB%E6%81%A2%E5%A4%8D">5.8.2.4. 快恢复</a></li><li><a href="#5-8-2-5-%E6%80%BB%E7%BB%93">5.8.2.5. 总结</a></li></ul></li><li><a href="#5-8-3-%E4%B8%BB%E5%8A%A8%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86AQM">5.8.3. 主动队列管理AQM</a></li></ul></li><li><a href="#5-9-TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86">5.9. TCP的连接管理</a><ul><li><a href="#5-9-1-TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B">5.9.1. TCP的连接建立</a></li><li><a href="#5-9-2-TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE">5.9.2. TCP的连接释放</a></li><li><a href="#5-9-3-TCP%E7%9A%84%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA">5.9.3. TCP的有限状态机</a></li></ul></li></ul></li><li><a href="#6-%E5%BA%94%E7%94%A8%E5%B1%82">6. 应用层</a><ul><li><a href="#6-1-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS">6.1. 域名系统DNS</a></li><li><a href="#6-2-%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AE">6.2. 文件传送协议</a><ul><li><a href="#6-2-1-FTP">6.2.1. FTP</a></li><li><a href="#6-2-2-TFTP">6.2.2. TFTP</a></li></ul></li><li><a href="#6-3-%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AEHTTP">6.3. 超文本传送协议HTTP</a><ul><li><a href="#6-3-1-HTTP%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B">6.3.1. HTTP基本过程</a></li><li><a href="#6-3-2-HTTP%E6%8A%A5%E6%96%87">6.3.2. HTTP报文</a><ul><li><a href="#6-3-2-1-HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87">6.3.2.1. HTTP请求报文</a></li><li><a href="#6-3-2-2-HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E6%8A%A5%E6%96%87">6.3.2.2. HTTP响应报文报文</a></li></ul></li><li><a href="#6-3-3-HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB">6.3.3. HTTP协议的区别</a></li><li><a href="#6-3-4-HTTPS">6.3.4. HTTPS</a><ul><li><a href="#6-3-4-1-HTTPS%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">6.3.4.1. HTTPS的工作原理</a></li><li><a href="#6-3-4-2-HTTPS%E5%92%8CHTTP%E7%9A%84%E5%8C%BA%E5%88%AB">6.3.4.2. HTTPS和HTTP的区别</a></li></ul></li><li><a href="#6-3-5-HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6">6.3.5. HTTP缓存机制</a><ul><li><a href="#6-3-5-1-%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98">6.3.5.1. 强制缓存</a></li><li><a href="#6-3-5-2-%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98">6.3.5.2. 协商缓存</a></li><li><a href="#6-3-5-3-%E6%80%BB%E7%BB%93">6.3.5.3. 总结</a></li></ul></li><li><a href="#6-3-6-SESSION%E5%92%8CCOOKIE">6.3.6. SESSION和COOKIE</a></li></ul></li><li><a href="#6-4-%E8%BE%93%E5%85%A5URL%E4%B9%8B%E5%90%8E%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88">6.4. 输入URL之后会发生什么</a><ul><li><a href="#6-4-1-%E5%A4%A7%E7%BA%B2">6.4.1. 大纲</a></li><li><a href="#6-4-2-%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B">6.4.2. 具体过程</a></li></ul></li></ul></li><li><a href="#7-%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">7. 参考链接</a><!-- /TOC --></li></ul><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><h2 id="1-1-互联网概述"><a href="#1-1-互联网概述" class="headerlink" title="1.1. 互联网概述"></a>1.1. 互联网概述</h2><ul><li>三大网：电信网、有线电视网、计算机网络。</li><li>计算机网络：简称为“网络”，由若干结点和连接这些节点的链路组成。</li><li>互连网（internet）：网络通过路由器互连起来构成更大的计算机网络，即“网络的网络”。</li><li>主机：与网络相连的计算机。</li><li>互联网（Internet）：当前全球最大的、开放的、众多网络互连而成的特定互连网，采用TCP/IP协议族作为通信规则。</li><li>互联网服务提供者ISP：商业公司ISP共同拥有整个互联网。</li><li>互联网的多层次ISP结构：主干ISP、地区ISP、本地ISP。</li></ul><p><img src="/images/network-basic/multi-isp.png" alt="multi-isp.png"></p><ul><li>互联网交换点IXP：允许两个网络直接相连并交换分组，而不再需要通过更高层的ISP转发分组，从而加快效率。IXP常采用工作在数据链路层的网络交换机，用局域网连接起来。</li></ul><h2 id="1-2-互联网的组成"><a href="#1-2-互联网的组成" class="headerlink" title="1.2. 互联网的组成"></a>1.2. 互联网的组成</h2><p>从工作方式上看，分为：</p><ul><li>边缘部分：由所有来凝结在互联网上的主机组成，用户直接使用，用来进行通信和资源共享，即资源子网。</li><li>核心部分：由大量网络和连接这些网络的路由器组成，为边缘部分提供连通性和交换，即通信子网。</li></ul><h3 id="1-2-1-边缘部分"><a href="#1-2-1-边缘部分" class="headerlink" title="1.2.1. 边缘部分"></a>1.2.1. 边缘部分</h3><p>连接在互联网上的所有主机又称为“端系统”。端系统之间的通信实质是进程之间的通信。<br>通信方式有两类：客户服务器方式（C/S）、对等方式（P2P）。</p><h4 id="1-2-1-1-客户-服务器方式"><a href="#1-2-1-1-客户-服务器方式" class="headerlink" title="1.2.1.1. 客户-服务器方式"></a>1.2.1.1. 客户-服务器方式</h4><p>描述的是两个应用进程之间服务与被服务的关系。<br>客户是服务请求方，服务器是服务提供方。</p><p><img src="/images/network-basic/cs.png" alt="cs.png"></p><p><strong>客户程序</strong></p><ul><li>被用户调用后运行，通信时主动想S发起请求，C必须知道S的地址；</li><li>不需要特殊的硬件和复杂的OS。</li></ul><p><strong>服务器程序</strong></p><ul><li>系统启动后自动调用并不断运行，被动地等待并接受C请求，可同时处理多个请求；</li><li>一般需要强大的硬件和复杂的OS支持。</li></ul><h4 id="1-2-1-2-对等连接方式"><a href="#1-2-1-2-对等连接方式" class="headerlink" title="1.2.1.2. 对等连接方式"></a>1.2.1.2. 对等连接方式</h4><p>两台主机在通信时不区分哪个是C或S，运行P2P软件即可平等通信，本质上看认识C/S方式。</p><p><img src="/images/network-basic/p2p.png" alt="p2p.png"></p><h3 id="1-2-2-核心部分"><a href="#1-2-2-核心部分" class="headerlink" title="1.2.2. 核心部分"></a>1.2.2. 核心部分</h3><p>起特殊作用的是<strong>路由器</strong>，实现分组交换。<br>三种交换方式：电路交换、报文交换、分组交换。</p><h4 id="1-2-2-1-电路交换"><a href="#1-2-2-1-电路交换" class="headerlink" title="1.2.2.1. 电路交换"></a>1.2.2.1. 电路交换</h4><p>从通信资源的分配角度来看，交换就是按照某种方式动态地分配传输线路的资源。</p><p>在通话之前，必须先拨号请求建立连接，也就是一条专用的物理通路。挂机后，交换机释放刚才使用的这条专用的物理通路。这种必须经过“建立连接（占用通信资源）→通话（一直占用通信资源）→释放连接（归还通信资源）”的交换方式即“电路交换”。</p><p>在通话的全部时间内，通话的两个用户始终占用端到端的通信资源。</p><p><img src="/images/network-basic/circuitSwitch.png" alt="circuitSwitch.png"></p><p>使用电路交换的线路的传输效率十分低。</p><h4 id="1-2-2-2-分组交换"><a href="#1-2-2-2-分组交换" class="headerlink" title="1.2.2.2. 分组交换"></a>1.2.2.2. 分组交换</h4><p>采用存储转发技术，待发送的在整个数据块称为报文，发送之前将报文划分成等长的数据段，再加上必要的控制信息组成的首部构成分组，又称为“包”。</p><p><img src="/images/network-basic/message.png" alt="message.png"></p><p>主机H1向主机H5发送数据。主机H1先将分组逐个地发往与它直接相连的路由器A。此时，除链路H1-A外，其他通信链路并不被目前通信的双方所占用。需要注意的是，即使是链路H1-A，也只是当分组正在此链路上传送时才被占用。在各分组传送之间的空闲时间，链路H1-A仍可为其他主机发送的分组使用。</p><p><img src="/images/network-basic/packetSwitch.png" alt="packetSwitch.png"></p><table><thead><tr><th>优点</th><th>所采用的手段</th></tr></thead><tbody><tr><td>高效</td><td>在分组传输的过程中动态分配传输带宽，对通信链路是逐段占用</td></tr><tr><td>灵活</td><td>为每一个分组独立地选择最合适的转发路由</td></tr><tr><td>迅速</td><td>以分组作为传送单位，可以不先建立连接就能向其他主机发送分组</td></tr><tr><td>可靠</td><td>保证可靠性的网络协议:分布式多路由的分组交换网，使网络有很好的生存性</td></tr></tbody></table><p>问题：</p><ul><li>分组在各路由器存储转发时需要排队，造成时延；</li><li>各分组携带的控制信息造成开销</li></ul><h4 id="1-2-2-3-报文交换"><a href="#1-2-2-3-报文交换" class="headerlink" title="1.2.2.3. 报文交换"></a>1.2.2.3. 报文交换</h4><p>采用存储转发原理，但每次交换整个报文。</p><p>三种交换方式的比较：</p><p><img src="/images/network-basic/switch.png"></p><h2 id="1-3-计算机网络的性能指标"><a href="#1-3-计算机网络的性能指标" class="headerlink" title="1.3. 计算机网络的性能指标"></a>1.3. 计算机网络的性能指标</h2><h3 id="1-3-1-速率"><a href="#1-3-1-速率" class="headerlink" title="1.3.1. 速率"></a>1.3.1. 速率</h3><p>用的信息量的单位。网络技术中的速率指的是数据的传送速率，它也称为数据率或比特率( bit rate)。速率是计算机网络中最重要的一个性能指标。速率的单位是bit/s。</p><p>当提到网络的速率时，往往指的是额定速率或标称速率，而并非网络实际上运行的</p><h3 id="1-3-2-带宽"><a href="#1-3-2-带宽" class="headerlink" title="1.3.2. 带宽"></a>1.3.2. 带宽</h3><p>带宽本来是指某个信号具有的频带宽度。在计算机网络中，带宽用来表示网络中某通道传送数据的能力，因此网络带宽表示在单位时间内网络中的某信道所能通过的“最高数据率”，单位bit/s。</p><p>前者为频域称谓，而后者为时域称谓，其本质是相同的。</p><h3 id="1-3-3-吞吐量"><a href="#1-3-3-吞吐量" class="headerlink" title="1.3.3. 吞吐量"></a>1.3.3. 吞吐量</h3><p>吞吐量表示在单位时间内通过某个网络(或信道、接口)的实际的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。显然，吞吐量受网络的带宽或网络的额定速率的限制。</p><h3 id="1-3-4-时延"><a href="#1-3-4-时延" class="headerlink" title="1.3.4. 时延"></a>1.3.4. 时延</h3><p>时延包括以下几个部分：</p><ul><li>发送时延：主机或路由器发送数据帧所需要的时间</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">发送时延&#x3D;数据帧长度bit&#x2F;发送速率bit&#x2F;s</span><br></pre></td></tr></table></figure><ul><li>传播时延 电磁波在信道中传播一定的距离需要花费的时间。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">传播时延&#x3D;信道长度m&#x2F;电磁波在信道上的传播速率m&#x2F;s</span><br></pre></td></tr></table></figure><p>发送时延与传输信道的长度没有关系，传播时延与信号的发送速率无关。</p><ul><li><p>处理时延：主机或路由器在收到分组时要花费一定的时间进行处理，例如分析分<br>组的首部、从分组中提取数据部分、进行差错检验或査找适当的路由等。</p></li><li><p>排队时延 分组在经过网络传输时，要经过许多路由器。但分组在进入路由器后<br>要先在输入队列中排队等待处理。排队时延的长短往往取决于网络当时的通信量。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总时延&#x3D;发送时延+传播时延+处理时延+排队时延</span><br></pre></td></tr></table></figure><p><img src="/images/network-basic/delay.png"></p></li></ul><p>对于高速链路，提高的仅仅是数据的发送速率而非比特在链路上的传播速率，减小了数据的发送时延，所以比特不会传送得更快。</p><h3 id="1-3-5-时延带宽积"><a href="#1-3-5-时延带宽积" class="headerlink" title="1.3.5. 时延带宽积"></a>1.3.5. 时延带宽积</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">时延带宽积&#x3D;传播时延*带宽</span><br></pre></td></tr></table></figure><p>管道中的比特数表示发送端发出的但未到达接收端的比特。</p><h3 id="1-3-6-往返时间RTT"><a href="#1-3-6-往返时间RTT" class="headerlink" title="1.3.6. 往返时间RTT"></a>1.3.6. 往返时间RTT</h3><p>信息双向交互一次所需的时间。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有效数据率&#x3D;数据长度&#x2F;发送时间+RTT</span><br></pre></td></tr></table></figure><h3 id="1-3-7-利用率"><a href="#1-3-7-利用率" class="headerlink" title="1.3.7. 利用率"></a>1.3.7. 利用率</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前时延&#x3D;网络空闲时的时延&#x2F;1-利用率</span><br></pre></td></tr></table></figure><p>这里U是网络的利用率，数值在0到1之间。当网络的利用率达到其容量的1/2时<br>时延就要加倍。</p><p>当网络的利用率接近最大值1时，网络的时延就趋于无穷大。因此我们必须有这样的概念:信道或网络的利用率过高会产生非常大的时延。</p><p><img src="/images/network-basic/delay-U.png"></p><h2 id="1-4-计算机网络体系结构"><a href="#1-4-计算机网络体系结构" class="headerlink" title="1.4. 计算机网络体系结构"></a>1.4. 计算机网络体系结构</h2><p>法律上的国际标准：OSI<br>事实上的国籍标准：TCP/IP</p><p>网络协议：未进行网络中的数据交换而建立的规则、标准或约定。包括：</p><ul><li>语法：即数据与控制信息的结构或格式</li><li>语义：即需要发出何种控制信息，完成何种动作以及做出何种响应，例如重传或丢弃的时间</li><li>同步：即事件实现顺序的详细说明</li></ul><p><img src="/images/network-basic/OSI.png"></p><h3 id="1-4-1-OSI七层模型"><a href="#1-4-1-OSI七层模型" class="headerlink" title="1.4.1. OSI七层模型"></a>1.4.1. OSI七层模型</h3><p>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><p>下4层完成通信子网的功能，上3层完成资源子网的功能。</p><p><img src="/images/network-basic/osi7.png"></p><h4 id="1-4-1-1-物理层"><a href="#1-4-1-1-物理层" class="headerlink" title="1.4.1.1. 物理层"></a>1.4.1.1. 物理层</h4><p>利用传输介质为数据链路层提供物理连接，实现比特流的透明传输，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。</p><p>考虑多大的电压代表“1”“0”，接收方应如何识别，电缆的插头应有多少根引脚、如何连接等。</p><h4 id="1-4-1-2-数据链路层"><a href="#1-4-1-2-数据链路层" class="headerlink" title="1.4.1.2. 数据链路层"></a>1.4.1.2. 数据链路层</h4><p>在物理层提供的比特流的基础上，通过差错控制、封装成帧、流量控制提供可靠的通过物理介质传输数据的方法。</p><p>该层通常又被分为介质访问控制（MAC）和逻辑链路控制（LLC）两个子层。</p><p>数据链路层的具体工作是接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层；并且，还负责处理接收端发回的确认帧的信息，以便提供可靠的数据传输。</p><h4 id="1-4-1-3-网络层"><a href="#1-4-1-3-网络层" class="headerlink" title="1.4.1.3. 网络层"></a>1.4.1.3. 网络层</h4><p>将上层的报文段或用户数据报封装成分组，也叫IP数据报。</p><p>另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。</p><p>数据链路层是解决同一网络内节点之间的通信，而网络层主要解决不同子网间的通信。</p><ul><li>寻址：数据链路层中使用的物理地址（如MAC地址）仅解决网络内部的寻址问题。在不同子网之间通信时，为了识别和找到网络中的设备，每一子网中的设备都会被分配一个唯一的地址。由于各子网使用的物理技术可能不同，因此这个地址应当是逻辑地址（如IP地址）。</li><li>交换：规定不同的信息交换方式。常见的交换技术有：线路交换技术和存储转发技术，后者又包括报文交换技术和分组交换技术。</li><li>路由算法：当源节点和目的节点之间存在多条路径时，本层可以根据路由算法，通过网络为数据分组选择最佳路径，并将信息从最合适的路径由发送端传送到接收端。</li><li>连接服务：与数据链路层流量控制不同的是，前者控制的是网络相邻节点间的流量，后者控制的是从源节点到目的节点间的流量。其目的在于防止阻塞，并进行差错检测。</li></ul><h4 id="1-4-1-4-传输层"><a href="#1-4-1-4-传输层" class="headerlink" title="1.4.1.4. 传输层"></a>1.4.1.4. 传输层</h4><p>OSI下3层的主要任务是数据通信，上3层的任务是数据处理。而传输层是通信子网和资源子网的接口和桥梁，起到承上启下的作用。</p><ul><li>传输连接管理：提供建立、维护和拆除传输连接的功能。传输层在网络层的基础上为高层提供“面向连接”和“面向无接连”的两种服务。</li><li>处理传输差错：提供可靠的“面向连接”和不太可靠的“面向无连接”的数据传输服务、差错控制和流量控制。在提供“面向连接”服务时，通过这一层传输的数据将由目标设备确认，如果在指定的时间内未收到确认信息，数据将被重发。</li></ul><h4 id="1-4-1-5-会话层"><a href="#1-4-1-5-会话层" class="headerlink" title="1.4.1.5. 会话层"></a>1.4.1.5. 会话层</h4><p>向两个实体的表示层提供建立和使用连接的方法。将不同实体之间的表示层的连接称为会话。因此会话层的任务就是组织和协调两个会话进程之间的通信，并对数据交换进行管理。</p><ul><li>会话管理：允许用户在两个实体设备之间建立、维持和终止会话，并支持它们之间的数据交换。例如提供单方向会话或双向同时会话，并管理会话中的发送顺序，以及会话所占用时间的长短。</li><li>会话流量控制：提供会话流量控制和交叉会话功能。</li><li>寻址：使用远程地址建立会话连接。l</li><li>出错控制：从逻辑上讲会话层主要负责数据交换的建立、保持和终止，但实际的工作却是接收来自传输层的数据，并负责纠正错误。会话控制和远程过程调用RPC均属于这一层的功能。但应注意，此层检查的错误不是通信介质的错误，而是磁盘空间、打印机缺纸等类型的高级错误。</li></ul><h4 id="1-4-1-6-表示层"><a href="#1-4-1-6-表示层" class="headerlink" title="1.4.1.6. 表示层"></a>1.4.1.6. 表示层</h4><p>对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。</p><p>其主要功能是“处理用户信息的表示问题，如编码、数据格式转换和加密解密”等。</p><ul><li>数据格式处理：协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异。</li><li>数据的编码：处理字符集和数字的转换。例如由于用户程序中的数据类型（整型或实型、有符号或无符号等）、用户标识等都可以有不同的表示方式，因此，在设备之间需要具有在不同字符集或格式之间转换的功能。</li><li>压缩和解压缩：为了减少数据的传输量，这一层还负责数据的压缩与恢复。</li><li>数据的加密和解密：可以提高网络的安全性。</li></ul><h4 id="1-4-1-7-应用层"><a href="#1-4-1-7-应用层" class="headerlink" title="1.4.1.7. 应用层"></a>1.4.1.7. 应用层</h4><p>计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，通过应用进程间的交互完成特定的网络应用。</p><ul><li>用户接口：应用层是用户与网络，以及应用程序与网络间的直接接口，使得用户能够与网络进行交互式联系。</li><li>实现各种服务：该层具有的各种应用程序可以完成和实现用户请求的各种服务。</li></ul><h3 id="1-4-2-总结"><a href="#1-4-2-总结" class="headerlink" title="1.4.2. 总结"></a>1.4.2. 总结</h3><p>OSI七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br>TCP/IP四层：网络接口层、 网际层、运输层、 应用层。<br>五层协议：物理层、数据链路层、网络层、运输层、 应用层。</p><p><strong>协议</strong><br>物理层：RJ45、CLOCK、IEEE802.3（网卡，网线，集线器，中继器，调制解调器）<br>数据链路：PPP、FR、HDLC、VLAN、MAC（网桥，交换机）<br>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器、网关）<br>传输层：TCP、UDP、SPX<br>会话层：NFS、SQL、NETBIOS、RPC<br>表示层：JPEG、MPEG、ASII<br>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</p><p><img src="/images/network-basic/protocolFamily.png"></p><p><strong>作用</strong><br>物理层：通过媒介传输比特，确定机械及电气规范（比特Bit）<br>数据链路层：将比特组装成帧和点到点的传递（帧Frame）<br>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）<br>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）<br>会话层：建立、管理和终止会话（会话协议数据单元SPDU）<br>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）<br>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）  </p><p><img src="/images/network-basic/data.png"></p><p>协议数据单元PDU：对等层次之间传送的数据单位。<br>服务数据单元SDU：层间交换的数据单位。<br>服务访问点SAP：同意系统中相邻两层的实体交换信息的地方。</p><p><img src="/images/network-basic/service-relation.png"></p><p>协议是水平的，服务是垂直的。</p><p><strong>交换机、路由器、网关</strong></p><ul><li><p>交换机<br>在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背 部总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部 交换矩阵迅速将数据包传送到目的端口。目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表中。<br>交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张 ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不 能划分网络层广播，即广播域。<br>交换机被广泛应用于二层网络交换，俗称“二层交换机”。<br>交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在OSI七层模型中的第二层、第三层、第四层盒第七层，并因此而得名。</p></li><li><p>路由器<br>路由器（Router）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。<br>路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。</p></li><li><p>网关<br>网关（Gateway），网关顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP/IP 的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家 庭中或者小型企业网络中使用，用于连接局域网和Internet。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。<br>在传统TCP/IP术语中，网络设备只分成两种，一种为网关（gateway），另一种为主机（host）。网关能在网络间转递数据包，但主机不能 转送数据包。在主机（又称终端系统，end system）中，数据包需经过TCP/IP四层协议处理，但是在网关（又称中介系 统，intermediate system）只需要到达网际层（Internet layer），决定路径之后就可以转送。在当时，网关 （gateway）与路由器（router）还没有区别。<br>在现代网络术语中，网关（gateway）与路由器（router）的定义不同。网关（gateway）能在不同协议间移动数据，而路由器（router）是在不同网络间移动数据，相当于传统所说的IP网关（IP gateway）。<br>网关是连接两个网络的设备，对于语音网关来说，他可以连接PSTN网络和以太网，这就相当于VOIP，把不同电话中的模拟信号通过网关而转换成数字信号，而且加入协议再去传输。在到了接收端的时候再通过网关还原成模拟的电话信号，最后才能在电话机上听到。<br>对于以太网中的网关只能转发三层以上数据包，这一点和路由是一样的。而不同的是网关中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。</p></li></ul><h1 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2. 物理层"></a>2. 物理层</h1><p>首先要强调指岀，物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而通信手段也有许多不同方式。物理层的作用正是要尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异。</p><p>可以将物理层的主要任务描述为确定与传输媒体的接口有关的一些特性，即</p><ol><li>机械特性指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置，等。平时常见的各种规格的接插件都有严格的标准化的规定。</li><li>电气特性指明在接口电缆的各条线上出现的电压的范围。</li><li>功能特性指明某条线上出现的某一电平的电压的意义。</li><li>过程特性指明对于不同功能的各种可能事件的出现顺序</li></ol><p>物理层还要完成串行-&gt;并行传输的转换。</p><h2 id="2-1-数据通信"><a href="#2-1-数据通信" class="headerlink" title="2.1. 数据通信"></a>2.1. 数据通信</h2><h3 id="2-1-1-数据通信系统"><a href="#2-1-1-数据通信系统" class="headerlink" title="2.1.1. 数据通信系统"></a>2.1.1. 数据通信系统</h3><p>可划分为三大部分，即源系统(或发送端、发送方)、传输系统(或传输网络)和目的系统(或接收端、接收方)。</p><p><img src="/images/network-basic/DataCommunication.png"></p><ul><li>模拟信号，或连续信号：代表消息的参数的取值是连续的。</li><li>数字信号，或离散信号：代表消息的参数的取值是离散的。代表不同离散数值的基本波形就称为码元。</li></ul><h3 id="2-1-2-信道"><a href="#2-1-2-信道" class="headerlink" title="2.1.2. 信道"></a>2.1.2. 信道</h3><p>从通信的双方信息交互的方式来看，可以有以下三种基本方式：</p><ul><li>单向通信：称为单工通信，即只能有一个方向的通信而没有反方向的交互。无<br>线电广播或有线电广播以及电视广播就属于这种类型</li><li>双向交替通信：又称为半双工通信，即通信的双方都可以发送信息，但不能双方<br>同时发送(当然也就不能同时接收)。</li><li>双向同时通信：又称为全双工通信，即通信的双方可以同时发送和接收信息<br>单向通信只需要一条信道，而双向交替通信或双向同时通信则都需要两条信道(每个<br>方向各一条)。</li></ul><p>显然，双向同时通信的传输效率最高。</p><p>来自信源的基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。所以必须对基带信号进行调制，分为两大类：</p><ul><li>基带调制：对基带信号的波形进行变换，使它能够与信道特性相适应，变换后的信号仍然是基带信号，也称为编码。<ul><li>不归零制</li><li>归零制</li><li>曼彻斯特编码</li><li>差分曼彻斯特编码</li></ul></li><li>带通调制：使用载波把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，经过载波调制后的信号称为带通信号，即仅在一段频率范围内能够通过信道。<ul><li>调幅（AM）</li><li>调频（FM）</li><li>调相（PM）</li></ul></li></ul><h3 id="2-1-3-信道的极限容量"><a href="#2-1-3-信道的极限容量" class="headerlink" title="2.1.3. 信道的极限容量"></a>2.1.3. 信道的极限容量</h3><p>码间串扰：接收端收到的信号波形就失去了码元之间的清晰界限。<br>严重的码间串扰使得本来分得很清楚的一串码元变得模糊而无法识别。</p><p>奈氏准则：在任何信道中，码元传输的速率是有上限的，传输速率超过此上限，就会出现严重的码间串扰的问题。</p><p>信噪比：所谓信噪比就是信号的平均功率和噪声的平均功率之比，常记为S/N，并用分贝(dB)作为度量单位。</p><p><img src="/images/network-basic/SNR.png"></p><p>香农公式：信道的极限信息传输速率C是</p><p><img src="/images/network-basic/shannon.png"></p><p>式中，W为信道的带宽(Hz);S为信道内所传信号的平均功率;N为信道内<br>部的高斯噪声功率。</p><p>香农公式的意义在于:只要信息传输速率低于信道的极限信息传输速率，就一定存在某种办法来实现无差错的传输。</p><p>从以上所讲的不难看出，对于频带宽度已确定的信道，可以用编码的方法让每一个码元携带更多比特的信息量。</p><h2 id="2-2-物理层下的传输媒体"><a href="#2-2-物理层下的传输媒体" class="headerlink" title="2.2. 物理层下的传输媒体"></a>2.2. 物理层下的传输媒体</h2><ul><li>导引型<ul><li>双绞线</li><li>同轴线缆</li><li>光缆</li></ul></li><li>非导引型<ul><li>短波通信</li><li>无线电微波通信</li><li>卫星通信</li></ul></li></ul><h2 id="2-3-信道复用技术"><a href="#2-3-信道复用技术" class="headerlink" title="2.3. 信道复用技术"></a>2.3. 信道复用技术</h2><p><img src="/images/network-basic/multiplexing.png"></p><ul><li>频分复用（FDM）：所有用户在同样的时间占用不同的带宽资源。</li><li>时分复用（TDM）：所有用户在不同的时间占用同样的频带宽度，又称为同步时分复用。</li></ul><p><img src="/images/network-basic/FDM-TDM.png"></p><ul><li>统计时分复用（STDM）：改进的时分复用，缓存用户数据放入STDM帧，又称为异步时分复用</li><li>波分复用（WDM）：光的频分复用。</li><li>码分复用（CDM）：共享信道。</li></ul><h2 id="2-4-宽带接入技术"><a href="#2-4-宽带接入技术" class="headerlink" title="2.4. 宽带接入技术"></a>2.4. 宽带接入技术</h2><ul><li>ADSL技术：改造电话用户线；</li><li>光纤同轴混合网（HFC网）：改造有线电视网；</li><li>光纤到户（FTTx）：光信号转电信号。</li></ul><h1 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3. 数据链路层"></a>3. 数据链路层</h1><p>数据链路层使用的信道：</p><ul><li>点对点信道。这种信道使用一对一的点对点通信方式。</li><li>广播信道。这种信道使用一对多的广播通信方式。</li></ul><h2 id="3-1-使用点对点信道"><a href="#3-1-使用点对点信道" class="headerlink" title="3.1. 使用点对点信道"></a>3.1. 使用点对点信道</h2><h3 id="3-1-1-三个基本问题"><a href="#3-1-1-三个基本问题" class="headerlink" title="3.1.1. 三个基本问题"></a>3.1.1. 三个基本问题</h3><p>封装成帧。透明传输、差错检测</p><h4 id="3-1-1-1-封装成帧"><a href="#3-1-1-1-封装成帧" class="headerlink" title="3.1.1.1. 封装成帧"></a>3.1.1.1. 封装成帧</h4><p>封装成帧就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧，</p><p>首部和尾部的一个重要作用就是进行帧定界(即确定帧的界限)。此外，首部和尾部还包括许多必要的控制信息。应当使帧的数据部分长度尽可能地大于首部和尾部的长度。每一种链路层协议都规定了所能传送的帧的数据部分长度上限—最大传送<br>单元MTU。</p><p><img src="/images/network-basic/MTU.PNG"></p><p>帧定界符SOH和EOT标识真的开始与结束，用以判断一个完整的帧。</p><h4 id="3-1-1-2-透明传输"><a href="#3-1-1-2-透明传输" class="headerlink" title="3.1.1.2. 透明传输"></a>3.1.1.2. 透明传输</h4><p>当传送的用文本组成的帧时，不管从键盘上输入什么字符都可以放在这样的帧中传输过去，因此这样的传输就是透明传输。</p><p>但当数据部分是非ASCI码的文本文件时(如二进制代码的计算机程序或图像等)，情<br>况就不同了。如果数据中的某个字节的二进制代码恰好和SOH或EOT这种控制字符一样<br>，数据链路层就会错误地“找到帧的边界”，把部分帧收下(误认为是个完整的<br>帧)，而把剩下的那部分数据丢弃(这部分找不到帧定界控制字符SOH)。</p><p><img src="/images/network-basic/EOT.PNG"></p><p><strong>字符填充</strong></p><p>为了解决透明传输问题，发送端的数据链路层在数据中出现控制字符<br>SOH”或“EOT”的前面插入一个转义字符“ESC”。而在接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符。</p><h4 id="3-1-1-3-差错检测"><a href="#3-1-1-3-差错检测" class="headerlink" title="3.1.1.3. 差错检测"></a>3.1.1.3. 差错检测</h4><p>比特差错：比特在传输过程中可能会产生差错：1可能会变成0，而0也可能变成1。</p><p>误码率BER：在一段时间内，传输错误的比特占所传输比特总数的比率。</p><p><strong>循环冗余检验CRC</strong></p><p><img src="/images/network-basic/CRC1.PNG"><br><img src="/images/network-basic/CRC2.PNG"></p><p>判定这个帧有差错，但无法确定究竟是哪一位或哪几位出现了差错。</p><p>在数据链路层若仅仅使用循环冗余检验CRC差错检测技术，则只能做到对帧的无差错接受</p><p>即:“凡是接收端数据链路层接受的帧，我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错”。接收端丢弃的帧虽然曾收到了，但最终还是因为有差错被丢弃，即没有被接受。</p><p>传输差错：帧丢失、帧重复或帧失序。</p><p>过去oSI的观点是:必须让数据链路层向上提供可靠传输。因此在CRC检错的基础上，增加了帧编号、确认和重传机制。</p><h3 id="3-1-2-点对点协议PPP"><a href="#3-1-2-点对点协议PPP" class="headerlink" title="3.1.2. 点对点协议PPP"></a>3.1.2. 点对点协议PPP</h3><p>在TCP/P协议族中，可靠传输由运输层的TCP协议负责，因此数据链路层的PPP协<br>议不需要进行纠错，不需要设置序号，也不需要进行流量控制。PPP协议不支持多点线路，只支持点对点的链路通信。此外，PPP协议只支持全双工链路。</p><h4 id="3-1-2-1-协议组成"><a href="#3-1-2-1-协议组成" class="headerlink" title="3.1.2.1. 协议组成"></a>3.1.2.1. 协议组成</h4><p>PPP协议有三个组成部分：</p><ol><li>将P数据报封装到串行链路的方法。PP既支持异步链路(无奇偶检验的8比<br>特数据)，也支持面向比特的同步链路。IP数据报在PPP帧中就是其信息部分。这个信息部分的长度受最大传送单元MTU的限制。</li><li>用来建立、配置和测试数据链路连接的链路控制协议LCP( Link Cont<br>Protoco)。通信的双方可协商一些选项。在RFC1661中定义了11种类型的LCP分组</li><li>一套网络控制协议 NCP(Network Control Protocol)°，其中的每一个协议支持不同的网络层协议，如IP、OSI的网络层、 DECnet，以及 AppleTalk等</li></ol><h4 id="3-1-2-2-PPP帧格式"><a href="#3-1-2-2-PPP帧格式" class="headerlink" title="3.1.2.2. PPP帧格式"></a>3.1.2.2. PPP帧格式</h4><p><img src="/images/network-basic/PPP.PNG"></p><ul><li>F：0x7E 01111110，标志字段，标识帧的开始或结束</li><li>A、C：无意义</li><li>协议：表示信息部分使用的协议类型</li><li>FCS：检验序列</li></ul><p><strong>字节填充</strong><br>使用异步传输时，它把转义符定义为0xD(即ol11101)，并使用字节填充<br>RFC1662规定了如下所述的填充方法</p><ol><li>把信息字段中出现的每一个0x7E字节转变成为2字节序列(0x7D，0x5E)</li><li>若信息字段中出现一个0x7D的字节(即出现了和转义字符一样的比特组合)，则<br>把0x7D转变成为2字节序列(0x7D，0x5D)</li><li>若信息字段中出现ASCI码的控制字符(即数值小于0x20的字符)，则在该字符前<br>面要加入一个αx⑦D字节，同时将该字符的编码加以改变。例如，出现0x03(在控制字符中是“传输结束”ETX)就要把它转变为2字节序列(0x7D，Ox23)。</li></ol><p><strong>零比特填充</strong><br>使用同步传输时，在发送端，只要发现有5个连续1，则立即填入一个0。因此经过这种填充后的数据，就可以保证在信息字段中不会出现6个连续1。接收端在收到一个帧<br>时，先找到标志字段F以确定一个帧的边界，接着再用硬件对其中的比特流进行扫描。每当发现5个连续1时，就把这5个连续1后的一个0删除，以还原成原来的信息比特流。</p><h4 id="3-1-2-3-PPP协议工作状态"><a href="#3-1-2-3-PPP协议工作状态" class="headerlink" title="3.1.2.3. PPP协议工作状态"></a>3.1.2.3. PPP协议工作状态</h4><p><img src="/images/network-basic/PPPstatus.PNG"></p><p>当用户拨号接入ISP后，就建立了一条从用户个人电脑到IsP的物理连接。这时，用户个人电脑向ISSP发送一系列的链路控制协议LCP分组(封装成多个PPP帧)，以便建立LCP连接。这些分组及其响应选择了将要使用的一些PPP参数。接着还要进行网络层配置，网络控制协议NCP给新接入的用户个人电脑分配一个临时的IP地址。这样，用户个人电脑就成为互联网上的一个有IP地址的主机</p><p>当用户通信完毕时，NCP释放网络层连接，收回原来分配出去的IP地址。接着，LCP释放数据链路层连接。最后释放的是物理层的连接。</p><p>在“网络层协议”状态，PPP链路的两端的网络控制协议NCP根据网络层的不同协议互相交换网络层特定的网络控制分组。这个步骤是很重要的，因为现在的路由器都能够同时支持多种网络层协议。总之，PPP协议两端的网络层可以运行不同的网络层协议，但仍然可使用同一个PP协议进行通信<br>如果在PPP链路上运行的是IP协议，则对PP链路的每一端配置IP协议模块(如分配IP地址)时就要使用NCP中支持IP的协议——IP控制协议IPCP( IP ControlProtoco)IPCP分组也封装成PPP帧(其中的协议字段为0x8021)在PP链路上传送。在低速链路上运行时，双方还可以协商使用压缩的TCP和P首部，以减少在链路上发送的比特数。</p><p>PPP协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。</p><h2 id="3-2-使用广播信道"><a href="#3-2-使用广播信道" class="headerlink" title="3.2. 使用广播信道"></a>3.2. 使用广播信道</h2><h3 id="3-2-1-局域网的数据链路层"><a href="#3-2-1-局域网的数据链路层" class="headerlink" title="3.2.1. 局域网的数据链路层"></a>3.2.1. 局域网的数据链路层</h3><p>局域网使用的就是广播信道。按照网络拓扑分为星形网、环形网、总线网。总线网以传统以太网最为著名，之后出现的快速以太网、吉比特以太网在市场中占据绝对优势，以太网成为局域网的同义词。</p><p>共享信道技术：</p><ul><li>静态划分信道：复用分用技术；</li><li>动态媒体接入控制：又称多点接入<ul><li>随机接入：用户随机发送信息，需要解决碰撞；</li><li>受控接入：用户发送信息需要服从控制。轮询。</li></ul></li></ul><h4 id="3-2-1-1-以太网的两个标准"><a href="#3-2-1-1-以太网的两个标准" class="headerlink" title="3.2.1.1. 以太网的两个标准"></a>3.2.1.1. 以太网的两个标准</h4><ul><li>DIX Ethernet V2</li><li>IEEE 802.3</li></ul><p>二者差别很小。后来IEEE 802将数据链路层拆分为逻辑链路控制LLC( Logical Link Contro)子层和媒体接入控制MAC( Medium Access Control)子层。与接入到传输媒体有关的内容都放在MAC子层，而LLC子层则与传输媒体无关。</p><p>后来市场稳定，LLC子层的作用消失，DIX Ethernet V2市场更大。</p><h4 id="3-2-1-2-适配器"><a href="#3-2-1-2-适配器" class="headerlink" title="3.2.1.2. 适配器"></a>3.2.1.2. 适配器</h4><p>计算机与外界局域网的连接时通过通信适配器进行的，又称为网络接口卡NIC。装有处理器和存储器（包括RAM和ROM）</p><p>作用：</p><ul><li>串并行的转换</li><li>缓存</li><li>实现以太网协议</li></ul><p>工作：</p><p>适配器在接收和发送时不使用计算机的CPU。当适配器收到有差错的帧时，就把这个帧直接丢弃而不必通知计算机。收到正确的帧时，它就使用中断来通知该计算机，并交付协议栈中的网络层。</p><p>当计算机要发送IP数据报时，就由协议栈把IP数据报向下交给适配器，组装成帧后发送到局域网。</p><p>计算机的硬件地址就在适配器的ROM中，而计算机的软件地址（IP地址）则在计算机的存储器中。</p><h3 id="3-2-2-CSMA-CD协议"><a href="#3-2-2-CSMA-CD协议" class="headerlink" title="3.2.2. CSMA/CD协议"></a>3.2.2. CSMA/CD协议</h3><p>总线使用。</p><p>为了通信简便，采用两个措施：</p><ol><li>采用较为灵活的无连接的工作方式，即不必先建立连接就可以直接发送数据<br>适配器对发送的数据帧不进行编号，也不要求对方发回确认。以太网提供的服务是尽最大努力的交付，即不可靠的交付。</li></ol><p>当目的站收到有差错的数据帧时，就把帧丢弃，其他什么也不做。对有差错帧是否需要重传则由高层来决定。</p><p>总线上在同一时间只能允许一台计算机发送数据，否则各计算机之间就会互相干扰，因此以太网使用CSMA/CD协议。</p><ol start="2"><li>以太网发送的数据都使用曼彻斯特( Manchester)编码的信号。</li></ol><p><strong>要点</strong></p><ul><li>先听后发<br>在发送前检测信道，是为了获得发送权。如果检测出已经有其他站在发送，则自己就暂时不许发送数据，必须要等到信道变为空闲时才能发送。</li><li>边听边发<br>在发送中检测信道，是为了及时发现有没有其他站的发送和本站发送的碰撞。</li><li>冲突停止<br>当适配器检测到的信号电压变化幅度超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。适配器就要立即停止发送，免得继续进行无效的<br>发送，白白浪费网络资源，然后等待一段随机时间后再次发送。</li><li>延迟重发<br>使用截断二进制指数退避算法确定延迟重发时机。</li></ul><p>因为传播时延的存在导致先听后发之后人有可能发生碰撞。发送数据后，最迟要经过多长时间才能知道自己发送的数据和其他站发送的数据有没有发生碰撞?这个时间最多是两倍的总线端到端的传播时延(2r)，称为争用期，又叫碰撞窗口。，即经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><p>因此局域网必须按最坏情况设计，即取总线两端的两个站之间的传播时延(这两个站之间的距离最大)为端到端传播时延。</p><p><img src="/images/network-basic/crash.PNG"></p><p>显然，在使用 CSMA/CD协议时，一个站不可能同时进行发送和接收(但必须边发送<br>边监听信道)。因此使用 CSMA/CD协议的以太网不可能进行全双工通信而只能进行双向交替通信(半双工通信)。</p><p>凡长度小于64字节的帧都是由于冲突而中止的无效帧。</p><p><strong>强化碰撞</strong><br>当发送数据的站一旦发现发生了碰撞时，除了立即停止发送数据外，还要再继续发送3比特或48比特的人为干扰信号，以便让所有用户都知道现在已经发生了碰撞。</p><p><strong>帧间最小间隔</strong><br>以太网还规定了帧间最小间隔为96μs，相当于96比特时间。这样做是为了使刚刚收<br>到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。</p><h3 id="3-2-3-使用集线器的星形拓扑"><a href="#3-2-3-使用集线器的星形拓扑" class="headerlink" title="3.2.3. 使用集线器的星形拓扑"></a>3.2.3. 使用集线器的星形拓扑</h3><p>集线器和每个站之间使用两对双绞线，用于发送和接收。<br>IEEE制定了10BASE-T星形以太网标准802.3i。“10”代表10Mbit/s的数据率，BASE表示连接线上的信号是基带信号，T代表双绞线。每个站到集线器的距离不超过100m。</p><p><strong>特点</strong></p><ul><li>用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是<br>CSMA/CD协议。</li><li>一个集线器有许多接口，每个接口通过RJ-45插头用两对双绞线与一台计算机上的适配器相连。因此，一个集线器很像一个多接口的转发器。</li><li>集线器工作在物理层，它的每个接口仅仅简单地转发比特，收到1就转发1，收<br>到0就转发0，不进行碰撞检测。</li></ul><h3 id="3-2-4-信道利用率"><a href="#3-2-4-信道利用率" class="headerlink" title="3.2.4. 信道利用率"></a>3.2.4. 信道利用率</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">信道利用率a&#x3D;\frac&#123;单程端到端时延r&#125;&#123;帧的发送时间T&#125;</span><br></pre></td></tr></table></figure><p>因此，以太网的连线的长度受到限制(否则r数值会太大)，同时以太网的帧长不能太短(否则T的值会太小，使a值太大)。</p><h3 id="3-2-5-MAC层"><a href="#3-2-5-MAC层" class="headerlink" title="3.2.5. MAC层"></a>3.2.5. MAC层</h3><h4 id="3-2-5-1-MAC地址"><a href="#3-2-5-1-MAC地址" class="headerlink" title="3.2.5.1. MAC地址"></a>3.2.5.1. MAC地址</h4><p>规定了一种48位的全球地址，是指局域网上的每一台计算机中固化在适配器的ROM中的地址。</p><p>适配器从网络上每收到一个MAC帧就先用硬件检査MAC帧中的目的地址。如果是发往本站的帧则收下，然后再进行其他的处理。否则就将此帧丢弃，不再进行其他的处理。</p><p>“发往本站的帧”包括以下三种帧：</p><ul><li>单播(unicast)帧(一对一)，即收到的帧的MAC地址与本站的硬件地址相同。</li><li>广播(broadcast帧(一对全体)，即发送给本局域网上所有站点的帧(全1地址)。</li><li>多播(multicas帧(一对多)，即发送给本局域网上一部分站点的帧</li></ul><p>所有的适配器都至少应当能够识别前两种帧，即能够识别单播和广播地址。显然，只有目的地址才能使用广播地址和多播地址。</p><h4 id="3-2-5-2-MAC帧的格式"><a href="#3-2-5-2-MAC帧的格式" class="headerlink" title="3.2.5.2. MAC帧的格式"></a>3.2.5.2. MAC帧的格式</h4><ol><li>DIX Ethernet V2</li></ol><p><img src="/images/network-basic/MAC.PNG"></p><p>类型：标注上一层是什么协议。</p><p><strong>帧长度</strong><br>在曼彻斯特编码的每一个码元(不管码元是1或0)的正中间一定有次电压的转换(从高到低或从低到高)。当发送方把一个以太网帧发送完毕后，就不再发送其他码元了(既不发送1，也不发送0)。因此，发送方网络适配器的接口上的电压也就不再变化了。这样，接收方就可以很容易地找到以太网帧的结束位置。在这个位置往前数4字节<br>(FCS字段长度是4字节)，就能确定数据字段的结束位置。</p><p><strong>8字节</strong><br>第一个字段是7个字节的前同步码(1和0交替码)，它的作用是使接收端的适配器在接收MAC帧时能够迅速调整其时钟频率，使它和发送端的时钟同步<br>也就是“实现位同步”(位同步就是比特同步的意思)。第二个字段是帧开始定界符，定义为10101011。</p><p><strong>定界</strong><br>以太网在传送帧时，各帧之间还必须有一定的间隙。因此，接收端只要找到帧开始定界符，其后面的连续到达的比特流就都属于同一个MAC帧。可见以太网不需要使用帧结束定界符，也不需要使用字节插入来保证透明传输。</p><ol start="2"><li>IEEE802.3</li></ol><ul><li>IEEE8023规定的MAC帧的第三个字段是“长度/类型”。当这个字段值大于<br>0x0600时(相当于十进制的1536)，就表示“类型”。这样的帧和以太网V2 MAC帧完全<br>样。只有当这个字段值小于0x0600时才表示“长度”，即MAC帧的数据部分长度。实际上，前面我们已经讲过，由于以太网采用了曼彻斯特编码，长度字段并无实际意义。</li><li>当“长度/类型”字段值小于0x0600时，数据字段必须装入上面的逻辑链路控制<br>JC子层的LLC帧。</li></ul><h3 id="3-2-6-扩展的以太网"><a href="#3-2-6-扩展的以太网" class="headerlink" title="3.2.6. 扩展的以太网"></a>3.2.6. 扩展的以太网</h3><p>扩展的以太网在网络层看来仍是一个网络。</p><h4 id="3-2-6-1-物理层扩展"><a href="#3-2-6-1-物理层扩展" class="headerlink" title="3.2.6.1. 物理层扩展"></a>3.2.6.1. 物理层扩展</h4><p>使用多级结构的集线器。</p><p><img src="/images/network-basic/physical-ex.PNG"></p><p><strong>缺点</strong></p><ol><li>通过集线器互连起来后就把三个碰撞域变成一个碰撞域，而这时的最大吞吐量没有变化。</li><li>如果不同的系使用不同的以太网技术，那么就不可能用集线器将们互连起来。</li></ol><h4 id="3-2-6-2-数据链路层扩展"><a href="#3-2-6-2-数据链路层扩展" class="headerlink" title="3.2.6.2. 数据链路层扩展"></a>3.2.6.2. 数据链路层扩展</h4><p>以太网交换机的出现代替了网桥转发帧。</p><h5 id="3-2-6-2-1-交换机特点"><a href="#3-2-6-2-1-交换机特点" class="headerlink" title="3.2.6.2.1. 交换机特点"></a>3.2.6.2.1. 交换机特点</h5><ul><li>实质是一个多接口的网桥，全双工工作，具有并行性，即同时连通多对接口使之同时通信。主机独占传输媒体，无碰撞地传输数据；</li><li>接口有存储器帮助缓存；</li><li>即插即用，内部的交换表通过自学习算法自动建立；</li><li>用户独享带宽，增加了总吞吐量；</li><li>多种速率的接口</li></ul><h5 id="3-2-6-2-2-路由器与交换机的主要区别"><a href="#3-2-6-2-2-路由器与交换机的主要区别" class="headerlink" title="3.2.6.2.2. 路由器与交换机的主要区别"></a>3.2.6.2.2. 路由器与交换机的主要区别</h5><ol><li>工作层次不同 <br>最初的的交换机是工作在数据链路层，而路由器一开始就设计工作在网络层。由于交换机工作在数据链路层，所以它的工作原理比较简单，而路由器工作在网络层，可以得到更多的协议信息，路由器可以做出更加智能的转发决策。 </li><li>数据转发所依据的对象不同 <br>交换机是利用物理地址或者说MAC地址来确定转发数据的目的地址。而路由器则是利用IP地址来确定数据转发的地址。IP地址是在软件中实现的，描述的是设备所在的网络。MAC地址通常是硬件自带的，由网卡生产商来分配的，而且已经固化到了网卡中去，一般来说是不可更改的。而IP地址则通常由网络管理员或系统自动分配。 </li><li>传统的交换机只能分割冲突域，不能分割广播域；而路由器可以分割广播域 <br>由交换机连接的网段仍属于同一个广播域，广播数据包会在交换机连接的所有网段上传播，在某些情况下会导致通信拥挤和安全漏洞。连接到路由器上的网段会被分配成不同的广播域，广播数据不会穿过路由器。虽然第三层以上交换机具有VLAN功能，也可以分割广播域，但是各子广播域之间是不能通信交流的，它们之间的交流仍然需要路由器。 </li><li>路由器提供了防火墙的服务 <br>路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴。</li></ol><h5 id="3-2-6-2-3-以太网的自学习功能"><a href="#3-2-6-2-3-以太网的自学习功能" class="headerlink" title="3.2.6.2.3. 以太网的自学习功能"></a>3.2.6.2.3. 以太网的自学习功能</h5><p><img src="/images/network-basic/self-learn.PNG"></p><p>A先向B发送一帧，从接口1进入到交换机。交换机收到帧后，先查找交换表，没有<br>查到应从哪个接口转发这个帧(在MAC地址这一列中，找不到目的地址为B的项目)。接<br>着，交换机把这个帧的源地址A和接口1写入交换表中，并向除接口1以外的所有接口<br>播这个帧(这个帧就是从接口1进来的，当然不应当把它再从接口1转发出去)。<br>C和D将丢弃这个帧，因为目的地址不对。只B才收下这个目的地址正确的帧。这也<br>称为过滤。<br>从新写入交换表的项目(A，1)可以看出，以后不管从哪一个接口收到帧，只要其目的地<br>址是A，就应当把收到的帧从接口1转发出去。这样做的依据是:既然A发出的帧是从接<br>口1进入到交换机的，那么从交换机的接口1转发出的帧也应当可以到达A。<br>假定接下来B通过接口3向A发送一帧。交换机查找交换表，发现交换表中的MAC地址有A。表明要发送给A的帧(即目的地址为A的帧)应从接口1转发。于是就把这个帧传送到接口1转发给A。显然，现在已经没有必要再广播收到的帧。交换表这时新增加的项目(B，3)，表明今后如有发送给B的帧，就应当从接口3转发出去。<br>经过一段时间后，只要主机C和D也向其他主机发送帧，以太网交换机中的交换表就会把转发到C或D应当经过的接口号(2或4)写入到交换表中。这样，交换表中的项目就齐全了。要转发给任何一台主机的帧，都能够很快地在交换表中找到相应的转发接口考虑到有时可能要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更改交换表中的项目。为此，在交换表中每个项目都设有一定的有效时间。过期的项目就<br>自动被删除。用这样的方法保证交换表中的数据都符合当前网络的实际状况。<br>以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置。</p><p><strong>生成树协议STP</strong></p><p><img src="/images/network-basic/STP.PNG"></p><p>假定一开始主机A通过接口交换机#1向主机B发送一帧。交换机#1收到这个帧后就向所有其他接口进行广播发送。现观察其中一个帧的走向:离开交换机#1的<br>接口3→交换机#2的接口1→接口2→交换机#1的接口4→接口3→交换机#的接口这样就无限制地循环兜圈子下去，白白消耗了网络资源<br>为了解决这种兜圈子问题，IEE的8021D标准制定了一个生成树协议STP( Spanning<br>Tree Protocol)。其要点就是不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从台主机到所有其他主机的路径是无环路的树状结构，从而消除了兜圈子现象。</p><h1 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4. 网络层"></a>4. 网络层</h1><h2 id="4-1-网络层提供的两种服务"><a href="#4-1-网络层提供的两种服务" class="headerlink" title="4.1. 网络层提供的两种服务"></a>4.1. 网络层提供的两种服务</h2><ul><li>面向连接：虚电路</li><li>无连接的</li></ul><p>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服。<br>网络在发送分组时不需要先建立连接。每一个分组(也就是IP数据报)独立发送，与其前后的分组无关(不进行编号)。网络层不提供服务质量的承诺。</p><p>虚电路服务与数据报服务的对比：</p><table><thead><tr><th>对比的方面</th><th>虚电路服务</th><th>数据报服务</th></tr></thead><tbody><tr><td>思路</td><td>靠通信应当由网络来保证</td><td>可靠通信应当由用户主机来保证</td></tr><tr><td>连接的建立</td><td>必须有</td><td>不需要</td></tr><tr><td>终点地址</td><td>仅在连接建立阶段使用，每个分组使用短</td><td>每个分组都有终点的完整地址</td></tr><tr><td>的虚电路号</td><td></td><td></td></tr><tr><td>分组的转发</td><td>属于同一条虚电路的分组均按照同一路由进行转发</td><td>每个分组独立选择路由进行转发</td></tr><tr><td>当结点出故障时</td><td>所有通过出故障的结点的虚电路均不能工作</td><td>出故障的结点可能会丢失分组</td></tr><tr><td>分组的顺序</td><td>总是按发送顺序到达终点</td><td>到达终点的时间不一定按发送顺序</td></tr><tr><td>端到端的差错处理和流量控制</td><td>可以由网络负责，也可以由用户主机负责</td><td>由用户主机负责</td></tr></tbody></table><h2 id="4-2-网际协议IP"><a href="#4-2-网际协议IP" class="headerlink" title="4.2. 网际协议IP"></a>4.2. 网际协议IP</h2><p>与IP协议配套使用的还有三个协议：</p><ul><li>地址解析协议ARP</li><li>网际控制报文协议ICMP</li><li>网际组管理协议IGMP</li><li><del>逆地址解析协议RARP</del>：使只知道自己硬件地址的主机能够通过RARP协议找出其IP地址。现在的DHCP协议已经包含RARP协议的功能。</li></ul><h3 id="4-2-1-分类的IP地址"><a href="#4-2-1-分类的IP地址" class="headerlink" title="4.2.1. 分类的IP地址"></a>4.2.1. 分类的IP地址</h3><p>IP编址经历的三个历史阶段：</p><ol><li>分类的IP地址</li><li>划分子网</li><li>构造超网</li></ol><h4 id="4-2-1-1-IP地址的表示"><a href="#4-2-1-1-IP地址的表示" class="headerlink" title="4.2.1.1. IP地址的表示"></a>4.2.1.1. IP地址的表示</h4><p>一个网络号在整个互联网范围内必须是唯一的，一台主机号在它前面的网络号所指明的网络范围内必须是唯一的，一个IP地址在整个互联网范围内是唯一的。</p><p>两级的IP地址可以记为:<br>IP地址:={&lt;网络号&gt;，&lt;主机号&gt;}</p><p><img src="/images/network-basic/divideClassIP.PNG"></p><h4 id="4-2-1-2-常见的三类IP地址"><a href="#4-2-1-2-常见的三类IP地址" class="headerlink" title="4.2.1.2. 常见的三类IP地址"></a>4.2.1.2. 常见的三类IP地址</h4><p>A类地址的网络号字段占1个字节，只有7位可供使用(该字段的第一位已固定为0)，但可指派的网络号是126个(即27-2)。减2的原因是:第一，IP地址中的全0表示“这个this”。网络号字段为全0的IP地址是个保留地址，意思是“本网络”;第二，网络号为127(即01111111作为本地软件环回测试( loopback test)本主机的进程之间的通信之用。目的地址为环回地址的IP数据报永远不会出现在任何网络上，因为网络号为127的地址根本不是一个网络地址。</p><p>A类地址的主机号占3个字节，因此每一个A类网络中的最大主机数是24-2，即6770214。这里减2的原因是:全0的主机号字段表示该IP地址是“本主机”所连接到的单个网络地址(例如，一主机的IP地址为567.8，则该主机所在的网络地址就是567.0.0.0)而全1表示“所有的(a)”，因此全1的主机号字段表示该网络上的所有主机</p><p>B类地址的网络号字段有2个字节，但前面两位(10)已经固定了，只剩下14位可以进行分配。因为网络号字段后面的14位无论怎样取值也不可能出现使整个2字节的网络号字段成为全0或全1，因此这里不存在网络总数减2的问题。</p><p>C类地址有3个字节的网络号字段，最前面的3位是(110)，还有21位可以进行分配。C类网络地址1920.0.0也是不指派的，可以指派的C类最小网络地址是92010</p><p><strong>IP地址的指派范围</strong></p><table><thead><tr><th>网络类别</th><th>最大可指派的网络数</th><th>第一个可指派的网络号</th><th>最后一个可指派的网络号</th><th>每个网络中的最大主机数</th></tr></thead><tbody><tr><td>A</td><td>2{7}-2</td><td>1</td><td>126</td><td>16777214</td></tr><tr><td>B</td><td>2{14}-2</td><td>128.1</td><td>191.255</td><td>65534</td></tr><tr><td>C</td><td>2{21}-2</td><td>192.0.1</td><td>223.255.255</td><td>254</td></tr></tbody></table><p><strong>一般不使用的特殊IP地址</strong></p><table><thead><tr><th>网络号</th><th>主机号</th><th>源地址使用</th><th>目的地址使用</th><th>代表的意思</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>可以</td><td>不可</td><td>在本网络上的本主机(DHCP)</td></tr><tr><td>0</td><td>host-id</td><td>可以</td><td>不可</td><td>在本网络上的某台主机 host-id</td></tr><tr><td>全1</td><td>全1</td><td>不可</td><td>可以</td><td>只在本网络上进行广播(各路由器均不转发)</td></tr><tr><td>net-id</td><td>全1</td><td>不可</td><td>可以</td><td>对net-id上的所有主机进行广播</td></tr><tr><td>127</td><td>非全0或全1的任何数</td><td>可以</td><td>可以</td><td>用于本地软件环回测试</td></tr></tbody></table><p><strong>特点</strong></p><ul><li>每一个IP地址都由网络号和主机号两部分组成。所以IP地址是一种<br>分等级的地址结构。分两个等级的好处是:<ul><li>IP地址管理机构在分配I地址时只分配网络号(第一级)，而剩下的主机号(第二级)则由得到该网络号的单位自行分配。</li><li>路由器仅根据目的主机所连接的网络号来转发分组(而不考虑目的主机号)，这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间以及查找路由表的时间。</li></ul></li><li>实际上IP地址是标志一台主机(或路由器)和一条链路的接口。当一台主机同时连<br>接到两个网络上时，该主机就必须同时具有两个相应的IP地址，其网络号必须是不同的<br>这种主机称为多归属主机。</li><li>用转发器或网桥连接起来的若干个局域网仍为一个网络，因为这些局域网都具有同样的网络号。具有不同网络号的局域网必须使用路由器进行互连。</li><li>所有分配到网络号的网络(不管是范围很小的局域网，还是可能覆盖很大地理范围的广域网)都是平等的。所谓平等，是指互联网同等对待每一个IP地址。</li></ul><p><img src="/images/network-basic/IPofInternet.PNG"></p><h3 id="4-2-2-私有地址"><a href="#4-2-2-私有地址" class="headerlink" title="4.2.2. 私有地址"></a>4.2.2. 私有地址</h3><p>由于IP地址的紧缺，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机数。考虑到互联网并不很安全，一个机构内也并不需要把所有的主机接入到外部的互联网.实际上，在许多情况下，很多主机主要还是和本机构内的其他主机进行通信。假定在一个机构内部的计算机通信也是采用 TCP/IP协议，那么从原则上讲，对于这些仅在机构内部使用的计算机就可以由本机构自行分配其IP地址。这就是说，让这些计算机使用仅在本机构有效的酽地址(这种地址称为私有地址)，而不需要向互联网的管理机构申请全球唯一的IP地址(这种地址称为公有地址)。这样就可以大大节约宝贵的全球IP地址资源。</p><p>为了解决这一问题，RFC1918指明了一些专用地址( private address)这些地址只能用<br>于一个机构的内部通信，而不能用于和互联网上的主机通信。在互联网中的所有路由器，对目的地址是专用地址的数据报<br>律不进行转发，即</p><ul><li>10.0.0.0到10.255.255.255(或记为10.0.0.0/8，它又称为24位块)</li><li>172.16.0.0到172.16.255.255(或记为172.16.0.0/12，它又称为20位块)</li><li>192.168.0.0到192.168.255.255(或记为192.168.0.0/16，它又称为16位块)</li></ul><p>采用这样的专用IP地址的互连网络就叫做专用网。专用IP地址也叫做可重用地址。</p><h3 id="4-2-3-网络地址转换NAT"><a href="#4-2-3-网络地址转换NAT" class="headerlink" title="4.2.3. 网络地址转换NAT"></a>4.2.3. 网络地址转换NAT</h3><p>下面讨论另一种情况，就是在专用网内部的一些主机本来已经分配到了本地IP地址，即仅在本专用网内使用的专用地址)，但现在又想和互联网上的主机通信(并不需要加密)，那么应当采取什么措施呢?</p><p>网络地址转换NAT需要在专用网连接到互联网的路由器上安装NAT软件。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。这样，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和互联网连接。</p><h3 id="4-2-4-DHCP协议"><a href="#4-2-4-DHCP协议" class="headerlink" title="4.2.4. DHCP协议"></a>4.2.4. DHCP协议</h3><p>DHCP动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p><h3 id="4-2-5-IP地址与硬件地址"><a href="#4-2-5-IP地址与硬件地址" class="headerlink" title="4.2.5. IP地址与硬件地址"></a>4.2.5. IP地址与硬件地址</h3><p>从层次的角度看，物理地址是数据链路层和物理层使用的地址，而IP地址是网络层和以上各层使用的地址，是一种逻辑地址(用软件实现的)。</p><p>IP地址放在IP数据报的首部，而硬件地址则放在MAC帧的首部。在网络层和网络层以上使用的是IP地址，而数据链路层及以下使用的是硬件地址。当IP数据报放入数据链路层的MAC帧中以后，整个的IP数据报就成为MAC帧的数据，因而在数据链路层看不见数据报的IP地址。</p><p><img src="/images/network-basic/ip-dl.PNG"></p><p><strong>要点</strong></p><ol><li>在IP层抽象的互联网上只能看到IP数据报。</li><li>虽然在P数据报首部有源站IP地址，但路由器只根据目的站的I地址的网络号进行路由选择</li><li>在局域网的链路层，只能看见MAC帧。<br>IP数据报被封装在MAC帧中。MAC帧在不同网络上传送时，其MAC帧首部中的源地址和目的地址要发生变化。开始在H1到R1间传送时，MAC帧首部中写的是从硬件地址HA1发送到硬件地址HA3，路由器R1收到此MAC帧后，在数据链路层，要丢弃原来的MAC帧的首部和尾部。在转发时在数据链路层，要重新添加上MAC帧的首部和尾部。这时首部中的源地址和目的地址分别便成为HA4和HA5。路由器R2收到此帧后，再次更换MAC帧的首部和尾部，首部中的源地址和目的地址分别变成为HA6和HA2。MAC帧的首部的这种变化，在上面的IP层上是看不见的。</li><li>尽管互连在一起的网络的硬件地址体系各不相同，但IP层抽象的互联网却屏蔽了<br>下层这些很复杂的细节。只要我们在网络层上讨论问题，就能够使用统一的、抽象的IP地址研究主机和主机或路由器之间的通信。</li></ol><p>既然在网络链路上传送的帧最终是按照硬件地址找到目的主机的，那么为什么我们还要使用抽象的IP地址，而不直接使用硬件地址进行通信?</p><p>由于全世界存在着各式各样的网络，它们使用不同的硬件地址。要使这些异构网络能<br>够互相通信就必须进行非常复杂的硬件地址转换工作，因此由用户或用户主机来完成这项作几乎是不可能的事。但IP编址把这个复杂问题解决了。连接到互联网的主机只需各自拥有一个唯一的IP地址，它们之间的通信就像连接在同一个网络上那样简单方便，因为上述的调用ARP的复杂过程都是由计算机软件自动进行的，对用户来说是看不见这种调用过程的。</p><h3 id="4-2-6-地址解析协议ARP"><a href="#4-2-6-地址解析协议ARP" class="headerlink" title="4.2.6. 地址解析协议ARP"></a>4.2.6. 地址解析协议ARP</h3><p>网络层使用的是IP地址，但在实际网络的链路上传送数据帧时还是必须使用该网络的硬件地址。但IP地址和下面的网络的硬件地址之间由于格式不同而不存在简单的映射关系。此外，IP或MAC地址可能会改变。地址解析协议ARP解决这个问题的方法是在主机ARP高速缓存中存放一个从IP地址到硬件地址的映射表，并且这个映射表还经常动态更新(新增或超时删除)。<br>每一台主机都设有一个ARP高速缓存( ARP cache)，里面有本局域网上的各主机和路由器的IP地址到硬件地址的映射表，这些都是该主机目前知道的一些地址。</p><h5 id="4-2-6-1-同一局域网"><a href="#4-2-6-1-同一局域网" class="headerlink" title="4.2.6.1. 同一局域网"></a>4.2.6.1. 同一局域网</h5><p>当主机A要向本局域网上的某台主机B发送IP数据报时，就先在其ARP高速缓存中<br>查看有无主机B的IP地址。</p><p>若有，就在ARP高速缓存中查出其对应的硬件地址，再把这硬件地址写入MAC帧，然后通过局域网把该MAC帧发往此硬件地址；<br>若没有，主机A就自动运行ARP，然后按以下步骤找出主机B的硬件地址。</p><ol><li>ARP进程在本局域网上广播发送一个ARP请求分组；</li><li>在本局域网上的所有主机上运行的ARP进程都收到此ARP请求分组</li><li>主机B的IP地址与ARP请求分组中要查询的P地址一致，就收下这个ARP请求分组，并向主机A发送ARP响应分组，同时在这个ARP响应分组中写入自己的硬件地址。由于其余的所有主机的IP地址都与ARP请求分组中要查询的IP地址不一致，因此都不理睬这个ARP请求分组。<br>ARP请求分组是广播发送的，但ARP响应分组是普通的单播。</li><li>主机A收到主机B的ARP响应分组后，就在其ARP高速缓存中写入主机B的IP地址到硬件地址的映射。同时主机B记录主机A的映射。</li></ol><p>ARP对保存在高速缓存中的每一个映射地址项目都设置生存时间凡超过生存时间的项目就从高速缓存中删除掉。</p><h5 id="4-2-6-2-不在同一局域网"><a href="#4-2-6-2-不在同一局域网" class="headerlink" title="4.2.6.2. 不在同一局域网"></a>4.2.6.2. 不在同一局域网</h5><p>四种情况：</p><p><img src="/images/network-basic/ARPfour.PNG"></p><ol><li>发送方是主机(如H1)，要把IP数据报发送到同一个网络上的另一台主机(如H2)。这时H发送ARP请求分组(在网1上广播)，找到目的主机H2的硬件地址。</li><li>发送方是主机(如H1)，要把IP数据报发送到另一个网络上的一台主机(如H3或H4)。这时H1发送ARP请求分组(在网1上广播)，找到网1上的一个路由器R1的硬件地址。剩下的工作由路由器R1来完成。R1要做的事情是下面的(3)或(4)。</li><li>发送方是路由器(如R1)，要把P数据报转发到与R1连接在同一个网络(网2)上的主机(如H3)。这时R1发送ARP请求分组(在网2上广播)，找到目的主机H3的硬件地址</li><li>发送方是路由器(如R1)，要把IP数据报转发到网3上的一台主机(如H4)。H4与不是连接在同一个网络上。这时R1发送ARP请求分组(在网2上广播)，找到连接在网2上的一个路由器R2的硬件地址。剩下的工作由这个路由器R2来完成</li></ol><h3 id="4-2-7-逆地址解析协议RARP"><a href="#4-2-7-逆地址解析协议RARP" class="headerlink" title="4.2.7. 逆地址解析协议RARP"></a>4.2.7. 逆地址解析协议RARP</h3><p>功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址，比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。</p><p><strong>工作流程</strong></p><ol><li>给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；</li><li>本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；</li><li>如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；</li><li>如果不存在，RARP服务器对此不做任何的响应；</li><li>源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。</li></ol><h3 id="4-2-8-IP数据报的格式"><a href="#4-2-8-IP数据报的格式" class="headerlink" title="4.2.8. IP数据报的格式"></a>4.2.8. IP数据报的格式</h3><p><img src="/images/network-basic/ip.PNG"></p><ul><li>版本：占4位，指P协议的版本。通信双方使用的P协议的版本必须一致。</li><li>首部长度：占4位，可表示的最大十进制数值是15。</li></ul><p>首部长度字段所表示数的单位是32位字(4字节)，因此首部长度字段的最小值是5，最大值15。当IP分组的首部长度不是4字节的整数倍时，必须利用最后的填充字段加以填充。因此IP数据报的数据部分永远在4字节的整数倍时开始，这样在实现IP协议时较为方便。</p><ul><li>区分服务：占8位，用来获得更好的服务。旧标准中叫做服务类型，但实际上一直没有被使用过。</li><li>总长度：总长度指首部和数据之和的长度，单位为字节。</li></ul><p>最常用的以太网规定其MTU值是1500字节。若所传送的数据报长度超过数据链路层的MTU值，就必须把过长的数据报进行分片处理。</p><p>虽然使用尽可能长的PP数据报会使传输效率得到提高，但每一个IP数据报越短，路由<br>转发的速度就越快。为此，IP协议规定，在互联网中所有的主机和路由器，必须能够接<br>受长度不超过576字节的数据报。这是假定上层交下来的数据长度有512字节，加上最长的IP首部60字节，再加上4字节的富余量，就得到576字节。当主机需要发送长度超过576字节的数据报时，应当先了解一下，目的主机能否接受所要发送的数据报长度。否则，就要进行分片。</p><p>在进行分片时(见后面的“片偏移”字段)，数据报首部中的“总长度”字段是指分片<br>后的每一个分片的首部长度与该分片的数据长度的总和。</p><ul><li>标识：占16位。IP软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。</li></ul><p>但这个“标识”并不是序号，因为IP是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的MTU而必须分片时，这个标识字段的值就被复制到所有的数据报片的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。</p><ul><li>标志：占3位，但目前只有两位有意义<ul><li>标志字段中的最低位记为MF(More Fragment)。MF=1即表示后面“还有分片”的数据报。MF=0表示这已是若干数据报片中的最后一个。</li><li>标志字段中间的一位记为DF(Don’ t Fragment)，意思是“不能分片”。只有当DF<br>0时才允许分片。</li></ul></li><li>片偏移：占13位。片偏移指出:较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对于用户数据字段的起点，该片从何处开始。片偏移以8个字节为偏移单位。这就是说，每个分片的长度一定是8字节(64位)的整数倍。</li></ul><p><img src="/images/network-basic/ip-shard.PNG"></p><ul><li>生存时间：占8位，生存时间字段常用的英文缩写是TTL( Time To live)，表明<br>这是数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在互联网中兜圈子。</li></ul><p>然而随着技术的进步，路由器处理数据报所需的时间不断在缩短，一般都远远小于1秒，后来就把TTL字段的功能改为“跳数限制”(但名称不变)。路由器在每次转发数据报之前就把TTL值减1。若TTL值减小到零，就丢弃这个数据报，不再转发。因此，现在TTL的单位不再是秒，而是跳数。TTL的意义是指明数据报在互联网中至多可经过多少路由器。显然，数据报能在互联网中经过的路由器的最大数值是255。若把TTL的初始值设置为1，就表示这个数据报只能在本局域网中传送。因为这个数据报一传送到局域网上的某个路由器，在被转发之前TIL值就减小到零，因而就会被这个路由器丢弃。</p><ul><li>协议：占8位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的<br>主机的IP层知道应将数据部分上交给哪个协议进行处理。</li><li>首部检验和占16位。这个字段只检验数据报的首部，但不包括数据部分。非CRC。</li><li>源地址：占32位。</li><li>目的地址：占32位。</li></ul><h3 id="4-2-9-IP层转发分组的流程"><a href="#4-2-9-IP层转发分组的流程" class="headerlink" title="4.2.9. IP层转发分组的流程"></a>4.2.9. IP层转发分组的流程</h3><p>在路由表中，对每一条路由最主要的是以下两个信息：</p><p><strong>(目的网络地址，下一跳地址)</strong></p><ol><li>从数据报的首部提取目的主机的IP地址D，得出目的网络地址为N；</li><li>若N就是与此路由器直接相连的某个网络地址，则进行直接交付，不需要再经过其<br>他的路由器，直接把数据报交付目的主机(这里包括把目的主机地址D转换为具体的硬件地址，把数据报封装为MAC帧，再发送此帧);否则就是间接交付，执行3；</li><li>若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的<br>下一跳路由器;否则，执行4；</li><li>若路由表中有到达网络N的路由，则把数据报传送给路由表中所指明的下一跳路由<br>器;否则，执行5；</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器;否<br>则，执行6；</li><li>报告转发分组出错。</li></ol><p>当路由器收到一个待转发的数据报，在从路由表得出下一跳路由器的IP地址后，不是<br>把这个地址填入IP数据报，而是送交数据链路层的网络接口软件。网络接口软件负责把下跳路由器的IP地址转换成硬件地址(必须使用ARP)，并将此硬件地址放在链路层的<br>MAC帧的首部，然后根据这个硬件地址找到下一跳路由器。由此可见，当发送一连串的数据报时，上述的这种查找路由表、用ARP得到硬件地址、把硬件地址写入MAC帧的首部等过程，将不断地重复进行，造成了一定的开销。</p><h2 id="4-3-划分子网和构造超网"><a href="#4-3-划分子网和构造超网" class="headerlink" title="4.3. 划分子网和构造超网"></a>4.3. 划分子网和构造超网</h2><h3 id="4-3-1-划分子网"><a href="#4-3-1-划分子网" class="headerlink" title="4.3.1. 划分子网"></a>4.3.1. 划分子网</h3><h4 id="4-3-1-1-三级IP地址"><a href="#4-3-1-1-三级IP地址" class="headerlink" title="4.3.1.1. 三级IP地址"></a>4.3.1.1. 三级IP地址</h4><p><strong>两级IP地址的缺点</strong></p><ul><li>IP地址空间的利用率有时很低。</li><li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。</li><li>两级IP地址不够灵活。</li></ul><p><strong>基本思路</strong></p><ul><li>一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个子网( subne划分子网纯属一个单位内部的事情。本单位以外的网络看不见这个网络是由多少个子网组成，因为这个单位对外仍然表现为一个网络。</li><li>划分子网的方法是从网络的主机号借用若干位作为子网号 ibnet-id，当然主机号<br>也就相应减少了同样的位数。于是两级IP地址在本单位内部就变为三级IP地址:网络号子网号和主机号。也可以用以下记法来表示</li></ul><p><strong>IP地址:={&lt;网络号&gt;，&lt;子网号&gt;，&lt;主机号&gt;}</strong></p><ul><li>凡是从其他网络发送给本单位某台主机的IP数据报，路由器在收到IP数据报后，再按目的网络号和子网号找到目的子网，把IP数据报交付目的主机。</li></ul><h4 id="4-3-1-2-子网掩码"><a href="#4-3-1-2-子网掩码" class="headerlink" title="4.3.1.2. 子网掩码"></a>4.3.1.2. 子网掩码</h4><p>使用子网掩码的好处:不管网络有没有划分子网，只要把子网掩码和IP地址进行<br>逐位的“与”运算(AND)，就立即得出网络地址来。这样在路由器处理到来的分组时就可采用同样的算法。</p><p><img src="/images/network-basic/subnetMask.PNG"></p><p>所有的网络都必须使用子网掩码，同时在路由器的路由表中也必须有子网掩码这一栏。如果一个网络不划分子网，那么该网络的子网掩码就使用默认子网掩码。默认子网掩码中1的位置和I地址中的网络号字段net-id正好相对应。因此，若用默认子网掩码和某个不划分子网的IP地址逐位相“与”(AND)，就应当能够得出该IP地址的网络地址来。这样做可以不用査找该地址的类别位就能知道这是哪一类的IP地址。显然，</p><p>A类地址的默认子网掩码是255.0.0.0，或0xFF000000<br>B类地址的默认子网掩码是255.255.0.0，或0 XFFFF0000。<br>C类地址的默认子网掩码是255.255.255.0，或0 XFFFFFF00。</p><p>B类地址的子网划分选择(使用固定长度子网)：</p><table><thead><tr><th>子网号的位数</th><th>子网掩码</th><th>子网数</th><th>每个子网的主机数</th></tr></thead><tbody><tr><td>2</td><td>255.255.192.0</td><td>2{2次方}-2</td><td>2{14次方}-2</td></tr><tr><td>2</td><td>255.255.224.0</td><td>2{3次方}-2</td><td>2{13次方}-2</td></tr><tr><td>2</td><td>255.255.240.0</td><td>2{4次方}-2</td><td>2{12次方}-2</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><p>子网号的位数中没有0，1，15和16这四种情况，因为这没有意义。</p><p>划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数。</p><h4 id="4-3-1-3-使用子网的分组转发"><a href="#4-3-1-3-使用子网的分组转发" class="headerlink" title="4.3.1.3. 使用子网的分组转发"></a>4.3.1.3. 使用子网的分组转发</h4><p>我们应当注意到，使用子网划分后，路由表必须包含以下三项内容:</p><p><strong>目的网络地址，子网掩码，下一跳地址</strong></p><p>在划分子网的情况下，路由器转发分组的算法如下：</p><ol><li>从收到的数据报的首部提取目的IP地址D；</li><li>先判断是否为直接交付。对路由器直接相连的网络逐个进行检查:用各网络的子网掩码和D逐位相“与”(AND操作)，看结果是否和相应的网络地址匹配。若匹配，则把分组进行直接交付(当然还需要把D转换成物理地址，把数据报封装成帧发送出去)，转发任务结束。否则就是间接交付，执行3；</li><li>若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的<br>下一跳路由器;否则，执行4；</li><li>对路由表中的每一行(目的网络地址，子网掩码，下一跳地址)，用其中的子网掩<br>码和D逐位相“与”(AND操作)，其结果为N。若N与该行的目的网络地址匹配，则把数<br>据报传送给该行指明的下一跳路由器;否则，执行5；</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器;否<br>则，执行6；</li><li>报告转发分组出错。</li></ol><h3 id="4-3-2-构造超网"><a href="#4-3-2-构造超网" class="headerlink" title="4.3.2. 构造超网"></a>4.3.2. 构造超网</h3><h4 id="4-3-2-1-网络前缀"><a href="#4-3-2-1-网络前缀" class="headerlink" title="4.3.2.1. 网络前缀"></a>4.3.2.1. 网络前缀</h4><p>因为IPv4的地址即将耗尽，出现无分类域间路由选择CIDR。</p><p><strong>特点</strong></p><ul><li>CIDR消除了传统的A类、B类和C类地址以及划分子网的概念，32位的IP地址划分为用来指明网络的“网络前缀”和主机号。其记法是：</li></ul><p><strong>IP地址∷={网络前缀&gt;，&lt;主机号&gt;}</strong></p><p>CDR还使用“斜线记法”，或称为CIDR记法，即在IP地址后面加上斜线然后写上网络前缀所占的位数。</p><p>CIDR使用32位的地址掩码。地址掩码由串1和一串0组成，而1的个数就是网络前缀的长度。斜线记法中，斜线后面的数字就是地址掩码中1的个数。</p><ul><li>CIDR把网络前缀都相同的连续的P地址组成一个“CIDR地址块”。</li></ul><p>由于一个CIDR地址块中有很多地址，所以在路由表中就利用CIDR地址块来查找目的<br>网络。这种地址的聚合常称为路由聚合( route aggregation)，它使得路由表中的一个项目可以表示原来传统分类地址的很多个(例如上千个)路由。路由聚合也称为构成超网。</p><p>常用的CIDR地址块：</p><table><thead><tr><th>CIDR前缀长度</th><th>点分十进制</th><th>包含的地址数</th><th>相当于包含分类的网络数</th></tr></thead><tbody><tr><td>/13</td><td>255.248.0.0</td><td>512K</td><td>8个B类或2048个C类</td></tr><tr><td>/14</td><td>255.252.0.0</td><td>256K</td><td>4个B类或1024个C类</td></tr><tr><td>/15</td><td>255.254.0.0</td><td>128K</td><td>2个B类或512个C类</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><p>使用CIDR的一个好处就是可以更加有效地分配IPv4的地址空间，可根据客户的需要<br>分配适当大小的CIDR地址块。然而在分类地址的环境中，向一个部门分配IP地址，就只能以/8，/16或/24为单位来分配，这就很不灵活。</p><p>构成超网是将网络前缀缩短。网络前缓越短，其地址块所包含的地址数就越多。而在三级结构的IP地址中，划分子网是使网络前缀变长。</p><h2 id="4-4-ICMP网际控制报文协议"><a href="#4-4-ICMP网际控制报文协议" class="headerlink" title="4.4. ICMP网际控制报文协议"></a>4.4. ICMP网际控制报文协议</h2><p>为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了网际控制报文协<br>议ICMP。ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP报文是装在IP数据报中，作为其中的数据部分。</p><p>两种常用的ICMP报文类型：</p><table><thead><tr><th>ICMP报文种类</th><th>类型的值</th><th>ICMP报文的类型</th></tr></thead><tbody><tr><td>差错报告报文</td><td>3</td><td>终点不可达：不能交付数据报</td></tr><tr><td>差错报告报文</td><td>11</td><td>时间超过：生存时间为零的数据报</td></tr><tr><td>差错报告报文</td><td>12</td><td>参数问题：数据报首部的参数不正确</td></tr><tr><td>差错报告报文</td><td>5</td><td>改变路由：最佳路由</td></tr><tr><td>询问报文</td><td>8或0</td><td>回送请求或回答：测试目的站是否可达以及了解其有关状态</td></tr><tr><td>询问报文</td><td>13或14</td><td>时间戳请求或回答：用于时钟同步和时间测量</td></tr></tbody></table><h2 id="4-5-路由选择协议"><a href="#4-5-路由选择协议" class="headerlink" title="4.5. 路由选择协议"></a>4.5. 路由选择协议</h2><p>倘若从路由算法能否随网络的通信量或拓扑自适应地进行调整变化来划分：</p><ul><li>静态路由选择策略：也叫做非自适应路由选择，特点是简单和开销较小，但不能及时适应网络状态的变化。对于很简单的小网络，完全可以采用静态路由选择，用人工配置每一条路由。</li><li>动态路由选择策略。也叫做自适应路由选择，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。适用于较复杂的大网络。</li></ul><p><strong>分层次的路由选择协议</strong></p><p>把整个互联网划分为许多较小的自治系统(autonomous system)，记为AS。一个AS对其他AS表现出的是一个单一的和一致的路由选择策略。</p><p>在目前的互联网中，一个大的ISP就是一个自治系统。这样，互联网就把路由选择协议<br>划分为两大类：</p><ul><li>内部网关协议IGP：即在一个自治系统内部使用的路由选择协议，而这与在互联网中的其他自治系统选用什么路由选择协议无关。如RIP和OSPF协议。</li><li>外部网关协议EGP：若源主机和目的主机处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议EGP。目前使用最多的外部网关协议是BGP的版本4(BGP4)。</li></ul><p>自治系统之间的路由选择也叫做域间路由选择，而在自治系统内部的路由选择叫做域内路由选择。</p><h3 id="4-5-1-内部网关协议RIP"><a href="#4-5-1-内部网关协议RIP" class="headerlink" title="4.5.1. 内部网关协议RIP"></a>4.5.1. 内部网关协议RIP</h3><h4 id="4-5-1-1-工作原理"><a href="#4-5-1-1-工作原理" class="headerlink" title="4.5.1.1. 工作原理"></a>4.5.1.1. 工作原理</h4><p>一种分布式的基于距离向量的路由选择协议。</p><p>RIP协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记<br>录。RIP协议将“距离”定义为从一路由器到直接连接的网络的距离定义为1。从一路由器到非直接连接的网络的距离定义为所经过的路由器数加1。</p><p><strong>特点</strong></p><ul><li>仅和相邻路由器交换信息。不相邻的路由器不交换信息</li><li>路由器交换的信息是当前本路由器所知道的全部信息，即自己现在的路由表。</li><li>按固定的时间间隔交换路由信息。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。</li></ul><h4 id="4-5-1-2-距离向量算法"><a href="#4-5-1-2-距离向量算法" class="headerlink" title="4.5.1.2. 距离向量算法"></a>4.5.1.2. 距离向量算法</h4><p>对每一个相邻路由器发送过来的RIP报文，进行以下步骤：</p><ul><li>对地址为ⅹ的相邻路由器发来的RIP报文，先修改此报文中的所有项目:把“下一跳”字段中的地址都改为X，并把所有的“距离”字段的值加1。每一个项目都有三个关键数据，即:到目的网络N，距离是d，下一跳路由器是X</li><li>对修改后的RP报文中的每一个项目，进行以下步骤:<ul><li>若原来的路由表中没有目的网络N，则把该项目添加到路由表中</li><li>否则(即在路由表中有目的网络N，这时就再査看下一跳路由器地址<ul><li>若下一跳路由器地址是Ⅹ，则把收到的项目替换原路由表中的项目</li><li>否则(即这个项目是:到目的网络N，但下一跳路由器不是X<ul><li>若收到的项目中的距离d小于路由表中的距离，则进行更新</li><li>否则什么也不做。</li></ul></li></ul></li></ul></li><li>若3分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达的路<br>由器，即把距离置为16(距离为16表示不可达)。</li><li>返回。</li></ul><p>RIP协议使得从每一个路由器到每一个目的网络的路由都是最短的。虽然所有的路由器最终都拥有了整个自治系统的全局路由信息，但由于每一个路由器的位置不同，它们的路由表当然也应当是不同的。</p><p><strong>优点</strong></p><ul><li>实现简单、开销较小。</li><li>好消息传播得快，但是坏消息传播得慢。</li></ul><p><strong>缺点</strong>n</p><ul><li>RIP限制了网络的规模，它能使用的最大距离为15(16表示不可达)。</li><li>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。最后，“坏消息传播得慢”，使更新过程的收敛时间过长。</li></ul><h3 id="4-5-2-内部网关协议OSPF"><a href="#4-5-2-内部网关协议OSPF" class="headerlink" title="4.5.2. 内部网关协议OSPF"></a>4.5.2. 内部网关协议OSPF</h3><p>开放最短路径优先OSPF，使用最短路径算法SPF，使用分布式的链路状态协议。它是为克服RIP的缺点而开发。</p><p><strong>特点</strong></p><ul><li>向本自治系统中所有路由器发送信息。这里使用的方法是洪泛法，路由器通过所有输出端口向所有相邻的路由器发送信息。而每一个相邻路由器又再将此信息发往其所有的相邻路由器(但不再发送给刚刚发来信息的那个路由器)。这样，最终整个区域中所有的路由器都得到了这个信息的一个副本。RIP协议是仅仅向自己相邻的几个路由器发送信息。</li><li>发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。所谓“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的度量”，称这个度量为“代价”。RIP协议发送的信息是到所有网络的距离和下一跳路由器。</li><li>只有当链路状态发生变化时，路由器才向所有路由器用洪泛法发送此信息。而不像<br>RIP那样，不管网络拓扑有无发生变化，路由器之间都要定期交换路由表的信息。</li></ul><p><strong>优点</strong></p><p>所有的路由器最终都能建立一个链路状态数据库，实际上就是全网的拓扑结构图。这个拓扑结构图在全网范围内是一致的。RIP协议的每一个路由器虽然知道到所有的网络的距离以及下一跳路由器，但却不知道全网的拓扑结构(只有到了下一跳路由器，才能知道再下一跳应当怎样走。</p><p>OSPF的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表，更新过程收敛得快是其重要优点。</p><p>OSPF不用UDP而是直接用IP数据报传送。</p><h3 id="4-5-3-外部网关协议BGP"><a href="#4-5-3-外部网关协议BGP" class="headerlink" title="4.5.3. 外部网关协议BGP"></a>4.5.3. 外部网关协议BGP</h3><p>内部网关协议(如RIP或OSPF)主要是设法使数据报在一个AS中尽可能有效地从源站传送到目的站。在一个AS内部也不需要考虑其他方面的策略。然而BGP使用的环境却不同。这主要是因为互联网的规模太大，使得自治系统AS之间路由选择非常困难，并且自治系统AS之间的路由选择必须考虑有关策略（自愿连接、安全等）。</p><p>所以边界网关协议BGP只能是力求寻找一条能够到达目的网络且比较好的<br>路由(不能兜圈子)，而并非要寻找一条最佳路由。</p><p>BGP采用了路径向量路由选择协议。</p><ol><li>每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“BGP发言人”。一般两个BGP发言人都是通过一个共享网络连接在一起的，而BGP发言人往往就是BGP边界路由器，也可以不是。</li><li>BGP发言人与其他AS的BGP发言人要交换路由信息，就要先建立TCP连接，彼此成为对方的邻站( neighbor〕或对等站(peer)。</li><li>边界网关协议BGP所交换的网终可达性的信息就是要到达某个网络所要经过的一系列自治系统。发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的较好路由。</li></ol><h1 id="5-运输层"><a href="#5-运输层" class="headerlink" title="5. 运输层"></a>5. 运输层</h1><h2 id="5-1-协议概述"><a href="#5-1-协议概述" class="headerlink" title="5.1. 协议概述"></a>5.1. 协议概述</h2><h3 id="5-1-1-进程之间的通信"><a href="#5-1-1-进程之间的通信" class="headerlink" title="5.1.1. 进程之间的通信"></a>5.1.1. 进程之间的通信</h3><p>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。当网络的边缘部分中的两台主机使用网络的核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。</p><p>运输层有一个很重要的功能—复用和分用。这里的“复用是指在发送方不同的应用进程都可以使用同一个运输层协议传送数据，而“分用”是指接收方的运输层在剥去报文的首部后能够把这些数据正确交付目的应用进程。</p><p>网络层为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。向高层用户屏蔽了下面网络核心的细节。</p><h3 id="5-1-2-两个主要协议"><a href="#5-1-2-两个主要协议" class="headerlink" title="5.1.2. 两个主要协议"></a>5.1.2. 两个主要协议</h3><ul><li>用户数据报协议UDP：UDP用户数据报，无连接，不可靠，尽最大努力交付的。</li><li>传输控制协议TCP：TCP报文段，面向连接，可靠的</li></ul><h3 id="5-1-3-端口"><a href="#5-1-3-端口" class="headerlink" title="5.1.3. 端口"></a>5.1.3. 端口</h3><p>为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法(而这种方法必须与特定操作系统无关)对TCP体系的应用进程进行标志。</p><p>解决这个问题的方法就是在运输层使用协议端口号，常简称为端口(port)。这就是说，虽然通信的终点是应用进程，但只要把所传送的报文交到目的主机的某个合适的目的端口，剩下的工作(即最后交付目的进程)就由TCP或UDP来完成。<br>这种在协议栈层间的抽象的协议端口是软件端口。</p><p>用一个16位端口号来标志一个端口。但端口号只具有本地意义，它只是为了标志本计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网不同计算机中，相同的端口号是没有关联的。16位的端口号可允许有65535个不同的端口。分为：</p><ul><li>服务器端使用的端口号<ul><li>熟知端口号 0~1023</li><li>等级端口号 1024~49151</li></ul></li><li>客户端使用的端口号 49152~65535</li></ul><p><strong>常见的熟知端口号</strong></p><table><thead><tr><th>FTP</th><th>TELNET</th><th>SMTP</th><th>DNS</th><th>TFTP</th><th>HTTP</th><th>SNMP</th><th>HTTPS</th></tr></thead><tbody><tr><td>21</td><td>23</td><td>25</td><td>53</td><td>69</td><td>80</td><td>161</td><td>443</td></tr></tbody></table><table><thead><tr><th>POP3</th><th>SSH</th><th>MySQL</th><th>Oracle</th><th>SQLServer</th><th>Sockets</th><th>Tomcat</th></tr></thead><tbody><tr><td>110</td><td>22</td><td>3306</td><td>1521</td><td>1433</td><td>1080</td><td>8080</td></tr></tbody></table><h2 id="5-2-用户数据报协议UDP"><a href="#5-2-用户数据报协议UDP" class="headerlink" title="5.2. 用户数据报协议UDP"></a>5.2. 用户数据报协议UDP</h2><ul><li>无连接的：减小开销和时延</li><li>尽最大努力：交付不可靠的</li><li>面向报文：保留上层报文的边界，一次交付一个完整的报文</li><li>没有拥塞控制：实时应用允许丢失，但需要低时延</li><li>支持一对一、一对多、多对一和多对多的交互通信</li><li>首部开销小：8字节</li></ul><p><img src="/images/network-basic/UDP.PNG"></p><ul><li>源端口：源端口号。在需要对方回信时选用。不需要时可用全0。</li><li>目的端口：目的端口号。这在终点交付报文时必须使用</li><li>长度：UDP用户数据报的长度，其最小值是8(仅有首部)。</li><li>检验和：检测UDP用户数据报在传输中是否有错。有错就丢弃，并由ICMP发送“终点不可达”。IP数据报只检验首部，UDP把首部和数据一起检验。</li></ul><h2 id="5-3-传输控制协议TCP概述"><a href="#5-3-传输控制协议TCP概述" class="headerlink" title="5.3. 传输控制协议TCP概述"></a>5.3. 传输控制协议TCP概述</h2><h3 id="5-3-1-TCP的主要特点"><a href="#5-3-1-TCP的主要特点" class="headerlink" title="5.3.1. TCP的主要特点"></a>5.3.1. TCP的主要特点</h3><ul><li>面向连接：建立连接、释放连接</li><li>每条TCP连接只能有两个端点：一对一</li><li>可靠交付</li><li>全双工通信：发送、接收缓存</li><li>面向字节流：然应用程序和TCP的交互是一次一个数据块(大小不等)，但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。TCP并不知道所传送的字节流的含义。</li></ul><h3 id="5-3-2-TCP的连接"><a href="#5-3-2-TCP的连接" class="headerlink" title="5.3.2. TCP的连接"></a>5.3.2. TCP的连接</h3><p>TCP的连接有两个断电，断电指的是套接字，即端口号拼接到IP地址：</p><p><strong>套接字 socket=(IP地址:端口号)</strong></p><p>每一条TCP连接唯一地被通信两端的两个端点(即两个套接字)所确定。即</p><p><strong>TCP连接:(socket1， socket2)=((IP1:port1)，(IP2:port2)</strong></p><h2 id="5-4-可靠传输的工作原理"><a href="#5-4-可靠传输的工作原理" class="headerlink" title="5.4. 可靠传输的工作原理"></a>5.4. 可靠传输的工作原理</h2><h3 id="5-4-1-停止等待协议"><a href="#5-4-1-停止等待协议" class="headerlink" title="5.4.1. 停止等待协议"></a>5.4.1. 停止等待协议</h3><p>“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。</p><h4 id="5-4-1-1-无差错情况"><a href="#5-4-1-1-无差错情况" class="headerlink" title="5.4.1.1. 无差错情况"></a>5.4.1.1. 无差错情况</h4><p>A发送分组M1，发完就暂停发送，等待B的确认。B收到了M1就向A发送确认。A在收到了对M1的确认后，就再发送下一个分组M2。同样，在收到B对M2的确认后，再发送M3。</p><p><img src="/images/network-basic/TCPstopwait.PNG"></p><h4 id="5-4-1-2-出现差错"><a href="#5-4-1-2-出现差错" class="headerlink" title="5.4.1.2. 出现差错"></a>5.4.1.2. 出现差错</h4><p>B接收M1时检测出了差错，就丢弃M1，其他什么也不做(不通知A收到有差错的分组)。A只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组，。这就叫做超时重传。要实现超时重传，就要在每发送完一个分组时设置一个超时计时器。如果在超时计时器到期之前收到了对方的确认，就撤销已设置的超时计时器。</p><p>因此要注意：</p><ol><li>A在发送完一个分组后，必须暂时保留已发送的分组的副本；</li><li>分组和确认分组都必须进行编号。</li><li>超时计时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些。</li></ol><h4 id="5-4-1-3-确认丢失和确认迟到"><a href="#5-4-1-3-确认丢失和确认迟到" class="headerlink" title="5.4.1.3. 确认丢失和确认迟到"></a>5.4.1.3. 确认丢失和确认迟到</h4><p><img src="/images/network-basic/TCPconfirmLossLate.PNG"></p><p><strong>确认丢失</strong></p><p>B所发送的对M1的确认丢失了。A在设定的超时重传时间内没有收到确认，并无法知道是自己发送的分组出错、丢失，或者是B发送的确认丢失了。因此A在超时计时器到期后就要重传M1。现在应注意B的动作。假定B又收到了重传的分组M1。这时应采取两个行动。</p><ol><li>丢弃这个重复的分组M1，不向上层交付。</li><li>向A发送确认。不能认为已经发送过确认就不再发送，因为A之所以重传M</li></ol><p><strong>确认迟到</strong></p><p>传输过程中没有出现差错，但B对分组M1的确认迟到了。A会收到重复的确认。对重复的确认的处理很简单:收下后就丢弃。B仍然会收到重复的M1，并且同样要丢弃重复的M1，并重传确认分组。</p><p>像上述的这种可靠传输协议常称为自动重传请求ARQ( Automatic Repeat reQuest)。意思<br>是重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组。</p><h4 id="5-4-1-4-信道利用率"><a href="#5-4-1-4-信道利用率" class="headerlink" title="5.4.1.4. 信道利用率"></a>5.4.1.4. 信道利用率</h4><p>停止等待协议的优点是简单，但缺点是信道利用率太低。</p><p><img src="/images/network-basic/TcpARQ.PNG"></p><p>当往返时间RTT远大于分组发送时间TD时，信道的利用率就会非常低。若出现重传，信道的利用率就还要降低。</p><p>为了提高传输效率，发送方可以采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地在传送。显然，这种传输方式可以获得很高的信道利用率。</p><p>即使用连续ARQ协议和滑动窗口协议。</p><h3 id="5-4-2-连续ARQ协议"><a href="#5-4-2-连续ARQ协议" class="headerlink" title="5.4.2. 连续ARQ协议"></a>5.4.2. 连续ARQ协议</h3><p>发送窗口的意义是:位于发送窗口内的5个分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。</p><p><img src="/images/network-basic/TcpSendWindow.PNG"></p><p>发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。接收方一般都是采用累积确认的方式。接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对按序到达的最后一个分组发送确认，这就表示:到这个分组为止的所有分组都已正确收到了。</p><p><strong>优缺点</strong></p><p>累积确认有优点也有缺点。优点是:容易实现，即使确认丢失也不必重传。但缺点是<br>不能向发送方反映出接收方已经正确收到的所有分组的信息，在通信质量不好时会多次重传。</p><h2 id="5-5-TCP报文段格式"><a href="#5-5-TCP报文段格式" class="headerlink" title="5.5. TCP报文段格式"></a>5.5. TCP报文段格式</h2><p>TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段。</p><p><img src="/images/network-basic/TCP.PNG"></p><ul><li>源端口和目的端口：各占2个字节，分别写入源端口号和目的端口号。</li><li>序号：占4字节。本报文段所发送的数据的第一个字节的序号。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。</li><li>确认号：占4字节，是期望收到对方下一个报文段的第一个数据字节的序号。若确认号=N，则表明:到序号N-1为止的所有数据都已正确收到。</li><li>数据偏移：占4位，实际上是指出TCP报文段的首部长度，单位是32位字(即以4字节）。</li><li>保留占6位，保留为今后使用，但目前应置为0。</li><li>紧急URG：当URG=1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(高优先级的数据)，而不要按原来的排队顺序来传送，例如<kbd>Ctrl + C</kbd>。TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据，这时要与首部中紧急指针字段配合使用。</li><li>确认ACK：仅当ACK=1时确认号字段才有效。当ACK=0时，确认号无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1。</li><li>推送PSH：当两个应用进程进行交互式的通信时，一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。发送方TCP把PSH置1，并立即创建一个报文段发送出去。接收方TCP收到PSH=1的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。</li><li>复位RST：当RST=1时，表明TCP连接中出现严重差错(如由于主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接。RST置1还用来拒绝一个非法的报文段或拒绝打开一个连接。</li><li>同步SYN：在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1。因此，SYN置为1就表示这是一个连接请求或连接接受报文。</li><li>终止FIN：用来释放一个连接。</li><li>窗口：占2字节。窗口指的是发送本报文段的的接收窗口(而不是自己的发送窗口)。窗口值代表目前允许对方发送的数据量(以字节为单位)。作为接收方让发送方设置其发送窗口的依据。</li><li>检验和：占2字节。检验和字段检验的范围包括首部和数据这两部分。</li><li>紧急指针：占2字节。紧急指针仅在URG=1时才有意义，它指出本报文段中的紧急数据的字节数，即紧急数据的末尾在报文段中的位置。</li><li>选项：长度可变，最长可达40字节。<ul><li>窗口扩大：高吞吐量下增大窗口数值的位数</li><li>时间戳：计算RTT；处理序号过大，防止序号取模绕回PAWS</li><li>选择确认</li></ul></li></ul><p>最大报文段长度MSS：每一个TCP报文段中的数据字段的最大长度。MSS太小，网络利用率降低；太大，IP层需要分片。</p><h2 id="5-6-TCP可靠传输的实现"><a href="#5-6-TCP可靠传输的实现" class="headerlink" title="5.6. TCP可靠传输的实现"></a>5.6. TCP可靠传输的实现</h2><h3 id="5-6-1-以字节为单位的滑动窗口"><a href="#5-6-1-以字节为单位的滑动窗口" class="headerlink" title="5.6.1. 以字节为单位的滑动窗口"></a>5.6.1. 以字节为单位的滑动窗口</h3><p>发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示己发送且己收到了确认。这些数据显然不需要再保留，而发送窗口前沿的前面部分表示不允许发送的。</p><p>发送窗口的位置由窗口前沿和后沿的位置共同确定。发送窗口后沿的变化情况有两种可能，即不动(没有收到新的确认)和前移(收到了新的确认)。发送窗口后沿不可能向后移动，因为不能撤销掉已收到的确认。发送窗口前沿通常是不断向前移动，但也有可能不动。</p><p><img src="/images/network-basic/TcpASend11.PNG"></p><p>B只能对按序收到的数据中的最高序号给出确认，因此B发送的确认报文段中的确认号仍然是31，而不能是32或33。<br>现在假定B收到了序号为31的数据，并把序号为31-33的数据交付主机，然后B删除这些数据。接着把接收窗口向前移动3个序号，同时给A发送确认，其中窗口值仍为20，但确认号是34。这表明B已经收到了到序号33为止的数据。我们注意到，B还收到了序号为37，38和40的数据，但这些都没有按序到达，只能先暂存在接收窗口中A收到B的确认后，就可以把发送窗口向前滑动3个序号，但指针P2不动。可以看出，现在A的可用窗口增大了，可发送的序号范围42-53。</p><p><img src="/images/network-basic/TcpAReceive.PNG"></p><p><strong>TCP的缓存与窗口的关系</strong></p><p><img src="/images/network-basic/TcpWinCacheRelation.PNG"></p><p>发送缓存用来暂时存放:</p><ul><li>发送应用程序传送给发送方TCP准备发送的数据;</li><li>TCP已发送出但尚未收到确认的数据。</li></ul><p>接收缓存用来暂时存放:</p><ul><li>按序到达的、但尚未被接收应用程序读取的数据</li><li>未按序到达的数据。</li></ul><p><strong>注意</strong></p><ol><li>在同一时刻，A的发送窗口并不总是和B的接收窗口一样大。因为通过网络传送窗口值需要经历一定的时间滞后；</li><li>对于不按序到达的数据应如何处理，TCP标准并无明确规定。如果接收方一律丢弃，对网络资源的利用不利，因此通常对不按序到达的数据是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程；</li><li>TCP要求接收方必须有累积确认的功能，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。</li></ol><h3 id="5-6-2-超时重传时间的选择"><a href="#5-6-2-超时重传时间的选择" class="headerlink" title="5.6.2. 超时重传时间的选择"></a>5.6.2. 超时重传时间的选择</h3><p>如果把超时重传时间设置得太短，就会引起很多报文段的不必要的重传，使网络负荷增大。但若把超时重传时间设置得过长，则又使网络的空闲时间增大，降低了传输效率。</p><p>TCP采用了一种自适应算法，它记录报文段的往返时间RTT。TCP保留了RTT的一个加权平均往返时间RTTs(这又称为平滑的往返时间）因为进行的是加权平均，因此得出的结果更加平滑)。每当第一次测量到RTT样本时，RTTs值就取为所测量到的RTT样本值。但以后每测量到一个新的RTT样本，就按下式重新计算一次RTTs：</p><p>新的RTTs=(1-α)×(旧的RTTs)+α*(新的RTT样本)</p><p>在上式中，0≤α&lt;1。若α很接近于零，表示新的RTTs值和旧的RTTs值相比变化不大，而对新的RTT样本影响不大(RTT值更新较慢)。若选择α接近于1，则表示新的RTTs值受新的RTT样本的影响较大(RT值更新较快)。</p><p>显然，超时计时器设置的超时重传时间RTO应略大于RTTs。RFC6298建议使用下式计算RTO</p><p>RTO=RTTs+4×RTTD</p><p>而RTTD是RTT的偏差的加权平均值，它与RTTs和新的RTT样本之差有关。</p><p>RFC6298建议这样计算RTTD。当第一次测量时，RTTD值取为测量到的RTT样本值的一半。在以后的测量中，则使用下式计算加权平均的RTT</p><p>新的RTTD=(1-β)×(旧的RTTD+β*|RTTs-新的RTT样本|</p><p>若收到的确认是对重传报文段的确认，但却被源主机当成是对原来的报文段的确认则这样计算出的RTTs和超时重传时间RTO就会偏大。若后面再发送的报文段又是经过重传后才收到确认报文段，则按此方法得出的超时重传时间RTO就越来越长。</p><p>Karn提出了一个算法:在计算加权平均RTTS时，只要报文段重传了，就不采用其往返时间样本，这样得出的加权平均RTTS和RTO就较准确。但是如果报文段的时延突然增大了很多，因<br>此在原来得出的重传时间内，不会收到确认报文段，于是就重传报文段。但根据Karn算<br>法，不考虑重传的报文段的往返时间样本，这样，超时重传时间就无法更新。</p><p>因此要对Karn算法进行修正。方法是:报文段每重传一次，就把超时重传时间RTO增大一些。典型的做法是取新的重传时间为旧的重传时间的2倍。当不再发生报文段的重传时，才根据上面给出的2式计算超时重传时间。实践证明，这种策略较为合理。</p><h3 id="5-6-3-选择确认SACK"><a href="#5-6-3-选择确认SACK" class="headerlink" title="5.6.3. 选择确认SACK"></a>5.6.3. 选择确认SACK</h3><p>若收到的报文段无差错，只是未按序号，中间还缺少一些序号的数据，那么能否设法只传送缺少的数据而不重传已经正确到达接收方的数据?选择确认就是一种可行的处理方法。</p><p><img src="/images/network-basic/SACK.PNG"></p><p>和前后字节不连续的每一个字节块都有两个边界:左边界和右边界。因此在图中用四个指针标记这些边界。左边界指出字节块的第一个字节的序号，但右边界减1才是字节块中的最后一个序号。</p><p>然而，SACK文档并没有指明发送方应当怎样响应SACK。因此大多数的实现还是重传所有未被确认的数据块。</p><h2 id="5-7-TCP的流量控制"><a href="#5-7-TCP的流量控制" class="headerlink" title="5.7. TCP的流量控制"></a>5.7. TCP的流量控制</h2><h3 id="5-7-1-利用滑动窗口实现流量控制"><a href="#5-7-1-利用滑动窗口实现流量控制" class="headerlink" title="5.7.1. 利用滑动窗口实现流量控制"></a>5.7.1. 利用滑动窗口实现流量控制</h3><p>所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</p><p><img src="/images/network-basic/TcpFlowControl.PNG"></p><p>现在我们考虑一种情况。B向A发送了零窗口的报文段后不久，B的接收缓存又有了一些存储空间。于是B向A发送了rwnd=400的报文段。然而这个报文段在传送过程中丢失了。A一直等待收到B发送的非零窗口的通知，而B也一直等待A发送的数据。如果没有其他措施，这种互相等待的死锁局面将一直延续下去。</p><p>为了解决这个问题，TCP为每一个连接设有一个持续计时器。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段(仅携带1字节的数据)，而对方就在确认这个探测报文段时给出了现在的窗口值。如果窗口仍然是零，那么收到这个报文段的一方就重新设置持续计时器。如果窗口不是零，那么死锁的僵局就可以打破了。</p><h3 id="5-7-2-TCP的传输效率"><a href="#5-7-2-TCP的传输效率" class="headerlink" title="5.7.2. TCP的传输效率"></a>5.7.2. TCP的传输效率</h3><p>不同的机制来控制TCP报文段的发送时机</p><ol><li>TCP维持一个变量，它等于最大报文段长度MSS。只要缓存中存放的数据达到MSS字节时，就组装成一个TCP报文段发送出去。</li><li>由发送方的应用进程指明要求发送报文段，即TCP支持的推送(push)操作。第三种机制是</li><li>发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段(但长度不能超过MSS)发送出去。</li></ol><p>在TCP的实现中广泛使用<strong>Nage算法</strong>。</p><p>算法如下:若发送应用进程把要发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。当发送方收到对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存。只有在收到对前一个报文段的确认后才继续发送下一个报文段。当数据到达较快而网络速率较慢时，用这样的方法可明显地减少所用的网络带宽。 Nagle算法还规定，当到达的数据已达到发送窗口大小的半或已达到报文段的最大长度时，就立即发送一个报文段。这样做，就可以有效地提高网络的吞吐量。</p><p><strong>糊涂窗口综合征</strong></p><p>设想一种情况:TCP接收方的缓存已满，而交互式的应用进程一次只从接收缓存中读取1个字节(这样就使接收缓存空间仅腾出1个字节)，然后向发送方发送确认，并把窗口设置为1个字节(但发送的数据报是40字节长)。接着，发送方又发来1个字节的数据(请注意，发送方发送的IP数据报是41字节长)。接收方发回确认，仍然将窗口设置为1个字节。这样进行下去，使网络的效率很低。</p><p>要解决这个问题，可以让接收方等待一段时间，使得或者接收缓存已有足够空间容纳最长的报文段，或者等到接收缓存已有一半空闲的空间。只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小。此外，发送方也不要发送太小的报文段，而是把数据积累成足够大的报文段，或达到接收方缓存的空间的一半大小。</p><h2 id="5-8-TCP的拥塞控制"><a href="#5-8-TCP的拥塞控制" class="headerlink" title="5.8. TCP的拥塞控制"></a>5.8. TCP的拥塞控制</h2><h3 id="5-8-1-拥塞控制的一般原理"><a href="#5-8-1-拥塞控制的一般原理" class="headerlink" title="5.8.1. 拥塞控制的一般原理"></a>5.8.1. 拥塞控制的一般原理</h3><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做<strong>拥塞</strong>。若网络中有许多资源同时呈现供应不足，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。</p><p>网络拥塞往往是由许多因素引起的。简单地扩大缓存的存储空间同样会造成网络资源的严重浪费，因而解决不了网络拥塞的问题。简单地将处理机的速率提高，可能会使上述情况缓解一些，但往往又会将瓶颈转移到其他地方。问题的实质往往是整个系统的各个部分不匹配。只有所有的部分都平衡了，问题才会得到解决。</p><p>拥塞控制与流量控制的关系密切，它们之间也存在着一些差别。所谓拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程。相反，流量控制往往是指点对点通信量的控制，是个端到端的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><p><img src="/images/network-basic/TcpCongestionControl.PNG"></p><p>从控制理论的角度来看有两种方法：</p><ul><li>开环控制：在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。</li><li>闭环控制是基于反馈环路的概念，主要有以下几种措施<ul><li>监测网络系统以便检测到拥塞在何时、何处发生。</li><li>把拥塞发生的信息传送到可采取行动的地方</li><li>调整网络系统的运行以解决出现的问题。</li></ul></li></ul><p>监测网络的拥塞：</p><ul><li>指标：由于缺少缓存空间而被丢弃的分组的百分数、平均队列长度、超时重传的分组数、平均分组时延、分组时延的标准差，等等。上述这些指标的上升都标志着拥塞的增长<br>般在监测到拥塞发生时，要将拥塞发生的信息传送到产生分组的源站。当然，通知<br>拥塞发生的分组同样会使网络更加拥塞</li><li>比特位：在路由器转发的分组中保留一个比特或字段，用该比特或字段的值表示网络没有拥塞或产生了拥塞。也可以由一些主机或路由器周期性地发出探测分组，以询问拥塞是否发生。</li></ul><h3 id="5-8-2-TCP的拥塞控制方法"><a href="#5-8-2-TCP的拥塞控制方法" class="headerlink" title="5.8.2. TCP的拥塞控制方法"></a>5.8.2. TCP的拥塞控制方法</h3><p>TCP进行拥塞控制的算法有四种：慢开始(sow-start)、拥塞避免(congestion avoidance)、快重传(fast retransmit)和快恢复(fast recovery)。</p><h4 id="5-8-2-1-慢开始"><a href="#5-8-2-1-慢开始" class="headerlink" title="5.8.2.1. 慢开始"></a>5.8.2.1. 慢开始</h4><p>发送方维持一个叫做<strong>拥塞窗口</strong>cwnd(congestion window)的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。<strong>发送方让自己的发送窗口等于拥塞窗口。</strong></p><p>发送方控制拥塞窗口的原则是:只要网络没有出现拥塞，拥塞窗口就可以再增大些，以便把更多的分组发送出去。但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些。</p><p>判断网络拥塞的依据就是出现了超时。</p><p>慢开始算法的思路是这样的:当主机开始发送数据时，是先探测一下，由小到大逐渐增大发送窗口，即由小到大逐渐增大拥塞窗口数值。</p><p>慢开始规定，在每收到一个对新的报文段的确认后，可以把拥塞窗口増加最多一个SMSS的数值。</p><p>拥塞窗口cwnd每次的增加量=min(N，SMSS)</p><p>请注意，实际上TCP是用<strong>字节数</strong>作为窗口大小的单位。但为叙述方便起见用报文段的个数作为窗口大小的单位。</p><p><img src="/images/network-basic/TcpSlowStart.PNG"></p><p>发送方每收到一个对新报文段的确认就使发送方的拥塞窗口加1每经过一个传输轮次，拥塞窗口cwnd就加倍。</p><p>一个传输轮次时间其实就是往返时间RTT(请注意，RTT并非是恒定的数值)。强调把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后个字节的确认。</p><p>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。慢开始门限ssthresh的用法如下:</p><p>当cwnd &lt; ssthresh时，使用上述的慢开始算法。<br>当cwnd &gt; ssthresh时，停止使用慢开始算法而改用拥塞避免算法。<br>当cwnd = ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法。</p><h4 id="5-8-2-2-拥塞避免"><a href="#5-8-2-2-拥塞避免" class="headerlink" title="5.8.2.2. 拥塞避免"></a>5.8.2.2. 拥塞避免</h4><p>拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是像慢开始阶段那样加倍增长。因此在拥塞避免阶段就有“加法増大”的特点。这表明在拥塞避免阶段，拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p><p>按线性规律增长。但请注意，“拥塞避免”并非完全能够避免了拥塞。“拥塞避免”是说托拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</p><p><img src="/images/network-basic/TcpCwnd.PNG"></p><p>当拥塞窗口cwnd=24时，网络出现了超时(图中的点2)，发送方判断为网络拥塞。于是调整门限值 ssthresh=cwnd/2=12，同时设置拥塞窗口cwnd=1，进入慢开始阶段</p><p>按照慢开始算法，发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值加1当拥塞窗口cwnd= ssthresh=12时(图中的点3，这是新的 ssthresh值)，改为执行拥塞避免算法，拥塞窗口按线性规律增大。</p><p>当拥塞窗口cwnd=16时(图中的点4)，出现了一个新的情况，就是发送方一连收到3<br>个对同一个报文段的重复确认(图中记为3-ACK)。</p><p>3-ACK解释：</p><p>有时，个别报文段会在网络中丢失，但实际上网络并未发生拥塞。如果发送方迟迟收不到确认，就会产生超时，就会误认为网络发生了拥塞。这就导致发送方错误地启动慢开始，把拥塞窗口cwnd又设置为1，因而降低了传输效率。</p><p>采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。</p><h4 id="5-8-2-3-快重传"><a href="#5-8-2-3-快重传" class="headerlink" title="5.8.2.3. 快重传"></a>5.8.2.3. 快重传</h4><p><img src="/images/network-basic/TcpFastRetransmit.PNG"></p><p>快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。如图5-26所示，接收方收到了M1和M2后都分别及时发出了确认。现假定接收方没有收到M3但却收到了M4本来接收方可以什么都不做。但按照快重传算法，接收方必须立即发送对M2的重复确认，以便让发送方及早知道接收方没有收到报文段M3。发送方接着发送M5和M6。接收方收到后也仍要再次分别发出对M2的重复确认。这样，发送方共收到了接收方的4个对M2的确认，其中后3个都是重复确认。</p><p>快重传算法规定，发送方只要一连收到3个重复确认，就知道接收方确实没有收到报文段M3，因而应当立即进行重传(即“快重传”)，这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。使用快重传可以使整个网络的吞吐量提高约20%。</p><p>因此，在图中的点4，发送方知道现在只是丢失了个别的报文段。于是不启动慢开始，而是执行快恢复算法。这时，发送方调整门限值 ssthresh=cwnd/2=8，同时设置拥塞窗口cwnd=ssthresh=8(图中的点6)，并开始执行拥塞避免算法。</p><h4 id="5-8-2-4-快恢复"><a href="#5-8-2-4-快恢复" class="headerlink" title="5.8.2.4. 快恢复"></a>5.8.2.4. 快恢复</h4><p>也有的快恢复实现是把快恢复开始时的拥塞窗口cwd值再增大一些(增大报文段的长度)，即等于新的 ssthresh+3×MSS。这样做的理由是:既然发送方收到3个重复的确认，就表明有3个分组已经离开了网络。这3个分组不再消耗网络的资源而是停留在接收方的缓存中(接收方发送出3个重复的确认就证明了这个事实)。可见现在网络中并不是堆积了分组而是减少了3个分组。因此可以适当把拥塞窗口扩大些。</p><h4 id="5-8-2-5-总结"><a href="#5-8-2-5-总结" class="headerlink" title="5.8.2.5. 总结"></a>5.8.2.5. 总结</h4><p><img src="/images/network-basic/TcpCongestionControlProcess.PNG"></p><p>在拥塞避免阶段，拥塞窗口是按照线性规律増大的，这常称为加法增大AI，而一旦出现超时或3个重复的确认，就要把门限值设置为当前拥塞窗口值的一半，并大大减小拥塞窗口的数值。这常称为“乘法减小”MD，二者合在一起就是所谓的AIMD算法。</p><p>总之，发送方的窗口的上限值应当取为接收方窗口rwnd和拥塞窗口cwnd这两个变量中较小的：</p><p><strong>发送方窗口的上限值 = Min[ rwnd ， cwnd ]</strong></p><p>当rwnd &lt; cwnd时，是接收方的接收能力限制发送方窗口的最大值</p><p>当cwnd &lt; rwnd时，则是网络的拥塞程度限制发送方窗口的最大值。</p><h3 id="5-8-3-主动队列管理AQM"><a href="#5-8-3-主动队列管理AQM" class="headerlink" title="5.8.3. 主动队列管理AQM"></a>5.8.3. 主动队列管理AQM</h3><p>网络层路由器的队列通常都是按照“先进先出”FIFO的规则处理到来的分组。当队列已满时，以后再到达的所有分组将都被丢弃。这就叫做<strong>尾部丢弃策略</strong>。这会同时影响到很多条TCP连接，结果使这许多TCP连接在同一时间突然都进入到慢开始状态。这在TCP的术语中称为全局同步。全局同步使得全网的通信量突然下降了很多，而在网络恢复正常后，其通<br>信量又突然增大很多。</p><p>为了避免发生网络中的全局同步现象，提出了主动队列管理AQM。AQM可以有不同实现方法，其中曾流行多年的就是随机早期检测RED。</p><p>实现RED时需要使路由器维持两个参数，即队列长度最小门限和最大门限。当每一个分组到达时，RED就按照规定的算法先计算当前的平均队列长度：</p><ol><li>若平均队列长度小于最小门限，则把新到达的分组放入队列进行排队</li><li>若平均队列长度超过最大门限，则把新到达的分组丢弃。</li><li>若平均队列长度在最小门限和最大门限之间，则按照某一丢弃概率p把新到达的分组丢弃(这就体现了丢弃分组的随机性)</li><li>由此可见，RED不是等到已经发生网络拥塞后才把所有在队列尾部的分组全部丢弃，<br>而是在检测到网络拥塞的早期征兆时(即路由器的平均队列长度达到一定数值时)，就以概<br>率p丢弃个别的分组，让拥塞控制只在个别的TCP连接上进行，因而避免发生全局性的拥<br>塞控制。</li></ol><h2 id="5-9-TCP的连接管理"><a href="#5-9-TCP的连接管理" class="headerlink" title="5.9. TCP的连接管理"></a>5.9. TCP的连接管理</h2><h3 id="5-9-1-TCP的连接建立"><a href="#5-9-1-TCP的连接建立" class="headerlink" title="5.9.1. TCP的连接建立"></a>5.9.1. TCP的连接建立</h3><p><img src="/images/network-basic/3handshake.PNG"></p><ol><li><p>开始，B的TCP服务器进程先创建传输控制块TCB，准备接受客户进程的连接请求。然后服务器进程就处于 LISTEN(收听)状态，等待客户的连接请求。如有，即作出响应。</p></li><li><p>A的TCP客户进程也是首先创建传输控制模块TCB。然后，在打算建立TCP连接时，向B发出连接请求报文段，这时首部中的同步位SYN=1，同时选择一个初始序号seq=ⅹ。TCP规定，SYN报文段(即SYN=1的报文段)不能携带数据，但要消耗掉一个序号这时，TCP客户进程进入 SYN-SENT(同步已发送)状态。</p></li><li><p>B收到连接请求报文段后，如同意建立连接，则向A发送确认。在确认报文段中应把SYN位和ACK位都置1，确认号是ack=x+1，同时也为自己选择一个初始序号seq=y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时TCP服务器进程进入 SYN-RCVD(同步收到)状态。</p></li><li><p>TCP客户进程收到B的确认后，还要向B给出确认。确认报文段的ACK置1，确认号ack=y+1，而自己的序号seq=x+1。TCP的标准规定，ACK报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是seq=x。</p></li><li><p>这时，TCP连接已经建立，A进入 ESTABLISHED(已建立连接)状态。当B收到A的确认后，也进入 ESTABLISHED状态</p></li></ol><p>为什么A最后还要发送一次确认呢?这主要是为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误。</p><p>所谓“已失效的连接请求报文段”是这样产生的。考虑一种正常情况，A发出连接请求，但因连接请求报文丢失而未收到确认。于是A再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A共发送了两个连接请求报文段，其中第一个丢失，第二个到达了B，没有“已失效的连接请求报文段”。现假定出现一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达B。本来这是一个早已失效的报文段。但B收到此失效的连接请求报文段后，就误认为是A又发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。假定不采用报文握手，那么只要B发出确认，新的连接就建立了由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据。但B却以为新的运输连接已经建立了，并一直等待A发来数据。B的许多资源就这样白白浪费了。</p><h3 id="5-9-2-TCP的连接释放"><a href="#5-9-2-TCP的连接释放" class="headerlink" title="5.9.2. TCP的连接释放"></a>5.9.2. TCP的连接释放</h3><p><img src="/images/network-basic/4handshake.PNG"></p><ol><li><p>数据传输结束后，通信的双方都可释放连接。现在A和B都处于 ESTABLISHED状态。A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。A把连接释放报文段首部的终止控制位FN置1，其序号seq=u，它等于前面已传送过的数据的最后一个字节的序号加1。这时A进入FⅠ N-WAIT-1(终止等待1)状态，等待B的确认。请注意，TCP规定，FIN报文段即使不携带数据，它也消耗掉序号。</p></li><li><p>B收到连接释放报文段后即发出确认，确认号是ack=u+1，而这个报文段自己的序号是v，等于B前面已传送过的数据的最后一个字节的序号加1。然后B就进入 CLOSEWAT(关闭等待)状态。TCP服务器进程这时应通知高层应用进程，因而从A到B这个方向的连接就释放了，这时的TCP连接处于<strong>半关闭</strong>状态，即A已经没有数据要发送了，但B若发送数据，A仍要接收。也就是说，从B到A这个方向的连接并未关闭，这个状态可能会持续一段时间。</p></li><li><p>A收到来自B的确认后，就进入 FIN-WAIT2(终止等待2)状态，等待B发出的连接释放报文段。</p></li><li><p>若B已经没有要向A发送的数据，其应用进程就通知TCP释放连接。这时B发出的连接释放报文段必须使FIN=1。现假定B的序号为w(在半关闭状态B可能又发送了一些数据)。B还必须重复上次已发送过的确认号ack=u+1。这时B就进入 LAST-ACK(最后确认)状态，等待A的确认。</p></li><li><p>A在收到B的连接释放报文段后，必须对此发出确认。在确认报文段中把ACK置1，确认号ack=w+1，而自己的序号是seq=u+1(根据TCP标准，前面发送过的FIN报文段要消耗一个序号)。然后进入到 TIME-WAIT(时间等待)状态。请注意，现在TCP连接还没有释放掉。必须经过时间等待计时器( TIME-WAIT timer)设置的时间2MSL后，A才进入到 CLOSED状态。</p></li></ol><p>MSL：最长报文段寿命。</p><p>为什么A在 TMME-WAIT状态必须等待2MSL的时间呢?</p><ol><li>为了保证A发送的最后一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而使处在 LAST-ACK状态的B收不到对已发送的FN+ACK报文段的确认。B会超时重传这个FN+ACK报文段，而A就能在2MSL时间内收到这个重传的FIN+ACK报文段。接着A重传一次确认，重新启动2MSL计时器。最后，A和B都正常进入到CLOSED状态。如果A在 TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后立即释放连接，那么就无法收到B重传的FN+ACK报文段，因而也不会再发送一次确认报文段。这样，B就无法按照正常步骤进入 CLOSED状态。1MSL时间留给最后的ACK确认报文段到达服务器端，1MSL时间留给服务器端再次发送的FIN。</li><li>防止上一节提到的“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。B只要收到了A发出的确认，就进入 CLOSED状态。同样，B在撤销相应的传输控制块TCB后，就结束了这次的TCP连接。我们注意到，B结束TCP连接的时间要比A早。</li></ol><p><strong>保活计时器</strong></p><p>设想有这样的情况:客户已主动与服务器建立了TCP连接。但后来客户端的主机突然出故障。显然，服务器以后就不能再收到客户发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就是使用保活计时器。服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两小时。若两小时没有收到客户的数据，服务器就发送一个探测报文段，以后则每隔75秒钟发送一次。若一连发送10个探测报文段后仍无客户的响应，服务器就认为客户端出了故障，接着就关闭这个连接。</p><h3 id="5-9-3-TCP的有限状态机"><a href="#5-9-3-TCP的有限状态机" class="headerlink" title="5.9.3. TCP的有限状态机"></a>5.9.3. TCP的有限状态机</h3><p><img src="/images/network-basic/TcpFiniteState.PNG"></p><h1 id="6-应用层"><a href="#6-应用层" class="headerlink" title="6. 应用层"></a>6. 应用层</h1><h2 id="6-1-域名系统DNS"><a href="#6-1-域名系统DNS" class="headerlink" title="6.1. 域名系统DNS"></a>6.1. 域名系统DNS</h2><p><strong>顶级域名：</strong></p><ul><li>国家顶级域名：.cn .us</li><li>通用顶级域名：.com .org</li><li>基础结构域名：.arpa</li></ul><p><strong>互联网的域名结构：</strong></p><p><img src="/images/network-basic/domin.PNG"></p><p><strong>域名服务器：</strong></p><ul><li>根域名服务器：最高层次的、最重要的域名服务器</li><li>顶级域名服务器：负责管理在该顶级域名服务器下注册的所有二级域名</li><li>权限域名服务器：负责一个区的域名服务器</li><li>本地域名服务器：默认域名服务器</li></ul><p><img src="/images/network-basic/nameServer.PNG"></p><p><strong>解析过程：</strong></p><ol><li>主机向本地域名服务器的查询一般都是采用递归查询。</li></ol><p>所谓递归查询就是:如果主机所询问的本地域名服务器不知道被査询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文(即替该主机继续查询)，而不是让该主机自己进行下一步的查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。</p><ol start="2"><li>本地域名服务器向根域名服务器的查询通常是采用迭代查询</li></ol><p>迭代査询的特点是这样的:当根域名服务器收到本地域名服务器发出的迭代查询请求报文时要么给出所要查询的IP地址，要么告诉本地域名服务器:“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询(而不是替本地域名服务器进行后续的查询)。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地域名服务器下一步应当向哪一个权限域名服务器进行查询，本地域名服务器就这样进行迭代査询。最后，知道了所要解析的域名的IP地址，然后把这个结果返回给发起查询的主机。</p><p><img src="/images/network-basic/nameQuery.PNG"></p><p>为了提高DNS查询效率，并减轻根域名服务器的负荷和减少互联网上的DNs查询报文数量，在域名服务器中广泛地使用了高速缓存(有时也称为高速缓存域名服务器)。由于名字到地址的绑定并不经常改变，为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并处理超过合理时间的项。</p><h2 id="6-2-文件传送协议"><a href="#6-2-文件传送协议" class="headerlink" title="6.2. 文件传送协议"></a>6.2. 文件传送协议</h2><h3 id="6-2-1-FTP"><a href="#6-2-1-FTP" class="headerlink" title="6.2.1. FTP"></a>6.2.1. FTP</h3><p>文件传送协议FTP是互联网上使用得最广泛的文件送协议，提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限，FTP屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件。</p><p>基于TCP的FTP和基于UDP的简单文件传送协议TFTP，它们都是文件共享协议中的一大类，即复制整个文件。而网络文件系统NFS则采用另一种思路，允许应用进程打开一个远地文件，并能在该文件的某一个特定的位置上开始读写数据。在网络上传送的只是少量的修改数据。</p><p>FTP的服务器进程由两大部分组成:一个主进程，负责接受新的请求;另外有若干个从属进程，<br>负责处理单个请求</p><p><strong>主进程的工作步骤</strong></p><ol><li>打开熟知端口(端口号为21)，使客户进程能够连接上</li><li>等待客户进程发出连接请求</li><li>启动从属进程处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程发之()回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并行的</li></ol><p>两个从属进程:控制进程和数据传送进程。为简单起见，服务器端的主进程没有画上</p><p>在进行文件传输时，FTP的客户和服务器之间要建立两个并行的TCP连接:“控制连<br>接（21号端口）”和“数据连接（20号端口）”。控制连接在整个会话期间一直保持打开，FTP客户所发出的传送请求，通过控制连接发送给服务器端的控制进程，但控制连接并不用来传送文件。实际用于传输文件的是“数据连接”。</p><h3 id="6-2-2-TFTP"><a href="#6-2-2-TFTP" class="headerlink" title="6.2.2. TFTP"></a>6.2.2. TFTP</h3><p>简单文件传送协议TFTP，它是个很小且易于实现的文件传送协议。也使用客户服务器方式，但它使用UDP数据报，因此TFTP需要有自己的差错改正措施。TFTP只支持文件传输而不支持交互。TFTP没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。</p><p>每次传送的数据报文中有512字节的数据，但最后一次可不足512字节，这正好可作为文件结束的标志。</p><p><strong>优点：</strong></p><ol><li>TFTP可用于UDP环境</li><li>TFTP代码所占的内存较小</li></ol><h2 id="6-3-超文本传送协议HTTP"><a href="#6-3-超文本传送协议HTTP" class="headerlink" title="6.3. 超文本传送协议HTTP"></a>6.3. 超文本传送协议HTTP</h2><h3 id="6-3-1-HTTP基本过程"><a href="#6-3-1-HTTP基本过程" class="headerlink" title="6.3.1. HTTP基本过程"></a>6.3.1. HTTP基本过程</h3><p>统一资源定位符URL：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/路径&gt;</p><p>URL里面的协议和主机不分大小写，路径有时区分。</p><p>HTTP使用了面向连接的TCP作为运输层协议，保证了数据的可靠传输。但是HTTP协议本身是无连接的。</p><p>HTTP协议是无状态的。也就是说，同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时的相同。</p><p>万维网客户就把HTTP请求报文作为建立TCP连接的三报文握手中的第三个报文的数据，发送给万维网服务器。服务器收到HTTP请求报文后，就把所请求的文档作为响应报文返回给客户。</p><p><img src="/images/network-basic/HTTPtime.PNG"></p><p>所以，请求一个万维网文档所需的时间是该文档的传输时间加上两倍往返时间RTT。</p><p><strong>HTTP/1.0的主要缺点</strong></p><ul><li>每请求一个文档就要有两倍RTT的开销。</li><li>万维网客户和服务器每一次建立新的TCP连接都要分配缓存和变量。特别是同时服务于大量客户的请求，使用并行TCP连接可以缩短响应时间。</li></ul><p><strong>HTTP/1.1协议</strong>较好地解决了这个问题，它使用了持续连接( persistent connection)。所谓持续连接就是万维网服务器在发送响应后仍然在一段时间内保持这条连接，使同一个客户(浏览器)和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。</p><p><strong>持续连接的工作方式：</strong></p><ul><li>非流水线方式：客户在收到前一个响应后才能发出下一个请求。因此客户每访问一次对象都要用去一个往返时间RTT，比1.0少一个。</li><li>流水线方式：客户在收到HTTP的响应报文之前就能够接着发送新的请求报文。因此客户访问所有的对象只需花费一个RTT时间。</li></ul><p><strong>代理服务器</strong></p><p>代理服务器(proxy server)是一种网络实体，它又称为万维网高速缓存( Web cache)。代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这个请求与暂时存放的请求相同，就返回暂存的响应，而不需要按URL的地址再次去互联网<br>访问该资源。代理服务器可在客户端或服务器端工作，也可在中间系统上工作。</p><h3 id="6-3-2-HTTP报文"><a href="#6-3-2-HTTP报文" class="headerlink" title="6.3.2. HTTP报文"></a>6.3.2. HTTP报文</h3><ul><li>请求报文</li><li>响应报文</li></ul><p><img src="/images/network-basic/HTTPmessage.PNG"></p><p>由于HTTP是面向文本的，因此在报文中的每一个字段都是一些ASCI码串，因而各个字段的长度都是不确定的。</p><p>HTTP请求报文和响应报文都是由三个部分组成的，区别仅开始行不同。</p><h4 id="6-3-2-1-HTTP请求报文"><a href="#6-3-2-1-HTTP请求报文" class="headerlink" title="6.3.2.1. HTTP请求报文"></a>6.3.2.1. HTTP请求报文</h4><p>请求报文的第一行有方法，请求资源的URL，以及HTTP的版本。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Get</td><td>请求资源</td></tr><tr><td>Post</td><td>向服务端发送资源</td></tr><tr><td>Delete</td><td>用于删除资源</td></tr><tr><td>Put</td><td>用于资源的更新，若资源不存在则新建一个</td></tr><tr><td>Option</td><td>请求一些选项信息</td></tr><tr><td>Head</td><td>只请求资源的头部，该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载， 以此可以节约带宽资源</td></tr><tr><td>Trace</td><td>用于环回测试的请求报文</td></tr><tr><td>Connect</td><td>用于代理服务器</td></tr></tbody></table><p><strong>Get/Post的区别</strong></p><ul><li>Get请求的参数放在URL里，有长度限制；Post请求的参数放在实体里，没有限制。</li><li>Get请求比起Post请求更加不安全，因为参数放在URL中，不能用来传递敏感信息。</li><li>GET用于信息获取，而且应该是安全和幂等的（对同一URL的多个请求应该返回同样的结果）；POST请求表示可能修改服务器上资源的请求</li></ul><h4 id="6-3-2-2-HTTP响应报文报文"><a href="#6-3-2-2-HTTP响应报文报文" class="headerlink" title="6.3.2.2. HTTP响应报文报文"></a>6.3.2.2. HTTP响应报文报文</h4><p>状态行包括三项内容，即HTTP的版本，状态码，以及解释状态码的简单短语</p><p>状态码都是三位数字的，分为5大类：</p><ul><li>1xx：通知信息</li><li>2xx：成功</li><li>3xx：重定向，中间态，如要完成请求还必须采取进一步的行动</li><li>4xx：客户的差错，如请求中有错误的语法或不能完成。</li><li>5xx：服务器错误，这些状态代码表示服务器在尝试处理请求时发生内部错误。</li></ul><p>具体的：</p><ul><li><p>200 OK：表示从客户端发送给服务器的请求被正常处理并返回；</p></li><li><p>204 No Content：表示客户端发送给客户端的请求得到了成功处理，但在返回的响应报文中没有资源可以返回；</p></li><li><p>206 Patial Content：表示客户端进行了范围请求，并且服务器成功执行了这部分的GET请求。</p></li><li><p>301 Moved Permanently：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL；</p></li><li><p>302 Found：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL；</p></li></ul><blockquote><p>永久是指原来访问的资源已经永久删除啦，客户端应该根据新的URI访问重定向。<br>临时是指访问的资源可能暂时先用location的URI访问，但旧资源还在的，下次你再来访问的时候可能就不用重定向了。</p></blockquote><ul><li>303 See Other：表示请求的资源被分配了新的URL，客户端应使用GET方法定向获取请求的资源；</li><li>304 Not Modified：该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但是从缓存获取资源</li></ul><blockquote><p>该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但是从缓存获取资源客户端在请求一个文件的时候，发现自己有该请求之前的缓存的文件，并且记录了 Last Modified ，那么在请求头中会包含 If Modified Since ，这个时间就是缓存文件的 Last Modified 。因此，如果请求中包含 If Modified Since，就说明已经有缓存在客户端。服务端只要判断这个时间和当前请求的文件的修改时间就可以确定是返回 304 还是 200 。在服务端的返回的响应头中通常有Last Modified 如果此值与请求头中的If Modified Since时间一致那么返回就是304，否则就是200。<br>对于静态文件，例如：CSS、图片，服务器会自动完成 Last Modified 和 If Modified Since 的比较，完成缓存或者更新。但是对于动态页面，就是动态产生的页面，往往没有包含 Last Modified 信息，这样浏览器、网关等都不会做缓存，也就是在每次请求的时候都完成一个 200 的请求。<br>因此，对于动态页面做缓存加速，首先要在 Response 的 HTTP Header 中增加 Last Modified 定义，其次根据 Request 中的 If Modified Since 和被请求内容的更新时间来返回 200 或者 304 。虽然在返回 304 的时候已经做了一次数据库查询，但是可以避免接下来更多的数据库查询，并且没有返回页面内容而只是一个 HTTP Header，从而大大的降低带宽的消耗，对于用户的感觉也是提高。</p></blockquote><ul><li><p>307 Temporary Redirect：临时重定向，与303有着相同的含义，307会遵照浏览器标准不会从POST变成GET；（不同浏览器可能会出现不同的情况）；</p></li><li><p>400 Bad Request：表示请求报文中存在语法错误；</p></li><li><p>401 Unauthorized：未经许可，需要通过HTTP认证；</p></li><li><p>403 Forbidden：服务器拒绝该次访问（访问权限出现问题）；</p></li><li><p>404 Not Found：表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；</p></li><li><p>500 Inter Server Error：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时；</p></li><li><p>503 Server Unavailable：表示服务器暂时处于超负载或正在进行停机维护，无法处理请求；</p></li></ul><p><strong>重定向</strong></p><p>所谓重定向就是，当浏览器向服务端发送url 请求的时候返回状态码为30x时表示请求被重定向了，例如请求时<a href="http://www.a.com/">http://www.a.com</a> 返回的请求头中location:<a href="https://www.a.com/">https://www.a.com</a> 那么客户端就要重新根据location 提供的信息重新发起新的请求。例如在外网的ingress  配置http 强制跳转https 的时候就是通过配置301强制跳转的。</p><p>请求报文：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/pet-products.txt</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.joes-hardware.com</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*</span><br></pre></td></tr></table></figure><p>服务端响应报文重定向到另一个地址：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">301</span> OK</span><br><span class="line"><span class="attribute">Location</span><span class="punctuation">: </span>http://www.gentle-grooming.com/</span><br><span class="line"><span class="attribute">Content-length</span><span class="punctuation">: </span>56</span><br><span class="line"><span class="attribute">Content-type</span><span class="punctuation">: </span>text/plain</span><br></pre></td></tr></table></figure><p>客户端浏览器收到重定向响应报文后，将发起一个向新地址的请求：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1  </span><br><span class="line">Host: www.gentle-grooming.com</span><br><span class="line">Accept: *</span><br></pre></td></tr></table></figure><p>新地址的响应报文：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-type</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Content-length</span><span class="punctuation">: </span>3307</span><br></pre></td></tr></table></figure><h3 id="6-3-3-HTTP协议的区别"><a href="#6-3-3-HTTP协议的区别" class="headerlink" title="6.3.3. HTTP协议的区别"></a>6.3.3. HTTP协议的区别</h3><p><strong>HTTP1.1比起1.0</strong></p><ol><li>缓存处理。在HTTP1.0中主要使用header里的If-Modified-Since、Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since， If-Match， If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li>带宽优化及网络连接的使用。HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li>错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li>Host头处理，为虚拟化准备。在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li><li>长连接。HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li></ol><p><strong>HTTP2.0比起1.1</strong></p><ol><li>新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li><li>多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的id将request再归属到各自不同的服务端请求里面。</li><li>header压缩、缓存。如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li><li>服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。</li></ol><p><img src="/images/network-basic/HTTPdiff.jpg"></p><h3 id="6-3-4-HTTPS"><a href="#6-3-4-HTTPS" class="headerlink" title="6.3.4. HTTPS"></a>6.3.4. HTTPS</h3><p>HTTPS：是以安全为目标的HTTP通道，简单讲：HTTPS = HTTP + TLS/SSL（TLS的前身是SSL）。</p><p>HTTPS协议的主要作用：</p><ul><li>加密数据，建立一个信息安全通道，来保证数据传输的安全；另一种就是</li><li>对网站服务器进行真实身份认证。</li></ul><h4 id="6-3-4-1-HTTPS的工作原理"><a href="#6-3-4-1-HTTPS的工作原理" class="headerlink" title="6.3.4.1. HTTPS的工作原理"></a>6.3.4.1. HTTPS的工作原理</h4><p><img src="/images/network-basic/HTTPS.png"></p><ol><li>Client发起一个HTTPS的请求，并将自己支持的加密规则发给Server。</li><li>Server从中选出一资加密算法和HASH算法，把自己的身份信息以公钥证书形式返回给客户端。</li><li>Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。</li><li>Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥。</li><li>Client使用约定好的HASH算法计算握手消息，并用生成的随机数对消息加密，发给Server。</li><li>Server使用自己的私钥解密，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。使用密码解析Client发来的握手消息，并验证HASH是否一致。</li><li>Server使用对称密钥加密一段内容，发送给Client。</li><li>Client使用对称密钥解密响应的密文，并计算HASH，得到明文内容。</li></ol><p>Server与Client互相发送加密的握手消息并验证，目的是保证双方获得一致的密码，并且可以正常地加解密，做一次测试。</p><p>非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据加密，HASH算法用于验证数据完整性。</p><p>SSL握手过程中有任何错误都会是加密连接断开，从而阻止隐私信息的传输，非常安全。攻击者常采用假证书欺骗客户端。</p><h4 id="6-3-4-2-HTTPS和HTTP的区别"><a href="#6-3-4-2-HTTPS和HTTP的区别" class="headerlink" title="6.3.4.2. HTTPS和HTTP的区别"></a>6.3.4.2. HTTPS和HTTP的区别</h4><ol><li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li><li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</li></ol><h3 id="6-3-5-HTTP缓存机制"><a href="#6-3-5-HTTP缓存机制" class="headerlink" title="6.3.5. HTTP缓存机制"></a>6.3.5. HTTP缓存机制</h3><p>浏览器的缓存机制也就是我们说的HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的，所以在分析浏览器缓存机制之前，我们先使用图文简单介绍一下HTTP报文，HTTP报文分为两种：</p><ul><li>HTTP请求(Request)报文，报文格式为：请求行 – HTTP头(通用信息头，请求头，实体头) – 请求报文主体(只有POST才有报文主体)</li></ul><p><img src="/images/network-basic/HttpRequestHead.png"></p><ul><li>HTTP响应(Response)报文，报文格式为：状态行 – HTTP头(通用信息头，响应头，实体头) – 响应报文主体</li></ul><p><img src="/images/network-basic/HttpResponseHead.png"></p><p>通用信息头指的是请求和响应报文都支持的头域，分别为Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via；</p><p>实体头则是实体信息的实体头域，分别为Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。</p><p>浏览器与服务器通信的方式为应答模式，即：浏览器发起HTTP请求 – 服务器响应该请求。</p><p><img src="/images/network-basic/HttpFirstRequest.png"></p><ol><li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li><li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li></ol><p>根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强制缓存和协商缓存。</p><h4 id="6-3-5-1-强制缓存"><a href="#6-3-5-1-强制缓存" class="headerlink" title="6.3.5.1. 强制缓存"></a>6.3.5.1. 强制缓存</h4><p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种：</p><ol><li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）：</li></ol><p><img src="/images/network-basic/HttpForceCache1.png"></p><ol start="2"><li>存在该缓存结果和缓存标识，但是结果已经失效，强制缓存失效，则使用协商缓存：</li></ol><p><img src="/images/network-basic/HttpForceCache2.png"></p><p>（3）存在该缓存结果和缓存标识，且该结果没有还没有失效，强制缓存生效，直接返回该结果：</p><p><img src="/images/network-basic/HttpForceCache3.png"></p><p><strong>强制缓存的缓存规则</strong></p><p>当浏览器向服务器发送请求的时候，服务器会将缓存规则（放入HTTP响应的报文的HTTP头中和请求结果一起）返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Conctrol的优先级比Expires高。</p><ol><li>Expires</li></ol><p>Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求的结果缓存的到期时间（绝对时间），即再次发送请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。</p><p>到了HTTP/1.1，Expires已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，如果客户端与服务端的时间由于某些原因（时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存直接失效，那么强制缓存存在的意义就毫无意义。</p><ol><li>Cache-Control</li></ol><p>取值为：</p><ul><li>public：所有内容都将被缓存（客户端和代理服务器都可缓存）</li><li>private：所有内容只有客户端可以缓存，Cache-Control的默认取值</li><li>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li><li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li><li>max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效（相对时间）</li></ul><p><strong>浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？</strong></p><p>内存缓存(from memory cache)和硬盘缓存(from disk cache):</p><ol><li>内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性：</li></ol><ul><li>快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。</li><li>时效性：一旦该进程关闭，则该进程的内存则会清空。</li></ul><ol start="2"><li>硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。</li></ol><p>在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。</p><p>行为分析：</p><p>访问某个网站 –&gt; 200 –&gt; 关闭博客的标签页 –&gt; 重新打开网站（渲染） –&gt; 200(from disk cache) –&gt; 刷新 –&gt; 200(from memory cache)。ctrl+F5 强制刷新就会200 发起新的请求而忽略缓存。</p><h4 id="6-3-5-2-协商缓存"><a href="#6-3-5-2-协商缓存" class="headerlink" title="6.3.5.2. 协商缓存"></a>6.3.5.2. 协商缓存</h4><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p><ol><li>协商缓存生效，返回304：</li></ol><p><img src="/images/network-basic/HttpConsultCacheSucc.png"></p><ol start="2"><li>协商缓存失败，返回200和请求结果：</li></ol><p><img src="/images/network-basic/HttpConsultCacheFail.png"></p><p>同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：</p><ul><li>Last-Modified / If-Modified-Since</li><li>Etag / If-None-Match</li></ul><p>其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。</p><p><strong>Last-Modified / If-Modified-Since</strong></p><ol><li>Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间，时间值。</li><li>If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，告诉服务器上次请求该资源时返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比：</li></ol><ul><li>若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；</li><li>否则则返回304，代表资源无更新，可继续使用缓存文件。</li></ul><p><strong>Etag / If-None-Match</strong></p><ol><li>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)</li><li>If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比：</li></ol><ul><li>一致则返回304，代表资源无更新，继续使用缓存文件；</li><li>不一致则重新返回资源文件，状态码为200。</li></ul><h4 id="6-3-5-3-总结"><a href="#6-3-5-3-总结" class="headerlink" title="6.3.5.3. 总结"></a>6.3.5.3. 总结</h4><p>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)</p><p>协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存，主要过程如下：</p><p><img src="/images/network-basic/HttpCache.png"></p><h3 id="6-3-6-session和cookie"><a href="#6-3-6-session和cookie" class="headerlink" title="6.3.6. session和cookie"></a>6.3.6. session和cookie</h3><p><strong>session与cookie的区别</strong></p><p>session：Session 是存放在服务器端的，类似于Session结构来存放用户数据，当浏览器 第一次发送请求时，服务器自动生成了一个Session和一个Session ID用来唯一标识这个Session，并将其通过响应发送到浏览器。当浏览器第二次发送请求，会将前一次服务器响应中的Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户对应的Session。由于Session存放在服务器端，所以随着时间的推移或者用户访问的增多，会给服务器增加负担。使用的时候要考虑下服务器的性能。</p><p>cookie：Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端会把Cookie保存起来。由于Cookie是存放在客户端，是可见的，安全性就会很低。因此不建议将一些重要的信息放在cookie中。</p><p><strong>区别</strong></p><ul><li>cookie存放在客户端，session存放在服务器端</li><li>cookie不是很安全，别人可以分析你本地的cookie信息进行cookie欺骗，因此重要信息应考虑保存在服务器端</li><li>session一定时间内回报存在服务器端，当访问量增大时，会影响服务器性能，从性能方面考虑应使用cookie</li><li>不同浏览器对cookie的数据大小限制不同，个数限制也不同</li><li>可以考虑将登陆信息等重要信息存放为session，不重要的信息可以放在cookie中</li></ul><p><strong>联系</strong></p><ul><li>都是用来记录用户的信息，以便让服务器分辨不同的用户</li><li>可以搭配使用，但都有自己的使用局限，要考虑到安全和性能的问题</li></ul><p><strong>如果客户端禁止 cookie，session 还能用吗？</strong></p><p>如果浏览器禁止cookie，那么客户端访问服务端时无法携带sessionid，服务端无法识别用户身份，便无法进行会话控制，session失效。但可以通过以下几种方法：</p><ul><li>URL重写：URL重写要求将站点中的所有超链接都进行改造，在超链接后用一个特殊的参数JSESSIONID保存当前浏览器对应session的编号，这样一来，当用户点击超链接访问服务器时，服务器可以从URL后的参数中分析出JSESSIONID，从而找到对应的sesison使用.</li><li>用文件、数据库等形式保存Session ID，在跨页过程中手动调用</li></ul><h2 id="6-4-输入URL之后会发生什么"><a href="#6-4-输入URL之后会发生什么" class="headerlink" title="6.4. 输入URL之后会发生什么"></a>6.4. 输入URL之后会发生什么</h2><h3 id="6-4-1-大纲"><a href="#6-4-1-大纲" class="headerlink" title="6.4.1. 大纲"></a>6.4.1. 大纲</h3><ol><li>浏览器解析URL</li><li>查找资源缓存</li><li>DNS解析</li><li>建立TCP连接（三次握手）</li><li>HTTP/HTTPS发起请求</li><li>对TCP报文打包，加入源IP地址和目标IP地址</li><li>网络层查询下一跳路由，ARP查询下一跳路由的MAC地址</li><li>数据链路层对IP报文打包并附上MAC地址</li><li>物理层发送数据</li><li>服务器处理请求，响应，浏览器接收HTTP响应</li><li>选择关闭TCP连接（四次挥手）</li><li>编码、解析构建规则树</li><li>渲染树</li></ol><h3 id="6-4-2-具体过程"><a href="#6-4-2-具体过程" class="headerlink" title="6.4.2. 具体过程"></a>6.4.2. 具体过程</h3><ul><li>浏览器解析URL获取协议、域名、端口、路径；</li><li>查看浏览器是否有资源的缓存<ul><li>有。判断是否过期<ul><li>没过期。直接读取缓存</li><li>过期。<ul><li>Etag和If-None-Match</li><li>Last-Modify和lf-Modified-Since</li><li>文件修改了则把新资源发给浏览器（状态码200），没修改则告诉浏览器读取缓存（状态码304）</li></ul></li></ul></li><li>没有则进行下一步</li></ul></li><li>DNS解析<ul><li>寻找浏览器是否存在缓存，若没有</li><li>寻找操作系统是否存在缓存，若没有</li><li>寻找hosts文件中是否有域名和ip的对应关系，若没有</li><li>查找路由器中是否有缓存</li><li>寻找DNS服务器是否没缓存，若没有</li><li>向本地域名服务器递归查询</li><li>本地域名服务器想根域名服务器迭代查询</li></ul></li><li>生成HTTP请求</li><li>建立TCP连接，三次握手<ul><li>客户端发送SYN=1，Seq=X</li><li>服务端发回SYN=1，ACK=X+1，Seq=Y</li><li>客户端发送ACK=Y+1，Seq=Y + 1</li></ul></li><li>如果是HTTP请求，对HTTP报文进行报文分割并标记序号和端口号</li><li>如果是HTTPS请求<ul><li>Client发起一个HTTPS的请求，并将自己支持的加密规则发给Server。</li><li>Server从中选出一资加密算法和HASH算法，把自己的身份信息以公钥证书形式返回给客户端。</li><li>Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。</li><li>Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥。</li><li>Client使用约定好的HASH算法计算握手消息，并用生成的随机数对消息加密，发给Server。</li><li>Server使用自己的私钥解密，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。使用密码解析Client发来的握手消息，并验证HASH是否一致。</li><li>Server使用对称密钥加密一段内容，发送给Client。</li><li>Client使用对称密钥解密响应的密文，并计算HASH，得到明文内容。</li></ul></li><li>对TCP报文打包，加入源IP地址和目标IP地址。</li><li>网络层根据目标IP地址和路由表，查询下一跳路由。使用ARP查询下一跳路由的MAC地址。</li><li> 数据链路层对IP报文打包并附上MAC地址。</li><li> 物理层发送数据。</li><li> 服务器在收到浏览器发送的HTTP请求之后，会将收到的HTTP报文封装成HTTP的Request对象，并通过不同的Web服务器进行处理，处理完的结果以HTTP的Response对象返回，主要包括状态码，响应头，响应报文三个部分。</li><li> 浏览器接收到HTTP响应，关闭TCP连接或保持复用，四次握手。</li><li> 如果说响应的内容是HTML文档的话，就需要浏览器进行解析渲染呈现给用户。</li><li> 根据响应头的字符集进行解码如果响应头没有字符集，则浏览器会默认用一套解码规则，当解析html解析到meta标签中的编码规则时，则替换成新的解码方式重新解码。</li><li> 浏览器通过解析HTML，生成DOM树，解析CSS，生成CSS规则树。</li><li> 然后通过DOM树和CSS规则树生成渲染树。渲染树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。repaint（重画颜色等，不影响布局）和reflow（组件的几何尺寸变了，重新验证并计算渲染树）。</li></ul><h1 id="7-参考链接"><a href="#7-参考链接" class="headerlink" title="7. 参考链接"></a>7. 参考链接</h1><ul><li>《计算机网络（第7版）》谢希仁，电子工业出版社</li><li><a href="https://www.cnblogs.com/maybe2030/p/4781555.html">计算机网络基础知识总结</a></li><li><a href="https://blog.csdn.net/yaopeng_2005/article/details/7064869">OSI七层模型详解</a></li><li><a href="https://www.cnblogs.com/zhengshiqiang47/p/8673559.html">HTTP协议以及HTTP2.0/1.1/1.0区别</a></li><li><a href="https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A">HTTP1.0、HTTP1.1 和 HTTP2.0 的区别</a></li><li><a href="https://blog.csdn.net/banana960531/article/details/85621865">HTTP常见状态码（14种）</a></li><li><a href="https://messiahhh.github.io/blog/frontend">菜鸟向前端指南</a></li><li><a href="https://www.cnblogs.com/wqhwe/p/5407468.html">HTTP与HTTPS的区别</a></li><li><a href="https://www.cnblogs.com/wuwuyong/p/12198928.html">计算机网络常见面试题</a></li><li><a href="https://www.cnblogs.com/inception6-lxc/p/9152691.html">计算机网络常见面试题</a></li><li><a href="https://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html">计算机网络之面试常考</a></li><li><a href="https://blog.csdn.net/weixin_41969587/article/details/88836161">HTTP请求和响应3：状态码（status）</a></li><li><a href="https://www.cnblogs.com/fanggege/p/13207204.html">http 状态码之3xx</a></li><li><a href="https://www.cnblogs.com/chengxs/p/10396066.html">彻底理解浏览器的缓存机制(htp绶存机制)</a></li><li><a href="https://mp.weixin.qq.com/s/DId9NRXF0SaMyCo27vmojg">这样看 B 站，可以更快！</a></li><li><a href="https://www.cnblogs.com/jxxblogs/p/12088924.html">session与cookie的区别？ 如果客户端禁止 cookie session 还能用吗？</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;概述、物理层、数据链路层、网络层、运输层、应用层。&lt;/p&gt;
&lt;p&gt;70页、5万字，超长总结。&lt;/p&gt;</summary>
    
    
    
    <category term="Study" scheme="https://memorykk.cn/categories/Study/"/>
    
    
    <category term="Network" scheme="https://memorykk.cn/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>网络爬虫基础</title>
    <link href="https://memorykk.cn/webCrawler-basic.html"/>
    <id>https://memorykk.cn/webCrawler-basic.html</id>
    <published>2021-03-13T04:48:16.000Z</published>
    <updated>2021-03-16T07:31:13.155Z</updated>
    
    <content type="html"><![CDATA[<p>待写</p><span id="more"></span><p>正文</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;待写&lt;/p&gt;</summary>
    
    
    
    <category term="Tool" scheme="https://memorykk.cn/categories/Tool/"/>
    
    
  </entry>
  
  <entry>
    <title>蓝桥杯Java</title>
    <link href="https://memorykk.cn/lanqiao-P11.html"/>
    <id>https://memorykk.cn/lanqiao-P11.html</id>
    <published>2021-03-10T12:50:02.000Z</published>
    <updated>2021-03-16T06:09:24.414Z</updated>
    
    <content type="html"><![CDATA[<p>第十一届蓝桥杯大赛软件类省赛Java大学B组第一场 &amp; 第一次校内模拟  &amp; 第三次校内模拟<br>详解及总结</p><span id="more"></span><hr><p><strong>目录</strong></p><ul><li><a href="#%E7%9C%81%E8%B5%9B">省赛</a><ul><li><a href="#A%E8%A7%A3%E5%AF%86">A解密</a></li><li><a href="#B%E7%BA%AA%E5%BF%B5%E6%97%A5">B纪念日</a></li><li><a href="#C%E5%90%88%E5%B9%B6%E6%A3%80%E6%B5%8B">C合并检测</a></li><li><a href="#D%E5%88%86%E9%85%8D%E5%8F%A3%E7%BD%A9">D分配口罩</a></li><li><a href="#E%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0">E斐波那契数列最大公约数</a></li><li><a href="#F%E5%88%86%E7%B1%BB%E8%AE%A1%E6%95%B0">F分类计数</a></li><li><a href="#G%E5%85%AB%E6%AC%A1%E6%B1%82%E5%92%8C">G八次求和</a></li><li><a href="#H%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81">H字符串编码</a></li><li><a href="#I%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9">I二叉搜索树插入节点</a></li></ul></li><li><a href="#%E6%A0%A1%E5%86%85%E6%A8%A1%E6%8B%9F%E8%B5%9B%E4%B8%80">校内模拟赛一</a><ul><li><a href="#A%E8%AE%A1%E7%AE%97">A计算</a></li><li><a href="#B%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0">B约数个数</a></li><li><a href="#C%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0">C叶节点数</a></li><li><a href="#D%E5%8C%85%E5%90%AB%E6%95%B0%E5%AD%979">D包含数字9</a></li><li><a href="#E%E6%95%B0%E4%BD%8D%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0">E数位递增的数</a></li><li><a href="#F%E9%80%92%E5%A2%9E%E4%B8%89%E5%85%83%E7%BB%84">F递增三元组</a></li><li><a href="#G%E9%9F%B3%E8%8A%82%E5%88%A4%E6%96%AD">G音节判断</a></li><li><a href="#H%E9%95%BF%E8%8D%89">H长草</a></li></ul></li><li><a href="#%E6%A0%A1%E5%86%85%E6%A8%A1%E6%8B%9F%E8%B5%9B%E4%B8%89">校内模拟赛三</a><ul><li><a href="#A">A</a></li><li><a href="#B">B</a></li><li><a href="#C">C</a></li><li><a href="#D">D</a></li><li><a href="#E">E</a></li><li><a href="#F">F</a></li><li><a href="#G">G</a></li><li><a href="#H">H</a></li><li><a href="#I">I</a></li><li><a href="#J">J</a></li></ul></li><li><a href="#%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%8D%A2">字符转换</a></li></ul><hr><h1 id="省赛"><a href="#省赛" class="headerlink" title="省赛"></a>省赛</h1><h2 id="A解密"><a href="#A解密" class="headerlink" title="A解密"></a>A解密</h2><p><img src="/images/lanqiao-P11/P11A1.png" alt="P11A1.png"><br><img src="/images/lanqiao-P11/P11A2.png" alt="P11A2.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String tc = <span class="string">&quot;yxmdacikntjhqlgoufszpwbrev&quot;</span>;</span><br><span class="line">        String str = <span class="string">&quot;EaFnjISplhFviDhwFbEjRjfIBBkRyY&quot;</span>;</span><br><span class="line">        String result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> xi;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (temp &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                temp += <span class="string">&#x27;a&#x27;</span> - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">                xi = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                xi = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result += (<span class="keyword">char</span>) (xi + tc.indexOf(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YeRikGSunlRzgDlvRwYkXkrGWWhXaA</span><br></pre></td></tr></table></figure><h2 id="B纪念日"><a href="#B纪念日" class="headerlink" title="B纪念日"></a>B纪念日</h2><p><img src="/images/lanqiao-P11/P11B.png" alt="P11B.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r=<span class="number">0</span>,p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1921</span>;i&lt;<span class="number">2020</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">100</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">400</span>==<span class="number">0</span>) &#123;</span><br><span class="line">                    r++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    p++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">4</span>==<span class="number">0</span>) &#123;</span><br><span class="line">                    r++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    p++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println((r*<span class="number">366</span>+p*<span class="number">365</span>-<span class="number">21</span>)*<span class="number">24</span>*<span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">52038720</span><br></pre></td></tr></table></figure><h2 id="C合并检测"><a href="#C合并检测" class="headerlink" title="C合并检测"></a>C合并检测</h2><p><img src="/images/lanqiao-P11/P11C.png" alt="P11C.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minK =<span class="number">0</span>,min=<span class="number">99999999</span>,temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">100</span> %i != <span class="number">0</span>)&#123;</span><br><span class="line">                temp =(<span class="number">100</span>/i)+i+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp=(<span class="number">100</span>/i)+i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp&lt;min)&#123;</span><br><span class="line">                min=temp;</span><br><span class="line">                minK=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(minK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="D分配口罩"><a href="#D分配口罩" class="headerlink" title="D分配口罩"></a>D分配口罩</h2><p><img src="/images/lanqiao-P11/P11D.png" alt="P11D.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *当要求在长度为n的大序列中取出长度为0-n的小序列时用DFS，一次性可求出，</span></span><br><span class="line"><span class="comment"> *如n=5,要求排列组合中求出A(1,5)、A(2,5)、...A(5,5)，跟穷举一样。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main4</span> </span>&#123;</span><br><span class="line"><span class="comment">//    public static int[] arr = &#123;9090400, 8499400, 5926800, 8547000, 4958200, 4422600, 5751200,4175600,</span></span><br><span class="line"><span class="comment">//    6309600, 5865200, 6604400, 4635000, 10663400, 8087200, 4554000&#125;;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">16</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[arr.length];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; arr.length; x++) &#123;</span><br><span class="line">            sum += arr[x];</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        System.out.println(min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= sum / <span class="number">2</span>) &#123;</span><br><span class="line">            min = Math.min(min, Math.abs(sum - index * <span class="number">2</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;___________________________________&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; arr.length; x++) &#123;</span><br><span class="line">            <span class="comment">//若未访问过</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[x]) &#123;</span><br><span class="line">                visited[x] = <span class="keyword">true</span>;</span><br><span class="line">                res[x]=arr[x];</span><br><span class="line">                dfs(index + arr[x]);</span><br><span class="line">                visited[x] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(index==<span class="number">0</span>||index==<span class="number">1</span>)</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+index+<span class="string">&quot;层--第&quot;</span>+x+<span class="string">&quot;个--&quot;</span>+Arrays.toString(res)+<span class="string">&quot;--结果：&quot;</span>+min);</span><br><span class="line">            res[x]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2400</span><br></pre></td></tr></table></figure><h2 id="E斐波那契数列最大公约数"><a href="#E斐波那契数列最大公约数" class="headerlink" title="E斐波那契数列最大公约数"></a>E斐波那契数列最大公约数</h2><p><img src="/images/lanqiao-P11/P11E.png" alt="P11E.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BigInteger arr[] = <span class="keyword">new</span> BigInteger[<span class="number">2025</span>]; <span class="comment">// int long型数据均会爆数组</span></span><br><span class="line">        arr[<span class="number">0</span>] = BigInteger.ZERO;</span><br><span class="line">        arr[<span class="number">1</span>] = arr[<span class="number">2</span>] = BigInteger.ONE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">2020</span>; i++) &#123;</span><br><span class="line">            arr[i] = arr[i - <span class="number">1</span>].add(arr[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(gcd(arr[<span class="number">2020</span>],arr[<span class="number">520</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigInteger <span class="title">gcd</span><span class="params">(BigInteger  a,BigInteger  b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.equals(BigInteger.ZERO)?a:gcd(b,a.mod(b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6765</span><br></pre></td></tr></table></figure><h2 id="F分类计数"><a href="#F分类计数" class="headerlink" title="F分类计数"></a>F分类计数</h2><p><img src="/images/lanqiao-P11/P11F.png" alt="P11F.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> H=<span class="number">0</span>,L=<span class="number">0</span>,D=<span class="number">0</span>;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = input.next();</span><br><span class="line">        <span class="keyword">char</span>[] arr = str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; arr[i]&lt;=<span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">                H++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i]&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; arr[i]&lt;=<span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">                L++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; arr[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                D++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(H);</span><br><span class="line">        System.out.println(L);</span><br><span class="line">        System.out.println(D);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G八次求和"><a href="#G八次求和" class="headerlink" title="G八次求和"></a>G八次求和</h2><p><img src="/images/lanqiao-P11/P11G.png" alt="P11G.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BigInteger base = <span class="keyword">new</span> BigInteger(<span class="keyword">new</span> Scanner(System.in).next());</span><br><span class="line">        BigInteger result = BigInteger.ZERO;</span><br><span class="line">        <span class="keyword">for</span>(BigInteger i=BigInteger.ONE;i.compareTo(base)&lt;<span class="number">1</span>;i=i.add(BigInteger.ONE))&#123;</span><br><span class="line">            result = result.add(i.pow(<span class="number">8</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result.mod(<span class="keyword">new</span> BigInteger(<span class="string">&quot;123456789&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H字符串编码"><a href="#H字符串编码" class="headerlink" title="H字符串编码"></a>H字符串编码</h2><p><img src="/images/lanqiao-P11/P11H.png" alt="P11H.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">char</span>[] arrC = <span class="keyword">new</span> Scanner(System.in).next().toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[arrC.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arrC.length;i++)&#123;</span><br><span class="line">            arr[i] = arrC[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;<span class="number">2</span>)&#123;</span><br><span class="line">                res += (<span class="keyword">char</span>)(arr[i]+<span class="string">&#x27;A&#x27;</span>-<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i]*<span class="number">10</span>+arr[i+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (temp &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    res += (<span class="keyword">char</span>)(temp+<span class="string">&#x27;A&#x27;</span>-<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    res += (<span class="keyword">char</span>)(arr[i] + <span class="string">&#x27;A&#x27;</span>-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="I二叉搜索树插入节点"><a href="#I二叉搜索树插入节点" class="headerlink" title="I二叉搜索树插入节点"></a>I二叉搜索树插入节点</h2><p><img src="/images/lanqiao-P11/P11I1.png" alt="P11I1.png"><br><img src="/images/lanqiao-P11/P11I2.png" alt="P11I2.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main9</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">        <span class="keyword">int</span> k = input.nextInt();</span><br><span class="line">        <span class="keyword">long</span> w[] = <span class="keyword">new</span> <span class="keyword">long</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> p[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="comment">//第i个节点权值w[i]，其父节点编号p[i],权值pw[i]</span></span><br><span class="line">            p[i] = input.nextInt();</span><br><span class="line">            w[i] = input.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> parentW=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> cntW=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;w.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i]==k)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                parentW=w[p[i]];</span><br><span class="line">                cntW=w[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==<span class="number">2</span>)&#123;</span><br><span class="line">            System.out.println(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//插入右子树</span></span><br><span class="line">            <span class="keyword">if</span>(cntW&lt;parentW)&#123;</span><br><span class="line">                <span class="comment">//K是其父的左子树</span></span><br><span class="line">                <span class="keyword">if</span>(w[k]&lt;w[p[k]])&#123;</span><br><span class="line">                    System.out.println(w[k]-w[p[k]]-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//K是其父的右子树</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.println(-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//插入左子树</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//K是其父的左子树</span></span><br><span class="line">                <span class="keyword">if</span>(w[k]&lt;w[p[k]])&#123;</span><br><span class="line">                    System.out.println(-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//K是其父的右子树</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.println(w[k]-w[p[k]]-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="校内模拟赛一"><a href="#校内模拟赛一" class="headerlink" title="校内模拟赛一"></a>校内模拟赛一</h1><h2 id="A计算"><a href="#A计算" class="headerlink" title="A计算"></a>A计算</h2><blockquote><p>在计算机存储中，15.125GB是多少MB？</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">1024</span>*<span class="number">15.125</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15488</span><br></pre></td></tr></table></figure><h2 id="B约数个数"><a href="#B约数个数" class="headerlink" title="B约数个数"></a>B约数个数</h2><blockquote><p>1200000有多少个约数（只计算正约数）。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1200000</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">1200000</span>%i==<span class="number">0</span>)&#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">96</span><br></pre></td></tr></table></figure><h2 id="C叶节点数"><a href="#C叶节点数" class="headerlink" title="C叶节点数"></a>C叶节点数</h2><blockquote><p>一棵包含有2019个结点的二叉树，最多包含多少个叶结点？</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n0&#x3D;n2+1</span><br><span class="line">n0+n1+n2&#x3D;2019</span><br><span class="line"></span><br><span class="line">max(n0)&#x3D;1010</span><br></pre></td></tr></table></figure><h2 id="D包含数字9"><a href="#D包含数字9" class="headerlink" title="D包含数字9"></a>D包含数字9</h2><blockquote><p>在1至2019中，有多少个数的数位中包含数字9？<br>注意，有的数中的数位中包含多个9，这个数只算一次。例如，1999这个数包含数字9，在计算只是算一个数。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2019</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] arr=(String.valueOf(i)).toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]==<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">544</span><br></pre></td></tr></table></figure><h2 id="E数位递增的数"><a href="#E数位递增的数" class="headerlink" title="E数位递增的数"></a>E数位递增的数</h2><blockquote><p>【问题描述】<br>一个正整数如果任何一个数位不大于右边相邻的数位，则称为一个数位递增的数，例如1135是一个数位递增的数，而1024不是一个数位递增的数。<br>给定正整数 n，请问在整数 1 至 n 中有多少个数位递增的数？<br>【输入格式】<br>输入的第一行包含一个整数 n。<br>【输出格式】<br>输出一行包含一个整数，表示答案。<br>【样例输入】<br>30<br>【样例输出】<br>26<br>【评测用例规模与约定】<br>对于 40% 的评测用例，1 &lt;= n &lt;= 1000。<br>对于 80% 的评测用例，1 &lt;= n &lt;= 100000。<br>对于所有评测用例，1 &lt;= n &lt;= 1000000。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> n = <span class="keyword">new</span> Scanner(System.in).nextLong();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] arr=(<span class="string">&quot;&quot;</span>+i).toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;arr.length-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j==arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F递增三元组"><a href="#F递增三元组" class="headerlink" title="F递增三元组"></a>F递增三元组</h2><blockquote><p>【问题描述】<br>在数列 a[1], a[2], …, a[n] 中，如果对于下标 i, j, k 满足 0&lt;i&lt;j&lt;k&lt;n+1 且 a[i]&lt;a[j]&lt;a[k]，则称 a[i], a[j], a[k] 为一组递增三元组，a[j]为递增三元组的中心。<br>给定一个数列，请问数列中有多少个元素可能是递增三元组的中心。<br>【输入格式】<br>输入的第一行包含一个整数 n。<br>第二行包含 n 个整数 a[1], a[2], …, a[n]，相邻的整数间用空格分隔，表示给定的数列。<br>【输出格式】<br>输出一行包含一个整数，表示答案。<br>【样例输入】<br>5<br>1 2 5 3 5<br>【样例输出】<br>2<br>【样例说明】<br>a[2] 和 a[4] 可能是三元组的中心。<br>【评测用例规模与约定】<br>对于 50% 的评测用例，2 &lt;= n &lt;= 100，0 &lt;= 数列中的数 &lt;= 1000。<br>对于所有评测用例，2 &lt;= n &lt;= 1000，0 &lt;= 数列中的数 &lt;= 10000。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> index = input.nextInt() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">        <span class="keyword">boolean</span>[] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[index];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = input.nextInt();</span><br><span class="line">            flag[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; arr.length; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (arr[j] &lt; arr[k] &amp;&amp; !flag[j]) &#123;</span><br><span class="line">                            flag[j] = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[i])&#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G音节判断"><a href="#G音节判断" class="headerlink" title="G音节判断"></a>G音节判断</h2><blockquote><p>【问题描述】<br>小明对类似于 hello 这种单词非常感兴趣，这种单词可以正好分为四段，第一段&gt; 由一个或多个辅音字母组成，第二段由一个或多个元音字母组成，第三段由一个或多个辅音字母组成，第四段由一个或多个元音字母组成。<br>给定一个单词，请判断这个单词是否也是这种单词，如果是请输出yes，否则请输出no。<br>元音字母包括 a, e, i, o, u，共五个，其他均为辅音字母。<br>【输入格式】<br>输入一行，包含一个单词，单词中只包含小写英文字母。<br>【输出格式】<br>输出答案，或者为yes，或者为no。<br>【样例输入】<br>lanqiao<br>【样例输出】<br>yes<br>【样例输入】<br>world<br>【样例输出】<br>no<br>【评测用例规模与约定】<br>对于所有评测用例，单词中的字母个数不超过100。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//public class Main7 &#123;</span></span><br><span class="line"><span class="comment">//    public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">//        int ex=0;</span></span><br><span class="line"><span class="comment">//        char[] arr=new Scanner(System.in).nextLine().toCharArray();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        if(isYuan(arr[0]))&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;no&quot;);</span></span><br><span class="line"><span class="comment">//            return;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        if(!isYuan(arr[arr.length-1]))&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;no&quot;);</span></span><br><span class="line"><span class="comment">//            return;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        for(int i=0;i&lt;arr.length-1;i++)&#123;</span></span><br><span class="line"><span class="comment">//            if(!isYuan(arr[i]))&#123;</span></span><br><span class="line"><span class="comment">//                if(isYuan(arr[i+1])) &#123;</span></span><br><span class="line"><span class="comment">//                    ex++;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;else&#123;</span></span><br><span class="line"><span class="comment">//                if(!isYuan(arr[i+1])) &#123;</span></span><br><span class="line"><span class="comment">//                    ex++;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        if(ex==3)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;yes&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;else&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;no&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    public static boolean isYuan(char c)&#123;</span></span><br><span class="line"><span class="comment">//        if(c==&#x27;a&#x27;||c==&#x27;e&#x27;||c==&#x27;i&#x27;||c==&#x27;o&#x27;||c==&#x27;u&#x27;)&#123;</span></span><br><span class="line"><span class="comment">//            return true;</span></span><br><span class="line"><span class="comment">//        &#125;else&#123;</span></span><br><span class="line"><span class="comment">//            return false;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正则表达式解法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">&quot;[^aeiou]+[aeiou]+[^aeiou]+[aeiou]+&quot;</span>);</span><br><span class="line">        Matcher m = p.matcher(<span class="keyword">new</span> Scanner(System.in).nextLine());</span><br><span class="line">        <span class="keyword">if</span> (m.matches()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H长草"><a href="#H长草" class="headerlink" title="H长草"></a>H长草</h2><blockquote><p>【问题描述】<br>小明有一块空地，他将这块空地划分为 n 行 m 列的小块，每行和每列的长度都为 1。<br>小明选了其中的一些小块空地，种上了草，其他小块仍然保持是空地。<br>这些草长得很快，每个月，草都会向外长出一些，如果一个小块种了草，则它将向自己的上、下、左、右四小块空地扩展，这四小块空地都将变为有草的小块。<br>请告诉小明，k 个月后空地上哪些地方有草。<br>【输入格式】<br>输入的第一行包含两个整数 n, m。<br>接下来 n 行，每行包含 m 个字母，表示初始的空地状态，字母之间没有空格。如果为小数点，表示为空地，如果字母为 g，表示种了草。<br>接下来包含一个整数 k。<br>【输出格式】<br>输出 n 行，每行包含 m 个字母，表示 k 个月后空地的状态。如果为小数点，表示为空地，如果字母为 g，表示长了草。<br>【样例输入】<br>4 5<br>.g…<br>…..<br>..g..<br>…..<br>2<br>【样例输出】<br>gggg.<br>gggg.<br>ggggg<br>.ggg.<br>【评测用例规模与约定】<br>对于 30% 的评测用例，2 &lt;= n, m &lt;= 20。<br>对于 70% 的评测用例，2 &lt;= n, m &lt;= 100。<br>对于所有评测用例，2 &lt;= n, m &lt;= 1000，1 &lt;= k &lt;= 1000。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n=input.nextInt();</span><br><span class="line">        <span class="keyword">int</span> m=input.nextInt();</span><br><span class="line">        <span class="keyword">char</span>[][] arr = <span class="keyword">new</span> <span class="keyword">char</span>[n][m];</span><br><span class="line">        <span class="keyword">boolean</span>[][] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][m];</span><br><span class="line">        input.nextLine();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            String temp = input.nextLine();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                arr[i][j]=temp.charAt(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = input.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//刷新标记</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[i][j]==<span class="string">&#x27;g&#x27;</span>)&#123;</span><br><span class="line">                        flag[i][j]=<span class="keyword">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        flag[i][j]=<span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[i][j]==<span class="string">&#x27;g&#x27;</span> &amp;&amp; flag[i][j]) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(i-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; arr[i-<span class="number">1</span>][j]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                            arr[i-<span class="number">1</span>][j]=<span class="string">&#x27;g&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n &amp;&amp; arr[i+<span class="number">1</span>][j]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                            arr[i+<span class="number">1</span>][j]=<span class="string">&#x27;g&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(j-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; arr[i][j-<span class="number">1</span>]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                            arr[i][j-<span class="number">1</span>]=<span class="string">&#x27;g&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(j+<span class="number">1</span>&lt;m &amp;&amp; arr[i][j+<span class="number">1</span>]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                            arr[i][j+<span class="number">1</span>]=<span class="string">&#x27;g&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                System.out.print((arr[i][j]));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="校内模拟赛三"><a href="#校内模拟赛三" class="headerlink" title="校内模拟赛三"></a>校内模拟赛三</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><blockquote><p>请问在 1 到 2020 中，有多少个数与 2020 互质，即有多少个数与 2020 的最大公约数为 1。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2020</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(gcd(<span class="number">2020</span>,i)==<span class="number">1</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i%j==<span class="number">0</span>)?j:gcd(j,i%j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">800</span><br></pre></td></tr></table></figure><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><blockquote><p>ASCII 码将每个字符对应到一个数值（编码），用于信息的表示和传输。在 ASCII 码中，英文字母是按从小到大的顺序依次编码的，例如：字母 A 编码是 65, 字母 B 编码是 66，字母 C 编码是 67，请问字母 Q 编码是多少？</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println((<span class="keyword">int</span>)<span class="string">&#x27;Q&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">81</span><br></pre></td></tr></table></figure><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote><p>有一棵二叉树，一个由2021个结点，其中有1000个结点有两个子结点，其他的结点有一个或者0个子结点。<br>请问，这棵二叉树有多少个叶结点？</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n0&#x3D;n2+1</span><br><span class="line">n2&#x3D;1000</span><br><span class="line"></span><br><span class="line">n0&#x3D;1001</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1001</span><br></pre></td></tr></table></figure><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote><p>对于整数 v 和 p，定义 Pierce 序列为：<br>　　a[1] = v<br>　　a[i] = p % a[i-1]<br>　　例如，当 v = 8, p = 21 时，对应的 Pierce 序列为<br>　　a[1] = 8<br>　　a[2] = 5<br>　　a[3] = 1<br>　　再往后计算，值变为 0，不在我们考虑的范围内。因此当 v = 8, p = 21 时， Pierce 序列的长度为 3。<br>　　当 p 一定时，对于不同的 v 值，Pierce 序列的长度可能不同。<br>　　当 p=2021 时，最长的 Pierce 序列出现在 v=1160 时，请问这个序列有多长？</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v=<span class="number">1160</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">1</span>,p=<span class="number">2021</span>;</span><br><span class="line">        <span class="keyword">while</span>(v!=<span class="number">1</span>)&#123;</span><br><span class="line">            v = p%v;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote><p>在 Excel 中，第 1 列到第 26 列的列名依次为 A 到 Z，从第 27 列开始，列名有两个字母组成，第 27 列到第 702 列的列名依次为 AA 到 ZZ。之后的列再用 3 个字母、4 个字母表示。<br>请问，第 2021 列的列名是什么？</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">2021</span>;</span><br><span class="line">        <span class="keyword">int</span> i=p/(<span class="number">26</span>*<span class="number">26</span>);</span><br><span class="line">        <span class="keyword">int</span> j=(p%(<span class="number">26</span>*<span class="number">26</span>))/<span class="number">26</span>;</span><br><span class="line">        <span class="keyword">int</span> k=p-i*<span class="number">26</span>*<span class="number">26</span>-j*<span class="number">26</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>) (<span class="string">&#x27;A&#x27;</span> + i - <span class="number">1</span>) + <span class="string">&quot;&quot;</span> + (<span class="keyword">char</span>) (<span class="string">&#x27;A&#x27;</span> + j - <span class="number">1</span>) + <span class="string">&quot;&quot;</span> + (<span class="keyword">char</span>) (<span class="string">&#x27;A&#x27;</span> + k - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>) (<span class="string">&#x27;A&#x27;</span> + j - <span class="number">1</span>) + <span class="string">&quot;&quot;</span> + (<span class="keyword">char</span>) (<span class="string">&#x27;A&#x27;</span> + k - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>) ((<span class="keyword">char</span>) (<span class="string">&#x27;A&#x27;</span> + k - <span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BYS</span><br></pre></td></tr></table></figure><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote><p>【问题描述】<br>斐波那契数列是这样一个数列：它的第一项和第二项都是1，从第三项开始每一项都是前两项的和。<br>根据以上定义，我们容易计算出斐波那契数列的前几项依次是：1, 1, 2, 3, 5, 8, 13, 21, 34, 55 ……<br>现在请你计算斐波那契数列第N项是奇数还是偶数？</p><p>【输入格式】<br>输入的包含一个整数N。</p><p>【输出格式】<br>如果是奇数输出1，是偶数输出0。</p><p>【样例输入】<br>10</p><p>【样例输出】<br>1</p><p>【提示】<br>找规律。</p><p>【评测用例规模与约定】<br>对于所有评测用例，1 &lt;= N &lt;= 1000000000。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="keyword">new</span> Scanner(System.in).nextInt();</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><blockquote><p>【问题描述】<br>在书写一个较大的整数时，为了方便看清数位，通常会在数位之间加上逗号来分割数位，具体的，从右向左，每三位分成一段，相邻的段之间加一个逗号。<br>例如，1234567 写成 1,234,567。<br>例如，17179869184 写成 17,179,869,184。<br>给定一个整数，请将这个整数增加分割符后输出。</p><p>【输入格式】<br>输入一行包含一个整数 v。</p><p>【输出格式】<br>输出增加分割符后的整数。</p><p>【样例输入】<br>1234567</p><p>【样例输出】<br>1,234,567</p><p>【样例输入】<br>17179869184</p><p>【样例输出】<br>17,179,869,184</p><p>【评测用例规模与约定】<br>对于 50% 的评测用例，0 &lt;= v &lt; 10^9 (10的9次方)。<br>对于所有评测用例，0 &lt;= v &lt; 10^18 (10的18次方)。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String temp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">char</span>[] arr=<span class="keyword">new</span> Scanner(System.in).next().toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] tempArr=<span class="keyword">new</span> <span class="keyword">char</span>[arr.length*<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=arr.length;i++)&#123;</span><br><span class="line">            temp += arr[arr.length-i];</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span> &amp;&amp; i!=arr.length)&#123;</span><br><span class="line">                temp += <span class="string">&quot;,&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tempArr = temp.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= tempArr.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            System.out.print(tempArr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><blockquote><p>【问题描述】<br>给定一个矩阵 M，由 n 行 m 列组成，第 i 行第 j 列值为 M[i][j]。<br>定义矩阵 M 的重量为矩阵中所有元素的和，几位weight(M)<br>请找到矩阵左上角的一个子矩阵S（矩阵的前 r 行中的前 c 列组成），使得这个子矩阵的重量的两倍最接近矩阵 M 重量。即 |2 weight(S)-weight(M)| 最小。<br>如果有多个子矩阵满足条件，请找出面积 r * c 最小的一个。<br>如果仍然有多个子矩阵满足条件，请找出其中 r 最小的一个。</p><p>【输入格式】<br>输入第一行包含两个整数 n, m，表示矩阵的大小。<br>接下来 n 行，每行 m 个整数，表示给定的矩阵M。</p><p>【输出格式】<br>输出一行，包含两个整数 r, c，表示子矩阵为矩阵 M 的前 r 行中的前 c 列。</p><p>【样例输入】<br>3 4<br>3 0 1 1<br>1 0 1 1<br>1 1 -2 4</p><p>【样例输出】<br>2 3</p><p>【评测用例规模与约定】<br>对于 30% 的评测用例，1 &lt;= n, m &lt;= 20, -10 &lt;= M[i][j] &lt;= 10。<br>对于 50% 的评测用例，1 &lt;= n, m &lt;= 100, -100 &lt;= M[i][j] &lt;= 100。<br>对于所有评测用例，1 &lt;= n, m &lt;= 1000, -1000 &lt;= M[i][j] &lt;= 1000。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">        <span class="keyword">int</span> m = input.nextInt();</span><br><span class="line">        <span class="keyword">int</span> weight=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span> [n*m];</span><br><span class="line">        <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span> [n*m];</span><br><span class="line">        <span class="comment">//权值</span></span><br><span class="line">        <span class="keyword">int</span> arr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="comment">//权值和</span></span><br><span class="line">        <span class="keyword">int</span> weightArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="comment">//差值</span></span><br><span class="line">        <span class="keyword">int</span> diffArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                arr[i][j] = input.nextInt();</span><br><span class="line">                weight += arr[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        weight /= <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//遍历计算第一行的权值和</span></span><br><span class="line">        <span class="keyword">int</span> tempWeight=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            tempWeight += arr[i][<span class="number">0</span>];</span><br><span class="line">            weightArr[i][<span class="number">0</span>] = tempWeight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历计算第一列的权值和</span></span><br><span class="line">        tempWeight=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            tempWeight += arr[<span class="number">0</span>][j];</span><br><span class="line">            weightArr[<span class="number">0</span>][j] = tempWeight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出计算所有项对应的权值和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">                weightArr[i][j] = arr[i][j] + weightArr[i-<span class="number">1</span>][j] + weightArr[i][j-<span class="number">1</span>] - weightArr[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找出最小差值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                diffArr[i][j] = Math.abs(weightArr[i][j]-weight);</span><br><span class="line">                <span class="keyword">if</span>(diffArr[i][j]&lt;min)&#123;</span><br><span class="line">                    min = diffArr[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(min);</span><br><span class="line">        <span class="comment">//统计最小值的个数cnt，并将下标记录在数组r[]c[]</span></span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(diffArr[i][j]==min)&#123;</span><br><span class="line">                    r[cnt]=i;</span><br><span class="line">                    c[cnt]=j;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//差值唯一</span></span><br><span class="line">        <span class="keyword">int</span>[] diffRC = <span class="keyword">new</span> <span class="keyword">int</span>[cnt];</span><br><span class="line">        <span class="keyword">int</span> minRC = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(cnt==<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="string">&quot;A:&quot;</span>+r[<span class="number">0</span>]+<span class="number">1</span>)+<span class="string">&quot; &quot;</span>+(c[<span class="number">0</span>]+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有多个相等的差值，判断r*c</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">                diffRC[i] = (r[i]+<span class="number">1</span>)*(c[i]+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(diffRC[i]&lt;minRC)&#123;</span><br><span class="line">                    minRC=diffRC[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计最小的R*C，个数cntRC</span></span><br><span class="line">        <span class="keyword">int</span> cntRC=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] diffR = <span class="keyword">new</span> <span class="keyword">int</span>[cnt];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(diffRC[i]==minRC)&#123;</span><br><span class="line">                diffR[cntRC]=i;</span><br><span class="line">                System.out.println(<span class="string">&quot;diffR[cntRC]：&quot;</span>+(r[diffR[cntRC]]+<span class="number">1</span>)+<span class="string">&quot; &quot;</span>+(c[diffR[cntRC]]+<span class="number">1</span>));</span><br><span class="line">                System.out.println(minRC);</span><br><span class="line">                cntRC++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;cntRC:&quot;</span>+cntRC);</span><br><span class="line">        <span class="keyword">int</span> minR = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> minRi = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//只有一个最小的R*C</span></span><br><span class="line">        <span class="keyword">if</span>(cntRC==<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="string">&quot;B:&quot;</span>+r[diffR[<span class="number">0</span>]]+<span class="number">1</span>)+<span class="string">&quot; &quot;</span>+(c[diffR[<span class="number">0</span>]]+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有多个最小的R*C，输出最小的R minR</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cntRC;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(r[diffR[i]]&lt;minR)&#123;</span><br><span class="line">                    minR=r[diffR[i]];</span><br><span class="line">                    minRi=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println((<span class="string">&quot;C:&quot;</span>+(r[diffR[minRi]]+<span class="number">1</span>))+<span class="string">&quot; &quot;</span>+(c[diffR[minRi]]+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">2 4 -2</span></span><br><span class="line"><span class="comment">6 0 2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">-----</span></span><br><span class="line"><span class="comment">12:6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2 6 4</span></span><br><span class="line"><span class="comment">8 12 12</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4 0 2</span></span><br><span class="line"><span class="comment">2 6 6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">3 0 1 1</span></span><br><span class="line"><span class="comment">1 0 1 1</span></span><br><span class="line"><span class="comment">1 1 -2 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">1 -1 1</span></span><br><span class="line"><span class="comment">-1 1 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><blockquote><p>【问题描述】<br>杂货铺老板一共有N件物品，每件物品具有ABC三种属性中的一种或多种。从杂货铺老板处购得一件物品需要支付相应的代价。<br>现在你需要计算出如何购买物品，可以使得ABC三种属性中的每一种都在至少一件购买的物品中出现，并且支付的总代价最小。</p><p>【输入格式】<br>输入第一行包含一个整数N。<br>以下N行，每行包含一个整数C和一个只包含”ABC”的字符串，代表购得该物品的代价和其具有的属性。</p><p>【输出格式】<br>输出一个整数，代表最小的代价。如果无论如何凑不齐ABC三种属性，输出-1。</p><p>【样例输入】<br>5<br>10 A<br>9 BC<br>11 CA<br>4 A<br>5 B</p><p>【样例输出】<br>13</p><p>【评测用例规模与约定】<br>对于50%的评测用例，1 &lt;= N &lt;= 20<br>对于所有评测用例，1 &lt;= N &lt;= 1000， 1 &lt;= C &lt;= 100000</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main91</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n=input.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] flag = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        Arrays.fill(flag,Integer.MAX_VALUE);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> w = input.nextInt();</span><br><span class="line">            v=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">char</span>[] str = input.next().toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;str.length;j++)&#123;</span><br><span class="line">                v |= <span class="number">1</span>&lt;&lt;(str[j]-<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;flag.length;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((k&amp;v)!=v &amp;&amp; flag[k]!=Integer.MAX_VALUE &amp;&amp; w+flag[k]&lt;flag[k|v])&#123;</span><br><span class="line">                    flag[k|v] = w+flag[k];</span><br><span class="line">                &#125;</span><br><span class="line">                flag[v]=Math.min(flag[v],w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(flag[<span class="number">7</span>]==Integer.MAX_VALUE?-<span class="number">1</span>:flag[<span class="number">7</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="J"><a href="#J" class="headerlink" title="J"></a>J</h2><blockquote><p>记不清了，之后补吧。<br>大意是：<br>输入一个n*m的数组，求出每个元素与它周围一圈的元素中最大的元素，输出数组</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 当时考试没想到，就“硬”写出来的暴力，不推荐</span></span><br><span class="line"><span class="comment"> * 更好的方法是读入矩阵并将其放置在比它大一圈的数组中，保持数据在中央，边缘置为</span></span><br><span class="line"><span class="comment"> * 这样就不用考虑4、6个的情况，只需要比较9个数的函数就可以</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">        <span class="keyword">int</span> m = input.nextInt();</span><br><span class="line">        <span class="keyword">int</span> arr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="keyword">int</span> res[][] = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                arr[i][j] = input.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>) &#123;</span><br><span class="line">        res[<span class="number">0</span>][i]=max4(arr[<span class="number">0</span>][<span class="number">0</span>],arr[<span class="number">0</span>][<span class="number">1</span>],arr[<span class="number">1</span>][<span class="number">0</span>],arr[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i==m-<span class="number">1</span>) &#123;</span><br><span class="line">        res[<span class="number">0</span>][i]=max4(arr[<span class="number">0</span>][m-<span class="number">1</span>],arr[<span class="number">0</span>][m-<span class="number">2</span>],arr[<span class="number">1</span>][m-<span class="number">1</span>],arr[<span class="number">1</span>][m-<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        res[<span class="number">0</span>][i]=max6(arr[<span class="number">0</span>][i-<span class="number">1</span>],arr[<span class="number">0</span>][i],arr[<span class="number">0</span>][i+<span class="number">1</span>],arr[<span class="number">1</span>][i-<span class="number">1</span>],arr[<span class="number">1</span>][i],arr[<span class="number">1</span>][i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>) &#123;</span><br><span class="line">        res[n-<span class="number">1</span>][i]=max4(arr[n-<span class="number">1</span>][<span class="number">0</span>],arr[n-<span class="number">1</span>][<span class="number">1</span>],arr[n-<span class="number">2</span>][<span class="number">0</span>],arr[n-<span class="number">2</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i==m-<span class="number">1</span>) &#123;</span><br><span class="line">        res[n-<span class="number">1</span>][i]=max4(arr[n-<span class="number">1</span>][m-<span class="number">1</span>],arr[n-<span class="number">1</span>][m-<span class="number">2</span>],arr[n-<span class="number">2</span>][m-<span class="number">1</span>],arr[n-<span class="number">2</span>][m-<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        res[n-<span class="number">1</span>][i]=max6(arr[n-<span class="number">1</span>][i-<span class="number">1</span>],arr[n-<span class="number">1</span>][i],arr[n-<span class="number">1</span>][i+<span class="number">1</span>],arr[n-<span class="number">2</span>][i-<span class="number">1</span>],arr[n-<span class="number">2</span>][i],arr[n-<span class="number">2</span>][i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n-<span class="number">1</span>;i++) &#123;</span><br><span class="line">        res[i][<span class="number">0</span>]=max6(arr[i-<span class="number">1</span>][<span class="number">0</span>],arr[i][<span class="number">0</span>],arr[i+<span class="number">1</span>][<span class="number">0</span>],arr[i-<span class="number">1</span>][<span class="number">1</span>],arr[i][<span class="number">1</span>],arr[i+<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n-<span class="number">1</span>;i++) &#123;</span><br><span class="line">        res[i][m-<span class="number">1</span>]=max6(arr[i-<span class="number">1</span>][m-<span class="number">1</span>],arr[i][m-<span class="number">1</span>],arr[i+<span class="number">1</span>][m-<span class="number">1</span>],arr[i-<span class="number">1</span>][m-<span class="number">2</span>],arr[i][m-<span class="number">2</span>],arr[i+<span class="number">1</span>][m-<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//中间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n-<span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m-<span class="number">1</span>;j++) &#123;</span><br><span class="line">        res[i][j]=max9(arr[i-<span class="number">1</span>][j-<span class="number">1</span>],arr[i-<span class="number">1</span>][j],arr[i-<span class="number">1</span>][j+<span class="number">1</span>],arr[i][j-<span class="number">1</span>],arr[i][j],arr[i][j+<span class="number">1</span>],arr[i+<span class="number">1</span>][j-<span class="number">1</span>],arr[i+<span class="number">1</span>][j],arr[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==m-<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print(res[i][j]);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.print(res[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max4</span><span class="params">(<span class="keyword">int</span> a0,<span class="keyword">int</span> a1,<span class="keyword">int</span> a2,<span class="keyword">int</span> a3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">    a[<span class="number">0</span>] = a0;</span><br><span class="line">    a[<span class="number">1</span>] = a1;</span><br><span class="line">    a[<span class="number">2</span>] = a2;</span><br><span class="line">    a[<span class="number">3</span>] = a3;</span><br><span class="line">    <span class="keyword">int</span> temp = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]&gt;temp) &#123;</span><br><span class="line">    temp = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max6</span><span class="params">(<span class="keyword">int</span> a0,<span class="keyword">int</span> a1,<span class="keyword">int</span> a2,<span class="keyword">int</span> a3,<span class="keyword">int</span> a4,<span class="keyword">int</span> a5)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>];</span><br><span class="line">    a[<span class="number">0</span>] = a0;</span><br><span class="line">    a[<span class="number">1</span>] = a1;</span><br><span class="line">    a[<span class="number">2</span>] = a2;</span><br><span class="line">    a[<span class="number">3</span>] = a3;</span><br><span class="line">    a[<span class="number">4</span>] = a4;</span><br><span class="line">    a[<span class="number">5</span>] = a5;</span><br><span class="line">    <span class="keyword">int</span> temp = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]&gt;temp) &#123;</span><br><span class="line">    temp = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max9</span><span class="params">(<span class="keyword">int</span> a0,<span class="keyword">int</span> a1,<span class="keyword">int</span> a2,<span class="keyword">int</span> a3,<span class="keyword">int</span> a4,<span class="keyword">int</span> a5,<span class="keyword">int</span> a6,<span class="keyword">int</span> a7,<span class="keyword">int</span> a8)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>];</span><br><span class="line">    a[<span class="number">0</span>] = a0;</span><br><span class="line">    a[<span class="number">1</span>] = a1;</span><br><span class="line">    a[<span class="number">2</span>] = a2;</span><br><span class="line">    a[<span class="number">3</span>] = a3;</span><br><span class="line">    a[<span class="number">4</span>] = a4;</span><br><span class="line">    a[<span class="number">5</span>] = a5;</span><br><span class="line">    a[<span class="number">6</span>] = a6;</span><br><span class="line">    a[<span class="number">7</span>] = a7;</span><br><span class="line">    a[<span class="number">8</span>] = a8;</span><br><span class="line">    <span class="keyword">int</span> temp = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]&gt;temp) &#123;</span><br><span class="line">    temp = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="K"><a href="#K" class="headerlink" title="K"></a>K</h2><blockquote><p>给定一个序列 (a_1, a_2, …, a_n), 它的一个上升子序列是指从序列中取出一些元素，按照原来的顺序排列后，是单调递增的序列。<br> 例如，对于序列 (3, 2, 7, 6, 7)，取出下标为 2, 4, 5 的元素 a_2, a_4, a_5，即 2, 6, 7，是一个上升子序列。<br> 在这个序列中，有 7 个长度为 2 的上升子序列，例如</p><p>   下标 1, 3 对应的 3, 7；<br>　　1. 下标 1, 4 对应的 3, 6；<br>　　2. 下标 1, 5 对应的 3, 7；<br>　　3. 下标 2, 3 对应的 2, 7；<br>　　4. 下标 2, 4 对应的 2, 6；<br>　　5. 下标 2, 5 对应的 2, 7；<br>　　6. 下标 4, 5 对应的 6, 7。<br>注意，可能有下标不同但对应数值相同的上升子序列，他们应当算成不同的上升子序列。<br>　　给定序列，请问序列中一共有多少个长度为 k 的上升子序列。<br>输入格式<br>　　输入第一行包含两个整数 n, k，表示序列的长度和上升子序列的长度。<br>　　第二行包含 n 个整数 a_1, a_2, …, a_n，表示给定的序列。<br>输出格式<br>　　输出一行，包含一个整数，表示长度为 k 的上升子序列的数量，答案可能很大，请输出答案除以 1000007 的余数。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> res;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = input.nextInt();</span><br><span class="line">        k = input.nextInt();</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            arr[i] = input.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        res = DFS(i,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res%<span class="number">1000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> kk)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(kk==k) &#123;</span><br><span class="line">    res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[j]&gt;arr[i]) &#123;</span><br><span class="line">        res++;</span><br><span class="line">        DFS(j,kk+<span class="number">1</span>);</span><br><span class="line">        res--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符转换"><a href="#字符转换" class="headerlink" title="字符转换"></a>字符转换</h1><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>String -&gt; char</td><td>toCharArray();<br>charAt();</td></tr><tr><td>char -&gt; String</td><td>String.valueOf(‘’);<br>“”+’’</td></tr><tr><td>String -&gt; int</td><td>int=Integer.parseInt(“”);<br>int=Integer.valueOf(“”).intValue();</td></tr><tr><td>int -&gt; String</td><td>String.valueOf()；<br>Integer.toString()；<br>String=””+int;</td></tr><tr><td>char -&gt; int(ascii)</td><td>int=char;</td></tr><tr><td>int(ascii) -&gt; char</td><td>char=(char)int;</td></tr><tr><td>char -&gt; int</td><td>int=’’-‘0’;</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;第十一届蓝桥杯大赛软件类省赛Java大学B组第一场 &amp;amp; 第一次校内模拟  &amp;amp; 第三次校内模拟&lt;br&gt;详解及总结&lt;/p&gt;</summary>
    
    
    
    <category term="Study" scheme="https://memorykk.cn/categories/Study/"/>
    
    
    <category term="lanqiao" scheme="https://memorykk.cn/tags/lanqiao/"/>
    
  </entry>
  
  <entry>
    <title>《鸟哥的Linux私房菜》第0-3章</title>
    <link href="https://memorykk.cn/linux-vbird-0-3.html"/>
    <id>https://memorykk.cn/linux-vbird-0-3.html</id>
    <published>2021-02-20T06:08:11.000Z</published>
    <updated>2021-03-11T14:58:40.926Z</updated>
    
    <content type="html"><![CDATA[<p>基础篇第 0-3 章学习笔记</p><span id="more"></span><hr><p><strong>目录</strong></p><ul><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%AE%BA">计算机概论</a><ul><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6">计算机硬件</a></li><li><a href="#CPU">CPU</a></li><li><a href="#%E5%86%85%E5%AD%98">内存</a></li><li><a href="#%E6%98%BE%E5%8D%A1">显卡</a></li><li><a href="#%E7%A1%AC%E7%9B%98%E4%B8%8E%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87">硬盘与存储设备</a></li><li><a href="#PCI%E9%80%82%E9%85%8D%E5%8D%A1">PCI 适配卡</a></li><li><a href="#%E4%B8%BB%E6%9D%BF">主板</a></li><li><a href="#%E7%94%B5%E6%BA%90">电源</a></li><li><a href="#%E6%96%87%E5%AD%97%E7%BC%96%E7%A0%81%E7%B3%BB%E7%BB%9F">文字编码系统</a></li><li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a></li><li><a href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">应用程序</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></li><li><a href="#Linux%E6%98%AF%E4%BB%80%E4%B9%88">Linux是什么</a><ul><li><a href="#%E5%8E%86%E5%8F%B2">历史</a></li><li><a href="#Linux%E7%9A%84%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC">Linux的内核版本</a></li><li><a href="#Linux-distribution">Linux distribution</a></li><li><a href="#Linux%E7%9A%84%E7%89%B9%E8%89%B2">Linux的特色</a></li></ul></li><li><a href="#%E4%B8%BB%E6%9C%BA%E8%A7%84%E5%88%92%E4%B8%8E%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA">主机规划与磁盘分区</a><ul><li><a href="#%E7%A3%81%E7%9B%98%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E5%90%8D%E7%9A%84%E5%85%B3%E7%B3%BB">磁盘连接的方式与设备文件名的关系</a><ul><li><a href="#IDE%E8%AE%BE%E5%A4%87">IDE设备</a></li><li><a href="#SATA%E8%AE%BE%E5%A4%87">SATA设备</a></li></ul></li><li><a href="#%E7%A3%81%E7%9B%98%E7%9A%84%E7%BB%84%E6%88%90">磁盘的组成</a></li><li><a href="#%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E8%A1%A8">磁盘分区表</a></li><li><a href="#%E5%BC%80%E6%9C%BA%E6%B5%81%E7%A8%8B%E4%B8%8E%E4%B8%BB%E5%BC%95%E5%AF%BC%E5%88%86%E5%8C%BAMBR">开机流程与主引导分区MBR</a><ul><li><a href="#%E5%BC%80%E6%9C%BA%E6%B5%81%E7%A8%8B">开机流程</a></li><li><a href="#BootLoader%E7%9A%84%E5%8A%9F%E8%83%BD">BootLoader的功能</a></li></ul></li><li><a href="#%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E7%9A%84%E9%80%89%E6%8B%A9">磁盘分区的选择</a></li><li><a href="#%E4%B8%BB%E6%9C%BA%E7%A1%AC%E7%9B%98%E7%9A%84%E4%B8%BB%E8%A6%81%E8%A7%84%E5%88%92">主机硬盘的主要规划</a></li></ul></li><li><a href="#%E5%AE%89%E8%A3%85CentOS-5-x%E4%B8%8E%E5%A4%9A%E9%87%8D%E5%BC%95%E5%AF%BC">安装CentOS 5.x与多重引导</a><ul><li><a href="#%E5%AE%89%E8%A3%85%E8%A7%84%E5%88%92">安装规划</a></li><li><a href="#%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4">安装步骤</a></li></ul></li></ul><hr><h1 id="计算机概论"><a href="#计算机概论" class="headerlink" title="计算机概论"></a>计算机概论</h1><h2 id="计算机硬件"><a href="#计算机硬件" class="headerlink" title="计算机硬件"></a>计算机硬件</h2><p><img src="/images/linux-vbird-0-3/computer.png" alt="computer.png"></p><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>CPU 的架构：</p><ul><li>精简指令集 RISC：单指令工作简单，执行快。arm</li><li>复杂指令集 CISC。单指令工作复杂，执行慢。intel(x86)、amd(x86_64)<br>1Byte=8bit</li></ul><p><img src="/images/linux-vbird-0-3/problem_memory.png" alt="problem_memory.png"></p><p>原本的单核 CPU 仅有一个运算单元,所谓的多核则是在一个 CPU 封装当中嵌入了两个以上的运算内核,简单地说,就是一个实际的 CPU 外壳中含有两个以上的 CPU 单元。<br>amd 内存与 cpu 直连，intel 内存通过北桥与 cpu 连接</p><p><strong>CPU 频率=外频*倍频</strong></p><ul><li>外频：cpu 与外部传输速率</li><li>倍频：cpu 内部运算的加速功能（出厂固定）</li></ul><p>超频：通过主板的设定功能更改成较高频率的一种方式。因为频率并非正常速度,故可能会造成死机等。</p><p>总线宽度：32/64<br>CPU 有向下兼容的能力</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>个人计算机的内存主要组件为动态随机访问内存 DRAM，挥发性</p><ul><li>SDRAM</li><li>DDR SDRAM：双倍数据传输速度 - DDR - DDRⅡ - DDRⅢ<br>双通道设计：两根 64 位总线宽度-&gt;128 位<br> CPU 外频=内存外频<br> 第二层缓存：常用的数据或程序放置在 CPU 内部，不在通过北桥从内存加载<br> DRAM 频率速度无法达到 L2=CPU 外频，因此使用静态随机访问内存 SRAM<br> <strong>只读存储器 ROM</strong><br>主板上组件参数存储在 CMOS 中，BIOS 是一套写死在 ROM 上的程序，非挥发性，系统开机时首先读取 BIOS；固件很多采用 ROM 进行软件写入；ROM 无法改写，因此 BIOS 通常写入 Flash Memory 或 EEPROM 中，以更新。</li></ul><h2 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h2><p>一般对于图形影像的显示重点在于分辨率与色彩深度，因为每个图像显示的颜色会占用内存，因此显卡上面会有一个内存的容量，这个显存容量将会影响到最终你的屏幕分辨率与色彩深度。越大越好。<br> 在显卡上嵌入 3D 加速芯片提升运算能力，即 GPU。<br> 北桥通信<br> 规格：AGP-&gt;PCI-&gt;PCIe</p><h2 id="硬盘与存储设备"><a href="#硬盘与存储设备" class="headerlink" title="硬盘与存储设备"></a>硬盘与存储设备</h2><p>硬盘：盘片、机械手臂、磁头、主轴马达。<br> 盘片上的数据：<br>磁盘上最小存储单位：扇区 512bytes；扇区组成圆：磁道；所有片上面的同一磁道：柱面（分割硬盘的最小单位）。<br>磁盘容量=header 数量<em>每个 header 负责的柱面数量</em>每个柱面所含有的扇区数量*扇区的容量<br>传输接口： - IDE 接口：连接两个设备，理论 133MB/s - SATA 接口：PC，一个设备，利于散热，理论 300MB/s</p><p>缓冲存储器：加速读取<br> 转速：主轴马达转动盘片<br> 运转：正常关机使机械手臂归回原位；避免移动主机使硬盘抖动</p><h2 id="PCI适配卡"><a href="#PCI适配卡" class="headerlink" title="PCI适配卡"></a>PCI适配卡</h2><p>用户额外的功能卡安插在 PCI 插槽上，很多组件（声卡、网卡）采用 PCI 接口传输，现多 PCIe</p><h2 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h2><p>主板上面负责通信各个组件的就是芯片组，芯片组一般分为北桥与南桥，需要散热。北桥负责 CPU/RAM/VGA 等的连接,南桥则负责 PCI 接口与速度较慢的 I/O 设备。<br> 芯片组：集成（显卡、网卡）型、独立型<br> I/O 地址：标识不同的设备；IRQ 中断信道：告知 CPU 该设备工作情况方便分配工作。sharing IRQ 技术。<br> CMOS 与 BIOS</p><h2 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h2><p>能源转换率<br> 接口</p><h2 id="文字编码系统"><a href="#文字编码系统" class="headerlink" title="文字编码系统"></a>文字编码系统</h2><p>英文：ASCII，一个字符占用 1B<br> 中文：big5（简体 gb2312），占用 2B<br> ISO/IEC 制订了 Unicode 编码系统，即 UTF8</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>内核、接口以及相关应用<br> 操作系统内核（kernel）：管理计算机的所有活动及驱动系统中的所有硬件，分配资源。内核所放置到内存中的区块受保护，开机后常驻内存。参考硬件规格，硬件不同则内核不同。<br> 系统调用（System Call）：一套开发接口，开发软件参考内核功能相关的开发接口。</p><p>内核功能：</p><ol><li>系统调用接口：与内核通信，软件开发</li><li>程序管理：多任务环境下有效分配资源</li><li>内存管理：虚拟内存功能提供在内存不足时的内存交换 swap</li><li>文件系统管理</li><li>设备驱动</li></ol><p>操作系统与驱动程序：OS 提供开发接口，让硬件开发商制作驱动，安装。</p><h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2><p>程序与 OS 有关系</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>计算机的定义为：”接受用户输入指令与数据，经由中央处理器的数据与逻辑单元运算处理后，以产生或存储成有用的信息“。<br> 计算机的五大单元包括输入单元、输出单元、CP∪ 内部的控制单元、算术逻辑单元与内存五大部分。<br> 数据会流进流出内存是 CPU 所发布的控制命令，而 CPU 实际要处理的数据则完全来自于内存。<br> CPU 依设计理念主要分为精简指令集(RSC)与复杂指令集(CSC)系统。<br> 关于 CPU 的频率部分，外频指的是 cPU 与外部组件进行数据传输时的速度,倍频则是 CPU 内部用来加速工作性能的一个倍数，两者相乘才是 cPU 的频率速度。<br> 一般主板芯片组分为北桥与南桥，北桥的总线称为系统总线,因为是内存传输的主要信道所以速度较快。南桥就是所谓的输入/输出(I/O)总线,主要在于连系硬盘、USB、网卡等接口设备。<br> 北桥所支持的频率我们称为前端总线速度( Front Side Bus,FSB),而每次传送的位数则是总线宽度。<br> CPU 每次能够处理的数据量称为字组大小( word size),字组大小依据 cPU 的设计而有 32 位与 64 位之分。我们现在所称的计算机是 32 或 64 位主要是依据这个 CPU 解析的字组大小而来的!<br> 个人计算机的内存主要组件为动态随机访问内存( Dynamic Random Access Memory,DRAM），至于 CPU 内部的第二层缓存则使用静态随机访问内存（Static Random Access Memory, SRAM）。<br> BIOS(Basic Input Output System)是一套程序,这套程序是写死到主板上面的一个内存芯片中,这个内存芯片在没有通电时也能够将数据记录下来,那就是只读存储器(Read Only Memory,ROM)。<br> 显卡的规格有 PCI/AGP/PCe,目前的主流为 Pcle 接口。<br> 硬盘是由盘片、机械手臂、磁头与主轴马达所组成的,其中盘片的组成为扇区、磁道与柱面。<br> 操作系统( Operating System,Os)其实也是一组程序,这组程序的重点在于管理计算机的所有活动以及驱动系统中的所有硬件。<br> 计算机主要以二进制作为单位,常用的磁盘容量单位为 Byte,其单位换算为 1Byte=8bt<br> 操作系统仅在于驱动与管理硬件,而要使用硬件时,就得需要通过应用软件或者是 she 的功能,来调用操作系统操纵硬件工作。目前,操作系统除了上述功能外,通常已经包含了日常工作所需要的应用软件在内了。</p><h1 id="Linux是什么"><a href="#Linux是什么" class="headerlink" title="Linux是什么"></a>Linux是什么</h1><p>Linux 是 OS 内核，包含内核及工具，沿袭 Unix，提供了一个完整的 OS 中最底层的硬件控制与资源管理的完整架构。</p><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><ul><li>Bell 实验室开发 Multics 分时系统无果，Ken Thompson 用汇编语言编写内核程序 Unics，之后为了移植，改用 C 语言编写内核发性 UNIX 正式版本，强调多用户多任务的兼容分时系统。后来 AT&amp;T 收回 UNIX 源码版权，谭宁邦自主编写 Minix，用于教学，公开源码，付费发行。</li><li>史托曼为了创建一个自由开放的 UNIX 操作系统，开始 GNU 项目，成立自由软件基金会 FSF，合作之下完成 GNU C Compiler，撰写通用公共许可证 GPL（CopyLeft），1991 年，芬兰大学生 Linus Torvalds 宣称 LInux 内核程序可以在 Intel 386 上运行。</li><li>GNU：发布软件的同时公布源码。</li><li>GNU GPL：GPL 代表具有自由度的软件，用户可以自由执行、复制、再发行、学习、修改与强化，但不能取消 GPL 授权，软件是自由的，但软件相关的“服务”是可以商业的。Open Source 的好处即修改程序代码去适合的工作环境。</li></ul><h2 id="Linux的内核版本"><a href="#Linux的内核版本" class="headerlink" title="Linux的内核版本"></a>Linux的内核版本</h2><p><strong>主版本.次版本.释出版本-修改版本</strong></p><ul><li>次版本为奇数：开发中版本，内核工程师使用；</li><li>次版本为偶数：稳定版本，家庭计算机以及企业版本。</li><li>释出版本：主次版本不变情况下，新增功能累积到一定程度之后释出。</li><li>Linux 内核版本与 distibution 版本并不相同</li></ul><h2 id="Linux-distribution"><a href="#Linux-distribution" class="headerlink" title="Linux distribution"></a>Linux distribution</h2><p>Linux 是 kernel，GNU GPL 授权模式，参考 POSIX 设计规范（POSIX 即可携式操作系统接口，重点在于规范内核与应用程序之间的接口），兼容 UNIX 操作系统，即 UNIX Like。</p><ul><li>为了让用户能够接触到 Linux，于是很多的商业公司或非营利团体就将 Kernel+ Softwares+ Tools 集成起来，加上自己具有创意的工具程序,这个工具程序可以让用户以光盘、DvD 或者通过网络直接安装管理 Lnux 系统。称为 dLinux distribution。</li></ul><p><img src="/images/linux-vbird-0-3/linux_distribution.png" alt="linux_distribution.png"></p><ul><li>Linux standard Base(LsSB)等标准来规范开发者,以及目录架构的 Fle system Hierarchy Standard(FHS)标准规范，它们的唯一差别可能就是该开发者自家所开发出来的管理工具以及套件管理的模式。所以说，基本上，每个 Linux distributions 除了架构的严谨度与选择的套件内容外，其实差异并不太大，最大的差异在于软件的安装模式。</li><li>团队版适合个人（更新快），商业版适合服务器（稳定）。</li><li>事实上鸟哥认为 distributions 主要分为两大系统，一种是使用 RPM 方式安装软件的系统,包括 Red Hat， Fedora，SusE，Centos 等都是这类；一种则是使用 Debian 的 dpkg 方式安装软件的系统，包括 Debian，Ubuntu，B2D 等。</li></ul><h2 id="Linux的特色"><a href="#Linux的特色" class="headerlink" title="Linux的特色"></a>Linux的特色</h2><ul><li>稳定的系统</li><li>免费或少许费用</li><li>安全性、漏洞的快速修补</li><li>多任务、多用户</li><li>用户、用户组</li><li>相对不耗资源</li><li>需要小内核的嵌入式系统</li><li>整合度佳且多样的用户界面（GUI）</li></ul><h1 id="主机规划与磁盘分区"><a href="#主机规划与磁盘分区" class="headerlink" title="主机规划与磁盘分区"></a>主机规划与磁盘分区</h1><p>各个硬件设备在 linux 中当成一个文件来对待，几乎所有的硬件设备文件在/dev 目录里。<br>Windows 下不管有多少个 IDE 设备都是顺序地分配盘符，而在 Linux 下是认真区分对待每一个硬盘的。<br><em>（来自<a href="https://blog.csdn.net/weixin_32482133/article/details/112946362">https://blog.csdn.net/weixin_32482133/article/details/112946362</a>）</em></p><h2 id="磁盘连接的方式与设备文件名的关系"><a href="#磁盘连接的方式与设备文件名的关系" class="headerlink" title="磁盘连接的方式与设备文件名的关系"></a>磁盘连接的方式与设备文件名的关系</h2><table><thead><tr><th>接口</th><th>命名</th></tr></thead><tbody><tr><td>IDE 设备</td><td>/dev/hd[a-d]</td></tr><tr><td>SCSI/SATA/USB 硬盘</td><td>/dev/sd[a-p]</td></tr></tbody></table><h3 id="IDE设备"><a href="#IDE设备" class="headerlink" title="IDE设备"></a>IDE设备</h3><p>一个 IDE 扁平线缆可以连接两个 IDE 设备，通常主机会提供两个接口 IDE1（primary）和 IDE2（secondary），故可以连接四个 IDE 设备，每个扁平线缆上的 IDE 设备分为 Master/Slave。</p><table><thead><tr><th>IDE</th><th>Master</th><th>Slave</th></tr></thead><tbody><tr><td>IDE1（primary）</td><td>/dev/hda</td><td>/dev/hdb</td></tr><tr><td>IDE2（secondary）</td><td>/dev/hdc</td><td>/dev/hdd</td></tr></tbody></table><h3 id="SATA设备"><a href="#SATA设备" class="headerlink" title="SATA设备"></a>SATA设备</h3><p>SATA/SCSI/USB 等磁盘接口使用 SCSI 模块驱动，使用/dev/sd[a-p]格式，SATA/USB 接口的磁盘根本没有顺序，文件名由 Linux 内核检测到磁盘的顺序排列。</p><h2 id="磁盘的组成"><a href="#磁盘的组成" class="headerlink" title="磁盘的组成"></a>磁盘的组成</h2><p>磁盘的第一个扇区（512bytes）记录重要信息：</p><ul><li>主引导分区 MBR（446bytes）：安装引导加载程序的地方。系统开机时主动读取，系统知道程序存放位置和如何开机。</li><li>分区表（64bytes）：记录整块硬盘分区的状态。硬盘必须切割才能使用。</li></ul><p><img src="/images/linux-vbird-0-3/disk_constitute.png" alt="disk_constitute.png"></p><h2 id="磁盘分区表"><a href="#磁盘分区表" class="headerlink" title="磁盘分区表"></a>磁盘分区表</h2><p>分区的最小单位是柱面，参考柱面号码切割硬盘，在分区表所在的 64bytes 容量中，分为四组记录区，每组记录区记录了该区段的起始与结束的柱面号码。这四个分区称为主或扩展分区。</p><p><img src="/images/linux-vbird-0-3/disk_separate1.png" alt="disk_separate1.png"></p><p>系统写入磁盘时，一定会参考分区表。分区的目的：安全性与性能。<br>利用额外的（第一个扇区之外的）扇区记录更多的分区信息，扩展分区本身不能被格式化，主分区与逻辑分区可以。</p><p><img src="/images/linux-vbird-0-3/disk_separate2.png" alt="disk_separate2.png"></p><p>这五个由扩展分区切割的分区成为逻辑分区（5个），设备名从主分区保留之后开始。<br>    主分区+扩展分区≤4（硬盘限制）；<br>    扩展分区≤1（操作系统限制）。<br>    P主分区、E扩展分区、L逻辑分区。主分区和扩展分区之外的空间将被浪费。考虑到连续性，E分配在最后。分区&gt;4时，一定要有E。<br>    例如：在第二块SATA硬盘下分6个分区，有方法：</p><p><img src="/images/linux-vbird-0-3/disk_separate3.png" alt="disk_separate3.png"><br><img src="/images/linux-vbird-0-3/disk_separate4.png" alt="disk_separate4.png"></p><h2 id="开机流程与主引导分区MBR"><a href="#开机流程与主引导分区MBR" class="headerlink" title="开机流程与主引导分区MBR"></a>开机流程与主引导分区MBR</h2><h3 id="开机流程"><a href="#开机流程" class="headerlink" title="开机流程"></a>开机流程</h3><ol><li>BIOS：开机主动执行韧体 BIOS，寻找开机设备（根据用户设置的能开机的硬盘）</li><li>MBR：分析存储设备（如硬盘）第一个扇区的 MBR 位置，内置引导加载程序</li><li>引导加载程序 Boot Loader：加载内核</li><li>内核文件：OS 工作。</li></ol><p>BIOS 和 MBR 由硬件支持，BootLoader 由 OS 支持。</p><h3 id="BootLoader的功能"><a href="#BootLoader的功能" class="headerlink" title="BootLoader的功能"></a>BootLoader的功能</h3><ul><li><p>提供菜单：多重引导</p></li><li><p>载入内核：指向可开机的程序区段</p></li><li><p>转交其他 Loader（一个硬盘上包含多个系统，如双系统）</p><p>硬盘的每个分区都有自己的启动扇区，内核文件实际放置在各分区内，Loader 只认识自己分区的内核以及其他 Loader。</p></li></ul><p><img src="/images/linux-vbird-0-3/mbr.png" alt="mbr.png"></p><h2 id="磁盘分区的选择"><a href="#磁盘分区的选择" class="headerlink" title="磁盘分区的选择"></a>磁盘分区的选择</h2><p>Linux 所有数据以文件形态呈现，使用目录树结构，实际存放在磁盘分区中。</p><p>挂载：文件系统与目录树的关系</p><ul><li>将一个目录当作磁盘的入口，进入目录即可读取分区。即“挂载”与“挂载点”，最重要的根目录一定需要挂载到某分区。<br>（磁盘上有/file，挂载到/mnt 下，即访问路径/mnt/file）</li><li>安装 distribution，自定义安装 Custom 模式，建议仅区分主分区/和交换分区 swap（补充内存）。更详细的分区方案参考网络。</li></ul><h2 id="主机硬盘的主要规划"><a href="#主机硬盘的主要规划" class="headerlink" title="主机硬盘的主要规划"></a>主机硬盘的主要规划</h2><p>  主机硬盘的需求和主机开放的服务有关，还需要注意数据分类和安全。</p><p>  最简单的的分区方法<br>  / &amp; swap &amp; 未分区</p><p>  根据用途：</p><p>  容量大且读写频繁的目录：/ /usr /home /var swap<br>  大硬盘配合旧主机造成无法开机的问题<br>  旧主板找不到大容量磁盘，导致误判，但是 Linux 内核顺利开机后会重新检测硬盘而不例会 BIOS，所以 Linux 能够安装。<br>  但是安装完毕无法开机，BIOS 不能正确识别硬盘，开机错误。BIOS 只能读取前面的扇区，故将启动扇区所在分区规范在 ≤1024 个柱面以内。<br>  分区/boot &amp; / &amp; swap，/boot 100MB 左右，放在硬盘最前面。</p><h1 id="安装CentOS-5-x与多重引导"><a href="#安装CentOS-5-x与多重引导" class="headerlink" title="安装CentOS 5.x与多重引导"></a>安装CentOS 5.x与多重引导</h1><h2 id="安装规划"><a href="#安装规划" class="headerlink" title="安装规划"></a>安装规划</h2><ul><li>Linux主机的角色定位</li><li>选择distribution</li><li>计算机硬件配置</li><li>磁盘分区配置：/boot&amp;/&amp;/home&amp;swap  PPPL</li><li>引导装载程序BootLoader：安装到MBR</li><li>选择软件：默认/最小/全部/自定义</li></ul><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol><li>调整启动媒体(BIOS):使用Linux安装光盘，调整BIOS的开机启动顺序为光盘；（无法以DVD开机时很可能是由于计算机硬件不支持、光驱会挑片、光盘问题、硬件超频等）</li><li>选择安装结构与开机:包括图形界面命令行界面等，也可加入特殊参数（硬件检测、安装媒体、内存测试）来开机进入安装界面；</li><li>选择语系数据:由于不同地区的键盘按键不同，此时需要调整语系/键盘/鼠标等配置；</li><li>磁盘分区:最重要的项目之一。提前规划。</li></ol><p>四种分区结构：</p><ul><li>整块硬盘：删除所有分区并创建默认分区结构</li><li>Linux分区：删除Linux分区并创建默认分区</li><li>选定驱动器的空闲空间：未分区空间</li><li>建立自定义分区结构</li></ul><p>Linux支持的文件系统类型：<br><em>（二三版书上介绍有差别）</em><br>ext2/ext3：Linux使用的文件系统类型，ext3/ext4比ext2多日志记录，恢复系统较为迅速</p><ol start="5"><li>引导装载程序、网络、时区设置与root密码:一些需要的系统基础设置!</li><li>软件选择:需要什么样的软件?全部安装还是默认安装即可?</li><li>安装后的首次设置:安装完毕后还有一些事项要处理,包括用户、 SELinux与防火墙等</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;基础篇第 0-3 章学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="Study" scheme="https://memorykk.cn/categories/Study/"/>
    
    
    <category term="linux" scheme="https://memorykk.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>记一次使用Github登录Gitalk跳至首页的解决过程</title>
    <link href="https://memorykk.cn/gitalk-405.html"/>
    <id>https://memorykk.cn/gitalk-405.html</id>
    <published>2021-02-19T08:45:48.000Z</published>
    <updated>2021-02-19T11:41:54.450Z</updated>
    
    <content type="html"><![CDATA[<p>使用自定义域名之后的 Github page 在使用 Github 登录 Github 时跳转首页，无限循环</p><span id="more"></span><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>博客使用的是Hexo+Github+Gitalk，使用 Github 登录 Gitalk 之后跳转至首页，无限循环，地址栏URL显示为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;memorykk.cn&#x2F;?error&#x3D;redirect_uri_mismatch&amp;error_description&#x3D;The+redirect_uri+MUST+match+the+registered+callback+URL+for+this+application.&amp;error_uri&#x3D;https%3A%2F%2Fdocs.github.com%2Fapps%2Fmanaging-oauth-apps%2Ftroubleshooting-authorization-request-errors%2F%23redirect-uri-mismatch</span><br></pre></td></tr></table></figure><h1 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h1><p>为了更清楚地检查，将此 URL 中的 Unicode 转为中文：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;memorykk.cn&#x2F;?</span><br><span class="line">error&#x3D;redirect_uri_mismatch&amp;</span><br><span class="line">error_description&#x3D;The+redirect_uri+MUST+match+the+registered+callback+URL+for+this+application.&amp;</span><br><span class="line">error_uri&#x3D;https:&#x2F;&#x2F;docs.github.com&#x2F;apps&#x2F;managing-oauth-apps&#x2F;troubleshooting-authorization-request-errors&#x2F;#redirect-uri-mismatch</span><br></pre></td></tr></table></figure><p>根据描述，<kbd>redirect error</kbd> <kbd>registered callback URL</kbd>不匹配。</p><p>打开<kbd>F12</kbd>查看<kbd>Network</kbd>：</p><p><img src="/images/gitalk-405/reirect_uri.png" alt="reirect_uri.png"></p><p><kbd>this application</kbd>我使用的是<kbd>OAuth Apps</kbd>，查看其Authorization callback URL，果不其然：</p><p><img src="/images/gitalk-405/Auth_callback_URL.png" alt="Auth_callback_URL.png"></p><p><code>http</code>和<code>https</code>的差别还是很大的！修改Authorization callback URL为<code>https</code>之后成功了。</p><p>点击<kbd>使用GitHub登录</kbd>之后，又出现 405 问题，<br><img src="/images/gitalk-405/405.png" alt="405.png"><br>打开<kbd>F12</kbd>查看<kbd>Network</kbd>：<br><img src="/images/gitalk-405/url1.png" alt="url1.png"><br>转换为中文：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Request URL: https:&#x2F;&#x2F;memorykk.cn&#x2F;TeamSpeak&#x2F;%7B%7B%20theme.gitalk.proxy%20%7D%7D</span><br><span class="line"></span><br><span class="line">Request URL: https:&#x2F;&#x2F;memorykk.cn&#x2F;TeamSpeak&#x2F;&#123;&#123; theme.gitalk.proxy &#125;&#125;</span><br></pre></td></tr></table></figure><p>好家伙，这还是源代码形式啊，坑定是后台有什么问题！<br>检查<kbd>theme\layout\components\comment.ejs</kbd>，这行代码果然是从这里出来的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var gitalk &#x3D; new Gitalk(&#123;</span><br><span class="line">clientID: &#39;&lt;%&#x3D; theme.gitalk_client_id %&gt;&#39;,</span><br><span class="line">clientSecret: &#39;&lt;%&#x3D; theme.gitalk_client_secret %&gt;&#39;,</span><br><span class="line">repo: &#39;&lt;%&#x3D; theme.gitalk_repo %&gt;&#39;,</span><br><span class="line">owner: &#39;&lt;%&#x3D; theme.gitalk_owner %&gt;&#39;,</span><br><span class="line">admin: [&#39;&lt;%- theme.gitalk_admin.join(&quot;&#39;, &#39;&quot;) %&gt;&#39;],</span><br><span class="line">id: location.pathname,</span><br><span class="line">distractionFreeMode: false,</span><br><span class="line">createIssueManually: true,</span><br><span class="line">proxy: &#39;&#123;&#123; theme.gitalk.proxy &#125;&#125;&#39;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>之前对node.js也不了解（虽然现在也一样，允悲），没注意格式。仿照上面几行代码改成：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy: &#39;&lt;%&#x3D; theme.gitalk.proxy %&gt;&#39;,</span><br></pre></td></tr></table></figure><p>还是报 405 错误，打开<kbd>F12</kbd>查看：<br><img src="/images/gitalk-405/405_2.png" alt="405_2.png"></p><p>总感觉之前白嫖的 CorsAnywhere Proxy 链接压根没有传递过去，直接手动写死在里面：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy: &#39;https:&#x2F;&#x2F;netnr-proxy.cloudno.de&#x2F;https:&#x2F;&#x2F;github.com&#x2F;login&#x2F;oauth&#x2F;access_token&#39;,</span><br></pre></td></tr></table></figure><p>好家伙，成功了，ohhhhhhhhhhh，虽然这种做法极不优雅！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>网页出错先用<kbd>F12</kbd>看看哪部分的问题，顺藤摸瓜，缩小范围。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用自定义域名之后的 Github page 在使用 Github 登录 Github 时跳转首页，无限循环&lt;/p&gt;</summary>
    
    
    
    <category term="Log" scheme="https://memorykk.cn/categories/Log/"/>
    
    
    <category term="Gitalk" scheme="https://memorykk.cn/tags/Gitalk/"/>
    
  </entry>
  
  <entry>
    <title>TeamSpeak</title>
    <link href="https://memorykk.cn/TeamSpeak.html"/>
    <id>https://memorykk.cn/TeamSpeak.html</id>
    <published>2021-02-19T06:22:14.000Z</published>
    <updated>2021-03-18T14:51:03.417Z</updated>
    
    <content type="html"><![CDATA[<p>一个简易的TeamSpeak使用教程</p><span id="more"></span><p>更新于2021-02-19 14:22:14：<br>旧地址<del>memorykk.cn</del>已不可用，为了您后续的正常使用，请使用新地址<text style="color:white;background-color:red">ts.memorykk.cn</text></p><p><img src="/images/TeamSpeak/address.png" alt="address.png"></p><hr><p>更新于2020/5/22 15:30：</p><p>根据 @洛杉矶湖人名宿孙悦 ​的提醒，<text style="color:red">不推荐下载ts1.cn的盗版客户端，也不推荐俱乐部或者各位玩家租用ts1.cn的盗版服务器。</text>具体可<a href="https://bbs.hupu.com/32525047.html">查看原帖</a>，所以希望大家去官网下载正版软件，如果官网或github下载太慢，可以点正文中转存的链接，都是一样的。</p><hr><p>去年自己搭建了一个TeamSpeak服务器，闲着也是闲着，分享出来给大家使用，市面上的服务器要么收费、要么音质权限不给，本服务器免费共享，合法合规，不涉及隐私信息等，请放心使用！</p><h1 id="什么是TeamSpeak"><a href="#什么是TeamSpeak" class="headerlink" title="什么是TeamSpeak"></a>什么是TeamSpeak</h1><blockquote><p>TeamSpeak (简称TS) 是一套专有的VoIP软件，使用者可以用耳机和麦克风，通过客户端软件连线到指定的服务器，与在服务器内频道的其他使用者进行通话。是一种很像电话会议的方式。 通常 TeamSpeak 的使用者大多为多人连线游戏的玩家，与同队伍的玩家进行通讯。在游戏的对战方面，语音对话通讯具有竞争优势。</p></blockquote><p>简言之，TeamSpeak是一款非常优秀的语音软件，类似于国内的YY语音、TT语音等，PUBG、CSGO等项目职业选手都在使用，在和小伙伴激情上分时，你该不会还在使用QQ微信电话吧？那么TS优点在哪里呢？有几点：</p><ul><li>界面简洁，没有广告，没有花里胡哨的付费内容；</li><li>极高的音乐级音质，超低的延迟；</li><li>独有的麦克风降噪、键盘声衰减、回声消除；</li><li>自动感应麦真的很好用。</li></ul><h1 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h1><ol><li>下载TeamSpeak客户端（最新版本为3.5.6）</li></ol><ul><li><a href="https://teamspeak.com/zh-CN/downloads/#client">官网下载</a></li><li>转存下载：（文件和官网一样，解决下载过慢问题）<ul><li><a href="https://wwa.lanzous.com/izgdukunldc">WINDOWS CLIENT 32-BIT 3.5.6</a></li><li><a href="https://wwa.lanzous.com/iQ78Wkun8ab">WINDOWS CLIENT 64-BIT 3.5.6</a></li><li><a href="https://memorykk.cn/src/TeamSpeak3-Client-macosx-3.5.6.dmg">MACOS CLIENT UNIVERSAL BINARY 3.5.6</a></li><li><a href="https://memorykk.cn/src/TeamSpeak3-Client-linux_x86-3.5.6.run">LINUX CLIENT 32-BIT 3.5.6</a></li><li><a href="https://memorykk.cn/src/TeamSpeak3-Client-linux_amd64-3.5.6.run">LINUX CLIENT 64-BIT 3.5.6</a></li></ul></li><li><a href="https://wwa.lanzous.com/icw5xgd">下载中文语音包&amp;语言包</a></li></ul><ol start="2"><li>安装客户端和中文包</li></ol><p>默认“下一步”就完事了，打开如下：</p><p><img src="/images/TeamSpeak/2-1.png" alt="2-1.png"><br><img src="/images/TeamSpeak/2-2.png" alt="2-2.png"></p><ol start="3"><li>注册登录你的TS账号（跳过这一步也可以）</li></ol><p>安装软件后会弹出来，没弹出来可以依次点击 <kbd>工具</kbd>-&gt;<kbd>选项</kbd>-&gt;<kbd>myTeamSpeak​</kbd> 继续操作。</p><p><img src="/images/TeamSpeak/3.png" alt="3.png"></p><ol start="4"><li>设置语音输入方式</li></ol><p>依次点击 <kbd>工具</kbd>-&gt;<kbd>选项</kbd>-&gt;<kbd>输入</kbd> 建议设置如下：</p><p><img src="/images/TeamSpeak/4.png" alt="4.png"></p><p>语音输入方式：</p><ul><li>Automatic：自动感应麦</li><li>Volume Gate：自定义麦克风的收音敏感度，点“开始测试”，比最高的分贝低一点就可以了</li><li>Hybrid：不懂，没用过</li></ul><ol start="5"><li>连接服务器</li></ol><p>依次点击左上角 <kbd>连接</kbd>-&gt;<kbd>连接</kbd>-&gt;输入服务器地址（<strong>ts.memorykk.cn</strong>）和昵称，无密码，直接点击连接，自动进入大厅。</p><p><img src="/images/TeamSpeak/5.png" alt="5.png"></p><ol start="6"><li>开房间</li></ol><p>空白处右键单击“创建频道”，设置房间名，有需要的可以设置密码，点击确定，房间开好了，双击房间名即可进入，这时候你就可以让你的小伙伴直接进入你的房间就完事了。</p><p><img src="/images/TeamSpeak/6-1.png" alt="6-1.png"><br><img src="/images/TeamSpeak/6-2.png" alt="6-2.png"></p><p><strong>注意</strong></p><ol><li>创建频道如果选择临时，当频道最后一人离开时，频道会自动消失。</li><li>可以设置频道音质，右键单击频道-&gt;声音-&gt;拖到质量条。</li><li>不推荐设置密码，方便大家组队。</li><li>频道可以设置图标，标注自己玩的游戏，有需要的下方留言哦。</li></ol><p>最后，有问题到下方留言或是查看<a href="https://memorykk.cn/about/">联系方式</a>，希望大家玩得开心。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个简易的TeamSpeak使用教程&lt;/p&gt;</summary>
    
    
    
    <category term="Tool" scheme="https://memorykk.cn/categories/Tool/"/>
    
    
    <category term="TeamSpeak" scheme="https://memorykk.cn/tags/TeamSpeak/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="https://memorykk.cn/Git.html"/>
    <id>https://memorykk.cn/Git.html</id>
    <published>2021-02-15T02:49:13.000Z</published>
    <updated>2021-02-18T14:26:23.672Z</updated>
    
    <content type="html"><![CDATA[<p>Git是目前世界上最先进的分布式版本控制系统（没有之一）。</p><span id="more"></span><hr><p><strong>目录</strong></p><ul><li><a href="#%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6">版本控制</a></li><li><a href="#%E5%AE%89%E8%A3%85git">安装Git</a><ul><li><a href="#linux">Linux</a></li><li><a href="#linux-1">Linux</a><ul><li><a href="#debianubuntu">Debian/Ubuntu</a></li><li><a href="#centosredhat">Centos/RedHat</a></li></ul></li><li><a href="#windows">Windows</a></li></ul></li><li><a href="#%E9%85%8D%E7%BD%AEgit">配置Git</a><ul><li><a href="#%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8Cemail">配置用户名和Email</a></li><li><a href="#%E5%A2%9E%E5%88%A0%E9%85%8D%E7%BD%AE%E9%A1%B9">增删配置项</a><ul><li><a href="#%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE%E9%A1%B9">添加配置项</a></li><li><a href="#%E5%88%A0%E9%99%A4%E9%85%8D%E7%BD%AE%E9%A1%B9">删除配置项</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E9%85%8D%E7%BD%AE%E9%A1%B9">更多配置项</a></li></ul></li><li><a href="#git%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">Git基本概念</a></li><li><a href="#git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">Git工作流程</a></li><li><a href="#git%E6%93%8D%E4%BD%9C">Git操作</a><ul><li><a href="#git%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93">Git创建版本库</a><ul><li><a href="#%E5%9C%A8%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%96">在工作目录中初始化</a></li><li><a href="#%E4%BB%8E%E7%8E%B0%E6%9C%89%E4%BB%93%E5%BA%93%E5%85%8B%E9%9A%86">从现有仓库克隆</a></li></ul></li><li><a href="#%E6%96%87%E4%BB%B6%E6%9B%B4%E6%96%B0">文件更新</a><ul><li><a href="#%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81">文件状态</a></li><li><a href="#%E6%A3%80%E6%9F%A5%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81">检查文件状态</a></li><li><a href="#%E8%B7%9F%E8%B8%AA%E6%96%87%E4%BB%B6">跟踪文件</a></li><li><a href="#%E6%9A%82%E5%AD%98%E5%B7%B2%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6">暂存已修改文件</a></li><li><a href="#%E5%BF%BD%E7%95%A5%E6%9F%90%E4%BA%9B%E6%96%87%E4%BB%B6">忽略某些文件</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E6%9C%AA%E6%9A%82%E5%AD%98%E7%9A%84%E6%9B%B4%E6%96%B0">查看未暂存的更新</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E5%B7%B2%E6%9A%82%E5%AD%98%E7%9A%84%E6%9B%B4%E6%96%B0">查看已暂存的更新</a></li><li><a href="#%E6%8F%90%E4%BA%A4%E6%9B%B4%E6%96%B0">提交更新</a></li><li><a href="#%E8%B7%B3%E8%BF%87%E4%BD%BF%E7%94%A8%E6%9A%82%E5%AD%98%E5%8C%BA%E5%9F%9F">跳过使用暂存区域</a></li><li><a href="#%E7%A7%BB%E9%99%A4%E6%96%87%E4%BB%B6">移除文件</a></li><li><a href="#%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6">移动文件</a></li></ul></li><li><a href="#%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2">查看提交历史</a><ul><li><a href="#%E9%99%90%E5%88%B6%E8%BE%93%E5%87%BA%E9%95%BF%E5%BA%A6">限制输出长度</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%B7%A5%E5%85%B7%E6%9F%A5%E9%98%85%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2">使用图形化工具查阅提交历史</a></li></ul></li><li><a href="#%E6%92%A4%E9%94%80">撤销</a><ul><li><a href="#%E4%BF%AE%E6%94%B9%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E6%8F%90%E4%BA%A4">修改最后一次提交</a></li><li><a href="#%E5%8F%96%E6%B6%88%E5%B7%B2%E7%BB%8F%E6%9A%82%E5%AD%98%E7%9A%84%E6%96%87%E4%BB%B6">取消已经暂存的文件</a></li><li><a href="#%E5%8F%96%E6%B6%88%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%AE%E6%94%B9">取消对文件的修改</a></li><li><a href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93">文件操作总结</a></li></ul></li></ul></li><li><a href="#git%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">Git远程仓库</a><ul><li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">查看远程仓库</a></li><li><a href="#%E6%B7%BB%E5%8A%A0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">添加远程仓库</a></li><li><a href="#%E4%BB%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E6%8A%93%E5%8F%96%E6%95%B0%E6%8D%AE">从远程仓库抓取数据</a></li><li><a href="#%E6%8E%A8%E9%80%81%E6%95%B0%E6%8D%AE%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">推送数据到远程仓库</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%BF%A1%E6%81%AF">查看远程仓库信息</a></li><li><a href="#%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E5%88%A0%E9%99%A4%E5%92%8C%E9%87%8D%E5%91%BD%E5%90%8D">远程仓库的删除和重命名</a><ul><li><a href="#%E9%87%8D%E5%91%BD%E5%90%8D">重命名</a></li><li><a href="#%E5%88%A0%E9%99%A4">删除</a></li></ul></li></ul></li><li><a href="#%E7%89%88%E6%9C%AC%E6%A0%87%E7%AD%BE">版本标签</a><ul><li><a href="#%E6%98%BE%E7%A4%BA%E5%B7%B2%E6%9C%89%E6%A0%87%E7%AD%BE">显示已有标签</a></li><li><a href="#%E6%96%B0%E5%BB%BA%E6%A0%87%E7%AD%BE">新建标签</a><ul><li><a href="#%E5%90%AB%E9%99%84%E6%B3%A8%E7%9A%84%E6%A0%87%E7%AD%BE">含附注的标签</a></li><li><a href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%A0%87%E7%AD%BE">轻量级标签</a></li><li><a href="#%E7%AD%BE%E7%BD%B2%E6%A0%87%E7%AD%BE">签署标签</a></li><li><a href="#%E9%AA%8C%E8%AF%81%E6%A0%87%E7%AD%BE">验证标签</a></li></ul></li><li><a href="#%E5%90%8E%E6%9C%9F%E5%8A%A0%E6%B3%A8%E6%A0%87%E7%AD%BE">后期加注标签</a></li><li><a href="#%E5%88%86%E4%BA%AB%E6%A0%87%E7%AD%BE">分享标签</a></li></ul></li><li><a href="#git%E5%88%86%E6%94%AF">Git分支</a><ul><li><a href="#%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B">分支简介</a></li><li><a href="#%E6%96%B0%E5%BB%BA%E5%88%86%E6%94%AF">新建分支</a></li><li><a href="#head">HEAD</a></li><li><a href="#%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF">切换分支</a></li><li><a href="#%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF">合并分支</a></li><li><a href="#%E9%81%87%E5%88%B0%E5%86%B2%E7%AA%81%E6%97%B6%E7%9A%84%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6">遇到冲突时的分支合并</a></li><li><a href="#%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF">删除分支</a></li><li><a href="#%E6%A1%88%E4%BE%8B">案例</a></li><li><a href="#%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86">分支管理</a></li><li><a href="#%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">远程分支</a></li><li><a href="#%E6%8E%A8%E9%80%81%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF">推送本地分支</a></li><li><a href="#%E8%B7%9F%E8%B8%AA%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">跟踪远程分支</a></li><li><a href="#%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">删除远程分支</a></li><li><a href="#%E5%88%86%E6%94%AF%E8%A1%8D%E5%90%88">分支衍合</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li></ul><hr><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。最初由 Linus Torvalds 为了帮助管理 Linux 内核开发而花了两周时间自己用C写出来的。（理那厮·掏袜子真的太绝了⊙ｏ⊙）</p><h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p>版本控制系统分为本地式、集中式和分布式。</p><ul><li><p>本地式：适合个人使用，用于记录文件更新。代表：RCS</p><img src="/images/Git/local.png" class=""></li><li><p>集中式：必须联网，断网后可编辑无法commit和回滚。版本库都存在中央服务器上，用户的本地只有自己以前所同步的版本，没有完整的版本库。代表：SVN、CVS、VSS。<br>假设SVN服务器没了，那你丢掉了所有历史信息，因为你的本地只有当前版本以及部分历史信息。</p><img src="/images/Git/centralization.png" class=""></li><li><p>分布式：只有在push、pull时需要联网，断网后可正常commit。中央服务器只为了修改起来方便，可有可无，每个用户本地都是一个完整的版本库。代表：Git。<br>每个人都同时对同一版本修改，commit操作提交到本地，多人协作时需要push操作和别人同步，但是团队人数多会导致非常麻烦，所以出现所谓的（便于修改的）中央服务器。<br>假设GitHub服务器没了，你不会丢掉任何git历史信息，因为你的本地有完整的版本库信息，你可以把本地的git库重新上传到另外的git服务商。 </p><img src="/images/Git/distributed.png" class=""></li></ul><p><strong>Git的特点</strong></p><ul><li><p>直接记录快照，而非差异比较<br>Git 只关心文件数据的<strong>整体</strong>是否发生变化，而大多数其他系统则只关心文件内容的具体差异。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。有变化则保存，无则链接。</p></li><li><p>近乎所有操作都是本地执行</p></li><li><p>时刻保持数据完整性<br>保存在 Git 数据库中的东西都是用此哈希值来作索引的，而不是靠文件名。</p></li><li><p>多数操作仅添加数据</p></li></ul><h1 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h1><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。<br><code>yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel</code><br>或<br><code>$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev</code><br>下载源码：<a href="http://git-scm.com/download">http://git-scm.com/download</a><br>编译安装<br><code>$ tar -zxf git-1.7.2.2.tar.gz</code><br><code>$ cd git-1.7.2.2</code><br><code>$ make prefix=/usr/local all</code><br><code>$ sudo make prefix=/usr/local install</code></p><h2 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h2><h3 id="Debian-Ubuntu"><a href="#Debian-Ubuntu" class="headerlink" title="Debian/Ubuntu"></a>Debian/Ubuntu</h3><p><code>$ sudo apt-get install git</code></p><h3 id="Centos-RedHat"><a href="#Centos-RedHat" class="headerlink" title="Centos/RedHat"></a>Centos/RedHat</h3><p><code>$ yum install git-core</code></p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p><a href="https://git-scm.com/downloads">官网下载</a><br><a href="https://npm.taobao.org/mirrors/git-for-windows/">镜像下载</a><br>默认安装。</p><img src="/images/Git/winGit.PNG" class=""><ul><li><kbd>Git Bash</kbd>：Unix与Linux风格的命令行（<strong>推荐</strong>）</li><li><kbd>Git CMD</kbd>：DOS风格的命令</li><li><kbd>Git GUI</kbd>：图形界面（<strong>新手不推荐</strong>）  </li></ul><p>打开<kbd>Git Bash</kbd>检查一下：  </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git --version</span></span><br><span class="line">git version 2.29.2.windows.2</span><br></pre></td></tr></table></figure><h1 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h1><h2 id="配置用户名和Email"><a href="#配置用户名和Email" class="headerlink" title="配置用户名和Email"></a>配置用户名和Email</h2><p>信息将会嵌入你的每次提交中。</p><p><strong>配置级别</strong>  </p><ul><li>系统级<kbd>--system</kbd>：系统中所有用户适用的配置<ul><li>Linux：/etc/gitconfig</li><li>Windows：Git/mingw64/etc/gitconfig</li></ul></li><li>用户级<kbd>--global</kbd>：当前用户适用的配置<ul><li>Linux：~/.gitconfig</li><li>Windows：C:/Users/Administrator/.gitconfig</li></ul></li><li>项目级<kbd>--local</kbd>：特定项目适用的配置<ul><li>Linux：gitProject/.gitconfig</li><li>Windows：gitProject/.gitconfig</li></ul></li></ul><p>低级覆盖高级：<strong>local&lt;globall&lt;system</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">&quot;Your Name&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">&quot;Your Email&quot;</span></span></span><br></pre></td></tr></table></figure><p>如果用了<kbd>--global</kbd>选项，所有项目都会默认使用这个全局配置，不加则为某个特定的项目信息。</p><h2 id="增删配置项"><a href="#增删配置项" class="headerlink" title="增删配置项"></a>增删配置项</h2><h3 id="添加配置项"><a href="#添加配置项" class="headerlink" title="添加配置项"></a>添加配置项</h3><p><code>git config [--local|--global|--system]  section.key value</code></p><p>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">51139@DESKTOP MINGW64 /e/blog</span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global Student.number 2018000001</span></span><br><span class="line">51139@DESKTOP MINGW64 /e/blog</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat C:/Users/51139/.gitconfig</span></span><br><span class="line">[user]</span><br><span class="line">        name = memorykkk</span><br><span class="line">        email = 511390937@qq.com</span><br><span class="line">[Student]</span><br><span class="line">        number = 2018000001</span><br></pre></td></tr></table></figure><h3 id="删除配置项"><a href="#删除配置项" class="headerlink" title="删除配置项"></a>删除配置项</h3><p><code>git config [--local|--global|--system] --unset section.key</code></p><h2 id="更多配置项"><a href="#更多配置项" class="headerlink" title="更多配置项"></a>更多配置项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config -l, --list     #list all    列出所有</span><br><span class="line">git config -e, --edit     #open an editor    打开一个编辑器</span><br><span class="line">git config --global color.ui true   #打开所有的默认终端着色</span><br><span class="line">git config --global alias.ci commit   #别名 ci 是commit的别名</span><br><span class="line">user.name  #用户名</span><br><span class="line">user.email  #邮箱</span><br><span class="line">core.editor  #文本编辑器  </span><br><span class="line">merge.tool  #差异分析工具  </span><br><span class="line">core.paper &quot;less -N&quot;  #配置显示方式  </span><br><span class="line">color.diff true  #diff颜色配置  </span><br><span class="line">alias.co checkout  #设置别名</span><br><span class="line">git config user.name  #获得用户名</span><br><span class="line">git config core.filemode false  #忽略修改权限的文件 </span><br></pre></td></tr></table></figure><p>学习<kbd>config</kbd>命令，运行  <code>$ git help config</code></p><p>查看手册 <a href="https://git-scm.com/docs/git-config">git config</a></p><h1 id="Git基本概念"><a href="#Git基本概念" class="headerlink" title="Git基本概念"></a>Git基本概念</h1><ol><li>Git本地有三个工作区域：<strong>工作区</strong>（Workspace）、<strong>暂存区</strong>（Index/Stage）、<strong>仓库</strong>（Repository），加上<strong>远程仓库</strong>（Remote）共四个工作区域。</li></ol><p>Git 各个命令可以理解为在各个仓库间转移数据，各个命令对应对每个仓库输入输出。</p><ul><li>Workspace：工作区，平时能看到的存放项目代码的地方</li><li>Index / Stage：暂存区，临时存放改动，保存即将提交到文件列表信息的文件，有时也叫作索引</li><li>Repository：仓库区（或本地仓库），安全存放数据的位置，含所有版本的数据，HEAD指向最新版本</li><li>Remote：远程仓库，托管代码的服务器，用于远程数据交换</li></ul><ol start="2"><li>对于本地三个区域的关系如下：<br><img src="/images/Git/local_relation.png" alt="local_relation"></li></ol><ul><li><p>Directory：使用Git管理的仓库，包含我们的工作空间和Git的管理空间</p></li><li><p>WorkSpace：需要通过Git进行版本控制的目录和文件组成工作空间</p></li><li><p>.git：存放Git管理信息的目录，初始化仓库的时候自动创建</p></li><li><p>Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前存放所有的更新</p></li><li><p>Local Repo：本地仓库，HEAD会只是当前的开发分支（branch）。</p></li><li><p>Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。<br>观察命令对各区域的影响：<br><img src="/images/Git/git_theory.jpg" alt="git_theory"></p></li><li><p>master 是 master 分支所代表的目录树，此时 HEAD 实际是指向 master 分支的一个”游标”，objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。</p></li><li><p>当对工作区修改（或新增）的文件执行 <kbd>git add</kbd> 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</p></li><li><p>当执行提交操作 <kbd>git commit</kbd>时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</p></li><li><p>当执行 <kbd>git reset HEAD</kbd> 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</p></li><li><p>当执行 <kbd>git rm --cached &lt;file></kbd> 命令时，会直接从暂存区删除文件，工作区则不做出改变。</p></li><li><p>当执行 <kbd>git checkout .</kbd> 或者 <kbd>git checkout -- &lt;file></kbd> 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</p></li><li><p>当执行 <kbd>git checkout HEAD .</kbd> 或者 <kbd>git checkout HEAD &lt;file></kbd> 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</p></li></ul><ol start="3"><li>若对四个区域分级：workspace &lt; index &lt; repository &lt; remote，基本的转移如下表，参数和选项决定数据来源。</li></ol><table><thead><tr><th></th><th>低等级输入</th><th>高等级输入</th></tr></thead><tbody><tr><td>workspace</td><td>手动</td><td>git checkout/git stash</td></tr><tr><td>index/stage</td><td>git add</td><td>git reset</td></tr><tr><td>repository</td><td>git commit</td><td>git pull</td></tr><tr><td>remote</td><td>git push</td><td>-</td></tr></tbody></table><p>四个区域转换关系如下：<br><img src="/images/Git/git_transition.png" alt="git_transition"></p><h1 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h1><p>一般工作流程如下：</p><ul><li>在工作目录中修改某些文件。</li><li>对修改后的文件进行快照，然后保存到暂存区域。</li><li>提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。</li></ul><p><img src="/images/Git/git-process-img.png" alt="git-process"></p><h1 id="Git操作"><a href="#Git操作" class="headerlink" title="Git操作"></a>Git操作</h1><h2 id="Git创建版本库"><a href="#Git创建版本库" class="headerlink" title="Git创建版本库"></a>Git创建版本库</h2><ul><li>在工作目录中初始化新仓库</li><li>从现有仓库克隆</li></ul><h3 id="在工作目录中初始化"><a href="#在工作目录中初始化" class="headerlink" title="在工作目录中初始化"></a>在工作目录中初始化</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure><p>在新建空目录或已有目录中，使用命令 <code>git init</code> 初始化一个新仓库。初始化后该目录下自动生成<kbd>.git</kbd>目录，用于生成所有 Git 需要的数据和资源。</p><p><strong>文件加入版本库</strong><br>将文件添加到仓库（workspace -&gt; stage）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add &lt;file&gt;</span></span><br></pre></td></tr></table></figure><p>执行后没有任何信息则代表执行成功。</p><p>将文件提交到仓库（stage -&gt; repository）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m &lt;message&gt;</span></span><br></pre></td></tr></table></figure><p>多次<kbd>add</kbd>不同的文件，但只需一次<kbd>commit</kbd>就可以提交。</p><h3 id="从现有仓库克隆"><a href="#从现有仓库克隆" class="headerlink" title="从现有仓库克隆"></a>从现有仓库克隆</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> &lt;url&gt; &lt;newName&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Git 收取的是项目历史的完整数据（每一个文件的每一个版本），而不是某个特定版本，服务器上有的数据克隆之后本地也都有了。  </li><li><kbd>url</kbd> 支持 git 协议或 SSH 传输协议。通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。  </li><li>克隆之后的目录名为 url 中 .git 前的名称，通过 <kbd>&lt;newName></kbd> 可以自定义。目录中包含<kbd>.git</kbd>目录，用于保存下载下来的所有版本记录，然后从中取出最新版本的文件拷贝。</li></ul><h2 id="文件更新"><a href="#文件更新" class="headerlink" title="文件更新"></a>文件更新</h2><h3 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h3><p>文件状态主要分两种，已跟踪（tracked）即本来就被纳入版本控制管理的文件，其它文件即未跟踪（untracked）。</p><ul><li>Untracked：未跟踪，此文件没有加入到git库，不参与版本控制。通过 <code>git add</code> 状态变为staged</li><li>Unmodify：文件已经入库，未修改，即版本库中的文件快照内容与文件夹中完全一致。这种文件被修改成为Modified，通过<code>git rm</code>移出版本库成为Untracked</li><li>Modified：文件已修改。这种文件通过<code>git add</code>可变成staged，通过<code>git checkout</code>则丢弃修改回到unmodify</li><li>Staged：暂存状态。通过<code>git commit</code>则将修改同步到库中，这时库中的文件和本地文件又变为一致，变为Unmodify状态。执行<code>git reset HEAD &lt;filename&gt;</code>取消暂存，变为Modified</li></ul><p>初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改（unmodified）。<br>文件状态变化周期：<br><img src="/images/Git/file-status.png" alt="file-status"></p><p>修改后的文件状态是 modified，逐步放在暂存区域，最后一次性提交。</p><h3 id="检查文件状态"><a href="#检查文件状态" class="headerlink" title="检查文件状态"></a>检查文件状态</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看指定文件状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status &lt;filename&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看所有文件状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br></pre></td></tr></table></figure><p>例如创建README之后：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim README</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Untracked files:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># README</span></span></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><p>表示当前处在<kbd>master</kbd>分支，未跟踪文件里包含 README，即 Git 之前的快照中没有这个文件，未纳入管理。</p><h3 id="跟踪文件"><a href="#跟踪文件" class="headerlink" title="跟踪文件"></a>跟踪文件</h3><p>（workspace -&gt; stage；untracked -&gt; staged）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加指定文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add &lt;file1&gt; &lt;file2&gt; ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加指定目录到暂存区，包括子目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add &lt;dir&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加当前目录的所有文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add README</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">    # On branch master</span><br><span class="line">    # Changes to be committed:</span><br><span class="line">    # (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">    #</span><br><span class="line">    # new file: README</span><br><span class="line">    #</span><br></pre></td></tr></table></figure><p>“Changes to be committed:” 表示其下的文件处于暂存区</p><h3 id="暂存已修改文件"><a href="#暂存已修改文件" class="headerlink" title="暂存已修改文件"></a>暂存已修改文件</h3><p>（untracked -&gt; staged）<br>修改一个已跟踪的文件后</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">    # On branch master</span><br><span class="line">    # Changes not staged for commit:</span><br><span class="line">    # (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">    #</span><br><span class="line">    # modified: benchmarks.rb</span><br><span class="line">    #</span><br></pre></td></tr></table></figure><p>“Changes not staged for commit:” 表示该文件内容发生变化但还未放到暂存区，需要重新运行 <code>git add</code> 命令。<br>也就是说，文件修改之后必须再次 <code>git add</code>，否则 <code>git commit</code> 提交的是修改前版本。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add benchmarks.rb</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># new file: README</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> modified: benchmarks.rb</span></span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure><p><code>git add</code> 根据目标文件的状态产生不同的效果：</p><ul><li>开始跟踪新文件</li><li>把已跟踪的文件放到暂存区</li><li>合并时把有冲突的文件标记为已解决状态</li></ul><h3 id="忽略某些文件"><a href="#忽略某些文件" class="headerlink" title="忽略某些文件"></a>忽略某些文件</h3><p>有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。有以下三种方式：</p><ol><li><p>创建<kbd>.gitignore</kbd>文件</p></li><li><p>项目设置中指定排除文件<br>临时指定。需要编辑当前项目中的 .git/info/exclude 文件</p></li><li><p>定义Git全局的 .gitignore 文件<br>设置全局的.gitignore文件来管理所有Git项目的行为。创建.gitignore文件，存放在任意位置，然后使用命令 <code># git config --global core.excludesfile ~/.gitignore</code> 配置。</p></li></ol><p>格式规范如下：</p><ul><li>每行一个，空格不匹配任意文件，可作为分隔符，可用反斜杠转义</li><li>所有空行或者以注释符号 <kbd>＃</kbd> 开头的行都会被 Git 忽略</li><li>可以使用标准的 glob 模式匹配：shell 所使用的简化了的正则表达式</li><li>匹配模式最后跟反斜杠<kbd>/</kbd>说明要忽略的是目录下所有文件</li><li>使用两个星号”**” 表示匹配任意中间目录</li><li><kbd>/</kbd>结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件；<kbd>/</kbd>开始的模式匹配项目根目录</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号<kbd>!</kbd>取反。</li><li>关于优先级等更多语法查看<a href="https://www.cnblogs.com/kevingrace/p/5690241.html">Git忽略提交规则 - .gitignore配置运维总结</a></li></ul><p>一般来说每个Git项目中都需要一个“.gitignore”文件，告诉Git哪些文件不需要添加到版本管理中，实际项目中很多文件都是不需要版本管理的，例如日志、缩略图、敏感信息等。</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span></span><br><span class="line">    doc/*.txt</span><br></pre></td></tr></table></figure><h3 id="查看未暂存的更新"><a href="#查看未暂存的更新" class="headerlink" title="查看未暂存的更新"></a>查看未暂存的更新</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br></pre></td></tr></table></figure><p>查看工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。<br>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br><span class="line">    diff --git a/benchmarks.rb b/benchmarks.rb</span><br><span class="line">    index 3cb747f..da65585 100644</span><br><span class="line">    --- a/benchmarks.rb</span><br><span class="line">    +++ b/benchmarks.rb</span><br><span class="line">    @@ -36,6 +36,10 @@ def main</span><br><span class="line">    @commit.parents[0].parents[0].parents[0]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    + run_code(x, &#x27;commits 1&#x27;) do</span><br><span class="line">    + git.commits.size</span><br><span class="line">    + end</span><br><span class="line">    +</span><br><span class="line">    run_code(x, &#x27;commits 2&#x27;) do</span><br><span class="line">    log = git.commits(&#x27;master&#x27;, 15)</span><br><span class="line">    log.size</span><br></pre></td></tr></table></figure><h3 id="查看已暂存的更新"><a href="#查看已暂存的更新" class="headerlink" title="查看已暂存的更新"></a>查看已暂存的更新</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached</span></span><br></pre></td></tr></table></figure><p>查看已经暂存起来的文件和上次提交时的快照之间的差异</p><h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h3><p>（staged -&gt; commited；stage -&gt; repository）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m &lt;file&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区的指定文件到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit &lt;file1&gt; &lt;file2&gt; ... -m &lt;message&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交工作区自上次commit之后的变化，直接到仓库区，跳过add,对新文件无效</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交时显示所有diff信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -v</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果我们提交后发现有个文件改错了，将修改过的文件通过<span class="string">&quot;git add&quot;</span>后执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m &lt;message&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend &lt;file1&gt; &lt;file2&gt; ...</span> </span><br></pre></td></tr></table></figure><p>使用 <code>git status</code> 查看暂存区域状态，准备妥当之后就可以提交了。<br>这样看来暂存区的意义在于<strong>精心准备</strong>每次提交。  </p><ul><li>直接使用不加 <kbd>-m</kbd> 的 <code>git commit</code> 提交会打开编辑器（通过 <code>$ git config --global core.editor emacs</code> 配置）以便输入本次提交的说明。</li><li>使用<kbd>-m</kbd>选项比较方便。</li></ul><p>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;Story 182: Fix benchmarks for speed&quot;</span></span></span><br><span class="line">    [master]: created 463dc4f: &quot;Fix benchmarks for speed&quot;</span><br><span class="line">    2 files changed, 3 insertions(+), 0 deletions(-)</span><br><span class="line">    create mode 100644 README</span><br></pre></td></tr></table></figure><p>显示了提交的分支（master）、SHA-1校验和（463dc4f）、修改过的文件数（2）和增（3）删<strong>行数</strong>。  </p><p>因为修改后但未暂存的处于已修改态（modified），只能纳入下一次版本。  </p><p><strong>每次提交都是对项目的一次快照，以后可以回退</strong></p><h3 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -a -m &lt;message&gt;</span></span><br></pre></td></tr></table></figure><p>Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤，对新文件无效</p><h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><ol><li>从 Git 中移除文件</li></ol><p>未跟踪文件对 Git 来说不存在，手动<code>rm</code>即可，已跟踪文件就必须要从已跟踪文件清单（stage）中移除，然后提交。可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm &lt;file&gt;</span></span><br></pre></td></tr></table></figure><p>如果只是简单地从工作目录中手工删除文件，运行 <code>git status</code> 时就会在 “Changes not staged for commit” 部分（未暂存清单）看到。（判断为“修改”操作？）</p><ol start="2"><li>从 Git 中移除，但仍然希望保留在当前工作目录<br>（stage -&gt; workspace；tracked:staged -&gt; untracked）<br>即不小心纳入仓库后，想要移除跟踪但不删除文件。</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm --cached &lt;file&gt;</span></span><br></pre></td></tr></table></figure><h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git mv &lt;oldfileName&gt; &lt;newFileName&gt;</span></span><br></pre></td></tr></table></figure><p>Git 并不跟踪文件移动操作。如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。要在 Git 中对文件改名，执行<code>git mv</code>实际上相当于</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mv old new</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm old</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add new</span></span><br></pre></td></tr></table></figure><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br></pre></td></tr></table></figure><p>默认不用任何参数，<code>git log</code> 会按提交时间列出所有的更新信息。<br>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">    commit ca82a6dff817ec66f44342007202690a93763949   #SHA-1校验和</span><br><span class="line">    Author: Scott Chacon &lt;schacon@gee-mail.com&gt;       #作者&lt;邮箱&gt;</span><br><span class="line">    Date: Mon Mar 17 21:52:11 2008 -0700              #时间</span><br><span class="line"></span><br><span class="line">    changed the version number                        #提交说明</span><br></pre></td></tr></table></figure><p><strong>选项</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> &lt;option&gt;</span></span><br><span class="line">  -p    #开显示每次提交的内容差异</span><br><span class="line">  --stat  #仅显示简要的增改行数统计</span><br><span class="line">  --shortstat #只显示 --stat 中最后的行数修改添加移除统计。</span><br><span class="line">  --name-only #仅在提交信息后显示已修改的文件清单。</span><br><span class="line">  --name-status #显示新增、修改、删除的文件清单。</span><br><span class="line">  --abbrev-commit #仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</span><br><span class="line">  --relative-date #使用较短的相对时间显示（比如，“2 weeks ago”）。</span><br><span class="line">  --graph 显示 ASCII #图形表示的分支合并历史。</span><br><span class="line">  --pretty #使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</span><br></pre></td></tr></table></figure><h3 id="限制输出长度"><a href="#限制输出长度" class="headerlink" title="限制输出长度"></a>限制输出长度</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> &lt;option&gt;</span></span><br><span class="line">  -(n) #仅显示最近的 n 条提交</span><br><span class="line">  --since, --after #仅显示指定时间之后的提交。</span><br><span class="line">  --until, --before #仅显示指定时间之前的提交。</span><br><span class="line">  --author #仅显示指定作者相关的提交。</span><br><span class="line">  --committer #仅显示指定提交者相关的提交。</span><br></pre></td></tr></table></figure><h3 id="使用图形化工具查阅提交历史"><a href="#使用图形化工具查阅提交历史" class="headerlink" title="使用图形化工具查阅提交历史"></a>使用图形化工具查阅提交历史</h3><p>随 Git 一同发布的 gitk 相当于 git log 命令的可视化版本。</p><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><p>任何已经提交到 Git 的都可以被恢复。你可能失去的数据，仅限于没有提交过的，对 Git 来说它们就像从未存在过一样。</p><h3 id="修改最后一次提交"><a href="#修改最后一次提交" class="headerlink" title="修改最后一次提交"></a>修改最后一次提交</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果我们提交后发现有个文件改错或没有加，将修改过的文件通过<span class="string">&quot;git add&quot;</span>后执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改上一次commit的提交信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m &lt;message&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend &lt;file1&gt; &lt;file2&gt; ...</span> </span><br></pre></td></tr></table></figure><p>也就是说，在执行<code>git commit</code>之后暂存区为空，此时若再次执行<code>git commit --amend</code>判断为修改上次的提交信息；此时若<code>git add</code>新文件到暂存区，执行此命令相当于添加到上次提交。</p><h3 id="取消已经暂存的文件"><a href="#取消已经暂存的文件" class="headerlink" title="取消已经暂存的文件"></a>取消已经暂存的文件</h3><p>（staged -&gt; modified）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset HEAD &lt;file&gt;</span></span><br></pre></td></tr></table></figure><p>文件从暂存区回到已修改未暂存状态。</p><h3 id="取消对文件的修改"><a href="#取消对文件的修改" class="headerlink" title="取消对文件的修改"></a>取消对文件的修改</h3><p>（modified -&gt; unmodified）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- &lt;file&gt;</span></span><br></pre></td></tr></table></figure><h3 id="文件操作总结"><a href="#文件操作总结" class="headerlink" title="文件操作总结"></a>文件操作总结</h3><p><img src="/images/Git/file-summary.png" alt="file-summary.png"></p><h1 id="Git远程仓库"><a href="#Git远程仓库" class="headerlink" title="Git远程仓库"></a>Git远程仓库</h1><p>Git 要求每个远程主机都必须指定一个主机名。</p><h2 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote</span></span><br></pre></td></tr></table></figure><p>查看每个远程库的简短名字。Git 默认使用“origin”这个名字来标识你所克隆的原始仓库。  </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br></pre></td></tr></table></figure><p>加上<kbd>-v</kbd>选项，显示对应的克隆地址。</p><h2 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add &lt;shortname&gt; &lt;url&gt;</span></span><br></pre></td></tr></table></figure><p><kbd>&lt;shortname></kbd>即自定义远程主机名<remote-name>，在<code>git remote</code>中显示，</p><h2 id="从远程仓库抓取数据"><a href="#从远程仓库抓取数据" class="headerlink" title="从远程仓库抓取数据"></a>从远程仓库抓取数据</h2><p><strong>git fetch</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch add &lt;remote-name&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch add &lt;remote-name&gt; &lt;branch-name&gt;  <span class="comment">#指定分支</span></span></span><br></pre></td></tr></table></figure><ul><li>抓取所有本地仓库没有的数据。但只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支。  </li><li>通常用来查看其他人的进程，因为它取回的代码对本地代码没有影响。  </li><li>指定分支所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。  </li><li>类似的，<code>git fetch origin</code>会抓取上次<code>clone</code>以来的别人提交的更新。  </li><li>如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。</li></ul><p><strong>git pull</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull &lt;remote-name&gt; &lt;remote-branch-name&gt;:&lt;local-branch-name&gt;</span></span><br></pre></td></tr></table></figure><ul><li>取回远程主机某个分支的更新，再与本地的指定分支合并。  </li><li>如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。  </li><li>如果是与当前分支合并，则冒号后面的部分可以省略。  </li><li>等同于先<code>git fetch</code>再<code>git merge</code>。  </li><li>如果远程主机删除了某个分支，默认情况下，<code>git pull</code> 不会在拉取远程分支的时删除对应的本地分支。这是为了防止由于其他人操作了远程主机，导致<code>git pull</code>不知不觉删除了本地分支。除非加上参数 <kbd>-p</kbd> 就会在本地删除远程已经删除的分支。</li></ul><h2 id="推送数据到远程仓库"><a href="#推送数据到远程仓库" class="headerlink" title="推送数据到远程仓库"></a>推送数据到远程仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;remote-name&gt; &lt;local-branch-name&gt;:&lt;remote-branch-name&gt;</span></span><br></pre></td></tr></table></figure><ul><li>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。  </li><li>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。<br>将本地仓库中的数据推送到远程仓库，只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。</li><li>如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</li><li>如果是新建分支第一次<code>git push</code>，会提示：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fatal: The current branch dev1 has no upstream branch.</span><br><span class="line">　　To push the current branch and set the remote as upstream, use</span><br><span class="line">　　git push --set-upstream origin dev1</span><br></pre></td></tr></table></figure><p>输入这行命令，然后输入用户名和密码就成功了，以后的push就只需要输入<code>git push origin</code>。</p><ul><li>如果当前分支只有一个追踪分支，那么主机名都可以省略。</li><li>如果当前分支与多个主机存在追踪关系，则可以使用<kbd>-u</kbd>选项指定一个默认主机，这样后面就可以不加任何参数使用<code>git push</code>。</li><li>如果不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用<kbd>--all</kbd>选项。</li><li>如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做<code>git pull</code>合并差异，然后再推送到远程主机。这时如果你一定要推送，可以使用<kbd>--force</kbd>选项。<br>结果导致远程主机上更新的版本被覆盖。</li></ul><h2 id="查看远程仓库信息"><a href="#查看远程仓库信息" class="headerlink" title="查看远程仓库信息"></a>查看远程仓库信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote show &lt;remote-name&gt;</span></span><br></pre></td></tr></table></figure><p>例如：  </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote show origin</span></span><br><span class="line">    * remote origin</span><br><span class="line">    URL: git@github.com:defunkt/github.git</span><br><span class="line">    Remote branch merged with &#x27;git pull&#x27; while on branch issues     # git pull 时将自动合并的分支</span><br><span class="line">    issues</span><br><span class="line">    Remote branch merged with &#x27;git pull&#x27; while on branch master     # git pull 时将自动合并的分支</span><br><span class="line">    master</span><br><span class="line">    New remote branches (next fetch will store in remotes/origin)   # 还没有同步到本地的远端分支</span><br><span class="line">    caching               </span><br><span class="line">    Stale tracking branches (use &#x27;git remote prune&#x27;)    #已同步到本地的远端分支在远端服务器上已被删除</span><br><span class="line">    libwalker</span><br><span class="line">    walker2</span><br><span class="line">    Tracked remote branches</span><br><span class="line">    acl</span><br><span class="line">    apiv2</span><br><span class="line">    dashboard2</span><br><span class="line">    issues</span><br><span class="line">    master</span><br><span class="line">    postgres</span><br><span class="line">    Local branch pushed with &#x27;git push&#x27;     # git push 缺省推送的分支</span><br><span class="line">    master:master         </span><br></pre></td></tr></table></figure><h2 id="远程仓库的删除和重命名"><a href="#远程仓库的删除和重命名" class="headerlink" title="远程仓库的删除和重命名"></a>远程仓库的删除和重命名</h2><h3 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote rename pb paul</span></span><br></pre></td></tr></table></figure><p>修改的是某个远程仓库在本地的简称，分支名也会发生变化。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote rm &lt;remote-name&gt;</span></span><br></pre></td></tr></table></figure><h1 id="版本标签"><a href="#版本标签" class="headerlink" title="版本标签"></a>版本标签</h1><h2 id="显示已有标签"><a href="#显示已有标签" class="headerlink" title="显示已有标签"></a>显示已有标签</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> $ git tag -l <span class="string">&#x27;&lt;tag-name&gt;&#x27;</span>    <span class="comment">#显示指定版本</span></span></span><br></pre></td></tr></table></figure><p>按照字母顺序排列。</p><h2 id="新建标签"><a href="#新建标签" class="headerlink" title="新建标签"></a>新建标签</h2><p>Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用；而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息。</p><p>建议一般使用含附注型的标签，临时性加注标签用轻量级标签。</p><h3 id="含附注的标签"><a href="#含附注的标签" class="headerlink" title="含附注的标签"></a>含附注的标签</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -a &lt;tag-name&gt; -m &lt;message&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show <span class="string">&#x27;&lt;tag-name&gt;&#x27;</span>    <span class="comment">#查看相应标签的版本信息</span></span></span><br></pre></td></tr></table></figure><p><kbd>-a</kbd>指定标签名，<kbd>-m</kbd>指定对应的标签说明，<code>git show</code>可以显示出。</p><h3 id="轻量级标签"><a href="#轻量级标签" class="headerlink" title="轻量级标签"></a>轻量级标签</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag &lt;tag-name&gt;</span></span><br></pre></td></tr></table></figure><p>没有选项。</p><h3 id="签署标签"><a href="#签署标签" class="headerlink" title="签署标签"></a>签署标签</h3><p>如果你有自己的私钥，还可以用 GPG 来签署标签，只需要把之前的 <kbd>-a</kbd> 改为 <kbd>-s</kbd> 即可。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -s &lt;tag-name&gt; -m &lt;message&gt;</span></span><br></pre></td></tr></table></figure><h3 id="验证标签"><a href="#验证标签" class="headerlink" title="验证标签"></a>验证标签</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -v &lt;tag-name&gt;</span></span><br></pre></td></tr></table></figure><p>验证已经签署的标签，会调用 GPG 来验证签名，所以需要有签署者的公钥，存放在 keyring 中，才能验证，否则报错<code>gpg: Can&#39;t check signature: public key not found</code>。</p><h2 id="后期加注标签"><a href="#后期加注标签" class="headerlink" title="后期加注标签"></a>后期加注标签</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -a &lt;tag-name&gt; &lt;SHA-1&gt;</span></span><br></pre></td></tr></table></figure><p>只要在打标签的时候跟上对应提交对象的校验和（或前几位字符）即可。<br>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v1.2 9fceb02</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show v1.2</span></span><br><span class="line">  version 1.2</span><br><span class="line">    commit 9fceb02d0ae598e95dc970b74767f19372d61af8</span><br><span class="line">    Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt;</span><br><span class="line">    Date: Sun Apr 27 20:43:35 2008 -0700</span><br><span class="line"></span><br><span class="line">    updated rakefile</span><br></pre></td></tr></table></figure><h2 id="分享标签"><a href="#分享标签" class="headerlink" title="分享标签"></a>分享标签</h2><p>默认情况下，<code>git push</code> 并不会把标签传送到远端服务器上</p><ul><li>使用<kbd>--tags</kbd>选项一次推送所有本地新增的标签上去</li><li>通过显式命令才能分享标签到远端仓库。  </li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin --tags</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin [tag-name]</span></span><br></pre></td></tr></table></figure><h1 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h1><p>使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。</p><h2 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h2><p>在 Git 中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针、作者等附属信息、零个或多个指向该提交对象的父对象指针。首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。</p><p>举例：对于三个文件暂存后，Git 嫁给你当前版本的快照（blob类型）连同每个文件的额SHA-1保存至仓库。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add README test.rb LICENSE</span></span><br><span class="line">    $ git commit -m &#x27;initial commit of my project&#x27;</span><br></pre></td></tr></table></figure><p>现在仓库中有五个对象：</p><ul><li>三个 blob 对象：表示文件快照内容</li><li>tree 对象：记录着目录树内容及其中各个文件对应的 blob 对象索引的</li><li>commit 对象：指向 tree 对象（根目录）的索引和其他提交信息元数据。在需要的时候重现此次快照。<br><img src="/images/Git/singleObj.png" alt="singleObj.png"></li></ul><p>作些修改后再次提交，那么这次的提交对象会包含一个指向上次提交对象的指针（parent 对象）。两次提交后：<br><img src="images/Git/multiObj.png" alt="multiObj.png"></p><p>Git 中的分支，其实本质上仅仅是个指向 commit 对象的可变指针。Git 会使用 <kbd>master</kbd> 作为分支的默认名字。在若干次提交后，你其实已经有了一个指向最后一次提交对象的 <kbd>master</kbd> 分支，它在每次提交的时候都会自动向前移动。<br><img src="images/Git/masterHistory.png" alt="masterHistory.png"></p><h2 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch &lt;branch-name&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>git branch testing</code>在当前 commit 对象上新建一个分支指针<kbd>testing</kbd>：<br><img src="images/Git/newBranch.png" alt="newBranch.png"></p><h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><p>HEAD 是一个指向你正在工作中的本地分支的指针，即当前分支。</p><p>运行 <code>git branch</code> 命令，仅仅是建立了一个新的分支，但不会自动切换到这个分支中去，所以依然还在 <kbd>master</kbd> 分支里工作：</p><p><img src="images/Git/headMaster.png" alt="headMaster.png"></p><h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout &lt;branch-name&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b &lt;branch-name&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>git checkout testing</code>切换分支<kbd>testing</kbd>：<br><img src="images/Git/checkout.png" alt="checkout.png"></p><p>或者运行 <code>git checkout</code> 并加上 <kbd>-b</kbd> 参数，新建并切换到该分支。</p><p>提交之后：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim test.rb</span></span><br><span class="line">    $ git commit -a -m &#x27;made a change&#x27;</span><br></pre></td></tr></table></figure><p><img src="images/Git/headTesting.png" alt="headTesting.png"><br>提交后 HEAD 随<kbd>testing</kbd>分支一起向前移动，，而 <kbd>master</kbd> 分支仍然指向原先 <code>git checkout</code> 时所在的 commit 对象。</p><p>如果此时执行<code>git checkout master</code>，切回<kbd>master</kbd>分支：</p><p><img src="images/Git/masterHistory.png" alt="masterHistory.png"><br>做了两件事：</p><ul><li>HEAD 指针移回到 <kbd>master</kbd> 分支</li><li>工作目录中的文件换成了 master 分支所指向的快照内容（较旧的进度）<br>它的主要作用是将 testing 分支里作出的修改暂时取消，这样你就可以向另一个方向进行开发。</li></ul><p>此时如果提交新文件，即：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim test.rb</span></span><br><span class="line">    $ git commit -a -m &#x27;made other changes&#x27;</span><br></pre></td></tr></table></figure><p><img src="images/Git/branchHistory.png" alt="branchHistory.png"></p><p><strong>Git 中的分支实际上仅是一个包含所指对象校验和（40 个字符长度 SHA-1 字串）的文件，Git 的实现与项目复杂度无关，并且每次提交都记录了 parent 对象，所以 Git 分支操作非常廉价。</strong></p><blockquote><p>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：<br>你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！<br>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：<br>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：<br>所以Git合并分支也很快！就改改指针，工作区内容也不变！<br>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支。</p></blockquote><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge iss53</span></span><br></pre></td></tr></table></figure><p>回到 <kbd>master</kbd> 分支，运行 <code>git merge</code> 命令指定要合并进来的分支<kbd>iss53</kbd></p><h2 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h2><p>如果在不同的分支中都修改了同一个文件的同一部分，Git 就无法干净地把两者合到一起（逻辑上说，这种问题只能由人来裁决）。结果如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge iss53</span></span><br><span class="line">    Auto-merging index.html</span><br><span class="line">    CONFLICT (content): Merge conflict in index.html</span><br><span class="line">    Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>Git 做了合并但没有提交，等待解决冲突。可以用 <code>git status</code> 查看合并时发生冲突的文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash"> unmerged: index.html</span></span><br></pre></td></tr></table></figure><p>任何包含未解决冲突的文件都会以未合并<strong>unmerged</strong>的状态列出。Git 会在有冲突的文件里加入标准的冲突解决标记：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line">    &lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class="line">    =======</span><br><span class="line">    &lt;div id=&quot;footer&quot;&gt;</span><br><span class="line">    please contact us at support@github.com</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></pre></td></tr></table></figure><p>可以看到 <kbd>=======</kbd> 隔开的上半部分，是 HEAD（当前分支）中的内容，下半部分是在 <kbd>iss53</kbd> 分支中的内容。</p><p>解决办法是删除上面的内容（包括’=’’&lt;’’&gt;’），自行决定怎么写。之后运行<code>git add</code>和<code>git status</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash"> modified: index.html</span></span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure><p>确认冲突已解决，标记为<strong>modified</strong>，再<code>git commit</code>提交。</p><p>也可以使用相关可视化工具解决冲突，运行<code>git mergetool</code>。</p><h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d &lt;branch-name&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">强制删除</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -D &lt;branch-name&gt;</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程分支，分支必须完全合并在其上游分支，或者在HEAD上没有设置上游</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete &lt;branch-name&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -dr &lt;remote-name/branch-name&gt;</span></span><br></pre></td></tr></table></figure><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><strong>工作流程</strong></p><ol><li>开发某个网站为</li><li>实现某个新的需求，创建一个分支。</li><li>在这个分支上开展工作。</li></ol><p>假设此时突然有个很严重的问题需要紧急修补，那么：</p><ol><li>返回到原先已经发布到生产服务器上的分支。</li><li>为这次紧急修补建立一个新分支，并在其中修复问题。</li><li>通过测试后，回到生产服务器所在的分支，将修补分支合并进来，然后再推送到生产服务器上。</li><li>切换到之前实现新需求的分支，继续工作。</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建iss53并切换</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b iss53</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 遇问题切回master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时工作区和之前 master 提交时完全一样</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建紧急修补分支 hotfix</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b <span class="string">&#x27;hotfix&#x27;</span></span></span><br></pre></td></tr></table></figure><p>Git 的好处：  </p><ul><li>不需要同时发布这个补丁和 iss53 里作出的修改</li><li>不需要在创建和发布该补丁到服务器之前花费大力气来复原这些修改</li></ul><p>切换分支时需要留心你的暂存区或者工作目录里<strong>还没有提交的修改</strong>，它会产生冲突从而阻止切换，最好保持一个清洁的工作区域（也可以通过 stashing 和 commit amending 绕过这种问题）。</p><p><img src="images/Git/hotfixSuccess.png" alt="hotfixSuccess.png.png"></p><p>修改、测试之后回到 <kbd>master</kbd> 分支并把 <kbd>hotfix</kbd> 合并：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge hotfix</span></span><br></pre></td></tr></table></figure><p>请注意，合并时出现了“Fast forward”的提示。由于当前 <kbd>master</kbd> 分支所在的提交对象是要并入的 <kbd>hotfix</kbd> 分支的直接上游，Git 只需把 <kbd>master</kbd> 分支指针直接右移。换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为<strong>快进</strong>（Fast forward）。</p><p><kbd>hotfix</kbd>分支完成历史使命之后可以删掉，回到正常的 iss53 正常工作：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d hotfix</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout iss53</span></span><br></pre></td></tr></table></figure><p><img src="images/Git/normalWork.png" alt="normalWork.png"></p><p>需求#53开发完之后，合并<kbd>master</kbd>和<kbd>iss53</kbd>分支：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge iss53</span></span><br></pre></td></tr></table></figure><p>这次合并操作的底层实现，并不同于之前 <kbd>hotfix</kbd> 的并入方式。因为这次你的开发历史是从更早的地方开始分叉的。由于当前 <kbd>master</kbd> 分支所指向的提交对象（C4）并不是 <kbd>iss53</kbd> 分支的直接祖先，Git 不得不进行一些额外处理。就此例而言，Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算：</p><p><img src="images/Git/merge3.png" alt="merge3.png"></p><p>这次，Git 没有简单地把分支指针右移，而是对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（C6）（见图 3-17）。这个提交对象比较特殊，它有两个祖先（C4 和 C5）。</p><p>值得一提的是 Git 可以自己裁决哪个共同祖先才是最佳合并基础；这和 CVS 或 Subversion（1.5 以后的版本）不同，它们需要开发者手工指定合并基础。所以此特性让 Git 的合并操作比其他系统都要简单不少。</p><p><img src="images/Git/mergeAutoCommit.png" alt="mergeAutoCommit.png"></p><p>此时<kbd>iss53</kbd>没用了，可以删除。</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p><strong>查看所有分支</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">    iss53</span><br><span class="line">    * master</span><br><span class="line">    testing</span><br></pre></td></tr></table></figure><p><code>git branch</code> 命令不加参数列出所有分支。 <kbd>master</kbd> 分支前的 <kbd>*</kbd> 字符表示当前所在的分支。也就是说如果现在提交更新，<kbd>master</kbd> 分支将随着开发进度前移。</p><p><strong>查看各分支最后一个 commit 对象的信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -v</span></span><br></pre></td></tr></table></figure><p><strong>查看与HEAD已合并/或未合并分支</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看已并入当前分支的==哪些分支是当前分支的直接上游</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --merged</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看尚未合并的</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --no-merged</span></span><br></pre></td></tr></table></figure><p>对于已合并的，可以用<code>git branch -d</code>直接删除，不会有损失。<br>对于已合并的，用<code>git branch -d</code>删除会报错，因为这样做会丢失数据，除非<kbd>-D</kbd>强制删除。</p><h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p>用<kbd>remote-name/remote-branch-name</kbd>描述远程分支，区别于本地分支。</p><p>在第一次<code>git clone</code>之后，下载的数据命名为<kbd>origin/master</kbd>，无法修改。之后 Git 创建属于本地的 <kbd>master</kbd> 分支，二者都指向远程<kbd>origin</kbd>的<kbd>master</kbd>分支。<br><img src="images/Git/remoteBranch1.png" alt="remoteBranch1.png"></p><p>如果在本地 <kbd>master</kbd> 分支做了些改动，在本地的提交历史正朝向不同方向发展，与此同时，其他人向 git.ourcompany.com 推送了他们的更新，服务器上的 <kbd>master</kbd> 分支就会向前推进。不过只要不和服务器通讯，本地的 <kbd>origin/master</kbd> 指针仍然保持原位不会移动。<br><img src="images/Git/remoteBranch2.png" alt="remoteBranch2.png"></p><p>可以运行 <code>git fetch origin</code> 来同步远程服务器上的数据到本地。从 origin 上获取尚未拥有的数据，更新你本地的数据库，然后把 <kbd>origin/master</kbd> 的指针移到最新位置。<br><img src="images/Git/remoteBranch3.png" alt="remoteBranch3.png"></p><p>假设，还有另一个仅供你的敏捷开发小组使用的内部服务器 git.team1.ourcompany.com。加为当前项目的远程分支之一，并命名为 teamone。</p><p>现在可以用 <code>git fetch teamone</code> 来获取小组服务器上你还没有的数据了。由于当前该服务器上的内容是你 <kbd>origin</kbd> 服务器上的子集，Git 不会下载任何数据，而只是简单地创建一个名为 <kbd>teamone/master</kbd> 的远程分支，指向 teamone 服务器上 <kbd>master</kbd> 分支所在的提交对象 <kbd>31b8e</kbd>。<br><img src="images/Git/remoteBranch4.png" alt="remoteBranch4.png"></p><p><kbd>master</kbd>并不是多么神秘复杂的东西，分清楚远程的别人的<kbd>origin/master</kbd>、本地的别人的<kbd>origin/master</kbd>、本地的自己的<kbd>master</kbd>就可以了。</p><h2 id="推送本地分支"><a href="#推送本地分支" class="headerlink" title="推送本地分支"></a>推送本地分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;remote-name&gt; &lt;branch-name&gt;</span></span><br></pre></td></tr></table></figure><p>要想和其他人分享某个本地分支，你需要把它推送到一个你拥有<strong>写权限</strong>的远程仓库。你创建的本地分支不会因为你的写入操作而被自动同步到你引入的远程服务器上，你需要明确地执行推送分支的操作。</p><p><code>git push origin serverfix:serverfix</code>意思是“上传我本地的 <kbd>serverfix</kbd> 分支到远程仓库中去，仍旧称它为 <kbd>serverfix</kbd> 分支”。通过此语法，你可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫作 <kbd>awesomebranch</kbd>，可以用 <code>git push origin serverfix:awesomebranch</code> 来推送数据。</p><h2 id="跟踪远程分支"><a href="#跟踪远程分支" class="headerlink" title="跟踪远程分支"></a>跟踪远程分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b &lt;branch-name&gt; &lt;remote-name/branch-name&gt;</span></span><br></pre></td></tr></table></figure><p>从远程分支 <code>checkout</code> 出来的本地分支，称为<strong>跟踪分支</strong> (tracking branch)。跟踪分支是一种和某个远程分支有直接联系的本地分支。在跟踪分支里输入 <code>git push</code>，Git 会自行推断应该向哪个服务器的哪个分支推送数据。</p><h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;remote-name&gt; :&lt;branch-name&gt;</span></span><br></pre></td></tr></table></figure><p>对于<code>git push &lt;remote-name&gt; &lt;local-branch-name&gt;:&lt;remote-branch-name&gt;</code> 语法，如果省略 <local-branch-name>，那就等于是在说“在这里提取空白然后把它变成<remote-branch-name>”。</p><h2 id="分支衍合"><a href="#分支衍合" class="headerlink" title="分支衍合"></a>分支衍合</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout &lt;rebase-branch-name&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rebase &lt;master-branch-name&gt;</span></span><br></pre></td></tr></table></figure><p>把一个分支中的修改整合到另一个分支有两种办法：<code>merge</code> 和 <code>rebase</code>。<br><strong>merge</strong><br><img src="images/Git/merge.png" alt="merge.png"></p><p><strong>rebase</strong><br>还有可以把在 C3 里产生的变化补丁在 C4 的基础上重新打一遍，这种操作叫做衍合（rebase）。即把在一个分支里提交的改变移到另一个分支里重放一遍。</p><p>原理是回到两个分支最近的共同祖先，根据当前分支（也就是要进行衍合的分支 <kbd>experiment</kbd>）后续的历次提交对象（这里只有一个 C3），生成一系列文件补丁，然后以基底分支（也就是主干分支 <kbd>master</kbd>）最后一个提交对象（C4）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（C3’），从而改写 <kbd>experiment</kbd> 的提交历史，使它成为 <kbd>master</kbd> 分支的直接下游：<br><img src="images/Git/rebase.png" alt="rebase.png"></p><p>再进行快进合并：<br><img src="images/Git/speedMerge.png" alt="speedMerge.png"></p><p>现在的 C3’ 对应的快照，其实和普通的三方合并，即 C5 对应的快照内容一模一样，结果没有任何区别，只不过提交历史不同。但衍合能产生一个更为整洁的提交历史，仿佛所有修改都是在一根线上先后进行的。</p><p>一般我们使用衍合的目的，是想要得到一个能在远程分支上干净应用的补丁。项目志愿开发者通过衍合提交，维护者就不需要做任何整合工作。实际上是把解决分支补丁同最新主干代码之间冲突的责任，化转为由提交补丁的人来解决。</p><p>衍合是按照每行的修改次序重演一遍修改，而合并是把最终结果合在一起。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://git-scm.com/docs">Git官方参考文档</a></li><li><a href="http://git.oschina.net/progit/">Pro Git（中文版）</a></li><li><a href="https://www.cnblogs.com/syp172654682/p/7689328.html">深入浅出Git教程</a></li><li><a href="https://www.cnblogs.com/yaozhongxiao/p/3811130.html">Git图解剖析</a></li><li><a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的官方网站</a></li><li><a href="https://www.runoob.com/git/">菜鸟教程</a></li><li><a href="https://www.cnblogs.com/kevingrace/p/5690241.html">Git忽略提交规则 - .gitignore配置运维总结</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Git是目前世界上最先进的分布式版本控制系统（没有之一）。&lt;/p&gt;</summary>
    
    
    
    <category term="Tool" scheme="https://memorykk.cn/categories/Tool/"/>
    
    
    <category term="Git" scheme="https://memorykk.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>记一次博客接入Gitalk出现403问题的解决过程</title>
    <link href="https://memorykk.cn/gitalk-403.html"/>
    <id>https://memorykk.cn/gitalk-403.html</id>
    <published>2021-02-14T01:44:16.000Z</published>
    <updated>2021-02-19T08:45:30.462Z</updated>
    
    <content type="html"><![CDATA[<p>小站的评论系统始终无法接入 Gitalk，提示 403 Error</p><span id="more"></span><hr><p><strong>目录</strong></p><ul><li><a href="#%E9%97%AE%E9%A2%98">问题</a></li><li><a href="#%E6%88%91%E7%9A%84%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B">我的解决过程</a></li><li><a href="#%E5%85%B6%E4%BB%96%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B">其他解决过程</a><ul><li><a href="#%E8%B5%B7%E5%9B%A0">起因</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E7%BB%8F%E9%AA%8C">经验</a></li></ul></li><li><a href="#%E9%83%A8%E7%BD%B2%E8%87%AA%E5%B7%B1%E7%9A%84CORSproxy">部署自己的 CORSproxy</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li></ul><hr><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>最近博客接入 Gitalk 评论系统时，始终报错 403，不知所以，无奈转至 LeanCloud 的 valine comment，但 valine 的风格总让人感觉不够优雅 ╯︿╰。</p><p>报错界面：<img src="/images/gitalk-403/no-issue.PNG" class="" title="no-issue" alt="no-issue"></p><p>点击 <kbd>使用 GitHub 登录</kbd> 之后，显示 Error：<img src="/images/gitalk-403/403.PNG" class="" title="403" alt="403"></p><h1 id="我的解决过程"><a href="#我的解决过程" class="headerlink" title="我的解决过程"></a>我的解决过程</h1><ol><li><p>打开 <kbd>F12</kbd> 控制台，刷新页面，查看出错的 Header：<img src="/images/gitalk-403/f12.PNG" class="" title="f12" alt="f12"></p></li><li><p>触及到知识盲区了。这个 URL 尽管没见过，但两个地址套起来的形式很有特点，习惯性地打开前面的<a href="https://cors-anywhere.herokuapp.com/">链接</a>，展示如下：<img src="/images/gitalk-403/core.PNG" class="" title="core" alt="core"></p></li></ol><p>大意是：CORS Anywhere 这是个实现跨域请求的 Demo，单击按钮临时解锁对演示的访问。</p><p>So，我被加锁了？</p><ol start="3"><li>打开<a href="https://github.com/Rob--W/cors-anywhere/issues/301">提示的参考链接</a>，这个 CORS Anywhere 的作者说：</li></ol><blockquote><p>Public demo server (cors-anywhere.herokuapp.com) will be very limited by January 2021, 31st #301<br>The user (developer) must visit a page at cors-anywhere.herokuapp.com to temporarily unlock the demo for their browser. This allows developers to try out the functionality, to help with deciding on self-hosting or looking for alternatives.</p></blockquote><p>意思是 CORS Anywhere 这个 Demo 被滥用，从 2021/1/31 开始限制，用户必须访问<a href="cors-anywhere.herokuapp.com">页面</a><strong>临时</strong>解锁。</p><ol start="4"><li><p>虽然这只是个临时解决方案，但当时没想太多，能用就行。<img src="/images/gitalk-403/requestTemp.PNG" class="" title="requestTemp" alt="requestTemp"></p></li><li><p>Gitalk 也确实正常工作了。</p></li></ol><h1 id="其他解决过程"><a href="#其他解决过程" class="headerlink" title="其他解决过程"></a>其他解决过程</h1><p>在 GitHub 上寻找相关 Issues 时看见这位大神的解决过程，自愧不如，经原作者同意之后搬运过来，特别是解决思路让我很受启发。以下是原文：</p><hr><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>我的博客最近刚换上了 hexo 框架，于是评论功能就换成了 Gitalk。但最近发现登录功能不好用了，点击使用 GitHub 登录总是失败。</p><p>就点击这个按钮的时候，始终登录不上去：</p><p><img src="https://qiniu.cuiqingcai.com/n79m6.png" alt="image-20210212223917778"></p><p>于是我就想着手解决一下这个问题。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里就记录一下我在排查过程中碰到的一些坑和解决思路。</p><p>首先，登录失败的问题，第一时间应该去排查的就是网络请求，打开控制台，查看 Network 面板，出现类似的结果：</p><p><img src="https://qiniu.cuiqingcai.com/4d8sw.png" alt="image-20210212224407613"></p><p>网络请求直接 403 了，拿不到 token 了，于是就登录不上了。</p><p>观察下，这个链接 cors-anywhere 似乎是用来解决跨域限制的，后面还跟了一个 GitHub 的 Access Token 获取地址，那没跑了，前面这个就是一个反向代理，后面是真实的请求 URL。</p><p>OK，看着这个也没啥思路啊，然后接着怎么办？</p><p>那就接着去搜这个 cors-anywhere.herokuapp.com，因为 herokuapp 很眼熟嘛，就是一个公用的网址 Host 平台，类似于 AWS、Azure 之类的，那么前面这个可能包含某些信息。万一是开源的那就好办了。</p><p>接着搜，cors-anywhere，然后就搜到了这个：<a href="https://github.com/Rob--W/cors-anywhere">https://github.com/Rob–W/cors-anywhere</a></p><p>介绍如下：</p><blockquote><p><strong>CORS Anywhere</strong> is a NodeJS proxy which adds CORS headers to the proxied request.</p><p>The url to proxy is literally taken from the path, validated and proxied. The protocol part of the proxied URI is optional, and defaults to “http”. If port 443 is specified, the protocol defaults to “https”.</p><p>This package does not put any restrictions on the http methods or headers, except for cookies. Requesting <a href="http://www.w3.org/TR/cors/#user-credentials">user credentials</a> is disallowed. The app can be configured to require a header for proxying a request, for example to avoid a direct visit from the browser.</p></blockquote><p>真是一个开源框架，和我猜的一样，就是一个解决跨域问题而生的反向代理。</p><p>然后我就在它的 README 中看到了这个：</p><p><img src="https://qiniu.cuiqingcai.com/e9xla.png" alt="image-20210212224946845"></p><p>好家伙，这不就是我刚才用到的链接吗？</p><p>那肯定是这个玩意出了什么毛病。</p><p>咋看呢？这个果断就是找 Issue 了：</p><p><img src="https://qiniu.cuiqingcai.com/yyu6t.png" alt="image-20210212225114466"></p><p>一看，太明显了：</p><blockquote><p>PSA: Public demo server (cors-anywhere.herokuapp.com) will be very limited by January 2021, 31st</p></blockquote><p>意思就是从今年 1.31 开始这个网站的访问会受限，点进去看看：</p><blockquote><p>The demo server of CORS Anywhere (cors-anywhere.herokuapp.com) is meant to be a demo of this project. But abuse has become so common that the platform where the demo is hosted (Heroku) has asked me to shut down the server, despite efforts to counter the abuse (rate limits in <a href="https://github.com/Rob--W/cors-anywhere/issues/45">#45</a> and <a href="https://github.com/Rob--W/cors-anywhere/issues/164">#164</a>, and blocking other forms of requests). Downtime becomes increasingly frequent (e.g. recently <a href="https://github.com/Rob--W/cors-anywhere/issues/300">#300</a>, <a href="https://github.com/Rob--W/cors-anywhere/issues/299">#299</a>, <a href="https://github.com/Rob--W/cors-anywhere/issues/295">#295</a>, <a href="https://github.com/Rob--W/cors-anywhere/issues/294">#294</a>, <a href="https://github.com/Rob--W/cors-anywhere/issues/287">#287</a>) due to abuse and its popularity.</p><p>To counter this, I will make the following changes:</p><ol><li> The rate limit will decrease from 200 (<a href="https://github.com/Rob--W/cors-anywhere/issues/164">#164</a>) per hour to 50 per hour.</li><li> By January 31st, 2021, cors-anywhere.herokuapp.com will stop serving as an open proxy.</li><li> From February 1st. 2021, cors-anywhere.herokuapp.com will only serve requests after the visitor has completed a challenge: The user (developer) must visit a page at cors-anywhere.herokuapp.com to temporarily unlock the demo for their browser. This allows developers to try out the functionality, to help with deciding on self-hosting or looking for alternatives.</li></ol></blockquote><p>好吧，意思就是说这个网站本来是演示用的，但是现在已经被滥用了，然后从 1.31 开始用户手动必须手动先访问这个网站获取临时的访问权限，然后才能使用。另外推荐开发者自己来维护一个网站。</p><p>接着下面的评论第一个就更滑稽了：</p><p><img src="https://qiniu.cuiqingcai.com/7d55t.png" alt="image-20210212225414735"></p><p>这个人直接艾特了 gitalk，哈哈哈，因为 Gitalk 就如刚才所说的那样，也用了这个。</p><p>那就顺便去 Gitalk <a href="https://github.com/gitalk/gitalk%EF%BC%8C%E9%80%9B%E4%B8%80%E4%B8%8B">https://github.com/gitalk/gitalk，逛一下</a> issue，看看是不是也有人遇到了同样的问题，果不其然了：</p><p><img src="https://qiniu.cuiqingcai.com/s7bn5.png" alt="image-20210212225919986"></p><p>最近几个 issue 都是关于 403 的，真热闹。</p><p>点进去看看，有个大收获，里面有个好心人说：</p><blockquote><p>这次直接去嫖了一个 CORS proxy,把 gitalk.js 的 6794 行改为 proxy: ‘<a href="https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access_token">https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access_token</a>‘, 就可以了。具体能用多久我也没普，且用且珍惜。</p></blockquote><p>真是得来全不费功夫，本来还想着自己部署着，这次那就换了就行了。</p><p>然而，这样不行，得需要改 gitalk.js 的源码，并不太好吧。</p><p>好，这时候就遇到了一个问题，要修改某些开源软件的源码应该怎么办？</p><p>首选的思路当然不是硬改，改了之后还要自己 host 一个新的 js 文件，那显然是很费精力的。</p><p>其实一半程序在编写的时候应该是预留一些接口和配置的，我们应该能很轻易地通过某些配置就能实现某些配置的复写。</p><p>那就接着看看吧，既然要改，那就得先看看 Gitalk 是怎么用的吧。</p><p>看文档，Gitalk 调用方式如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">const gitalk = new Gitalk(&#123;  </span><br><span class="line"> clientID: &#x27;GitHub Application Client ID&#x27;,  </span><br><span class="line"> clientSecret: &#x27;GitHub Application Client Secret&#x27;,  </span><br><span class="line"> repo: &#x27;GitHub repo&#x27;, // The repository of store comments,  </span><br><span class="line"> owner: &#x27;GitHub repo owner&#x27;,  </span><br><span class="line"> admin: \[&#x27;GitHub repo owner and collaborators, only these guys can initialize github issues&#x27;\],  </span><br><span class="line"> id: location.pathname, // Ensure uniqueness and length less than 50  </span><br><span class="line"> distractionFreeMode: false // Facebook-like distraction free mode  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gitalk.render(&#x27;gitalk-container&#x27;)</span><br></pre></td></tr></table></figure><p>看来这个在声明的时候是有参数的，那刚才 URL 配置没看到在哪里配啊，既然如此，那就看看 Gitalk 这个对象支持多少参数吧。</p><p>接着就去找 Gitalk 的构造参数说明，找到这么一个：</p><ul><li>proxy：<code>String</code></li></ul><p>Default: <code>https://cors-anywhere.herokuapp.com/https://github.com/login/oauth/access_token</code>.</p><p>果然找到了，所以这里如果我们要修改，那就改 proxy 参数就行了，初始化 Gitalk 的时候复写掉 proxy 就行。</p><p>OK，基本思路有了，那我怎么改到我的源码里呢？</p><p>我的博客是基于 Hexo 的 Next 主题的，根据经验，Gitalk 是 Next 主题自带的，所以 Gitalk 的声明应该就在 Next 主题源码里面。</p><p>那怎么找呢？</p><p>这时候就需要借助于一些搜索技巧了，搜什么？既然要用 Gitalk，那一定有刚才初始化的调用，那就搜 Gitalk 这个关键字就行了。另外还需要缩小一下搜索范围。</p><p>于是我就把范围限定到了 next 主题目录，搜索 Gitalk。</p><p><img src="https://qiniu.cuiqingcai.com/ey8tq.png" alt="image-20210212230931998"></p><p>简直不要太舒服，一搜就有了，文件是 themes/next/layout/_third-party/comments/gitalk.swig。</p><p>这里我们只需要把 proxy 参数加上不就行了，值是什么呢？仿照写就行了，配置风格保持统一，那就加一条：</p><p>1</p><p>proxy : ‘‘,</p><p>OK，那这个配置的值很明显是主题配置文件，那就把配置文件里面加上 proxy 这个参数就好了。</p><p>找到 themes/next/_config.yml，添加行：</p><p>1</p><p>proxy: <a href="https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access/_token">https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access\_token</a></p><p>结果如下：</p><p><img src="https://qiniu.cuiqingcai.com/nnb1f.png" alt="image-20210212231224403"></p><p>好了，大功告成！</p><p>重新部署 Hexo，现在评论又能重新使用了，问题就解决了！</p><p>测试地址：<a href="https://cuiqingcai.com/message/%EF%BC%8C%E5%A4%A7%E5%AE%B6%E6%9D%A5%E7%BB%99%E6%88%91%E7%95%99%E8%A8%80%E5%90%A7%EF%BD%9E">https://cuiqingcai.com/message/，大家来给我留言吧～</a></p><p>好了，这就是我排查问题的整个过程，做一下记录。</p><h2 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h2><p>另外，其实这篇文章的用意不仅仅是单纯解决这个问题，因为这个问题大家可能并没有遇到过，因此这个解决方案仅仅是给极少数遇到这个问题的朋友提供的。</p><p>但是，这并不代表这篇文章没有价值，因为其中有的思路是通用的，在这里稍微做一下总结，希望对大家有帮助：</p><ul><li>当遇到网页功能异常的时候，排查问题就主要看两个——控制台、网络请求，这里面往往能找到主要问题。</li><li>结合一些基本知识进行合理的推断，比如刚才我就推断了 cors- anywhere 的作用并结合 herokuapp 推断这个可能还会是个公用的服务。</li><li>当碰到没有思路或者不确定的时候，去谷歌它！不要百度，另外还可以在 GitHub 或者 Gitee 上搜。</li><li>如果找到对应的 GitHub 仓库，Issue 区往往能找到一些有效答案，比如刚才我就在 Issue 区找到了一个可替代的 cors 网站。</li><li>修改代码功能的时候要想着尽量复写，也就是 overwrite，而不是直接改，前者更具有灵活性，而且某些情况下会省去一些麻烦。</li><li>复写的时候去找一些参数配置，比如找一些初始化参数、默认参数配置，看看能否实现改写的需求。</li><li>找不到入口的时候善用全局搜索功能，比如刚才 Gitalk 找哪里调用的时候，就直接全局搜索。</li><li>根据功能限制某些搜索范围，比如刚才我就知道 Gitalk 这个功能是 Next 主题提供的，所以我就直接限制搜索范围是 Next 主题的源码。</li><li>以上步骤多尝试，熟能生巧。</li></ul><hr><h1 id="部署自己的-CORSproxy"><a href="#部署自己的-CORSproxy" class="headerlink" title="部署自己的 CORSproxy"></a>部署自己的 CORSproxy</h1><p>就在我以为一切都要结束的时候，我看到了这个评论，兴趣来了！</p><img src="/images/gitalk-403/baipiao.PNG" class="" title="baipiao" alt="baipiao"><p>参考步骤：</p><ol><li><a href="https://dash.cloudflare.com/">注册 CloudFlare 账号</a></li><li><a href="https://workers.cloudflare.com/">building Worker</a></li><li><a href="https://github.com/Zibri/cloudflare-cors-anywhere">上传代码</a></li></ol><p>然而我卡在了第一步，DNS 设置 CF 的名称服务器一直验证不通过。。。</p><img src="/images/gitalk-403/cfCheck.PNG" class="" width="50" height="50" title="cfCheck" alt="cfCheck"><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://cuiqingcai.com/30010.html">Gitalk 评论登录 403 问题解决</a> 精觅-崔庆才的个人站点.</li><li><a href="https://github.com/Rob--W/cors-anywhere/issues/301">PSA: Public demo server (cors-anywhere.herokuapp.com) will be very limited by January 2021, 31st #301</a></li><li><a href="https://github.com/gitalk/gitalk/issues/428">使用 Github 登录后，提示 403 错误 #428</a></li><li><a href="https://github.com/Zibri/cloudflare-cors-anywhere">cloudflare-cors-anywhere</a></li><li><a href="https://blog.csdn.net/u012424449/article/details/103068412">一分钟教程：利用 cloudflare worker 搭建在线代理—-jsproxy</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;小站的评论系统始终无法接入 Gitalk，提示 403 Error&lt;/p&gt;</summary>
    
    
    
    <category term="Log" scheme="https://memorykk.cn/categories/Log/"/>
    
    
    <category term="Gitalk" scheme="https://memorykk.cn/tags/Gitalk/"/>
    
  </entry>
  
  <entry>
    <title>Hexo中Markdown语法失效问题</title>
    <link href="https://memorykk.cn/Hexo-Markdown-nonsupport.html"/>
    <id>https://memorykk.cn/Hexo-Markdown-nonsupport.html</id>
    <published>2021-02-13T06:20:06.000Z</published>
    <updated>2021-02-19T06:11:39.188Z</updated>
    
    <content type="html"><![CDATA[<p>在Hexo站上用Markdown写博时发现好多语法失效问题，记录一下</p><span id="more"></span><hr><p><strong>目录</strong></p><ul><li><a href="#1-%E8%A1%A8%E6%A0%BC%E7%9B%B4%E6%8E%A5%E4%BB%A5%E6%BA%90%E7%A0%81%E6%98%BE%E7%A4%BA%E6%97%A0%E6%B8%B2%E6%9F%93">1.表格直接以源码显示无渲染</a></li><li><a href="#2-lt-kbd-gt-%E6%97%A0%E6%A0%B7%E5%BC%8F">2.&lt;kbd&gt;无样式</a></li><li><a href="#3-%E6%8F%92%E5%85%A5-lt-table-gt-%E4%B8%8D%E6%B8%B2%E6%9F%93">3.插入&lt;table&gt;不渲染</a></li><li><a href="#4-%E6%8F%92%E5%85%A5HTML%E6%A0%87%E7%AD%BE%E4%BA%A7%E7%94%9F%E5%A4%A7%E9%87%8F%E6%8D%A2%E8%A1%8C">4.插入HTML标签产生大量换行</a></li><li><a href="#5-%E7%9B%AE%E5%BD%95%E8%B7%B3%E8%BD%AC%E6%97%A0%E5%8F%8D%E5%BA%94">5.目录跳转无反应</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul><hr><h2 id="1-表格直接以源码显示无渲染"><a href="#1-表格直接以源码显示无渲染" class="headerlink" title="1.表格直接以源码显示无渲染"></a>1.表格直接以源码显示无渲染</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>| 左对齐 | 右对齐 | 居中对齐 |<br>| :—-| —-: | :——: |<br>| 单元格aaaaaaaaaa | 单aaaaaaaaaaaaaa元格 | 单元aaaaaaaaaaa格 |<br>| 单元格 | 单元格 | 单元格 |<br>| 单 | 单 | 单 |  </p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul><li>表格和正文之间空两行。  </li><li>Markdown中生成的表格十分简洁，这倒也符合快速的特点，如果想自定义样式，通过嵌入css实现，例如本例。  </li><li>我使用的Hacker主题，通用样式文件存放在themes\Hacker\source\css\base\normalize.css，对这种通用性的追加即可，其他主题同理。</li></ul><table><thead><tr><th align="left">居中对齐</th><th align="right">对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单</td><td align="right">单</td><td align="center">单</td></tr></tbody></table><h3 id="待解决"><a href="#待解决" class="headerlink" title="待解决"></a>待解决</h3><p>  表格正常显示之后，对齐方式却不生效，网上没找到和我一样问题的，不过这个需求也不大，或许只能通过css解决。</p><h2 id="2-lt-kbd-gt-无样式"><a href="#2-lt-kbd-gt-无样式" class="headerlink" title="2.&lt;kbd&gt;无样式"></a>2.&lt;kbd&gt;无样式</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>比如这个kbd标签，Ctrl ，看起来很不明显有没有，大概率本来就这样，但是我一开始希望它是这样：<block style="display:inline-block;"><img src="/images/Hexo-Markdown-nonsupport/ctrl.PNG" class="" width="50" height="50" title="ctrl" alt="ctrl"></block></p><blockquote><p>提示: &lt;kbd&gt; 标签已废弃，不推荐使用，但是可以通过CSS实现丰富的效果。<br>——<a href="https://www.runoob.com/tags/tag-kbd.html">HTML&lt;kbd&gt;标签</a></p></blockquote><h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><p>因为我感觉这个会很常用，但我给它加了css样式，还不错。<kbd>Ctrl</kbd></p><h2 id="3-插入-lt-table-gt-不渲染"><a href="#3-插入-lt-table-gt-不渲染" class="headerlink" title="3.插入&lt;table&gt;不渲染"></a>3.插入&lt;table&gt;不渲染</h2><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>我在HTML里面测试好table，再将整个&lt;table&gt;&lt;/table&gt;粘贴到VSC的md文件中，但是这时HTML标签不渲染，直接以源码显示。</p><h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><ul><li>先在md中手写&lt;table&gt;&lt;/table&gt;这两个标签，再将table里面的内容粘过去，不要开始和结束标签。</li><li>或者可能是HTML代码中有空行！</li></ul><h2 id="4-插入HTML标签产生大量换行"><a href="#4-插入HTML标签产生大量换行" class="headerlink" title="4.插入HTML标签产生大量换行"></a>4.插入HTML标签产生大量换行</h2><h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><p>插入HTML标签产生大量换行</p><h3 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h3><p>将HTML标签之间的空格删除，也就是写到一行中。</p><h2 id="5-目录跳转无反应"><a href="#5-目录跳转无反应" class="headerlink" title="5.目录跳转无反应"></a>5.目录跳转无反应</h2><h3 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h3><p>因为本主题（或是别的问题）不会生成文章目录结构，所以我一般写完后用MarkdownAllinOne生成目录，但是点击无反应，不跳转。</p><h3 id="解决-4"><a href="#解决-4" class="headerlink" title="解决"></a>解决</h3><ul><li><p>首先标题里不能有符号<br>如果标题为”&amp;总结”，但MarkdownAllinOne生成目录自动链接到”#总结”，Hexo渲染出的HTML源码却是：</p><p><code>&lt;h2 id=&quot;amp-总结&quot;&gt;&lt;a href=&quot;#amp-总结&quot; class=&quot;headerlink&quot; title=&quot;&amp;amp;总结&quot;&gt;&lt;/a&gt;&amp;amp;总结&lt;/h2&gt;</code></p><p>这样看来，”#amp-总结”才是正确跳转。</p></li><li><p>若大小写原因，关闭MarkdownAllinOne扩展的自动转换小写选项<br>去<kbd>扩展设置</kbd>里关闭。  </p><p><img src="/images/Hexo-Markdown-nonsupport/mdPlugin1.PNG" alt="mdPlugin2.PNG"></p><p><em><strong>（！这不是必须的，只是为了方便，顺便关闭自动更新目录）</strong></em></p><p><img src="/images/Hexo-Markdown-nonsupport/mdPlugin2.PNG" alt="mdPlugin1.PNG"></p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关键还得搞清楚Hexo生成的是静态页面这个大方向，然后根据自己想法发挥。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Hexo站上用Markdown写博时发现好多语法失效问题，记录一下&lt;/p&gt;</summary>
    
    
    
    <category term="Log" scheme="https://memorykk.cn/categories/Log/"/>
    
    
    <category term="Hexo" scheme="https://memorykk.cn/tags/Hexo/"/>
    
    <category term="Markdown" scheme="https://memorykk.cn/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Markdown</title>
    <link href="https://memorykk.cn/Markdown.html"/>
    <id>https://memorykk.cn/Markdown.html</id>
    <published>2021-02-13T02:52:04.000Z</published>
    <updated>2021-02-13T11:47:47.155Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown是一种轻量级标记语言，以纯文本格式快速编写文档。</p><span id="more"></span><ul><li>Markdown编写的文档后缀为 .md、.markdown，可以导出HTML、Word、图像、PDF、Epub等多种格式的文档。  </li><li>Hexo、github等支持使用markdown编辑器编写文章，刚好边学边练。</li><li>可以通过css的方式，美化Hexo元素，嵌入style 标签，在生成html时，style标签也随之写入到html页面中，产生自定义效果。</li></ul><hr><p><strong>目录</strong></p><ul><li><a href="#markdown%E8%AF%AD%E6%B3%95">Markdown语法</a><ul><li><a href="#%E6%A0%87%E9%A2%98">标题</a></li><li><a href="#%E5%AD%97%E4%BD%93">字体</a></li><li><a href="#%E6%8D%A2%E8%A1%8C">换行</a></li><li><a href="#%E5%88%86%E9%9A%94%E7%BA%BF">分隔线</a></li><li><a href="#%E8%84%9A%E6%B3%A8">脚注</a></li><li><a href="#%E5%88%97%E8%A1%A8">列表</a></li><li><a href="#%E5%8C%BA%E5%9D%97">区块</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li><li><a href="#%E9%93%BE%E6%8E%A5">链接</a></li><li><a href="#%E5%9B%BE%E7%89%87">图片</a></li><li><a href="#%E8%A1%A8%E6%A0%BC">表格</a></li><li><a href="#%E6%94%AF%E6%8C%81%E7%9A%84html%E5%85%83%E7%B4%A0">支持的HTML元素</a></li><li><a href="#%E8%BD%AC%E4%B9%89">转义</a></li><li><a href="#%E5%85%AC%E5%BC%8F">公式</a></li><li><a href="#%E7%94%BB%E5%9B%BE">画图</a></li></ul></li><li><a href="#markdown%E5%B7%A5%E5%85%B7">Markdown工具</a></li><li><a href="#%E6%8E%A8%E8%8D%90">推荐</a></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><hr><h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用<kbd>#</kbd>标记标题，1-6个<kbd>#</kbd>标识1-6级标题。<br><em>（markdown语法中的关键字之后一般要加一个空格）</em><br>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><ul><li>斜体<br>使用一个<kbd>*</kbd>包起来</li><li>加粗<br>使用两个<kbd>*</kbd>包起来</li><li>斜体加粗<br>使用三个<kbd>*</kbd>包起来</li><li>删除线<br>使用两个<kbd>~</kbd>包起来</li><li>下划线<br>使用HTML的<kbd>&lt;u>&lt;/u></kbd>包起来</li></ul><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*这是倾斜的文字*</span></span><br><span class="line"><span class="strong">**这是加粗的文字**</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*这是斜体加粗的文字<span class="strong">**<span class="emphasis">*</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">~~这是加删除线的文字~~</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>这是加下划线的文字<span class="xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span></span></span></span></span><br></pre></td></tr></table></figure><p>效果如下：<br><em>这是倾斜的文字</em><br><strong>这是加粗的文字</strong><br><em><strong>这是斜体加粗的文字</strong></em><br><del>这是加删除线的文字</del><br><u>这是加下划线的文字</u></p><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>markdown源文件中的回车不会换行，必须使用<kbd>两个空格+回车</kbd>或者<kbd>两个回车</kbd>。</p><p>示例 <em>（注意第一段之后的空格）</em>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一段  </span><br><span class="line">第二段</span><br><span class="line"></span><br><span class="line">第三段</span><br></pre></td></tr></table></figure><p>效果如下：</p><p>第一段<br>第二段</p><p>第三段</p><h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p>在一行中用三个以上的<kbd>*</kbd>、<kbd>-</kbd>、<kbd>_</kbd>来建分隔线，显示效果一致，行内不能有其他东西，但可以在行内插入空格。</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="strong"><span class="emphasis">---</span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong">__<span class="emphasis">_</span></span></span></span></span><br></pre></td></tr></table></figure><p>效果如下：</p><hr><hr><hr><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a><del>脚注</del></h2><p><strong>！貌似无法使用</strong><br>脚注是对文本的补充说明，鼠标悬停即可查看，使用<kbd>[^要注明的文本]</kbd>，在之后任意位置重复<kbd>[^要注明的文本]:补充内容</kbd>。</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Welcome To [^Memorykk&#x27;s Blog]</span><br><span class="line">[<span class="symbol">^Memorykk&#x27;s Blog</span>]: <span class="link">https://memorykk.cn</span></span><br></pre></td></tr></table></figure><p>效果如下：<br>Welcome To [^ Memorykk ]<br>[^ Memorykk ]: <a href="https://memorykk.cn/">https://memorykk.cn</a><br>参考：<img src="https://www.runoob.com/wp-content/uploads/2019/03/md5.gif" alt="参考示例"></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表使用<kbd>*</kbd>、<kbd>+</kbd>、<kbd>-</kbd>标记，追加列表内容，三者无差异。</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> 第一项</span><br><span class="line"><span class="bullet">+</span> 第二项</span><br><span class="line"><span class="bullet">-</span> 第三项</span><br></pre></td></tr></table></figure><p>效果如下：  </p><ul><li>第一项</li></ul><ul><li>第二项</li></ul><ul><li>第三项</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表使用数字+<kbd>.</kbd>标记。</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一项</span><br><span class="line"><span class="bullet">2.</span> 第二项</span><br></pre></td></tr></table></figure><p>效果如下：  </p><ol><li>第一项</li><li>第二项</li></ol><h3 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h3><p>子列表的选项前加四个空格即可。</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一项</span><br><span class="line"><span class="bullet">    *</span> 元素1</span><br><span class="line"><span class="bullet">    *</span> 元素2</span><br><span class="line"><span class="bullet">2.</span> 第二项</span><br><span class="line"><span class="bullet">    -</span> 元素3</span><br><span class="line"><span class="bullet">    -</span> 元素4</span><br></pre></td></tr></table></figure><p>效果如下：  </p><blockquote><ol><li>第一项<ul><li>元素1</li><li>元素2</li></ul></li><li>第二项<ul><li>元素3</li><li>元素4</li></ul></li></ol></blockquote><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>区块使用<kbd>></kbd>标记，追加区块内容。<br>区块支持嵌套，一个<kbd>></kbd>为最外层，两个<kbd>></kbd>为第一层嵌套，以此类推。<br>另外，区块可与列表等随意嵌套。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 1. 第一项</span></span><br><span class="line"><span class="quote">&gt;     <span class="emphasis">* 元素1</span></span></span><br><span class="line"><span class="quote"><span class="emphasis">&gt;     *</span> 元素2</span></span><br><span class="line"><span class="bullet">2.</span> 第二项</span><br><span class="line"><span class="code">    &gt; - 元素3</span></span><br><span class="line"><span class="code">    &gt; - 元素4</span></span><br></pre></td></tr></table></figure><p>效果如下：  </p><blockquote><ol><li>第一项<ul><li>元素1</li><li>元素2</li></ul></li><li>第二项<ul><li>元素3</li><li>元素4</li></ul></li></ol></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="单行代码"><a href="#单行代码" class="headerlink" title="单行代码"></a>单行代码</h3><p>使用一个<kbd>`</kbd>将代码包起来。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">`System.out.println(&quot;Hello World!&quot;);`</span></span><br></pre></td></tr></table></figure><p>效果如下：<br><code>System.out.println(&quot;Hello World!&quot;);</code></p><h3 id="多行代码"><a href="#多行代码" class="headerlink" title="多行代码"></a>多行代码</h3><p>使用六个<kbd>`</kbd>将代码包起来，前三个<kbd>`</kbd>接代码语言，也可不指定。</p><p>示例：<em>（为了防止编辑器转义，在前后加了前后括号，实际使用中不能写哦~）</em></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">（<span class="code">```java</span></span><br><span class="line"><span class="code">System.out.println(&quot;Hello&quot;);</span></span><br><span class="line"><span class="code">System.out.println(&quot;World&quot;);</span></span><br><span class="line"><span class="code">System.out.println(&quot;!&quot;);</span></span><br><span class="line"><span class="code">```）</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;!&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="普通链接"><a href="#普通链接" class="headerlink" title="普通链接"></a>普通链接</h3><p>使用<kbd>[链接名称]</kbd><kbd>(链接地址)</kbd>或者直接<kbd><链接地址></kbd>标记。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">Memorykk&#x27;s Blog</span>](<span class="link">https://memorykk.cn</span>)  </span><br><span class="line"><span class="xml">&lt;https://www.memorykkk.cn&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：<br><a href="https://memorykk.cn/">Memorykk’s Blog</a><br><a href="https://www.memorykkk.cn/">https://www.memorykkk.cn</a></p><h3 id="高级链接"><a href="#高级链接" class="headerlink" title="高级链接"></a>高级链接</h3><p>通过变量来设置一个链接，变量赋值在文档末尾。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这个链接赋给变量1：[<span class="string">Memorykk&#x27;s Blog</span>][<span class="symbol">1</span>]</span><br><span class="line">这个链接赋给变量google：[<span class="string">GOOGLE</span>][<span class="symbol">google</span>]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">1</span>]: <span class="link">https://memorykk.cn</span></span><br><span class="line">[<span class="symbol">google</span>]: <span class="link">https://www.google.com</span></span><br></pre></td></tr></table></figure><p>效果如下：<br>这个链接赋给变量1：<a href="https://memorykk.cn/">Memorykk’s Blog</a><br>这个链接赋给变量google：<a href="https://www.google.com/">GOOGLE</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>使用<kbd>![alt文本]</kbd><kbd>(图片链接 "可选标题")</kbd>标记。<br>markdown不支持指定宽高，可使用HTML &lt;img&gt;标签标记。<br>可以制作图片链接</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">Github.ico</span>](<span class="link">https://github.githubassets.com/favicons/favicon.svg</span>)</span><br></pre></td></tr></table></figure><p>效果如下：<br><img src="https://github.githubassets.com/favicons/favicon.svg" alt="Github.ico"></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>使用<kbd>|</kbd>标记单元格，使用<kbd>-</kbd>分隔表头和其他行，还可设置对其方式：</p><ul><li><kbd>-:</kbd>设置内容和标题栏居右对齐。</li><li><kbd>:-</kbd>设置内容和标题栏居左对齐。</li><li><kbd>:-:</kbd>设置内容和标题栏居中对齐。  </li></ul><hr><ul><li>:之间多余的空格会被忽略</li><li>的数量至少一个</li><li>内容和|之间多余的空格会被忽略</li></ul><p>示例：<em>（但是本页并未生效，Hexo的问题？）</em></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :------| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单 | 单 | 单 |</span><br></pre></td></tr></table></figure><p>效果如下：  </p><p><img src="/images/Markdown/table.PNG" alt="table.PNG"></p><h2 id="支持的HTML元素"><a href="#支持的HTML元素" class="headerlink" title="支持的HTML元素"></a>支持的HTML元素</h2><p>直接在文档里面用 HTML 撰写。<br>目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等。</p><h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符反斜杠<kbd>\</kbd>。<br>目前支持的特殊字符：<br><kbd>\</kbd>、<kbd>`</kbd>、<kbd>*</kbd>、<kbd>_</kbd>、<kbd>{}</kbd>、<kbd>[]</kbd>、<kbd>()</kbd>、<kbd>#</kbd>、<kbd>+</kbd>、<kbd>-</kbd>、<kbd>.</kbd>、<kbd>!</kbd>、<kbd>HTML元素</kbd>。</p><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>使用两个<kbd>$</kbd>包裹 TeX 或 LaTeX 格式的数学公式。<br>提交后会根据需要加载 Mathjax 对数学公式进行渲染。</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\lim<span class="emphasis">_&#123;x \to 0&#125; \frac&#123;3x^2 +7x^3&#125;&#123;x^2 +5x^4&#125; = 3</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><p>效果如下：<br>$$<br>\lim_{x \to 0} \frac{3x^2 +7x^3}{x^2 +5x^4} = 3<br>$$</p><h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><p>参考 <a href="https://www.runoob.com/markdown/md-advance.html">菜鸟教程</a></p><h1 id="Markdown工具"><a href="#Markdown工具" class="headerlink" title="Markdown工具"></a>Markdown工具</h1><p>目前我使用的是Visual Studio Code，默认支持markdown编辑以及即时预览，配合插件十分好用：  </p><ul><li><a href="https://marketplace.visualstudio.com/items?itemName=bierner.markdown-preview-github-styles">Markdown Preview Github Styling</a>：预览您的Markdown在Github上呈现的样子</li><li><a href="https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one">Markdown All in One</a>Markdown所需的全部功能（键盘快捷键、目录、自动预览等）</li></ul><h1 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h1><p>  <a href="Hexo-Markdown-nonsupport.html">Hexo中Markdown语法失效问题</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.runoob.com/markdown">Markdown教程</a></li><li><a href="https://www.jianshu.com/p/191d1e21f7ed">Markdown基本语法</a></li><li><a href="https://javahikers.github.io/2019/05/04/markdown-simple-to-use/">markdown简明使用方法</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Markdown是一种轻量级标记语言，以纯文本格式快速编写文档。&lt;/p&gt;</summary>
    
    
    
    <category term="Tool" scheme="https://memorykk.cn/categories/Tool/"/>
    
    
    <category term="Markdown" scheme="https://memorykk.cn/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://memorykk.cn/hello-world.html"/>
    <id>https://memorykk.cn/hello-world.html</id>
    <published>2021-02-11T15:59:59.000Z</published>
    <updated>2021-02-12T12:09:08.216Z</updated>
    
    <content type="html"><![CDATA[<p>照例写个HelloWorld占好位置。</p><span id="more"></span><p>这里是正文。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;照例写个HelloWorld占好位置。&lt;/p&gt;</summary>
    
    
    
    <category term="Fragment" scheme="https://memorykk.cn/categories/Fragment/"/>
    
    
    <category term="Hexo" scheme="https://memorykk.cn/tags/Hexo/"/>
    
  </entry>
  
</feed>
