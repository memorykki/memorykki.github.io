<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Memorykk</title>
  
  <subtitle>never too late to learn</subtitle>
  <link href="https://memorykk.cn/atom.xml" rel="self"/>
  
  <link href="https://memorykk.cn/"/>
  <updated>2021-02-19T11:41:54.450Z</updated>
  <id>https://memorykk.cn/</id>
  
  <author>
    <name>Memorykk</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次使用Github登录Gitalk跳至首页的解决过程</title>
    <link href="https://memorykk.cn/gitalk-405.html"/>
    <id>https://memorykk.cn/gitalk-405.html</id>
    <published>2021-02-19T08:45:48.000Z</published>
    <updated>2021-02-19T11:41:54.450Z</updated>
    
    <content type="html"><![CDATA[<p>使用自定义域名之后的 Github page 在使用 Github 登录 Github 时跳转首页，无限循环</p><span id="more"></span><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>博客使用的是Hexo+Github+Gitalk，使用 Github 登录 Gitalk 之后跳转至首页，无限循环，地址栏URL显示为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;memorykk.cn&#x2F;?error&#x3D;redirect_uri_mismatch&amp;error_description&#x3D;The+redirect_uri+MUST+match+the+registered+callback+URL+for+this+application.&amp;error_uri&#x3D;https%3A%2F%2Fdocs.github.com%2Fapps%2Fmanaging-oauth-apps%2Ftroubleshooting-authorization-request-errors%2F%23redirect-uri-mismatch</span><br></pre></td></tr></table></figure><h1 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h1><p>为了更清楚地检查，将此 URL 中的 Unicode 转为中文：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;memorykk.cn&#x2F;?</span><br><span class="line">error&#x3D;redirect_uri_mismatch&amp;</span><br><span class="line">error_description&#x3D;The+redirect_uri+MUST+match+the+registered+callback+URL+for+this+application.&amp;</span><br><span class="line">error_uri&#x3D;https:&#x2F;&#x2F;docs.github.com&#x2F;apps&#x2F;managing-oauth-apps&#x2F;troubleshooting-authorization-request-errors&#x2F;#redirect-uri-mismatch</span><br></pre></td></tr></table></figure><p>根据描述，<kbd>redirect error</kbd> <kbd>registered callback URL</kbd>不匹配。</p><p>打开<kbd>F12</kbd>查看<kbd>Network</kbd>：</p><p><img src="/images/gitalk-405/reirect_uri.png" alt="reirect_uri.png"></p><p><kbd>this application</kbd>我使用的是<kbd>OAuth Apps</kbd>，查看其Authorization callback URL，果不其然：</p><p><img src="/images/gitalk-405/Auth_callback_URL.png" alt="Auth_callback_URL.png"></p><p><code>http</code>和<code>https</code>的差别还是很大的！修改Authorization callback URL为<code>https</code>之后成功了。</p><p>点击<kbd>使用GitHub登录</kbd>之后，又出现 405 问题，<br><img src="/images/gitalk-405/405.png" alt="405.png"><br>打开<kbd>F12</kbd>查看<kbd>Network</kbd>：<br><img src="/images/gitalk-405/url1.png" alt="url1.png"><br>转换为中文：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Request URL: https:&#x2F;&#x2F;memorykk.cn&#x2F;TeamSpeak&#x2F;%7B%7B%20theme.gitalk.proxy%20%7D%7D</span><br><span class="line"></span><br><span class="line">Request URL: https:&#x2F;&#x2F;memorykk.cn&#x2F;TeamSpeak&#x2F;&#123;&#123; theme.gitalk.proxy &#125;&#125;</span><br></pre></td></tr></table></figure><p>好家伙，这还是源代码形式啊，坑定是后台有什么问题！<br>检查<kbd>theme\layout\components\comment.ejs</kbd>，这行代码果然是从这里出来的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var gitalk &#x3D; new Gitalk(&#123;</span><br><span class="line">clientID: &#39;&lt;%&#x3D; theme.gitalk_client_id %&gt;&#39;,</span><br><span class="line">clientSecret: &#39;&lt;%&#x3D; theme.gitalk_client_secret %&gt;&#39;,</span><br><span class="line">repo: &#39;&lt;%&#x3D; theme.gitalk_repo %&gt;&#39;,</span><br><span class="line">owner: &#39;&lt;%&#x3D; theme.gitalk_owner %&gt;&#39;,</span><br><span class="line">admin: [&#39;&lt;%- theme.gitalk_admin.join(&quot;&#39;, &#39;&quot;) %&gt;&#39;],</span><br><span class="line">id: location.pathname,</span><br><span class="line">distractionFreeMode: false,</span><br><span class="line">createIssueManually: true,</span><br><span class="line">proxy: &#39;&#123;&#123; theme.gitalk.proxy &#125;&#125;&#39;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>之前对node.js也不了解（虽然现在也一样，允悲），没注意格式。仿照上面几行代码改成：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy: &#39;&lt;%&#x3D; theme.gitalk.proxy %&gt;&#39;,</span><br></pre></td></tr></table></figure><p>还是报 405 错误，打开<kbd>F12</kbd>查看：<br><img src="/images/gitalk-405/405_2.png" alt="405_2.png"></p><p>总感觉之前白嫖的 CorsAnywhere Proxy 链接压根没有传递过去，直接手动写死在里面：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy: &#39;https:&#x2F;&#x2F;netnr-proxy.cloudno.de&#x2F;https:&#x2F;&#x2F;github.com&#x2F;login&#x2F;oauth&#x2F;access_token&#39;,</span><br></pre></td></tr></table></figure><p>好家伙，成功了，ohhhhhhhhhhh，虽然这种做法极不优雅！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>网页出错先用<kbd>F12</kbd>看看哪部分的问题，顺藤摸瓜，缩小范围。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用自定义域名之后的 Github page 在使用 Github 登录 Github 时跳转首页，无限循环&lt;/p&gt;</summary>
    
    
    
    <category term="Log" scheme="https://memorykk.cn/categories/Log/"/>
    
    
    <category term="Gitalk" scheme="https://memorykk.cn/tags/Gitalk/"/>
    
  </entry>
  
  <entry>
    <title>TeamSpeak</title>
    <link href="https://memorykk.cn/TeamSpeak.html"/>
    <id>https://memorykk.cn/TeamSpeak.html</id>
    <published>2021-02-19T06:22:14.000Z</published>
    <updated>2021-03-01T14:55:05.561Z</updated>
    
    <content type="html"><![CDATA[<p>一个简易的TeamSpeak使用教程</p><span id="more"></span><p>更新于2021-02-19 14:22:14：<br>旧地址<del>memorykk.cn</del>已不可用，为了您后续的正常使用，请使用新地址<text style="color:white;background-color:red">ts.memorykk.cn</text></p><p><img src="/images/TeamSpeak/address.png" alt="address.png"></p><hr><p>更新于2020/5/22 15:30：</p><p>根据 @洛杉矶湖人名宿孙悦 ​的提醒，<text style="color:red">不推荐下载ts1.cn的盗版客户端，也不推荐俱乐部或者各位玩家租用ts1.cn的盗版服务器。</text>具体可<a href="https://bbs.hupu.com/32525047.html">查看原帖</a>，所以希望大家去官网下载正版软件，如果官网或github下载太慢，可以点正文中转存的链接，都是一样的。</p><hr><p>去年自己搭建了一个TeamSpeak服务器，闲着也是闲着，分享出来给大家使用，市面上的服务器要么收费、要么音质权限不给，本服务器免费共享，合法合规，不涉及隐私信息等，请放心使用！</p><h1 id="什么是TeamSpeak"><a href="#什么是TeamSpeak" class="headerlink" title="什么是TeamSpeak"></a>什么是TeamSpeak</h1><blockquote><p>TeamSpeak (简称TS) 是一套专有的VoIP软件，使用者可以用耳机和麦克风，通过客户端软件连线到指定的服务器，与在服务器内频道的其他使用者进行通话。是一种很像电话会议的方式。 通常 TeamSpeak 的使用者大多为多人连线游戏的玩家，与同队伍的玩家进行通讯。在游戏的对战方面，语音对话通讯具有竞争优势。</p></blockquote><p>简言之，TeamSpeak是一款非常优秀的语音软件，类似于国内的YY语音、TT语音等，PUBG、CSGO等项目职业选手都在使用，在和小伙伴激情上分时，你该不会还在使用QQ微信电话吧？那么TS优点在哪里呢？有几点：</p><ul><li>界面简洁，没有广告，没有花里胡哨的付费内容；</li><li>极高的音乐级音质，超低的延迟；</li><li>独有的麦克风降噪、键盘声衰减、回声消除；</li><li>自动感应麦真的很好用。</li></ul><h1 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h1><ol><li>下载TeamSpeak客户端（最新版本为3.5.6）</li></ol><ul><li><a href="https://teamspeak.com/zh-CN/downloads/#client">官网下载</a></li><li>转存下载：（文件和官网一样，解决下载过慢问题）<ul><li><a href="https://wwa.lanzous.com/izgdukunldc">WINDOWS CLIENT 32-BIT 3.5.6</a></li><li><a href="https://wwa.lanzous.com/iQ78Wkun8ab">WINDOWS CLIENT 64-BIT 3.5.6</a></li><li><a href="https://memorykk.cn/src/TeamSpeak3-Client-macosx-3.5.6.dmg">MACOS CLIENT UNIVERSAL BINARY 3.5.6</a></li><li><a href="https://memorykk.cn/src/TeamSpeak3-Client-linux_x86-3.5.6.run">LINUX CLIENT 32-BIT 3.5.6</a></li><li><a href="https://memorykk.cn/src/TeamSpeak3-Client-linux_amd64-3.5.6.run">LINUX CLIENT 64-BIT 3.5.6</a></li></ul></li><li><a href="https://wwa.lanzous.com/icw5xgd">下载中文语音包&amp;语言包</a></li></ul><ol start="2"><li>安装客户端和中文包</li></ol><p>默认“下一步”就完事了，打开如下：</p><p><img src="/images/TeamSpeak/2-1.png" alt="2-1.png"><br><img src="/images/TeamSpeak/2-2.png" alt="2-2.png"></p><ol start="3"><li>注册登录你的TS账号（跳过这一步也可以）</li></ol><p>安装软件后会弹出来，没弹出来可以依次点击 <kbd>工具</kbd>-&gt;<kbd>选项</kbd>-&gt;<kbd>myTeamSpeak​</kbd> 继续操作。</p><p><img src="/images/TeamSpeak/3.png" alt="3.png"></p><ol start="4"><li>设置语音输入方式</li></ol><p>依次点击 <kbd>工具</kbd>-&gt;<kbd>选项</kbd>-&gt;<kbd>输入</kbd> 建议设置如下：</p><p><img src="/images/TeamSpeak/4.png" alt="4.png"></p><p>语音输入方式：</p><ul><li>Automatic：自动感应麦</li><li>Volume Gate：自定义麦克风的收音敏感度，点“开始测试”，比最高的分贝低一点就可以了</li><li>Hybrid：不懂，没用过</li></ul><ol start="5"><li>连接服务器</li></ol><p>依次点击左上角 <kbd>连接</kbd>-&gt;<kbd>连接</kbd>-&gt;输入服务器地址（<strong>ts.memorykk.cn</strong>）和昵称，无密码，直接点击连接，自动进入大厅。</p><p><img src="/images/TeamSpeak/5.png" alt="5.png"></p><ol start="6"><li>开房间</li></ol><p>空白处右键单击“创建频道”，设置房间名，有需要的可以设置密码，点击确定，房间开好了，双击房间名即可进入，这时候你就可以让你的小伙伴直接进入你的房间就完事了。</p><p><img src="/images/TeamSpeak/6-1.png" alt="6-1.png"><br><img src="/images/TeamSpeak/6-2.png" alt="6-2.png"></p><p><strong>注意</strong>：创建频道如果选择临时，当频道最后一人离开时，频道会自动消失。</p><p><strong>注意</strong>：可以设置频道音质，右键单击频道-&gt;声音-&gt;拖到质量条。</p><p>最后，有问题到下方留言，希望大家玩得开心。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个简易的TeamSpeak使用教程&lt;/p&gt;</summary>
    
    
    
    <category term="Tool" scheme="https://memorykk.cn/categories/Tool/"/>
    
    
    <category term="TeamSpeak" scheme="https://memorykk.cn/tags/TeamSpeak/"/>
    
  </entry>
  
  <entry>
    <title>《鸟哥的Linux私房菜》第0-3章</title>
    <link href="https://memorykk.cn/linux-vbird-0-3.html"/>
    <id>https://memorykk.cn/linux-vbird-0-3.html</id>
    <published>2021-02-19T06:08:11.000Z</published>
    <updated>2021-03-01T12:53:42.156Z</updated>
    
    <content type="html"><![CDATA[<p>基础篇第 0-3 章学习笔记</p><span id="more"></span><hr><p><strong>目录</strong></p><ul><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%AE%BA">计算机概论</a><ul><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6">计算机硬件</a></li><li><a href="#CPU">CPU</a></li><li><a href="#%E5%86%85%E5%AD%98">内存</a></li><li><a href="#%E6%98%BE%E5%8D%A1">显卡</a></li><li><a href="#%E7%A1%AC%E7%9B%98%E4%B8%8E%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87">硬盘与存储设备</a></li><li><a href="#PCI%E9%80%82%E9%85%8D%E5%8D%A1">PCI 适配卡</a></li><li><a href="#%E4%B8%BB%E6%9D%BF">主板</a></li><li><a href="#%E7%94%B5%E6%BA%90">电源</a></li><li><a href="#%E6%96%87%E5%AD%97%E7%BC%96%E7%A0%81%E7%B3%BB%E7%BB%9F">文字编码系统</a></li><li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a></li><li><a href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">应用程序</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></li><li><a href="#Linux%E6%98%AF%E4%BB%80%E4%B9%88">Linux是什么</a><ul><li><a href="#%E5%8E%86%E5%8F%B2">历史</a></li><li><a href="#Linux%E7%9A%84%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC">Linux的内核版本</a></li><li><a href="#Linux-distribution">Linux distribution</a></li><li><a href="#Linux%E7%9A%84%E7%89%B9%E8%89%B2">Linux的特色</a></li></ul></li><li><a href="#%E4%B8%BB%E6%9C%BA%E8%A7%84%E5%88%92%E4%B8%8E%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA">主机规划与磁盘分区</a><ul><li><a href="#%E7%A3%81%E7%9B%98%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E5%90%8D%E7%9A%84%E5%85%B3%E7%B3%BB">磁盘连接的方式与设备文件名的关系</a><ul><li><a href="#IDE%E8%AE%BE%E5%A4%87">IDE设备</a></li><li><a href="#SATA%E8%AE%BE%E5%A4%87">SATA设备</a></li></ul></li><li><a href="#%E7%A3%81%E7%9B%98%E7%9A%84%E7%BB%84%E6%88%90">磁盘的组成</a></li><li><a href="#%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E8%A1%A8">磁盘分区表</a></li><li><a href="#%E5%BC%80%E6%9C%BA%E6%B5%81%E7%A8%8B%E4%B8%8E%E4%B8%BB%E5%BC%95%E5%AF%BC%E5%88%86%E5%8C%BAMBR">开机流程与主引导分区MBR</a><ul><li><a href="#%E5%BC%80%E6%9C%BA%E6%B5%81%E7%A8%8B">开机流程</a></li><li><a href="#BootLoader%E7%9A%84%E5%8A%9F%E8%83%BD">BootLoader的功能</a></li></ul></li><li><a href="#%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E7%9A%84%E9%80%89%E6%8B%A9">磁盘分区的选择</a></li><li><a href="#%E4%B8%BB%E6%9C%BA%E7%A1%AC%E7%9B%98%E7%9A%84%E4%B8%BB%E8%A6%81%E8%A7%84%E5%88%92">主机硬盘的主要规划</a></li></ul></li><li><a href="#%E5%AE%89%E8%A3%85CentOS-5-x%E4%B8%8E%E5%A4%9A%E9%87%8D%E5%BC%95%E5%AF%BC">安装CentOS 5.x与多重引导</a><ul><li><a href="#%E5%AE%89%E8%A3%85%E8%A7%84%E5%88%92">安装规划</a></li><li><a href="#%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4">安装步骤</a></li></ul></li></ul><hr><h1 id="计算机概论"><a href="#计算机概论" class="headerlink" title="计算机概论"></a>计算机概论</h1><h2 id="计算机硬件"><a href="#计算机硬件" class="headerlink" title="计算机硬件"></a>计算机硬件</h2><p><img src="/images/linux-vbird-0-3/computer.png" alt="computer.png"></p><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>CPU 的架构：</p><ul><li>精简指令集 RISC：单指令工作简单，执行快。arm</li><li>复杂指令集 CISC。单指令工作复杂，执行慢。intel(x86)、amd(x86_64)<br>1Byte=8bit</li></ul><p><img src="/images/linux-vbird-0-3/problem_memory.png" alt="problem_memory.png"></p><p>原本的单核 CPU 仅有一个运算单元,所谓的多核则是在一个 CPU 封装当中嵌入了两个以上的运算内核,简单地说,就是一个实际的 CPU 外壳中含有两个以上的 CPU 单元。<br>amd 内存与 cpu 直连，intel 内存通过北桥与 cpu 连接</p><p><strong>CPU 频率=外频*倍频</strong></p><ul><li>外频：cpu 与外部传输速率</li><li>倍频：cpu 内部运算的加速功能（出厂固定）</li></ul><p>超频：通过主板的设定功能更改成较高频率的一种方式。因为频率并非正常速度,故可能会造成死机等。</p><p>总线宽度：32/64<br>CPU 有向下兼容的能力</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>个人计算机的内存主要组件为动态随机访问内存 DRAM，挥发性</p><ul><li>SDRAM</li><li>DDR SDRAM：双倍数据传输速度 - DDR - DDRⅡ - DDRⅢ<br>双通道设计：两根 64 位总线宽度-&gt;128 位<br> CPU 外频=内存外频<br> 第二层缓存：常用的数据或程序放置在 CPU 内部，不在通过北桥从内存加载<br> DRAM 频率速度无法达到 L2=CPU 外频，因此使用静态随机访问内存 SRAM<br> <strong>只读存储器 ROM</strong><br>主板上组件参数存储在 CMOS 中，BIOS 是一套写死在 ROM 上的程序，非挥发性，系统开机时首先读取 BIOS；固件很多采用 ROM 进行软件写入；ROM 无法改写，因此 BIOS 通常写入 Flash Memory 或 EEPROM 中，以更新。</li></ul><h2 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h2><p>一般对于图形影像的显示重点在于分辨率与色彩深度，因为每个图像显示的颜色会占用内存，因此显卡上面会有一个内存的容量，这个显存容量将会影响到最终你的屏幕分辨率与色彩深度。越大越好。<br> 在显卡上嵌入 3D 加速芯片提升运算能力，即 GPU。<br> 北桥通信<br> 规格：AGP-&gt;PCI-&gt;PCIe</p><h2 id="硬盘与存储设备"><a href="#硬盘与存储设备" class="headerlink" title="硬盘与存储设备"></a>硬盘与存储设备</h2><p>硬盘：盘片、机械手臂、磁头、主轴马达。<br> 盘片上的数据：<br>磁盘上最小存储单位：扇区 512bytes；扇区组成圆：磁道；所有片上面的同一磁道：柱面（分割硬盘的最小单位）。<br>磁盘容量=header 数量<em>每个 header 负责的柱面数量</em>每个柱面所含有的扇区数量*扇区的容量<br>传输接口： - IDE 接口：连接两个设备，理论 133MB/s - SATA 接口：PC，一个设备，利于散热，理论 300MB/s</p><p>缓冲存储器：加速读取<br> 转速：主轴马达转动盘片<br> 运转：正常关机使机械手臂归回原位；避免移动主机使硬盘抖动</p><h2 id="PCI适配卡"><a href="#PCI适配卡" class="headerlink" title="PCI适配卡"></a>PCI适配卡</h2><p>用户额外的功能卡安插在 PCI 插槽上，很多组件（声卡、网卡）采用 PCI 接口传输，现多 PCIe</p><h2 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h2><p>主板上面负责通信各个组件的就是芯片组，芯片组一般分为北桥与南桥，需要散热。北桥负责 CPU/RAM/VGA 等的连接,南桥则负责 PCI 接口与速度较慢的 I/O 设备。<br> 芯片组：集成（显卡、网卡）型、独立型<br> I/O 地址：标识不同的设备；IRQ 中断信道：告知 CPU 该设备工作情况方便分配工作。sharing IRQ 技术。<br> CMOS 与 BIOS</p><h2 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h2><p>能源转换率<br> 接口</p><h2 id="文字编码系统"><a href="#文字编码系统" class="headerlink" title="文字编码系统"></a>文字编码系统</h2><p>英文：ASCII，一个字符占用 1B<br> 中文：big5（简体 gb2312），占用 2B<br> ISO/IEC 制订了 Unicode 编码系统，即 UTF8</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>内核、接口以及相关应用<br> 操作系统内核（kernel）：管理计算机的所有活动及驱动系统中的所有硬件，分配资源。内核所放置到内存中的区块受保护，开机后常驻内存。参考硬件规格，硬件不同则内核不同。<br> 系统调用（System Call）：一套开发接口，开发软件参考内核功能相关的开发接口。</p><p>内核功能：</p><ol><li>系统调用接口：与内核通信，软件开发</li><li>程序管理：多任务环境下有效分配资源</li><li>内存管理：虚拟内存功能提供在内存不足时的内存交换 swap</li><li>文件系统管理</li><li>设备驱动</li></ol><p>操作系统与驱动程序：OS 提供开发接口，让硬件开发商制作驱动，安装。</p><h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2><p>程序与 OS 有关系</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>计算机的定义为：”接受用户输入指令与数据，经由中央处理器的数据与逻辑单元运算处理后，以产生或存储成有用的信息“。<br> 计算机的五大单元包括输入单元、输出单元、CP∪ 内部的控制单元、算术逻辑单元与内存五大部分。<br> 数据会流进流出内存是 CPU 所发布的控制命令，而 CPU 实际要处理的数据则完全来自于内存。<br> CPU 依设计理念主要分为精简指令集(RSC)与复杂指令集(CSC)系统。<br> 关于 CPU 的频率部分，外频指的是 cPU 与外部组件进行数据传输时的速度,倍频则是 CPU 内部用来加速工作性能的一个倍数，两者相乘才是 cPU 的频率速度。<br> 一般主板芯片组分为北桥与南桥，北桥的总线称为系统总线,因为是内存传输的主要信道所以速度较快。南桥就是所谓的输入/输出(I/O)总线,主要在于连系硬盘、USB、网卡等接口设备。<br> 北桥所支持的频率我们称为前端总线速度( Front Side Bus,FSB),而每次传送的位数则是总线宽度。<br> CPU 每次能够处理的数据量称为字组大小( word size),字组大小依据 cPU 的设计而有 32 位与 64 位之分。我们现在所称的计算机是 32 或 64 位主要是依据这个 CPU 解析的字组大小而来的!<br> 个人计算机的内存主要组件为动态随机访问内存( Dynamic Random Access Memory,DRAM），至于 CPU 内部的第二层缓存则使用静态随机访问内存（Static Random Access Memory, SRAM）。<br> BIOS(Basic Input Output System)是一套程序,这套程序是写死到主板上面的一个内存芯片中,这个内存芯片在没有通电时也能够将数据记录下来,那就是只读存储器(Read Only Memory,ROM)。<br> 显卡的规格有 PCI/AGP/PCe,目前的主流为 Pcle 接口。<br> 硬盘是由盘片、机械手臂、磁头与主轴马达所组成的,其中盘片的组成为扇区、磁道与柱面。<br> 操作系统( Operating System,Os)其实也是一组程序,这组程序的重点在于管理计算机的所有活动以及驱动系统中的所有硬件。<br> 计算机主要以二进制作为单位,常用的磁盘容量单位为 Byte,其单位换算为 1Byte=8bt<br> 操作系统仅在于驱动与管理硬件,而要使用硬件时,就得需要通过应用软件或者是 she 的功能,来调用操作系统操纵硬件工作。目前,操作系统除了上述功能外,通常已经包含了日常工作所需要的应用软件在内了。</p><h1 id="Linux是什么"><a href="#Linux是什么" class="headerlink" title="Linux是什么"></a>Linux是什么</h1><p>Linux 是 OS 内核，包含内核及工具，沿袭 Unix，提供了一个完整的 OS 中最底层的硬件控制与资源管理的完整架构。</p><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><ul><li>Bell 实验室开发 Multics 分时系统无果，Ken Thompson 用汇编语言编写内核程序 Unics，之后为了移植，改用 C 语言编写内核发性 UNIX 正式版本，强调多用户多任务的兼容分时系统。后来 AT&amp;T 收回 UNIX 源码版权，谭宁邦自主编写 Minix，用于教学，公开源码，付费发行。</li><li>史托曼为了创建一个自由开放的 UNIX 操作系统，开始 GNU 项目，成立自由软件基金会 FSF，合作之下完成 GNU C Compiler，撰写通用公共许可证 GPL（CopyLeft），1991 年，芬兰大学生 Linus Torvalds 宣称 LInux 内核程序可以在 Intel 386 上运行。</li><li>GNU：发布软件的同时公布源码。</li><li>GNU GPL：GPL 代表具有自由度的软件，用户可以自由执行、复制、再发行、学习、修改与强化，但不能取消 GPL 授权，软件是自由的，但软件相关的“服务”是可以商业的。Open Source 的好处即修改程序代码去适合的工作环境。</li></ul><h2 id="Linux的内核版本"><a href="#Linux的内核版本" class="headerlink" title="Linux的内核版本"></a>Linux的内核版本</h2><p><strong>主版本.次版本.释出版本-修改版本</strong></p><ul><li>次版本为奇数：开发中版本，内核工程师使用；</li><li>次版本为偶数：稳定版本，家庭计算机以及企业版本。</li><li>释出版本：主次版本不变情况下，新增功能累积到一定程度之后释出。</li><li>Linux 内核版本与 distibution 版本并不相同</li></ul><h2 id="Linux-distribution"><a href="#Linux-distribution" class="headerlink" title="Linux distribution"></a>Linux distribution</h2><p>Linux 是 kernel，GNU GPL 授权模式，参考 POSIX 设计规范（POSIX 即可携式操作系统接口，重点在于规范内核与应用程序之间的接口），兼容 UNIX 操作系统，即 UNIX Like。</p><ul><li>为了让用户能够接触到 Linux，于是很多的商业公司或非营利团体就将 Kernel+ Softwares+ Tools 集成起来，加上自己具有创意的工具程序,这个工具程序可以让用户以光盘、DvD 或者通过网络直接安装管理 Lnux 系统。称为 dLinux distribution。</li></ul><p><img src="/images/linux-vbird-0-3/linux_distribution.png" alt="linux_distribution.png"></p><ul><li>Linux standard Base(LsSB)等标准来规范开发者,以及目录架构的 Fle system Hierarchy Standard(FHS)标准规范，它们的唯一差别可能就是该开发者自家所开发出来的管理工具以及套件管理的模式。所以说，基本上，每个 Linux distributions 除了架构的严谨度与选择的套件内容外，其实差异并不太大，最大的差异在于软件的安装模式。</li><li>团队版适合个人（更新快），商业版适合服务器（稳定）。</li><li>事实上鸟哥认为 distributions 主要分为两大系统，一种是使用 RPM 方式安装软件的系统,包括 Red Hat， Fedora，SusE，Centos 等都是这类；一种则是使用 Debian 的 dpkg 方式安装软件的系统，包括 Debian，Ubuntu，B2D 等。</li></ul><h2 id="Linux的特色"><a href="#Linux的特色" class="headerlink" title="Linux的特色"></a>Linux的特色</h2><ul><li>稳定的系统</li><li>免费或少许费用</li><li>安全性、漏洞的快速修补</li><li>多任务、多用户</li><li>用户、用户组</li><li>相对不耗资源</li><li>需要小内核的嵌入式系统</li><li>整合度佳且多样的用户界面（GUI）</li></ul><h1 id="主机规划与磁盘分区"><a href="#主机规划与磁盘分区" class="headerlink" title="主机规划与磁盘分区"></a>主机规划与磁盘分区</h1><p>各个硬件设备在 linux 中当成一个文件来对待，几乎所有的硬件设备文件在/dev 目录里。<br>Windows 下不管有多少个 IDE 设备都是顺序地分配盘符，而在 Linux 下是认真区分对待每一个硬盘的。<br><em>（来自<a href="https://blog.csdn.net/weixin_32482133/article/details/112946362">https://blog.csdn.net/weixin_32482133/article/details/112946362</a>）</em></p><h2 id="磁盘连接的方式与设备文件名的关系"><a href="#磁盘连接的方式与设备文件名的关系" class="headerlink" title="磁盘连接的方式与设备文件名的关系"></a>磁盘连接的方式与设备文件名的关系</h2><table><thead><tr><th>接口</th><th>命名</th></tr></thead><tbody><tr><td>IDE 设备</td><td>/dev/hd[a-d]</td></tr><tr><td>SCSI/SATA/USB 硬盘</td><td>/dev/sd[a-p]</td></tr></tbody></table><h3 id="IDE设备"><a href="#IDE设备" class="headerlink" title="IDE设备"></a>IDE设备</h3><p>一个 IDE 扁平线缆可以连接两个 IDE 设备，通常主机会提供两个接口 IDE1（primary）和 IDE2（secondary），故可以连接四个 IDE 设备，每个扁平线缆上的 IDE 设备分为 Master/Slave。</p><table><thead><tr><th>IDE</th><th>Master</th><th>Slave</th></tr></thead><tbody><tr><td>IDE1（primary）</td><td>/dev/hda</td><td>/dev/hdb</td></tr><tr><td>IDE2（secondary）</td><td>/dev/hdc</td><td>/dev/hdd</td></tr></tbody></table><h3 id="SATA设备"><a href="#SATA设备" class="headerlink" title="SATA设备"></a>SATA设备</h3><p>SATA/SCSI/USB 等磁盘接口使用 SCSI 模块驱动，使用/dev/sd[a-p]格式，SATA/USB 接口的磁盘根本没有顺序，文件名由 Linux 内核检测到磁盘的顺序排列。</p><h2 id="磁盘的组成"><a href="#磁盘的组成" class="headerlink" title="磁盘的组成"></a>磁盘的组成</h2><p>磁盘的第一个扇区（512bytes）记录重要信息：</p><ul><li>主引导分区 MBR（446bytes）：安装引导加载程序的地方。系统开机时主动读取，系统知道程序存放位置和如何开机。</li><li>分区表（64bytes）：记录整块硬盘分区的状态。硬盘必须切割才能使用。</li></ul><p><img src="/images/linux-vbird-0-3/disk_constitute.png" alt="disk_constitute.png"></p><h2 id="磁盘分区表"><a href="#磁盘分区表" class="headerlink" title="磁盘分区表"></a>磁盘分区表</h2><p>分区的最小单位是柱面，参考柱面号码切割硬盘，在分区表所在的 64bytes 容量中，分为四组记录区，每组记录区记录了该区段的起始与结束的柱面号码。这四个分区称为主或扩展分区。</p><p><img src="/images/linux-vbird-0-3/disk_separate1.png" alt="disk_separate1.png"></p><p>系统写入磁盘时，一定会参考分区表。分区的目的：安全性与性能。<br>利用额外的（第一个扇区之外的）扇区记录更多的分区信息，扩展分区本身不能被格式化，主分区与逻辑分区可以。</p><p><img src="/images/linux-vbird-0-3/disk_separate2.png" alt="disk_separate2.png"></p><p>这五个由扩展分区切割的分区成为逻辑分区（5个），设备名从主分区保留之后开始。<br>    主分区+扩展分区≤4（硬盘限制）；<br>    扩展分区≤1（操作系统限制）。<br>    P主分区、E扩展分区、L逻辑分区。主分区和扩展分区之外的空间将被浪费。考虑到连续性，E分配在最后。分区&gt;4时，一定要有E。<br>    例如：在第二块SATA硬盘下分6个分区，有方法：</p><p><img src="/images/linux-vbird-0-3/disk_separate3.png" alt="disk_separate3.png"><br><img src="/images/linux-vbird-0-3/disk_separate4.png" alt="disk_separate4.png"></p><h2 id="开机流程与主引导分区MBR"><a href="#开机流程与主引导分区MBR" class="headerlink" title="开机流程与主引导分区MBR"></a>开机流程与主引导分区MBR</h2><h3 id="开机流程"><a href="#开机流程" class="headerlink" title="开机流程"></a>开机流程</h3><ol><li>BIOS：开机主动执行韧体 BIOS，寻找开机设备（根据用户设置的能开机的硬盘）</li><li>MBR：分析存储设备（如硬盘）第一个扇区的 MBR 位置，内置引导加载程序</li><li>引导加载程序 Boot Loader：加载内核</li><li>内核文件：OS 工作。</li></ol><p>BIOS 和 MBR 由硬件支持，BootLoader 由 OS 支持。</p><h3 id="BootLoader的功能"><a href="#BootLoader的功能" class="headerlink" title="BootLoader的功能"></a>BootLoader的功能</h3><ul><li><p>提供菜单：多重引导</p></li><li><p>载入内核：指向可开机的程序区段</p></li><li><p>转交其他 Loader（一个硬盘上包含多个系统，如双系统）</p><p>硬盘的每个分区都有自己的启动扇区，内核文件实际放置在各分区内，Loader 只认识自己分区的内核以及其他 Loader。</p></li></ul><p><img src="/images/linux-vbird-0-3/mbr.png" alt="mbr.png"></p><h2 id="磁盘分区的选择"><a href="#磁盘分区的选择" class="headerlink" title="磁盘分区的选择"></a>磁盘分区的选择</h2><p>Linux 所有数据以文件形态呈现，使用目录树结构，实际存放在磁盘分区中。</p><p>挂载：文件系统与目录树的关系</p><ul><li>将一个目录当作磁盘的入口，进入目录即可读取分区。即“挂载”与“挂载点”，最重要的根目录一定需要挂载到某分区。<br>（磁盘上有/file，挂载到/mnt 下，即访问路径/mnt/file）</li><li>安装 distribution，自定义安装 Custom 模式，建议仅区分主分区/和交换分区 swap（补充内存）。更详细的分区方案参考网络。</li></ul><h2 id="主机硬盘的主要规划"><a href="#主机硬盘的主要规划" class="headerlink" title="主机硬盘的主要规划"></a>主机硬盘的主要规划</h2><p>  主机硬盘的需求和主机开放的服务有关，还需要注意数据分类和安全。</p><p>  最简单的的分区方法<br>  / &amp; swap &amp; 未分区</p><p>  根据用途：</p><p>  容量大且读写频繁的目录：/ /usr /home /var swap<br>  大硬盘配合旧主机造成无法开机的问题<br>  旧主板找不到大容量磁盘，导致误判，但是 Linux 内核顺利开机后会重新检测硬盘而不例会 BIOS，所以 Linux 能够安装。<br>  但是安装完毕无法开机，BIOS 不能正确识别硬盘，开机错误。BIOS 只能读取前面的扇区，故将启动扇区所在分区规范在 ≤1024 个柱面以内。<br>  分区/boot &amp; / &amp; swap，/boot 100MB 左右，放在硬盘最前面。</p><h1 id="安装CentOS-5-x与多重引导"><a href="#安装CentOS-5-x与多重引导" class="headerlink" title="安装CentOS 5.x与多重引导"></a>安装CentOS 5.x与多重引导</h1><h2 id="安装规划"><a href="#安装规划" class="headerlink" title="安装规划"></a>安装规划</h2><ul><li>Linux主机的角色定位</li><li>选择distribution</li><li>计算机硬件配置</li><li>磁盘分区配置：/boot&amp;/&amp;/home&amp;swap  PPPL</li><li>引导装载程序BootLoader：安装到MBR</li><li>选择软件：默认/最小/全部/自定义</li></ul><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol><li>调整启动媒体(BIOS):使用Linux安装光盘，调整BIOS的开机启动顺序为光盘；（无法以DVD开机时很可能是由于计算机硬件不支持、光驱会挑片、光盘问题、硬件超频等）</li><li>选择安装结构与开机:包括图形界面命令行界面等，也可加入特殊参数（硬件检测、安装媒体、内存测试）来开机进入安装界面；</li><li>选择语系数据:由于不同地区的键盘按键不同，此时需要调整语系/键盘/鼠标等配置；</li><li>磁盘分区:最重要的项目之一。提前规划。</li></ol><p>四种分区结构：</p><ul><li>整块硬盘：删除所有分区并创建默认分区结构</li><li>Linux分区：删除Linux分区并创建默认分区</li><li>选定驱动器的空闲空间：未分区空间</li><li>建立自定义分区结构</li></ul><p>Linux支持的文件系统类型：<br><em>（二三版书上介绍有差别）</em><br>ext2/ext3：Linux使用的文件系统类型，ext3/ext4比ext2多日志记录，恢复系统较为迅速</p><ol start="5"><li>引导装载程序、网络、时区设置与root密码:一些需要的系统基础设置!</li><li>软件选择:需要什么样的软件?全部安装还是默认安装即可?</li><li>安装后的首次设置:安装完毕后还有一些事项要处理,包括用户、 SELinux与防火墙等</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;基础篇第 0-3 章学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="Study" scheme="https://memorykk.cn/categories/Study/"/>
    
    
    <category term="linux" scheme="https://memorykk.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="https://memorykk.cn/Git.html"/>
    <id>https://memorykk.cn/Git.html</id>
    <published>2021-02-15T02:49:13.000Z</published>
    <updated>2021-02-18T14:26:23.672Z</updated>
    
    <content type="html"><![CDATA[<p>Git是目前世界上最先进的分布式版本控制系统（没有之一）。</p><span id="more"></span><hr><p><strong>目录</strong></p><ul><li><a href="#%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6">版本控制</a></li><li><a href="#%E5%AE%89%E8%A3%85git">安装Git</a><ul><li><a href="#linux">Linux</a></li><li><a href="#linux-1">Linux</a><ul><li><a href="#debianubuntu">Debian/Ubuntu</a></li><li><a href="#centosredhat">Centos/RedHat</a></li></ul></li><li><a href="#windows">Windows</a></li></ul></li><li><a href="#%E9%85%8D%E7%BD%AEgit">配置Git</a><ul><li><a href="#%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8Cemail">配置用户名和Email</a></li><li><a href="#%E5%A2%9E%E5%88%A0%E9%85%8D%E7%BD%AE%E9%A1%B9">增删配置项</a><ul><li><a href="#%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE%E9%A1%B9">添加配置项</a></li><li><a href="#%E5%88%A0%E9%99%A4%E9%85%8D%E7%BD%AE%E9%A1%B9">删除配置项</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E9%85%8D%E7%BD%AE%E9%A1%B9">更多配置项</a></li></ul></li><li><a href="#git%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">Git基本概念</a></li><li><a href="#git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">Git工作流程</a></li><li><a href="#git%E6%93%8D%E4%BD%9C">Git操作</a><ul><li><a href="#git%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93">Git创建版本库</a><ul><li><a href="#%E5%9C%A8%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%96">在工作目录中初始化</a></li><li><a href="#%E4%BB%8E%E7%8E%B0%E6%9C%89%E4%BB%93%E5%BA%93%E5%85%8B%E9%9A%86">从现有仓库克隆</a></li></ul></li><li><a href="#%E6%96%87%E4%BB%B6%E6%9B%B4%E6%96%B0">文件更新</a><ul><li><a href="#%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81">文件状态</a></li><li><a href="#%E6%A3%80%E6%9F%A5%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81">检查文件状态</a></li><li><a href="#%E8%B7%9F%E8%B8%AA%E6%96%87%E4%BB%B6">跟踪文件</a></li><li><a href="#%E6%9A%82%E5%AD%98%E5%B7%B2%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6">暂存已修改文件</a></li><li><a href="#%E5%BF%BD%E7%95%A5%E6%9F%90%E4%BA%9B%E6%96%87%E4%BB%B6">忽略某些文件</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E6%9C%AA%E6%9A%82%E5%AD%98%E7%9A%84%E6%9B%B4%E6%96%B0">查看未暂存的更新</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E5%B7%B2%E6%9A%82%E5%AD%98%E7%9A%84%E6%9B%B4%E6%96%B0">查看已暂存的更新</a></li><li><a href="#%E6%8F%90%E4%BA%A4%E6%9B%B4%E6%96%B0">提交更新</a></li><li><a href="#%E8%B7%B3%E8%BF%87%E4%BD%BF%E7%94%A8%E6%9A%82%E5%AD%98%E5%8C%BA%E5%9F%9F">跳过使用暂存区域</a></li><li><a href="#%E7%A7%BB%E9%99%A4%E6%96%87%E4%BB%B6">移除文件</a></li><li><a href="#%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6">移动文件</a></li></ul></li><li><a href="#%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2">查看提交历史</a><ul><li><a href="#%E9%99%90%E5%88%B6%E8%BE%93%E5%87%BA%E9%95%BF%E5%BA%A6">限制输出长度</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%B7%A5%E5%85%B7%E6%9F%A5%E9%98%85%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2">使用图形化工具查阅提交历史</a></li></ul></li><li><a href="#%E6%92%A4%E9%94%80">撤销</a><ul><li><a href="#%E4%BF%AE%E6%94%B9%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E6%8F%90%E4%BA%A4">修改最后一次提交</a></li><li><a href="#%E5%8F%96%E6%B6%88%E5%B7%B2%E7%BB%8F%E6%9A%82%E5%AD%98%E7%9A%84%E6%96%87%E4%BB%B6">取消已经暂存的文件</a></li><li><a href="#%E5%8F%96%E6%B6%88%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%AE%E6%94%B9">取消对文件的修改</a></li><li><a href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93">文件操作总结</a></li></ul></li></ul></li><li><a href="#git%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">Git远程仓库</a><ul><li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">查看远程仓库</a></li><li><a href="#%E6%B7%BB%E5%8A%A0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">添加远程仓库</a></li><li><a href="#%E4%BB%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E6%8A%93%E5%8F%96%E6%95%B0%E6%8D%AE">从远程仓库抓取数据</a></li><li><a href="#%E6%8E%A8%E9%80%81%E6%95%B0%E6%8D%AE%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">推送数据到远程仓库</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%BF%A1%E6%81%AF">查看远程仓库信息</a></li><li><a href="#%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E5%88%A0%E9%99%A4%E5%92%8C%E9%87%8D%E5%91%BD%E5%90%8D">远程仓库的删除和重命名</a><ul><li><a href="#%E9%87%8D%E5%91%BD%E5%90%8D">重命名</a></li><li><a href="#%E5%88%A0%E9%99%A4">删除</a></li></ul></li></ul></li><li><a href="#%E7%89%88%E6%9C%AC%E6%A0%87%E7%AD%BE">版本标签</a><ul><li><a href="#%E6%98%BE%E7%A4%BA%E5%B7%B2%E6%9C%89%E6%A0%87%E7%AD%BE">显示已有标签</a></li><li><a href="#%E6%96%B0%E5%BB%BA%E6%A0%87%E7%AD%BE">新建标签</a><ul><li><a href="#%E5%90%AB%E9%99%84%E6%B3%A8%E7%9A%84%E6%A0%87%E7%AD%BE">含附注的标签</a></li><li><a href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%A0%87%E7%AD%BE">轻量级标签</a></li><li><a href="#%E7%AD%BE%E7%BD%B2%E6%A0%87%E7%AD%BE">签署标签</a></li><li><a href="#%E9%AA%8C%E8%AF%81%E6%A0%87%E7%AD%BE">验证标签</a></li></ul></li><li><a href="#%E5%90%8E%E6%9C%9F%E5%8A%A0%E6%B3%A8%E6%A0%87%E7%AD%BE">后期加注标签</a></li><li><a href="#%E5%88%86%E4%BA%AB%E6%A0%87%E7%AD%BE">分享标签</a></li></ul></li><li><a href="#git%E5%88%86%E6%94%AF">Git分支</a><ul><li><a href="#%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B">分支简介</a></li><li><a href="#%E6%96%B0%E5%BB%BA%E5%88%86%E6%94%AF">新建分支</a></li><li><a href="#head">HEAD</a></li><li><a href="#%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF">切换分支</a></li><li><a href="#%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF">合并分支</a></li><li><a href="#%E9%81%87%E5%88%B0%E5%86%B2%E7%AA%81%E6%97%B6%E7%9A%84%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6">遇到冲突时的分支合并</a></li><li><a href="#%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF">删除分支</a></li><li><a href="#%E6%A1%88%E4%BE%8B">案例</a></li><li><a href="#%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86">分支管理</a></li><li><a href="#%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">远程分支</a></li><li><a href="#%E6%8E%A8%E9%80%81%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF">推送本地分支</a></li><li><a href="#%E8%B7%9F%E8%B8%AA%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">跟踪远程分支</a></li><li><a href="#%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">删除远程分支</a></li><li><a href="#%E5%88%86%E6%94%AF%E8%A1%8D%E5%90%88">分支衍合</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li></ul><hr><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。最初由 Linus Torvalds 为了帮助管理 Linux 内核开发而花了两周时间自己用C写出来的。（理那厮·掏袜子真的太绝了⊙ｏ⊙）</p><h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p>版本控制系统分为本地式、集中式和分布式。</p><ul><li><p>本地式：适合个人使用，用于记录文件更新。代表：RCS</p><img src="/images/Git/local.png" class=""></li><li><p>集中式：必须联网，断网后可编辑无法commit和回滚。版本库都存在中央服务器上，用户的本地只有自己以前所同步的版本，没有完整的版本库。代表：SVN、CVS、VSS。<br>假设SVN服务器没了，那你丢掉了所有历史信息，因为你的本地只有当前版本以及部分历史信息。</p><img src="/images/Git/centralization.png" class=""></li><li><p>分布式：只有在push、pull时需要联网，断网后可正常commit。中央服务器只为了修改起来方便，可有可无，每个用户本地都是一个完整的版本库。代表：Git。<br>每个人都同时对同一版本修改，commit操作提交到本地，多人协作时需要push操作和别人同步，但是团队人数多会导致非常麻烦，所以出现所谓的（便于修改的）中央服务器。<br>假设GitHub服务器没了，你不会丢掉任何git历史信息，因为你的本地有完整的版本库信息，你可以把本地的git库重新上传到另外的git服务商。 </p><img src="/images/Git/distributed.png" class=""></li></ul><p><strong>Git的特点</strong></p><ul><li><p>直接记录快照，而非差异比较<br>Git 只关心文件数据的<strong>整体</strong>是否发生变化，而大多数其他系统则只关心文件内容的具体差异。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。有变化则保存，无则链接。</p></li><li><p>近乎所有操作都是本地执行</p></li><li><p>时刻保持数据完整性<br>保存在 Git 数据库中的东西都是用此哈希值来作索引的，而不是靠文件名。</p></li><li><p>多数操作仅添加数据</p></li></ul><h1 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h1><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。<br><code>yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel</code><br>或<br><code>$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev</code><br>下载源码：<a href="http://git-scm.com/download">http://git-scm.com/download</a><br>编译安装<br><code>$ tar -zxf git-1.7.2.2.tar.gz</code><br><code>$ cd git-1.7.2.2</code><br><code>$ make prefix=/usr/local all</code><br><code>$ sudo make prefix=/usr/local install</code></p><h2 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h2><h3 id="Debian-Ubuntu"><a href="#Debian-Ubuntu" class="headerlink" title="Debian/Ubuntu"></a>Debian/Ubuntu</h3><p><code>$ sudo apt-get install git</code></p><h3 id="Centos-RedHat"><a href="#Centos-RedHat" class="headerlink" title="Centos/RedHat"></a>Centos/RedHat</h3><p><code>$ yum install git-core</code></p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p><a href="https://git-scm.com/downloads">官网下载</a><br><a href="https://npm.taobao.org/mirrors/git-for-windows/">镜像下载</a><br>默认安装。</p><img src="/images/Git/winGit.PNG" class=""><ul><li><kbd>Git Bash</kbd>：Unix与Linux风格的命令行（<strong>推荐</strong>）</li><li><kbd>Git CMD</kbd>：DOS风格的命令</li><li><kbd>Git GUI</kbd>：图形界面（<strong>新手不推荐</strong>）  </li></ul><p>打开<kbd>Git Bash</kbd>检查一下：  </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git --version</span></span><br><span class="line">git version 2.29.2.windows.2</span><br></pre></td></tr></table></figure><h1 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h1><h2 id="配置用户名和Email"><a href="#配置用户名和Email" class="headerlink" title="配置用户名和Email"></a>配置用户名和Email</h2><p>信息将会嵌入你的每次提交中。</p><p><strong>配置级别</strong>  </p><ul><li>系统级<kbd>--system</kbd>：系统中所有用户适用的配置<ul><li>Linux：/etc/gitconfig</li><li>Windows：Git/mingw64/etc/gitconfig</li></ul></li><li>用户级<kbd>--global</kbd>：当前用户适用的配置<ul><li>Linux：~/.gitconfig</li><li>Windows：C:/Users/Administrator/.gitconfig</li></ul></li><li>项目级<kbd>--local</kbd>：特定项目适用的配置<ul><li>Linux：gitProject/.gitconfig</li><li>Windows：gitProject/.gitconfig</li></ul></li></ul><p>低级覆盖高级：<strong>local&lt;globall&lt;system</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">&quot;Your Name&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">&quot;Your Email&quot;</span></span></span><br></pre></td></tr></table></figure><p>如果用了<kbd>--global</kbd>选项，所有项目都会默认使用这个全局配置，不加则为某个特定的项目信息。</p><h2 id="增删配置项"><a href="#增删配置项" class="headerlink" title="增删配置项"></a>增删配置项</h2><h3 id="添加配置项"><a href="#添加配置项" class="headerlink" title="添加配置项"></a>添加配置项</h3><p><code>git config [--local|--global|--system]  section.key value</code></p><p>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">51139@DESKTOP MINGW64 /e/blog</span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global Student.number 2018000001</span></span><br><span class="line">51139@DESKTOP MINGW64 /e/blog</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat C:/Users/51139/.gitconfig</span></span><br><span class="line">[user]</span><br><span class="line">        name = memorykkk</span><br><span class="line">        email = 511390937@qq.com</span><br><span class="line">[Student]</span><br><span class="line">        number = 2018000001</span><br></pre></td></tr></table></figure><h3 id="删除配置项"><a href="#删除配置项" class="headerlink" title="删除配置项"></a>删除配置项</h3><p><code>git config [--local|--global|--system] --unset section.key</code></p><h2 id="更多配置项"><a href="#更多配置项" class="headerlink" title="更多配置项"></a>更多配置项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config -l, --list     #list all    列出所有</span><br><span class="line">git config -e, --edit     #open an editor    打开一个编辑器</span><br><span class="line">git config --global color.ui true   #打开所有的默认终端着色</span><br><span class="line">git config --global alias.ci commit   #别名 ci 是commit的别名</span><br><span class="line">user.name  #用户名</span><br><span class="line">user.email  #邮箱</span><br><span class="line">core.editor  #文本编辑器  </span><br><span class="line">merge.tool  #差异分析工具  </span><br><span class="line">core.paper &quot;less -N&quot;  #配置显示方式  </span><br><span class="line">color.diff true  #diff颜色配置  </span><br><span class="line">alias.co checkout  #设置别名</span><br><span class="line">git config user.name  #获得用户名</span><br><span class="line">git config core.filemode false  #忽略修改权限的文件 </span><br></pre></td></tr></table></figure><p>学习<kbd>config</kbd>命令，运行  <code>$ git help config</code></p><p>查看手册 <a href="https://git-scm.com/docs/git-config">git config</a></p><h1 id="Git基本概念"><a href="#Git基本概念" class="headerlink" title="Git基本概念"></a>Git基本概念</h1><ol><li>Git本地有三个工作区域：<strong>工作区</strong>（Workspace）、<strong>暂存区</strong>（Index/Stage）、<strong>仓库</strong>（Repository），加上<strong>远程仓库</strong>（Remote）共四个工作区域。</li></ol><p>Git 各个命令可以理解为在各个仓库间转移数据，各个命令对应对每个仓库输入输出。</p><ul><li>Workspace：工作区，平时能看到的存放项目代码的地方</li><li>Index / Stage：暂存区，临时存放改动，保存即将提交到文件列表信息的文件，有时也叫作索引</li><li>Repository：仓库区（或本地仓库），安全存放数据的位置，含所有版本的数据，HEAD指向最新版本</li><li>Remote：远程仓库，托管代码的服务器，用于远程数据交换</li></ul><ol start="2"><li>对于本地三个区域的关系如下：<br><img src="/images/Git/local_relation.png" alt="local_relation"></li></ol><ul><li><p>Directory：使用Git管理的仓库，包含我们的工作空间和Git的管理空间</p></li><li><p>WorkSpace：需要通过Git进行版本控制的目录和文件组成工作空间</p></li><li><p>.git：存放Git管理信息的目录，初始化仓库的时候自动创建</p></li><li><p>Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前存放所有的更新</p></li><li><p>Local Repo：本地仓库，HEAD会只是当前的开发分支（branch）。</p></li><li><p>Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。<br>观察命令对各区域的影响：<br><img src="/images/Git/git_theory.jpg" alt="git_theory"></p></li><li><p>master 是 master 分支所代表的目录树，此时 HEAD 实际是指向 master 分支的一个”游标”，objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。</p></li><li><p>当对工作区修改（或新增）的文件执行 <kbd>git add</kbd> 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</p></li><li><p>当执行提交操作 <kbd>git commit</kbd>时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</p></li><li><p>当执行 <kbd>git reset HEAD</kbd> 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</p></li><li><p>当执行 <kbd>git rm --cached &lt;file></kbd> 命令时，会直接从暂存区删除文件，工作区则不做出改变。</p></li><li><p>当执行 <kbd>git checkout .</kbd> 或者 <kbd>git checkout -- &lt;file></kbd> 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</p></li><li><p>当执行 <kbd>git checkout HEAD .</kbd> 或者 <kbd>git checkout HEAD &lt;file></kbd> 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</p></li></ul><ol start="3"><li>若对四个区域分级：workspace &lt; index &lt; repository &lt; remote，基本的转移如下表，参数和选项决定数据来源。</li></ol><table><thead><tr><th></th><th>低等级输入</th><th>高等级输入</th></tr></thead><tbody><tr><td>workspace</td><td>手动</td><td>git checkout/git stash</td></tr><tr><td>index/stage</td><td>git add</td><td>git reset</td></tr><tr><td>repository</td><td>git commit</td><td>git pull</td></tr><tr><td>remote</td><td>git push</td><td>-</td></tr></tbody></table><p>四个区域转换关系如下：<br><img src="/images/Git/git_transition.png" alt="git_transition"></p><h1 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h1><p>一般工作流程如下：</p><ul><li>在工作目录中修改某些文件。</li><li>对修改后的文件进行快照，然后保存到暂存区域。</li><li>提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。</li></ul><p><img src="/images/Git/git-process-img.png" alt="git-process"></p><h1 id="Git操作"><a href="#Git操作" class="headerlink" title="Git操作"></a>Git操作</h1><h2 id="Git创建版本库"><a href="#Git创建版本库" class="headerlink" title="Git创建版本库"></a>Git创建版本库</h2><ul><li>在工作目录中初始化新仓库</li><li>从现有仓库克隆</li></ul><h3 id="在工作目录中初始化"><a href="#在工作目录中初始化" class="headerlink" title="在工作目录中初始化"></a>在工作目录中初始化</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure><p>在新建空目录或已有目录中，使用命令 <code>git init</code> 初始化一个新仓库。初始化后该目录下自动生成<kbd>.git</kbd>目录，用于生成所有 Git 需要的数据和资源。</p><p><strong>文件加入版本库</strong><br>将文件添加到仓库（workspace -&gt; stage）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add &lt;file&gt;</span></span><br></pre></td></tr></table></figure><p>执行后没有任何信息则代表执行成功。</p><p>将文件提交到仓库（stage -&gt; repository）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m &lt;message&gt;</span></span><br></pre></td></tr></table></figure><p>多次<kbd>add</kbd>不同的文件，但只需一次<kbd>commit</kbd>就可以提交。</p><h3 id="从现有仓库克隆"><a href="#从现有仓库克隆" class="headerlink" title="从现有仓库克隆"></a>从现有仓库克隆</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> &lt;url&gt; &lt;newName&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Git 收取的是项目历史的完整数据（每一个文件的每一个版本），而不是某个特定版本，服务器上有的数据克隆之后本地也都有了。  </li><li><kbd>url</kbd> 支持 git 协议或 SSH 传输协议。通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。  </li><li>克隆之后的目录名为 url 中 .git 前的名称，通过 <kbd>&lt;newName></kbd> 可以自定义。目录中包含<kbd>.git</kbd>目录，用于保存下载下来的所有版本记录，然后从中取出最新版本的文件拷贝。</li></ul><h2 id="文件更新"><a href="#文件更新" class="headerlink" title="文件更新"></a>文件更新</h2><h3 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h3><p>文件状态主要分两种，已跟踪（tracked）即本来就被纳入版本控制管理的文件，其它文件即未跟踪（untracked）。</p><ul><li>Untracked：未跟踪，此文件没有加入到git库，不参与版本控制。通过 <code>git add</code> 状态变为staged</li><li>Unmodify：文件已经入库，未修改，即版本库中的文件快照内容与文件夹中完全一致。这种文件被修改成为Modified，通过<code>git rm</code>移出版本库成为Untracked</li><li>Modified：文件已修改。这种文件通过<code>git add</code>可变成staged，通过<code>git checkout</code>则丢弃修改回到unmodify</li><li>Staged：暂存状态。通过<code>git commit</code>则将修改同步到库中，这时库中的文件和本地文件又变为一致，变为Unmodify状态。执行<code>git reset HEAD &lt;filename&gt;</code>取消暂存，变为Modified</li></ul><p>初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改（unmodified）。<br>文件状态变化周期：<br><img src="/images/Git/file-status.png" alt="file-status"></p><p>修改后的文件状态是 modified，逐步放在暂存区域，最后一次性提交。</p><h3 id="检查文件状态"><a href="#检查文件状态" class="headerlink" title="检查文件状态"></a>检查文件状态</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看指定文件状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status &lt;filename&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看所有文件状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br></pre></td></tr></table></figure><p>例如创建README之后：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim README</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Untracked files:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># README</span></span></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><p>表示当前处在<kbd>master</kbd>分支，未跟踪文件里包含 README，即 Git 之前的快照中没有这个文件，未纳入管理。</p><h3 id="跟踪文件"><a href="#跟踪文件" class="headerlink" title="跟踪文件"></a>跟踪文件</h3><p>（workspace -&gt; stage；untracked -&gt; staged）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加指定文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add &lt;file1&gt; &lt;file2&gt; ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加指定目录到暂存区，包括子目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add &lt;dir&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加当前目录的所有文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add README</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">    # On branch master</span><br><span class="line">    # Changes to be committed:</span><br><span class="line">    # (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">    #</span><br><span class="line">    # new file: README</span><br><span class="line">    #</span><br></pre></td></tr></table></figure><p>“Changes to be committed:” 表示其下的文件处于暂存区</p><h3 id="暂存已修改文件"><a href="#暂存已修改文件" class="headerlink" title="暂存已修改文件"></a>暂存已修改文件</h3><p>（untracked -&gt; staged）<br>修改一个已跟踪的文件后</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">    # On branch master</span><br><span class="line">    # Changes not staged for commit:</span><br><span class="line">    # (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">    #</span><br><span class="line">    # modified: benchmarks.rb</span><br><span class="line">    #</span><br></pre></td></tr></table></figure><p>“Changes not staged for commit:” 表示该文件内容发生变化但还未放到暂存区，需要重新运行 <code>git add</code> 命令。<br>也就是说，文件修改之后必须再次 <code>git add</code>，否则 <code>git commit</code> 提交的是修改前版本。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add benchmarks.rb</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># new file: README</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> modified: benchmarks.rb</span></span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure><p><code>git add</code> 根据目标文件的状态产生不同的效果：</p><ul><li>开始跟踪新文件</li><li>把已跟踪的文件放到暂存区</li><li>合并时把有冲突的文件标记为已解决状态</li></ul><h3 id="忽略某些文件"><a href="#忽略某些文件" class="headerlink" title="忽略某些文件"></a>忽略某些文件</h3><p>有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。有以下三种方式：</p><ol><li><p>创建<kbd>.gitignore</kbd>文件</p></li><li><p>项目设置中指定排除文件<br>临时指定。需要编辑当前项目中的 .git/info/exclude 文件</p></li><li><p>定义Git全局的 .gitignore 文件<br>设置全局的.gitignore文件来管理所有Git项目的行为。创建.gitignore文件，存放在任意位置，然后使用命令 <code># git config --global core.excludesfile ~/.gitignore</code> 配置。</p></li></ol><p>格式规范如下：</p><ul><li>每行一个，空格不匹配任意文件，可作为分隔符，可用反斜杠转义</li><li>所有空行或者以注释符号 <kbd>＃</kbd> 开头的行都会被 Git 忽略</li><li>可以使用标准的 glob 模式匹配：shell 所使用的简化了的正则表达式</li><li>匹配模式最后跟反斜杠<kbd>/</kbd>说明要忽略的是目录下所有文件</li><li>使用两个星号”**” 表示匹配任意中间目录</li><li><kbd>/</kbd>结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件；<kbd>/</kbd>开始的模式匹配项目根目录</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号<kbd>!</kbd>取反。</li><li>关于优先级等更多语法查看<a href="https://www.cnblogs.com/kevingrace/p/5690241.html">Git忽略提交规则 - .gitignore配置运维总结</a></li></ul><p>一般来说每个Git项目中都需要一个“.gitignore”文件，告诉Git哪些文件不需要添加到版本管理中，实际项目中很多文件都是不需要版本管理的，例如日志、缩略图、敏感信息等。</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span></span><br><span class="line">    doc/*.txt</span><br></pre></td></tr></table></figure><h3 id="查看未暂存的更新"><a href="#查看未暂存的更新" class="headerlink" title="查看未暂存的更新"></a>查看未暂存的更新</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br></pre></td></tr></table></figure><p>查看工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。<br>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br><span class="line">    diff --git a/benchmarks.rb b/benchmarks.rb</span><br><span class="line">    index 3cb747f..da65585 100644</span><br><span class="line">    --- a/benchmarks.rb</span><br><span class="line">    +++ b/benchmarks.rb</span><br><span class="line">    @@ -36,6 +36,10 @@ def main</span><br><span class="line">    @commit.parents[0].parents[0].parents[0]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    + run_code(x, &#x27;commits 1&#x27;) do</span><br><span class="line">    + git.commits.size</span><br><span class="line">    + end</span><br><span class="line">    +</span><br><span class="line">    run_code(x, &#x27;commits 2&#x27;) do</span><br><span class="line">    log = git.commits(&#x27;master&#x27;, 15)</span><br><span class="line">    log.size</span><br></pre></td></tr></table></figure><h3 id="查看已暂存的更新"><a href="#查看已暂存的更新" class="headerlink" title="查看已暂存的更新"></a>查看已暂存的更新</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached</span></span><br></pre></td></tr></table></figure><p>查看已经暂存起来的文件和上次提交时的快照之间的差异</p><h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h3><p>（staged -&gt; commited；stage -&gt; repository）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m &lt;file&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区的指定文件到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit &lt;file1&gt; &lt;file2&gt; ... -m &lt;message&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交工作区自上次commit之后的变化，直接到仓库区，跳过add,对新文件无效</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交时显示所有diff信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -v</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果我们提交后发现有个文件改错了，将修改过的文件通过<span class="string">&quot;git add&quot;</span>后执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m &lt;message&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend &lt;file1&gt; &lt;file2&gt; ...</span> </span><br></pre></td></tr></table></figure><p>使用 <code>git status</code> 查看暂存区域状态，准备妥当之后就可以提交了。<br>这样看来暂存区的意义在于<strong>精心准备</strong>每次提交。  </p><ul><li>直接使用不加 <kbd>-m</kbd> 的 <code>git commit</code> 提交会打开编辑器（通过 <code>$ git config --global core.editor emacs</code> 配置）以便输入本次提交的说明。</li><li>使用<kbd>-m</kbd>选项比较方便。</li></ul><p>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;Story 182: Fix benchmarks for speed&quot;</span></span></span><br><span class="line">    [master]: created 463dc4f: &quot;Fix benchmarks for speed&quot;</span><br><span class="line">    2 files changed, 3 insertions(+), 0 deletions(-)</span><br><span class="line">    create mode 100644 README</span><br></pre></td></tr></table></figure><p>显示了提交的分支（master）、SHA-1校验和（463dc4f）、修改过的文件数（2）和增（3）删<strong>行数</strong>。  </p><p>因为修改后但未暂存的处于已修改态（modified），只能纳入下一次版本。  </p><p><strong>每次提交都是对项目的一次快照，以后可以回退</strong></p><h3 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -a -m &lt;message&gt;</span></span><br></pre></td></tr></table></figure><p>Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤，对新文件无效</p><h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><ol><li>从 Git 中移除文件</li></ol><p>未跟踪文件对 Git 来说不存在，手动<code>rm</code>即可，已跟踪文件就必须要从已跟踪文件清单（stage）中移除，然后提交。可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm &lt;file&gt;</span></span><br></pre></td></tr></table></figure><p>如果只是简单地从工作目录中手工删除文件，运行 <code>git status</code> 时就会在 “Changes not staged for commit” 部分（未暂存清单）看到。（判断为“修改”操作？）</p><ol start="2"><li>从 Git 中移除，但仍然希望保留在当前工作目录<br>（stage -&gt; workspace；tracked:staged -&gt; untracked）<br>即不小心纳入仓库后，想要移除跟踪但不删除文件。</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm --cached &lt;file&gt;</span></span><br></pre></td></tr></table></figure><h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git mv &lt;oldfileName&gt; &lt;newFileName&gt;</span></span><br></pre></td></tr></table></figure><p>Git 并不跟踪文件移动操作。如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。要在 Git 中对文件改名，执行<code>git mv</code>实际上相当于</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mv old new</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm old</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add new</span></span><br></pre></td></tr></table></figure><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br></pre></td></tr></table></figure><p>默认不用任何参数，<code>git log</code> 会按提交时间列出所有的更新信息。<br>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">    commit ca82a6dff817ec66f44342007202690a93763949   #SHA-1校验和</span><br><span class="line">    Author: Scott Chacon &lt;schacon@gee-mail.com&gt;       #作者&lt;邮箱&gt;</span><br><span class="line">    Date: Mon Mar 17 21:52:11 2008 -0700              #时间</span><br><span class="line"></span><br><span class="line">    changed the version number                        #提交说明</span><br></pre></td></tr></table></figure><p><strong>选项</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> &lt;option&gt;</span></span><br><span class="line">  -p    #开显示每次提交的内容差异</span><br><span class="line">  --stat  #仅显示简要的增改行数统计</span><br><span class="line">  --shortstat #只显示 --stat 中最后的行数修改添加移除统计。</span><br><span class="line">  --name-only #仅在提交信息后显示已修改的文件清单。</span><br><span class="line">  --name-status #显示新增、修改、删除的文件清单。</span><br><span class="line">  --abbrev-commit #仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</span><br><span class="line">  --relative-date #使用较短的相对时间显示（比如，“2 weeks ago”）。</span><br><span class="line">  --graph 显示 ASCII #图形表示的分支合并历史。</span><br><span class="line">  --pretty #使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</span><br></pre></td></tr></table></figure><h3 id="限制输出长度"><a href="#限制输出长度" class="headerlink" title="限制输出长度"></a>限制输出长度</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> &lt;option&gt;</span></span><br><span class="line">  -(n) #仅显示最近的 n 条提交</span><br><span class="line">  --since, --after #仅显示指定时间之后的提交。</span><br><span class="line">  --until, --before #仅显示指定时间之前的提交。</span><br><span class="line">  --author #仅显示指定作者相关的提交。</span><br><span class="line">  --committer #仅显示指定提交者相关的提交。</span><br></pre></td></tr></table></figure><h3 id="使用图形化工具查阅提交历史"><a href="#使用图形化工具查阅提交历史" class="headerlink" title="使用图形化工具查阅提交历史"></a>使用图形化工具查阅提交历史</h3><p>随 Git 一同发布的 gitk 相当于 git log 命令的可视化版本。</p><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><p>任何已经提交到 Git 的都可以被恢复。你可能失去的数据，仅限于没有提交过的，对 Git 来说它们就像从未存在过一样。</p><h3 id="修改最后一次提交"><a href="#修改最后一次提交" class="headerlink" title="修改最后一次提交"></a>修改最后一次提交</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果我们提交后发现有个文件改错或没有加，将修改过的文件通过<span class="string">&quot;git add&quot;</span>后执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改上一次commit的提交信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m &lt;message&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend &lt;file1&gt; &lt;file2&gt; ...</span> </span><br></pre></td></tr></table></figure><p>也就是说，在执行<code>git commit</code>之后暂存区为空，此时若再次执行<code>git commit --amend</code>判断为修改上次的提交信息；此时若<code>git add</code>新文件到暂存区，执行此命令相当于添加到上次提交。</p><h3 id="取消已经暂存的文件"><a href="#取消已经暂存的文件" class="headerlink" title="取消已经暂存的文件"></a>取消已经暂存的文件</h3><p>（staged -&gt; modified）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset HEAD &lt;file&gt;</span></span><br></pre></td></tr></table></figure><p>文件从暂存区回到已修改未暂存状态。</p><h3 id="取消对文件的修改"><a href="#取消对文件的修改" class="headerlink" title="取消对文件的修改"></a>取消对文件的修改</h3><p>（modified -&gt; unmodified）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- &lt;file&gt;</span></span><br></pre></td></tr></table></figure><h3 id="文件操作总结"><a href="#文件操作总结" class="headerlink" title="文件操作总结"></a>文件操作总结</h3><p><img src="/images/Git/file-summary.png" alt="file-summary.png"></p><h1 id="Git远程仓库"><a href="#Git远程仓库" class="headerlink" title="Git远程仓库"></a>Git远程仓库</h1><p>Git 要求每个远程主机都必须指定一个主机名。</p><h2 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote</span></span><br></pre></td></tr></table></figure><p>查看每个远程库的简短名字。Git 默认使用“origin”这个名字来标识你所克隆的原始仓库。  </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br></pre></td></tr></table></figure><p>加上<kbd>-v</kbd>选项，显示对应的克隆地址。</p><h2 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add &lt;shortname&gt; &lt;url&gt;</span></span><br></pre></td></tr></table></figure><p><kbd>&lt;shortname></kbd>即自定义远程主机名<remote-name>，在<code>git remote</code>中显示，</p><h2 id="从远程仓库抓取数据"><a href="#从远程仓库抓取数据" class="headerlink" title="从远程仓库抓取数据"></a>从远程仓库抓取数据</h2><p><strong>git fetch</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch add &lt;remote-name&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch add &lt;remote-name&gt; &lt;branch-name&gt;  <span class="comment">#指定分支</span></span></span><br></pre></td></tr></table></figure><ul><li>抓取所有本地仓库没有的数据。但只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支。  </li><li>通常用来查看其他人的进程，因为它取回的代码对本地代码没有影响。  </li><li>指定分支所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。  </li><li>类似的，<code>git fetch origin</code>会抓取上次<code>clone</code>以来的别人提交的更新。  </li><li>如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。</li></ul><p><strong>git pull</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull &lt;remote-name&gt; &lt;remote-branch-name&gt;:&lt;local-branch-name&gt;</span></span><br></pre></td></tr></table></figure><ul><li>取回远程主机某个分支的更新，再与本地的指定分支合并。  </li><li>如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。  </li><li>如果是与当前分支合并，则冒号后面的部分可以省略。  </li><li>等同于先<code>git fetch</code>再<code>git merge</code>。  </li><li>如果远程主机删除了某个分支，默认情况下，<code>git pull</code> 不会在拉取远程分支的时删除对应的本地分支。这是为了防止由于其他人操作了远程主机，导致<code>git pull</code>不知不觉删除了本地分支。除非加上参数 <kbd>-p</kbd> 就会在本地删除远程已经删除的分支。</li></ul><h2 id="推送数据到远程仓库"><a href="#推送数据到远程仓库" class="headerlink" title="推送数据到远程仓库"></a>推送数据到远程仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;remote-name&gt; &lt;local-branch-name&gt;:&lt;remote-branch-name&gt;</span></span><br></pre></td></tr></table></figure><ul><li>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。  </li><li>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。<br>将本地仓库中的数据推送到远程仓库，只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。</li><li>如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</li><li>如果是新建分支第一次<code>git push</code>，会提示：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fatal: The current branch dev1 has no upstream branch.</span><br><span class="line">　　To push the current branch and set the remote as upstream, use</span><br><span class="line">　　git push --set-upstream origin dev1</span><br></pre></td></tr></table></figure><p>输入这行命令，然后输入用户名和密码就成功了，以后的push就只需要输入<code>git push origin</code>。</p><ul><li>如果当前分支只有一个追踪分支，那么主机名都可以省略。</li><li>如果当前分支与多个主机存在追踪关系，则可以使用<kbd>-u</kbd>选项指定一个默认主机，这样后面就可以不加任何参数使用<code>git push</code>。</li><li>如果不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用<kbd>--all</kbd>选项。</li><li>如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做<code>git pull</code>合并差异，然后再推送到远程主机。这时如果你一定要推送，可以使用<kbd>--force</kbd>选项。<br>结果导致远程主机上更新的版本被覆盖。</li></ul><h2 id="查看远程仓库信息"><a href="#查看远程仓库信息" class="headerlink" title="查看远程仓库信息"></a>查看远程仓库信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote show &lt;remote-name&gt;</span></span><br></pre></td></tr></table></figure><p>例如：  </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote show origin</span></span><br><span class="line">    * remote origin</span><br><span class="line">    URL: git@github.com:defunkt/github.git</span><br><span class="line">    Remote branch merged with &#x27;git pull&#x27; while on branch issues     # git pull 时将自动合并的分支</span><br><span class="line">    issues</span><br><span class="line">    Remote branch merged with &#x27;git pull&#x27; while on branch master     # git pull 时将自动合并的分支</span><br><span class="line">    master</span><br><span class="line">    New remote branches (next fetch will store in remotes/origin)   # 还没有同步到本地的远端分支</span><br><span class="line">    caching               </span><br><span class="line">    Stale tracking branches (use &#x27;git remote prune&#x27;)    #已同步到本地的远端分支在远端服务器上已被删除</span><br><span class="line">    libwalker</span><br><span class="line">    walker2</span><br><span class="line">    Tracked remote branches</span><br><span class="line">    acl</span><br><span class="line">    apiv2</span><br><span class="line">    dashboard2</span><br><span class="line">    issues</span><br><span class="line">    master</span><br><span class="line">    postgres</span><br><span class="line">    Local branch pushed with &#x27;git push&#x27;     # git push 缺省推送的分支</span><br><span class="line">    master:master         </span><br></pre></td></tr></table></figure><h2 id="远程仓库的删除和重命名"><a href="#远程仓库的删除和重命名" class="headerlink" title="远程仓库的删除和重命名"></a>远程仓库的删除和重命名</h2><h3 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote rename pb paul</span></span><br></pre></td></tr></table></figure><p>修改的是某个远程仓库在本地的简称，分支名也会发生变化。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote rm &lt;remote-name&gt;</span></span><br></pre></td></tr></table></figure><h1 id="版本标签"><a href="#版本标签" class="headerlink" title="版本标签"></a>版本标签</h1><h2 id="显示已有标签"><a href="#显示已有标签" class="headerlink" title="显示已有标签"></a>显示已有标签</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> $ git tag -l <span class="string">&#x27;&lt;tag-name&gt;&#x27;</span>    <span class="comment">#显示指定版本</span></span></span><br></pre></td></tr></table></figure><p>按照字母顺序排列。</p><h2 id="新建标签"><a href="#新建标签" class="headerlink" title="新建标签"></a>新建标签</h2><p>Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用；而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息。</p><p>建议一般使用含附注型的标签，临时性加注标签用轻量级标签。</p><h3 id="含附注的标签"><a href="#含附注的标签" class="headerlink" title="含附注的标签"></a>含附注的标签</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -a &lt;tag-name&gt; -m &lt;message&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show <span class="string">&#x27;&lt;tag-name&gt;&#x27;</span>    <span class="comment">#查看相应标签的版本信息</span></span></span><br></pre></td></tr></table></figure><p><kbd>-a</kbd>指定标签名，<kbd>-m</kbd>指定对应的标签说明，<code>git show</code>可以显示出。</p><h3 id="轻量级标签"><a href="#轻量级标签" class="headerlink" title="轻量级标签"></a>轻量级标签</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag &lt;tag-name&gt;</span></span><br></pre></td></tr></table></figure><p>没有选项。</p><h3 id="签署标签"><a href="#签署标签" class="headerlink" title="签署标签"></a>签署标签</h3><p>如果你有自己的私钥，还可以用 GPG 来签署标签，只需要把之前的 <kbd>-a</kbd> 改为 <kbd>-s</kbd> 即可。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -s &lt;tag-name&gt; -m &lt;message&gt;</span></span><br></pre></td></tr></table></figure><h3 id="验证标签"><a href="#验证标签" class="headerlink" title="验证标签"></a>验证标签</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -v &lt;tag-name&gt;</span></span><br></pre></td></tr></table></figure><p>验证已经签署的标签，会调用 GPG 来验证签名，所以需要有签署者的公钥，存放在 keyring 中，才能验证，否则报错<code>gpg: Can&#39;t check signature: public key not found</code>。</p><h2 id="后期加注标签"><a href="#后期加注标签" class="headerlink" title="后期加注标签"></a>后期加注标签</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -a &lt;tag-name&gt; &lt;SHA-1&gt;</span></span><br></pre></td></tr></table></figure><p>只要在打标签的时候跟上对应提交对象的校验和（或前几位字符）即可。<br>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v1.2 9fceb02</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show v1.2</span></span><br><span class="line">  version 1.2</span><br><span class="line">    commit 9fceb02d0ae598e95dc970b74767f19372d61af8</span><br><span class="line">    Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt;</span><br><span class="line">    Date: Sun Apr 27 20:43:35 2008 -0700</span><br><span class="line"></span><br><span class="line">    updated rakefile</span><br></pre></td></tr></table></figure><h2 id="分享标签"><a href="#分享标签" class="headerlink" title="分享标签"></a>分享标签</h2><p>默认情况下，<code>git push</code> 并不会把标签传送到远端服务器上</p><ul><li>使用<kbd>--tags</kbd>选项一次推送所有本地新增的标签上去</li><li>通过显式命令才能分享标签到远端仓库。  </li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin --tags</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin [tag-name]</span></span><br></pre></td></tr></table></figure><h1 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h1><p>使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。</p><h2 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h2><p>在 Git 中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针、作者等附属信息、零个或多个指向该提交对象的父对象指针。首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。</p><p>举例：对于三个文件暂存后，Git 嫁给你当前版本的快照（blob类型）连同每个文件的额SHA-1保存至仓库。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add README test.rb LICENSE</span></span><br><span class="line">    $ git commit -m &#x27;initial commit of my project&#x27;</span><br></pre></td></tr></table></figure><p>现在仓库中有五个对象：</p><ul><li>三个 blob 对象：表示文件快照内容</li><li>tree 对象：记录着目录树内容及其中各个文件对应的 blob 对象索引的</li><li>commit 对象：指向 tree 对象（根目录）的索引和其他提交信息元数据。在需要的时候重现此次快照。<br><img src="/images/Git/singleObj.png" alt="singleObj.png"></li></ul><p>作些修改后再次提交，那么这次的提交对象会包含一个指向上次提交对象的指针（parent 对象）。两次提交后：<br><img src="images/Git/multiObj.png" alt="multiObj.png"></p><p>Git 中的分支，其实本质上仅仅是个指向 commit 对象的可变指针。Git 会使用 <kbd>master</kbd> 作为分支的默认名字。在若干次提交后，你其实已经有了一个指向最后一次提交对象的 <kbd>master</kbd> 分支，它在每次提交的时候都会自动向前移动。<br><img src="images/Git/masterHistory.png" alt="masterHistory.png"></p><h2 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch &lt;branch-name&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>git branch testing</code>在当前 commit 对象上新建一个分支指针<kbd>testing</kbd>：<br><img src="images/Git/newBranch.png" alt="newBranch.png"></p><h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><p>HEAD 是一个指向你正在工作中的本地分支的指针，即当前分支。</p><p>运行 <code>git branch</code> 命令，仅仅是建立了一个新的分支，但不会自动切换到这个分支中去，所以依然还在 <kbd>master</kbd> 分支里工作：</p><p><img src="images/Git/headMaster.png" alt="headMaster.png"></p><h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout &lt;branch-name&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b &lt;branch-name&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>git checkout testing</code>切换分支<kbd>testing</kbd>：<br><img src="images/Git/checkout.png" alt="checkout.png"></p><p>或者运行 <code>git checkout</code> 并加上 <kbd>-b</kbd> 参数，新建并切换到该分支。</p><p>提交之后：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim test.rb</span></span><br><span class="line">    $ git commit -a -m &#x27;made a change&#x27;</span><br></pre></td></tr></table></figure><p><img src="images/Git/headTesting.png" alt="headTesting.png"><br>提交后 HEAD 随<kbd>testing</kbd>分支一起向前移动，，而 <kbd>master</kbd> 分支仍然指向原先 <code>git checkout</code> 时所在的 commit 对象。</p><p>如果此时执行<code>git checkout master</code>，切回<kbd>master</kbd>分支：</p><p><img src="images/Git/masterHistory.png" alt="masterHistory.png"><br>做了两件事：</p><ul><li>HEAD 指针移回到 <kbd>master</kbd> 分支</li><li>工作目录中的文件换成了 master 分支所指向的快照内容（较旧的进度）<br>它的主要作用是将 testing 分支里作出的修改暂时取消，这样你就可以向另一个方向进行开发。</li></ul><p>此时如果提交新文件，即：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim test.rb</span></span><br><span class="line">    $ git commit -a -m &#x27;made other changes&#x27;</span><br></pre></td></tr></table></figure><p><img src="images/Git/branchHistory.png" alt="branchHistory.png"></p><p><strong>Git 中的分支实际上仅是一个包含所指对象校验和（40 个字符长度 SHA-1 字串）的文件，Git 的实现与项目复杂度无关，并且每次提交都记录了 parent 对象，所以 Git 分支操作非常廉价。</strong></p><blockquote><p>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：<br>你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！<br>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：<br>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：<br>所以Git合并分支也很快！就改改指针，工作区内容也不变！<br>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支。</p></blockquote><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge iss53</span></span><br></pre></td></tr></table></figure><p>回到 <kbd>master</kbd> 分支，运行 <code>git merge</code> 命令指定要合并进来的分支<kbd>iss53</kbd></p><h2 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h2><p>如果在不同的分支中都修改了同一个文件的同一部分，Git 就无法干净地把两者合到一起（逻辑上说，这种问题只能由人来裁决）。结果如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge iss53</span></span><br><span class="line">    Auto-merging index.html</span><br><span class="line">    CONFLICT (content): Merge conflict in index.html</span><br><span class="line">    Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>Git 做了合并但没有提交，等待解决冲突。可以用 <code>git status</code> 查看合并时发生冲突的文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash"> unmerged: index.html</span></span><br></pre></td></tr></table></figure><p>任何包含未解决冲突的文件都会以未合并<strong>unmerged</strong>的状态列出。Git 会在有冲突的文件里加入标准的冲突解决标记：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line">    &lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class="line">    =======</span><br><span class="line">    &lt;div id=&quot;footer&quot;&gt;</span><br><span class="line">    please contact us at support@github.com</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></pre></td></tr></table></figure><p>可以看到 <kbd>=======</kbd> 隔开的上半部分，是 HEAD（当前分支）中的内容，下半部分是在 <kbd>iss53</kbd> 分支中的内容。</p><p>解决办法是删除上面的内容（包括’=’’&lt;’’&gt;’），自行决定怎么写。之后运行<code>git add</code>和<code>git status</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash"> modified: index.html</span></span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure><p>确认冲突已解决，标记为<strong>modified</strong>，再<code>git commit</code>提交。</p><p>也可以使用相关可视化工具解决冲突，运行<code>git mergetool</code>。</p><h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d &lt;branch-name&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">强制删除</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -D &lt;branch-name&gt;</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程分支，分支必须完全合并在其上游分支，或者在HEAD上没有设置上游</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete &lt;branch-name&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -dr &lt;remote-name/branch-name&gt;</span></span><br></pre></td></tr></table></figure><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><strong>工作流程</strong></p><ol><li>开发某个网站为</li><li>实现某个新的需求，创建一个分支。</li><li>在这个分支上开展工作。</li></ol><p>假设此时突然有个很严重的问题需要紧急修补，那么：</p><ol><li>返回到原先已经发布到生产服务器上的分支。</li><li>为这次紧急修补建立一个新分支，并在其中修复问题。</li><li>通过测试后，回到生产服务器所在的分支，将修补分支合并进来，然后再推送到生产服务器上。</li><li>切换到之前实现新需求的分支，继续工作。</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建iss53并切换</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b iss53</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 遇问题切回master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时工作区和之前 master 提交时完全一样</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建紧急修补分支 hotfix</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b <span class="string">&#x27;hotfix&#x27;</span></span></span><br></pre></td></tr></table></figure><p>Git 的好处：  </p><ul><li>不需要同时发布这个补丁和 iss53 里作出的修改</li><li>不需要在创建和发布该补丁到服务器之前花费大力气来复原这些修改</li></ul><p>切换分支时需要留心你的暂存区或者工作目录里<strong>还没有提交的修改</strong>，它会产生冲突从而阻止切换，最好保持一个清洁的工作区域（也可以通过 stashing 和 commit amending 绕过这种问题）。</p><p><img src="images/Git/hotfixSuccess.png" alt="hotfixSuccess.png.png"></p><p>修改、测试之后回到 <kbd>master</kbd> 分支并把 <kbd>hotfix</kbd> 合并：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge hotfix</span></span><br></pre></td></tr></table></figure><p>请注意，合并时出现了“Fast forward”的提示。由于当前 <kbd>master</kbd> 分支所在的提交对象是要并入的 <kbd>hotfix</kbd> 分支的直接上游，Git 只需把 <kbd>master</kbd> 分支指针直接右移。换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为<strong>快进</strong>（Fast forward）。</p><p><kbd>hotfix</kbd>分支完成历史使命之后可以删掉，回到正常的 iss53 正常工作：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d hotfix</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout iss53</span></span><br></pre></td></tr></table></figure><p><img src="images/Git/normalWork.png" alt="normalWork.png"></p><p>需求#53开发完之后，合并<kbd>master</kbd>和<kbd>iss53</kbd>分支：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge iss53</span></span><br></pre></td></tr></table></figure><p>这次合并操作的底层实现，并不同于之前 <kbd>hotfix</kbd> 的并入方式。因为这次你的开发历史是从更早的地方开始分叉的。由于当前 <kbd>master</kbd> 分支所指向的提交对象（C4）并不是 <kbd>iss53</kbd> 分支的直接祖先，Git 不得不进行一些额外处理。就此例而言，Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算：</p><p><img src="images/Git/merge3.png" alt="merge3.png"></p><p>这次，Git 没有简单地把分支指针右移，而是对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（C6）（见图 3-17）。这个提交对象比较特殊，它有两个祖先（C4 和 C5）。</p><p>值得一提的是 Git 可以自己裁决哪个共同祖先才是最佳合并基础；这和 CVS 或 Subversion（1.5 以后的版本）不同，它们需要开发者手工指定合并基础。所以此特性让 Git 的合并操作比其他系统都要简单不少。</p><p><img src="images/Git/mergeAutoCommit.png" alt="mergeAutoCommit.png"></p><p>此时<kbd>iss53</kbd>没用了，可以删除。</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p><strong>查看所有分支</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">    iss53</span><br><span class="line">    * master</span><br><span class="line">    testing</span><br></pre></td></tr></table></figure><p><code>git branch</code> 命令不加参数列出所有分支。 <kbd>master</kbd> 分支前的 <kbd>*</kbd> 字符表示当前所在的分支。也就是说如果现在提交更新，<kbd>master</kbd> 分支将随着开发进度前移。</p><p><strong>查看各分支最后一个 commit 对象的信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -v</span></span><br></pre></td></tr></table></figure><p><strong>查看与HEAD已合并/或未合并分支</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看已并入当前分支的==哪些分支是当前分支的直接上游</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --merged</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看尚未合并的</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --no-merged</span></span><br></pre></td></tr></table></figure><p>对于已合并的，可以用<code>git branch -d</code>直接删除，不会有损失。<br>对于已合并的，用<code>git branch -d</code>删除会报错，因为这样做会丢失数据，除非<kbd>-D</kbd>强制删除。</p><h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p>用<kbd>remote-name/remote-branch-name</kbd>描述远程分支，区别于本地分支。</p><p>在第一次<code>git clone</code>之后，下载的数据命名为<kbd>origin/master</kbd>，无法修改。之后 Git 创建属于本地的 <kbd>master</kbd> 分支，二者都指向远程<kbd>origin</kbd>的<kbd>master</kbd>分支。<br><img src="images/Git/remoteBranch1.png" alt="remoteBranch1.png"></p><p>如果在本地 <kbd>master</kbd> 分支做了些改动，在本地的提交历史正朝向不同方向发展，与此同时，其他人向 git.ourcompany.com 推送了他们的更新，服务器上的 <kbd>master</kbd> 分支就会向前推进。不过只要不和服务器通讯，本地的 <kbd>origin/master</kbd> 指针仍然保持原位不会移动。<br><img src="images/Git/remoteBranch2.png" alt="remoteBranch2.png"></p><p>可以运行 <code>git fetch origin</code> 来同步远程服务器上的数据到本地。从 origin 上获取尚未拥有的数据，更新你本地的数据库，然后把 <kbd>origin/master</kbd> 的指针移到最新位置。<br><img src="images/Git/remoteBranch3.png" alt="remoteBranch3.png"></p><p>假设，还有另一个仅供你的敏捷开发小组使用的内部服务器 git.team1.ourcompany.com。加为当前项目的远程分支之一，并命名为 teamone。</p><p>现在可以用 <code>git fetch teamone</code> 来获取小组服务器上你还没有的数据了。由于当前该服务器上的内容是你 <kbd>origin</kbd> 服务器上的子集，Git 不会下载任何数据，而只是简单地创建一个名为 <kbd>teamone/master</kbd> 的远程分支，指向 teamone 服务器上 <kbd>master</kbd> 分支所在的提交对象 <kbd>31b8e</kbd>。<br><img src="images/Git/remoteBranch4.png" alt="remoteBranch4.png"></p><p><kbd>master</kbd>并不是多么神秘复杂的东西，分清楚远程的别人的<kbd>origin/master</kbd>、本地的别人的<kbd>origin/master</kbd>、本地的自己的<kbd>master</kbd>就可以了。</p><h2 id="推送本地分支"><a href="#推送本地分支" class="headerlink" title="推送本地分支"></a>推送本地分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;remote-name&gt; &lt;branch-name&gt;</span></span><br></pre></td></tr></table></figure><p>要想和其他人分享某个本地分支，你需要把它推送到一个你拥有<strong>写权限</strong>的远程仓库。你创建的本地分支不会因为你的写入操作而被自动同步到你引入的远程服务器上，你需要明确地执行推送分支的操作。</p><p><code>git push origin serverfix:serverfix</code>意思是“上传我本地的 <kbd>serverfix</kbd> 分支到远程仓库中去，仍旧称它为 <kbd>serverfix</kbd> 分支”。通过此语法，你可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫作 <kbd>awesomebranch</kbd>，可以用 <code>git push origin serverfix:awesomebranch</code> 来推送数据。</p><h2 id="跟踪远程分支"><a href="#跟踪远程分支" class="headerlink" title="跟踪远程分支"></a>跟踪远程分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b &lt;branch-name&gt; &lt;remote-name/branch-name&gt;</span></span><br></pre></td></tr></table></figure><p>从远程分支 <code>checkout</code> 出来的本地分支，称为<strong>跟踪分支</strong> (tracking branch)。跟踪分支是一种和某个远程分支有直接联系的本地分支。在跟踪分支里输入 <code>git push</code>，Git 会自行推断应该向哪个服务器的哪个分支推送数据。</p><h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;remote-name&gt; :&lt;branch-name&gt;</span></span><br></pre></td></tr></table></figure><p>对于<code>git push &lt;remote-name&gt; &lt;local-branch-name&gt;:&lt;remote-branch-name&gt;</code> 语法，如果省略 <local-branch-name>，那就等于是在说“在这里提取空白然后把它变成<remote-branch-name>”。</p><h2 id="分支衍合"><a href="#分支衍合" class="headerlink" title="分支衍合"></a>分支衍合</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout &lt;rebase-branch-name&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rebase &lt;master-branch-name&gt;</span></span><br></pre></td></tr></table></figure><p>把一个分支中的修改整合到另一个分支有两种办法：<code>merge</code> 和 <code>rebase</code>。<br><strong>merge</strong><br><img src="images/Git/merge.png" alt="merge.png"></p><p><strong>rebase</strong><br>还有可以把在 C3 里产生的变化补丁在 C4 的基础上重新打一遍，这种操作叫做衍合（rebase）。即把在一个分支里提交的改变移到另一个分支里重放一遍。</p><p>原理是回到两个分支最近的共同祖先，根据当前分支（也就是要进行衍合的分支 <kbd>experiment</kbd>）后续的历次提交对象（这里只有一个 C3），生成一系列文件补丁，然后以基底分支（也就是主干分支 <kbd>master</kbd>）最后一个提交对象（C4）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（C3’），从而改写 <kbd>experiment</kbd> 的提交历史，使它成为 <kbd>master</kbd> 分支的直接下游：<br><img src="images/Git/rebase.png" alt="rebase.png"></p><p>再进行快进合并：<br><img src="images/Git/speedMerge.png" alt="speedMerge.png"></p><p>现在的 C3’ 对应的快照，其实和普通的三方合并，即 C5 对应的快照内容一模一样，结果没有任何区别，只不过提交历史不同。但衍合能产生一个更为整洁的提交历史，仿佛所有修改都是在一根线上先后进行的。</p><p>一般我们使用衍合的目的，是想要得到一个能在远程分支上干净应用的补丁。项目志愿开发者通过衍合提交，维护者就不需要做任何整合工作。实际上是把解决分支补丁同最新主干代码之间冲突的责任，化转为由提交补丁的人来解决。</p><p>衍合是按照每行的修改次序重演一遍修改，而合并是把最终结果合在一起。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://git-scm.com/docs">Git官方参考文档</a></li><li><a href="http://git.oschina.net/progit/">Pro Git（中文版）</a></li><li><a href="https://www.cnblogs.com/syp172654682/p/7689328.html">深入浅出Git教程</a></li><li><a href="https://www.cnblogs.com/yaozhongxiao/p/3811130.html">Git图解剖析</a></li><li><a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的官方网站</a></li><li><a href="https://www.runoob.com/git/">菜鸟教程</a></li><li><a href="https://www.cnblogs.com/kevingrace/p/5690241.html">Git忽略提交规则 - .gitignore配置运维总结</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Git是目前世界上最先进的分布式版本控制系统（没有之一）。&lt;/p&gt;</summary>
    
    
    
    <category term="Tool" scheme="https://memorykk.cn/categories/Tool/"/>
    
    
    <category term="Git" scheme="https://memorykk.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>记一次博客接入Gitalk出现403问题的解决过程</title>
    <link href="https://memorykk.cn/gitalk-403.html"/>
    <id>https://memorykk.cn/gitalk-403.html</id>
    <published>2021-02-14T01:44:16.000Z</published>
    <updated>2021-02-19T08:45:30.462Z</updated>
    
    <content type="html"><![CDATA[<p>小站的评论系统始终无法接入 Gitalk，提示 403 Error</p><span id="more"></span><hr><p><strong>目录</strong></p><ul><li><a href="#%E9%97%AE%E9%A2%98">问题</a></li><li><a href="#%E6%88%91%E7%9A%84%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B">我的解决过程</a></li><li><a href="#%E5%85%B6%E4%BB%96%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B">其他解决过程</a><ul><li><a href="#%E8%B5%B7%E5%9B%A0">起因</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E7%BB%8F%E9%AA%8C">经验</a></li></ul></li><li><a href="#%E9%83%A8%E7%BD%B2%E8%87%AA%E5%B7%B1%E7%9A%84CORSproxy">部署自己的 CORSproxy</a></li><li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li></ul><hr><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>最近博客接入 Gitalk 评论系统时，始终报错 403，不知所以，无奈转至 LeanCloud 的 valine comment，但 valine 的风格总让人感觉不够优雅 ╯︿╰。</p><p>报错界面：<img src="/images/gitalk-403/no-issue.PNG" class="" title="no-issue" alt="no-issue"></p><p>点击 <kbd>使用 GitHub 登录</kbd> 之后，显示 Error：<img src="/images/gitalk-403/403.PNG" class="" title="403" alt="403"></p><h1 id="我的解决过程"><a href="#我的解决过程" class="headerlink" title="我的解决过程"></a>我的解决过程</h1><ol><li><p>打开 <kbd>F12</kbd> 控制台，刷新页面，查看出错的 Header：<img src="/images/gitalk-403/f12.PNG" class="" title="f12" alt="f12"></p></li><li><p>触及到知识盲区了。这个 URL 尽管没见过，但两个地址套起来的形式很有特点，习惯性地打开前面的<a href="https://cors-anywhere.herokuapp.com/">链接</a>，展示如下：<img src="/images/gitalk-403/core.PNG" class="" title="core" alt="core"></p></li></ol><p>大意是：CORS Anywhere 这是个实现跨域请求的 Demo，单击按钮临时解锁对演示的访问。</p><p>So，我被加锁了？</p><ol start="3"><li>打开<a href="https://github.com/Rob--W/cors-anywhere/issues/301">提示的参考链接</a>，这个 CORS Anywhere 的作者说：</li></ol><blockquote><p>Public demo server (cors-anywhere.herokuapp.com) will be very limited by January 2021, 31st #301<br>The user (developer) must visit a page at cors-anywhere.herokuapp.com to temporarily unlock the demo for their browser. This allows developers to try out the functionality, to help with deciding on self-hosting or looking for alternatives.</p></blockquote><p>意思是 CORS Anywhere 这个 Demo 被滥用，从 2021/1/31 开始限制，用户必须访问<a href="cors-anywhere.herokuapp.com">页面</a><strong>临时</strong>解锁。</p><ol start="4"><li><p>虽然这只是个临时解决方案，但当时没想太多，能用就行。<img src="/images/gitalk-403/requestTemp.PNG" class="" title="requestTemp" alt="requestTemp"></p></li><li><p>Gitalk 也确实正常工作了。</p></li></ol><h1 id="其他解决过程"><a href="#其他解决过程" class="headerlink" title="其他解决过程"></a>其他解决过程</h1><p>在 GitHub 上寻找相关 Issues 时看见这位大神的解决过程，自愧不如，经原作者同意之后搬运过来，特别是解决思路让我很受启发。以下是原文：</p><hr><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>我的博客最近刚换上了 hexo 框架，于是评论功能就换成了 Gitalk。但最近发现登录功能不好用了，点击使用 GitHub 登录总是失败。</p><p>就点击这个按钮的时候，始终登录不上去：</p><p><img src="https://qiniu.cuiqingcai.com/n79m6.png" alt="image-20210212223917778"></p><p>于是我就想着手解决一下这个问题。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里就记录一下我在排查过程中碰到的一些坑和解决思路。</p><p>首先，登录失败的问题，第一时间应该去排查的就是网络请求，打开控制台，查看 Network 面板，出现类似的结果：</p><p><img src="https://qiniu.cuiqingcai.com/4d8sw.png" alt="image-20210212224407613"></p><p>网络请求直接 403 了，拿不到 token 了，于是就登录不上了。</p><p>观察下，这个链接 cors-anywhere 似乎是用来解决跨域限制的，后面还跟了一个 GitHub 的 Access Token 获取地址，那没跑了，前面这个就是一个反向代理，后面是真实的请求 URL。</p><p>OK，看着这个也没啥思路啊，然后接着怎么办？</p><p>那就接着去搜这个 cors-anywhere.herokuapp.com，因为 herokuapp 很眼熟嘛，就是一个公用的网址 Host 平台，类似于 AWS、Azure 之类的，那么前面这个可能包含某些信息。万一是开源的那就好办了。</p><p>接着搜，cors-anywhere，然后就搜到了这个：<a href="https://github.com/Rob--W/cors-anywhere">https://github.com/Rob–W/cors-anywhere</a></p><p>介绍如下：</p><blockquote><p><strong>CORS Anywhere</strong> is a NodeJS proxy which adds CORS headers to the proxied request.</p><p>The url to proxy is literally taken from the path, validated and proxied. The protocol part of the proxied URI is optional, and defaults to “http”. If port 443 is specified, the protocol defaults to “https”.</p><p>This package does not put any restrictions on the http methods or headers, except for cookies. Requesting <a href="http://www.w3.org/TR/cors/#user-credentials">user credentials</a> is disallowed. The app can be configured to require a header for proxying a request, for example to avoid a direct visit from the browser.</p></blockquote><p>真是一个开源框架，和我猜的一样，就是一个解决跨域问题而生的反向代理。</p><p>然后我就在它的 README 中看到了这个：</p><p><img src="https://qiniu.cuiqingcai.com/e9xla.png" alt="image-20210212224946845"></p><p>好家伙，这不就是我刚才用到的链接吗？</p><p>那肯定是这个玩意出了什么毛病。</p><p>咋看呢？这个果断就是找 Issue 了：</p><p><img src="https://qiniu.cuiqingcai.com/yyu6t.png" alt="image-20210212225114466"></p><p>一看，太明显了：</p><blockquote><p>PSA: Public demo server (cors-anywhere.herokuapp.com) will be very limited by January 2021, 31st</p></blockquote><p>意思就是从今年 1.31 开始这个网站的访问会受限，点进去看看：</p><blockquote><p>The demo server of CORS Anywhere (cors-anywhere.herokuapp.com) is meant to be a demo of this project. But abuse has become so common that the platform where the demo is hosted (Heroku) has asked me to shut down the server, despite efforts to counter the abuse (rate limits in <a href="https://github.com/Rob--W/cors-anywhere/issues/45">#45</a> and <a href="https://github.com/Rob--W/cors-anywhere/issues/164">#164</a>, and blocking other forms of requests). Downtime becomes increasingly frequent (e.g. recently <a href="https://github.com/Rob--W/cors-anywhere/issues/300">#300</a>, <a href="https://github.com/Rob--W/cors-anywhere/issues/299">#299</a>, <a href="https://github.com/Rob--W/cors-anywhere/issues/295">#295</a>, <a href="https://github.com/Rob--W/cors-anywhere/issues/294">#294</a>, <a href="https://github.com/Rob--W/cors-anywhere/issues/287">#287</a>) due to abuse and its popularity.</p><p>To counter this, I will make the following changes:</p><ol><li> The rate limit will decrease from 200 (<a href="https://github.com/Rob--W/cors-anywhere/issues/164">#164</a>) per hour to 50 per hour.</li><li> By January 31st, 2021, cors-anywhere.herokuapp.com will stop serving as an open proxy.</li><li> From February 1st. 2021, cors-anywhere.herokuapp.com will only serve requests after the visitor has completed a challenge: The user (developer) must visit a page at cors-anywhere.herokuapp.com to temporarily unlock the demo for their browser. This allows developers to try out the functionality, to help with deciding on self-hosting or looking for alternatives.</li></ol></blockquote><p>好吧，意思就是说这个网站本来是演示用的，但是现在已经被滥用了，然后从 1.31 开始用户手动必须手动先访问这个网站获取临时的访问权限，然后才能使用。另外推荐开发者自己来维护一个网站。</p><p>接着下面的评论第一个就更滑稽了：</p><p><img src="https://qiniu.cuiqingcai.com/7d55t.png" alt="image-20210212225414735"></p><p>这个人直接艾特了 gitalk，哈哈哈，因为 Gitalk 就如刚才所说的那样，也用了这个。</p><p>那就顺便去 Gitalk <a href="https://github.com/gitalk/gitalk%EF%BC%8C%E9%80%9B%E4%B8%80%E4%B8%8B">https://github.com/gitalk/gitalk，逛一下</a> issue，看看是不是也有人遇到了同样的问题，果不其然了：</p><p><img src="https://qiniu.cuiqingcai.com/s7bn5.png" alt="image-20210212225919986"></p><p>最近几个 issue 都是关于 403 的，真热闹。</p><p>点进去看看，有个大收获，里面有个好心人说：</p><blockquote><p>这次直接去嫖了一个 CORS proxy,把 gitalk.js 的 6794 行改为 proxy: ‘<a href="https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access_token">https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access_token</a>‘, 就可以了。具体能用多久我也没普，且用且珍惜。</p></blockquote><p>真是得来全不费功夫，本来还想着自己部署着，这次那就换了就行了。</p><p>然而，这样不行，得需要改 gitalk.js 的源码，并不太好吧。</p><p>好，这时候就遇到了一个问题，要修改某些开源软件的源码应该怎么办？</p><p>首选的思路当然不是硬改，改了之后还要自己 host 一个新的 js 文件，那显然是很费精力的。</p><p>其实一半程序在编写的时候应该是预留一些接口和配置的，我们应该能很轻易地通过某些配置就能实现某些配置的复写。</p><p>那就接着看看吧，既然要改，那就得先看看 Gitalk 是怎么用的吧。</p><p>看文档，Gitalk 调用方式如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">const gitalk = new Gitalk(&#123;  </span><br><span class="line"> clientID: &#x27;GitHub Application Client ID&#x27;,  </span><br><span class="line"> clientSecret: &#x27;GitHub Application Client Secret&#x27;,  </span><br><span class="line"> repo: &#x27;GitHub repo&#x27;, // The repository of store comments,  </span><br><span class="line"> owner: &#x27;GitHub repo owner&#x27;,  </span><br><span class="line"> admin: \[&#x27;GitHub repo owner and collaborators, only these guys can initialize github issues&#x27;\],  </span><br><span class="line"> id: location.pathname, // Ensure uniqueness and length less than 50  </span><br><span class="line"> distractionFreeMode: false // Facebook-like distraction free mode  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gitalk.render(&#x27;gitalk-container&#x27;)</span><br></pre></td></tr></table></figure><p>看来这个在声明的时候是有参数的，那刚才 URL 配置没看到在哪里配啊，既然如此，那就看看 Gitalk 这个对象支持多少参数吧。</p><p>接着就去找 Gitalk 的构造参数说明，找到这么一个：</p><ul><li>proxy：<code>String</code></li></ul><p>Default: <code>https://cors-anywhere.herokuapp.com/https://github.com/login/oauth/access_token</code>.</p><p>果然找到了，所以这里如果我们要修改，那就改 proxy 参数就行了，初始化 Gitalk 的时候复写掉 proxy 就行。</p><p>OK，基本思路有了，那我怎么改到我的源码里呢？</p><p>我的博客是基于 Hexo 的 Next 主题的，根据经验，Gitalk 是 Next 主题自带的，所以 Gitalk 的声明应该就在 Next 主题源码里面。</p><p>那怎么找呢？</p><p>这时候就需要借助于一些搜索技巧了，搜什么？既然要用 Gitalk，那一定有刚才初始化的调用，那就搜 Gitalk 这个关键字就行了。另外还需要缩小一下搜索范围。</p><p>于是我就把范围限定到了 next 主题目录，搜索 Gitalk。</p><p><img src="https://qiniu.cuiqingcai.com/ey8tq.png" alt="image-20210212230931998"></p><p>简直不要太舒服，一搜就有了，文件是 themes/next/layout/_third-party/comments/gitalk.swig。</p><p>这里我们只需要把 proxy 参数加上不就行了，值是什么呢？仿照写就行了，配置风格保持统一，那就加一条：</p><p>1</p><p>proxy : ‘‘,</p><p>OK，那这个配置的值很明显是主题配置文件，那就把配置文件里面加上 proxy 这个参数就好了。</p><p>找到 themes/next/_config.yml，添加行：</p><p>1</p><p>proxy: <a href="https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access/_token">https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access\_token</a></p><p>结果如下：</p><p><img src="https://qiniu.cuiqingcai.com/nnb1f.png" alt="image-20210212231224403"></p><p>好了，大功告成！</p><p>重新部署 Hexo，现在评论又能重新使用了，问题就解决了！</p><p>测试地址：<a href="https://cuiqingcai.com/message/%EF%BC%8C%E5%A4%A7%E5%AE%B6%E6%9D%A5%E7%BB%99%E6%88%91%E7%95%99%E8%A8%80%E5%90%A7%EF%BD%9E">https://cuiqingcai.com/message/，大家来给我留言吧～</a></p><p>好了，这就是我排查问题的整个过程，做一下记录。</p><h2 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h2><p>另外，其实这篇文章的用意不仅仅是单纯解决这个问题，因为这个问题大家可能并没有遇到过，因此这个解决方案仅仅是给极少数遇到这个问题的朋友提供的。</p><p>但是，这并不代表这篇文章没有价值，因为其中有的思路是通用的，在这里稍微做一下总结，希望对大家有帮助：</p><ul><li>当遇到网页功能异常的时候，排查问题就主要看两个——控制台、网络请求，这里面往往能找到主要问题。</li><li>结合一些基本知识进行合理的推断，比如刚才我就推断了 cors- anywhere 的作用并结合 herokuapp 推断这个可能还会是个公用的服务。</li><li>当碰到没有思路或者不确定的时候，去谷歌它！不要百度，另外还可以在 GitHub 或者 Gitee 上搜。</li><li>如果找到对应的 GitHub 仓库，Issue 区往往能找到一些有效答案，比如刚才我就在 Issue 区找到了一个可替代的 cors 网站。</li><li>修改代码功能的时候要想着尽量复写，也就是 overwrite，而不是直接改，前者更具有灵活性，而且某些情况下会省去一些麻烦。</li><li>复写的时候去找一些参数配置，比如找一些初始化参数、默认参数配置，看看能否实现改写的需求。</li><li>找不到入口的时候善用全局搜索功能，比如刚才 Gitalk 找哪里调用的时候，就直接全局搜索。</li><li>根据功能限制某些搜索范围，比如刚才我就知道 Gitalk 这个功能是 Next 主题提供的，所以我就直接限制搜索范围是 Next 主题的源码。</li><li>以上步骤多尝试，熟能生巧。</li></ul><hr><h1 id="部署自己的-CORSproxy"><a href="#部署自己的-CORSproxy" class="headerlink" title="部署自己的 CORSproxy"></a>部署自己的 CORSproxy</h1><p>就在我以为一切都要结束的时候，我看到了这个评论，兴趣来了！</p><img src="/images/gitalk-403/baipiao.PNG" class="" title="baipiao" alt="baipiao"><p>参考步骤：</p><ol><li><a href="https://dash.cloudflare.com/">注册 CloudFlare 账号</a></li><li><a href="https://workers.cloudflare.com/">building Worker</a></li><li><a href="https://github.com/Zibri/cloudflare-cors-anywhere">上传代码</a></li></ol><p>然而我卡在了第一步，DNS 设置 CF 的名称服务器一直验证不通过。。。</p><img src="/images/gitalk-403/cfCheck.PNG" class="" width="50" height="50" title="cfCheck" alt="cfCheck"><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://cuiqingcai.com/30010.html">Gitalk 评论登录 403 问题解决</a> 精觅-崔庆才的个人站点.</li><li><a href="https://github.com/Rob--W/cors-anywhere/issues/301">PSA: Public demo server (cors-anywhere.herokuapp.com) will be very limited by January 2021, 31st #301</a></li><li><a href="https://github.com/gitalk/gitalk/issues/428">使用 Github 登录后，提示 403 错误 #428</a></li><li><a href="https://github.com/Zibri/cloudflare-cors-anywhere">cloudflare-cors-anywhere</a></li><li><a href="https://blog.csdn.net/u012424449/article/details/103068412">一分钟教程：利用 cloudflare worker 搭建在线代理—-jsproxy</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;小站的评论系统始终无法接入 Gitalk，提示 403 Error&lt;/p&gt;</summary>
    
    
    
    <category term="Log" scheme="https://memorykk.cn/categories/Log/"/>
    
    
    <category term="Gitalk" scheme="https://memorykk.cn/tags/Gitalk/"/>
    
  </entry>
  
  <entry>
    <title>Hexo中Markdown语法失效问题</title>
    <link href="https://memorykk.cn/Hexo-Markdown-nonsupport.html"/>
    <id>https://memorykk.cn/Hexo-Markdown-nonsupport.html</id>
    <published>2021-02-13T06:20:06.000Z</published>
    <updated>2021-02-19T06:11:39.188Z</updated>
    
    <content type="html"><![CDATA[<p>在Hexo站上用Markdown写博时发现好多语法失效问题，记录一下</p><span id="more"></span><hr><p><strong>目录</strong></p><ul><li><a href="#1-%E8%A1%A8%E6%A0%BC%E7%9B%B4%E6%8E%A5%E4%BB%A5%E6%BA%90%E7%A0%81%E6%98%BE%E7%A4%BA%E6%97%A0%E6%B8%B2%E6%9F%93">1.表格直接以源码显示无渲染</a></li><li><a href="#2-lt-kbd-gt-%E6%97%A0%E6%A0%B7%E5%BC%8F">2.&lt;kbd&gt;无样式</a></li><li><a href="#3-%E6%8F%92%E5%85%A5-lt-table-gt-%E4%B8%8D%E6%B8%B2%E6%9F%93">3.插入&lt;table&gt;不渲染</a></li><li><a href="#4-%E6%8F%92%E5%85%A5HTML%E6%A0%87%E7%AD%BE%E4%BA%A7%E7%94%9F%E5%A4%A7%E9%87%8F%E6%8D%A2%E8%A1%8C">4.插入HTML标签产生大量换行</a></li><li><a href="#5-%E7%9B%AE%E5%BD%95%E8%B7%B3%E8%BD%AC%E6%97%A0%E5%8F%8D%E5%BA%94">5.目录跳转无反应</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul><hr><h2 id="1-表格直接以源码显示无渲染"><a href="#1-表格直接以源码显示无渲染" class="headerlink" title="1.表格直接以源码显示无渲染"></a>1.表格直接以源码显示无渲染</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>| 左对齐 | 右对齐 | 居中对齐 |<br>| :—-| —-: | :——: |<br>| 单元格aaaaaaaaaa | 单aaaaaaaaaaaaaa元格 | 单元aaaaaaaaaaa格 |<br>| 单元格 | 单元格 | 单元格 |<br>| 单 | 单 | 单 |  </p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul><li>表格和正文之间空两行。  </li><li>Markdown中生成的表格十分简洁，这倒也符合快速的特点，如果想自定义样式，通过嵌入css实现，例如本例。  </li><li>我使用的Hacker主题，通用样式文件存放在themes\Hacker\source\css\base\normalize.css，对这种通用性的追加即可，其他主题同理。</li></ul><table><thead><tr><th align="left">居中对齐</th><th align="right">对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单</td><td align="right">单</td><td align="center">单</td></tr></tbody></table><h3 id="待解决"><a href="#待解决" class="headerlink" title="待解决"></a>待解决</h3><p>  表格正常显示之后，对齐方式却不生效，网上没找到和我一样问题的，不过这个需求也不大，或许只能通过css解决。</p><h2 id="2-lt-kbd-gt-无样式"><a href="#2-lt-kbd-gt-无样式" class="headerlink" title="2.&lt;kbd&gt;无样式"></a>2.&lt;kbd&gt;无样式</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>比如这个kbd标签，Ctrl ，看起来很不明显有没有，大概率本来就这样，但是我一开始希望它是这样：<block style="display:inline-block;"><img src="/images/Hexo-Markdown-nonsupport/ctrl.PNG" class="" width="50" height="50" title="ctrl" alt="ctrl"></block></p><blockquote><p>提示: &lt;kbd&gt; 标签已废弃，不推荐使用，但是可以通过CSS实现丰富的效果。<br>——<a href="https://www.runoob.com/tags/tag-kbd.html">HTML&lt;kbd&gt;标签</a></p></blockquote><h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><p>因为我感觉这个会很常用，但我给它加了css样式，还不错。<kbd>Ctrl</kbd></p><h2 id="3-插入-lt-table-gt-不渲染"><a href="#3-插入-lt-table-gt-不渲染" class="headerlink" title="3.插入&lt;table&gt;不渲染"></a>3.插入&lt;table&gt;不渲染</h2><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>我在HTML里面测试好table，再将整个&lt;table&gt;&lt;/table&gt;粘贴到VSC的md文件中，但是这时HTML标签不渲染，直接以源码显示。</p><h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><ul><li>先在md中手写&lt;table&gt;&lt;/table&gt;这两个标签，再将table里面的内容粘过去，不要开始和结束标签。</li><li>或者可能是HTML代码中有空行！</li></ul><h2 id="4-插入HTML标签产生大量换行"><a href="#4-插入HTML标签产生大量换行" class="headerlink" title="4.插入HTML标签产生大量换行"></a>4.插入HTML标签产生大量换行</h2><h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><p>插入HTML标签产生大量换行</p><h3 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h3><p>将HTML标签之间的空格删除，也就是写到一行中。</p><h2 id="5-目录跳转无反应"><a href="#5-目录跳转无反应" class="headerlink" title="5.目录跳转无反应"></a>5.目录跳转无反应</h2><h3 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h3><p>因为本主题（或是别的问题）不会生成文章目录结构，所以我一般写完后用MarkdownAllinOne生成目录，但是点击无反应，不跳转。</p><h3 id="解决-4"><a href="#解决-4" class="headerlink" title="解决"></a>解决</h3><ul><li><p>首先标题里不能有符号<br>如果标题为”&amp;总结”，但MarkdownAllinOne生成目录自动链接到”#总结”，Hexo渲染出的HTML源码却是：</p><p><code>&lt;h2 id=&quot;amp-总结&quot;&gt;&lt;a href=&quot;#amp-总结&quot; class=&quot;headerlink&quot; title=&quot;&amp;amp;总结&quot;&gt;&lt;/a&gt;&amp;amp;总结&lt;/h2&gt;</code></p><p>这样看来，”#amp-总结”才是正确跳转。</p></li><li><p>若大小写原因，关闭MarkdownAllinOne扩展的自动转换小写选项<br>去<kbd>扩展设置</kbd>里关闭。  </p><p><img src="/images/Hexo-Markdown-nonsupport/mdPlugin1.PNG" alt="mdPlugin2.PNG"></p><p><em><strong>（！这不是必须的，只是为了方便，顺便关闭自动更新目录）</strong></em></p><p><img src="/images/Hexo-Markdown-nonsupport/mdPlugin2.PNG" alt="mdPlugin1.PNG"></p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关键还得搞清楚Hexo生成的是静态页面这个大方向，然后根据自己想法发挥。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Hexo站上用Markdown写博时发现好多语法失效问题，记录一下&lt;/p&gt;</summary>
    
    
    
    <category term="Log" scheme="https://memorykk.cn/categories/Log/"/>
    
    
    <category term="Hexo" scheme="https://memorykk.cn/tags/Hexo/"/>
    
    <category term="Markdown" scheme="https://memorykk.cn/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Markdown</title>
    <link href="https://memorykk.cn/Markdown.html"/>
    <id>https://memorykk.cn/Markdown.html</id>
    <published>2021-02-13T02:52:04.000Z</published>
    <updated>2021-02-13T11:47:47.155Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown是一种轻量级标记语言，以纯文本格式快速编写文档。</p><span id="more"></span><ul><li>Markdown编写的文档后缀为 .md、.markdown，可以导出HTML、Word、图像、PDF、Epub等多种格式的文档。  </li><li>Hexo、github等支持使用markdown编辑器编写文章，刚好边学边练。</li><li>可以通过css的方式，美化Hexo元素，嵌入style 标签，在生成html时，style标签也随之写入到html页面中，产生自定义效果。</li></ul><hr><p><strong>目录</strong></p><ul><li><a href="#markdown%E8%AF%AD%E6%B3%95">Markdown语法</a><ul><li><a href="#%E6%A0%87%E9%A2%98">标题</a></li><li><a href="#%E5%AD%97%E4%BD%93">字体</a></li><li><a href="#%E6%8D%A2%E8%A1%8C">换行</a></li><li><a href="#%E5%88%86%E9%9A%94%E7%BA%BF">分隔线</a></li><li><a href="#%E8%84%9A%E6%B3%A8">脚注</a></li><li><a href="#%E5%88%97%E8%A1%A8">列表</a></li><li><a href="#%E5%8C%BA%E5%9D%97">区块</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li><li><a href="#%E9%93%BE%E6%8E%A5">链接</a></li><li><a href="#%E5%9B%BE%E7%89%87">图片</a></li><li><a href="#%E8%A1%A8%E6%A0%BC">表格</a></li><li><a href="#%E6%94%AF%E6%8C%81%E7%9A%84html%E5%85%83%E7%B4%A0">支持的HTML元素</a></li><li><a href="#%E8%BD%AC%E4%B9%89">转义</a></li><li><a href="#%E5%85%AC%E5%BC%8F">公式</a></li><li><a href="#%E7%94%BB%E5%9B%BE">画图</a></li></ul></li><li><a href="#markdown%E5%B7%A5%E5%85%B7">Markdown工具</a></li><li><a href="#%E6%8E%A8%E8%8D%90">推荐</a></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><hr><h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用<kbd>#</kbd>标记标题，1-6个<kbd>#</kbd>标识1-6级标题。<br><em>（markdown语法中的关键字之后一般要加一个空格）</em><br>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><ul><li>斜体<br>使用一个<kbd>*</kbd>包起来</li><li>加粗<br>使用两个<kbd>*</kbd>包起来</li><li>斜体加粗<br>使用三个<kbd>*</kbd>包起来</li><li>删除线<br>使用两个<kbd>~</kbd>包起来</li><li>下划线<br>使用HTML的<kbd>&lt;u>&lt;/u></kbd>包起来</li></ul><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*这是倾斜的文字*</span></span><br><span class="line"><span class="strong">**这是加粗的文字**</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*这是斜体加粗的文字<span class="strong">**<span class="emphasis">*</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">~~这是加删除线的文字~~</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>这是加下划线的文字<span class="xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span></span></span></span></span><br></pre></td></tr></table></figure><p>效果如下：<br><em>这是倾斜的文字</em><br><strong>这是加粗的文字</strong><br><em><strong>这是斜体加粗的文字</strong></em><br><del>这是加删除线的文字</del><br><u>这是加下划线的文字</u></p><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>markdown源文件中的回车不会换行，必须使用<kbd>两个空格+回车</kbd>或者<kbd>两个回车</kbd>。</p><p>示例 <em>（注意第一段之后的空格）</em>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一段  </span><br><span class="line">第二段</span><br><span class="line"></span><br><span class="line">第三段</span><br></pre></td></tr></table></figure><p>效果如下：</p><p>第一段<br>第二段</p><p>第三段</p><h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p>在一行中用三个以上的<kbd>*</kbd>、<kbd>-</kbd>、<kbd>_</kbd>来建分隔线，显示效果一致，行内不能有其他东西，但可以在行内插入空格。</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="strong"><span class="emphasis">---</span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong">__<span class="emphasis">_</span></span></span></span></span><br></pre></td></tr></table></figure><p>效果如下：</p><hr><hr><hr><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a><del>脚注</del></h2><p><strong>！貌似无法使用</strong><br>脚注是对文本的补充说明，鼠标悬停即可查看，使用<kbd>[^要注明的文本]</kbd>，在之后任意位置重复<kbd>[^要注明的文本]:补充内容</kbd>。</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Welcome To [^Memorykk&#x27;s Blog]</span><br><span class="line">[<span class="symbol">^Memorykk&#x27;s Blog</span>]: <span class="link">https://memorykk.cn</span></span><br></pre></td></tr></table></figure><p>效果如下：<br>Welcome To [^ Memorykk ]<br>[^ Memorykk ]: <a href="https://memorykk.cn/">https://memorykk.cn</a><br>参考：<img src="https://www.runoob.com/wp-content/uploads/2019/03/md5.gif" alt="参考示例"></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表使用<kbd>*</kbd>、<kbd>+</kbd>、<kbd>-</kbd>标记，追加列表内容，三者无差异。</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> 第一项</span><br><span class="line"><span class="bullet">+</span> 第二项</span><br><span class="line"><span class="bullet">-</span> 第三项</span><br></pre></td></tr></table></figure><p>效果如下：  </p><ul><li>第一项</li></ul><ul><li>第二项</li></ul><ul><li>第三项</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表使用数字+<kbd>.</kbd>标记。</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一项</span><br><span class="line"><span class="bullet">2.</span> 第二项</span><br></pre></td></tr></table></figure><p>效果如下：  </p><ol><li>第一项</li><li>第二项</li></ol><h3 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h3><p>子列表的选项前加四个空格即可。</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一项</span><br><span class="line"><span class="bullet">    *</span> 元素1</span><br><span class="line"><span class="bullet">    *</span> 元素2</span><br><span class="line"><span class="bullet">2.</span> 第二项</span><br><span class="line"><span class="bullet">    -</span> 元素3</span><br><span class="line"><span class="bullet">    -</span> 元素4</span><br></pre></td></tr></table></figure><p>效果如下：  </p><blockquote><ol><li>第一项<ul><li>元素1</li><li>元素2</li></ul></li><li>第二项<ul><li>元素3</li><li>元素4</li></ul></li></ol></blockquote><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>区块使用<kbd>></kbd>标记，追加区块内容。<br>区块支持嵌套，一个<kbd>></kbd>为最外层，两个<kbd>></kbd>为第一层嵌套，以此类推。<br>另外，区块可与列表等随意嵌套。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 1. 第一项</span></span><br><span class="line"><span class="quote">&gt;     <span class="emphasis">* 元素1</span></span></span><br><span class="line"><span class="quote"><span class="emphasis">&gt;     *</span> 元素2</span></span><br><span class="line"><span class="bullet">2.</span> 第二项</span><br><span class="line"><span class="code">    &gt; - 元素3</span></span><br><span class="line"><span class="code">    &gt; - 元素4</span></span><br></pre></td></tr></table></figure><p>效果如下：  </p><blockquote><ol><li>第一项<ul><li>元素1</li><li>元素2</li></ul></li><li>第二项<ul><li>元素3</li><li>元素4</li></ul></li></ol></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="单行代码"><a href="#单行代码" class="headerlink" title="单行代码"></a>单行代码</h3><p>使用一个<kbd>`</kbd>将代码包起来。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">`System.out.println(&quot;Hello World!&quot;);`</span></span><br></pre></td></tr></table></figure><p>效果如下：<br><code>System.out.println(&quot;Hello World!&quot;);</code></p><h3 id="多行代码"><a href="#多行代码" class="headerlink" title="多行代码"></a>多行代码</h3><p>使用六个<kbd>`</kbd>将代码包起来，前三个<kbd>`</kbd>接代码语言，也可不指定。</p><p>示例：<em>（为了防止编辑器转义，在前后加了前后括号，实际使用中不能写哦~）</em></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">（<span class="code">```java</span></span><br><span class="line"><span class="code">System.out.println(&quot;Hello&quot;);</span></span><br><span class="line"><span class="code">System.out.println(&quot;World&quot;);</span></span><br><span class="line"><span class="code">System.out.println(&quot;!&quot;);</span></span><br><span class="line"><span class="code">```）</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;!&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="普通链接"><a href="#普通链接" class="headerlink" title="普通链接"></a>普通链接</h3><p>使用<kbd>[链接名称]</kbd><kbd>(链接地址)</kbd>或者直接<kbd><链接地址></kbd>标记。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">Memorykk&#x27;s Blog</span>](<span class="link">https://memorykk.cn</span>)  </span><br><span class="line"><span class="xml">&lt;https://www.memorykkk.cn&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：<br><a href="https://memorykk.cn/">Memorykk’s Blog</a><br><a href="https://www.memorykkk.cn/">https://www.memorykkk.cn</a></p><h3 id="高级链接"><a href="#高级链接" class="headerlink" title="高级链接"></a>高级链接</h3><p>通过变量来设置一个链接，变量赋值在文档末尾。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这个链接赋给变量1：[<span class="string">Memorykk&#x27;s Blog</span>][<span class="symbol">1</span>]</span><br><span class="line">这个链接赋给变量google：[<span class="string">GOOGLE</span>][<span class="symbol">google</span>]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">1</span>]: <span class="link">https://memorykk.cn</span></span><br><span class="line">[<span class="symbol">google</span>]: <span class="link">https://www.google.com</span></span><br></pre></td></tr></table></figure><p>效果如下：<br>这个链接赋给变量1：<a href="https://memorykk.cn/">Memorykk’s Blog</a><br>这个链接赋给变量google：<a href="https://www.google.com/">GOOGLE</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>使用<kbd>![alt文本]</kbd><kbd>(图片链接 "可选标题")</kbd>标记。<br>markdown不支持指定宽高，可使用HTML &lt;img&gt;标签标记。<br>可以制作图片链接</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">Github.ico</span>](<span class="link">https://github.githubassets.com/favicons/favicon.svg</span>)</span><br></pre></td></tr></table></figure><p>效果如下：<br><img src="https://github.githubassets.com/favicons/favicon.svg" alt="Github.ico"></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>使用<kbd>|</kbd>标记单元格，使用<kbd>-</kbd>分隔表头和其他行，还可设置对其方式：</p><ul><li><kbd>-:</kbd>设置内容和标题栏居右对齐。</li><li><kbd>:-</kbd>设置内容和标题栏居左对齐。</li><li><kbd>:-:</kbd>设置内容和标题栏居中对齐。  </li></ul><hr><ul><li>:之间多余的空格会被忽略</li><li>的数量至少一个</li><li>内容和|之间多余的空格会被忽略</li></ul><p>示例：<em>（但是本页并未生效，Hexo的问题？）</em></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :------| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单 | 单 | 单 |</span><br></pre></td></tr></table></figure><p>效果如下：  </p><p><img src="/images/Markdown/table.PNG" alt="table.PNG"></p><h2 id="支持的HTML元素"><a href="#支持的HTML元素" class="headerlink" title="支持的HTML元素"></a>支持的HTML元素</h2><p>直接在文档里面用 HTML 撰写。<br>目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等。</p><h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符反斜杠<kbd>\</kbd>。<br>目前支持的特殊字符：<br><kbd>\</kbd>、<kbd>`</kbd>、<kbd>*</kbd>、<kbd>_</kbd>、<kbd>{}</kbd>、<kbd>[]</kbd>、<kbd>()</kbd>、<kbd>#</kbd>、<kbd>+</kbd>、<kbd>-</kbd>、<kbd>.</kbd>、<kbd>!</kbd>、<kbd>HTML元素</kbd>。</p><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>使用两个<kbd>$</kbd>包裹 TeX 或 LaTeX 格式的数学公式。<br>提交后会根据需要加载 Mathjax 对数学公式进行渲染。</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\lim<span class="emphasis">_&#123;x \to 0&#125; \frac&#123;3x^2 +7x^3&#125;&#123;x^2 +5x^4&#125; = 3</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><p>效果如下：<br>$$<br>\lim_{x \to 0} \frac{3x^2 +7x^3}{x^2 +5x^4} = 3<br>$$</p><h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><p>参考 <a href="https://www.runoob.com/markdown/md-advance.html">菜鸟教程</a></p><h1 id="Markdown工具"><a href="#Markdown工具" class="headerlink" title="Markdown工具"></a>Markdown工具</h1><p>目前我使用的是Visual Studio Code，默认支持markdown编辑以及即时预览，配合插件十分好用：  </p><ul><li><a href="https://marketplace.visualstudio.com/items?itemName=bierner.markdown-preview-github-styles">Markdown Preview Github Styling</a>：预览您的Markdown在Github上呈现的样子</li><li><a href="https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one">Markdown All in One</a>Markdown所需的全部功能（键盘快捷键、目录、自动预览等）</li></ul><h1 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h1><p>  <a href="Hexo-Markdown-nonsupport.html">Hexo中Markdown语法失效问题</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.runoob.com/markdown">Markdown教程</a></li><li><a href="https://www.jianshu.com/p/191d1e21f7ed">Markdown基本语法</a></li><li><a href="https://javahikers.github.io/2019/05/04/markdown-simple-to-use/">markdown简明使用方法</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Markdown是一种轻量级标记语言，以纯文本格式快速编写文档。&lt;/p&gt;</summary>
    
    
    
    <category term="Tool" scheme="https://memorykk.cn/categories/Tool/"/>
    
    
    <category term="Markdown" scheme="https://memorykk.cn/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://memorykk.cn/hello-world.html"/>
    <id>https://memorykk.cn/hello-world.html</id>
    <published>2021-02-11T15:59:59.000Z</published>
    <updated>2021-02-12T12:09:08.216Z</updated>
    
    <content type="html"><![CDATA[<p>照例写个HelloWorld占好位置。</p><span id="more"></span><p>这里是正文。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;照例写个HelloWorld占好位置。&lt;/p&gt;</summary>
    
    
    
    <category term="Fragment" scheme="https://memorykk.cn/categories/Fragment/"/>
    
    
    <category term="Hexo" scheme="https://memorykk.cn/tags/Hexo/"/>
    
  </entry>
  
</feed>
