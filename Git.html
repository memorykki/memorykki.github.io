<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Git | Memorykk | never too late to learn</title>

  
  <meta name="author" content="Memorykk">
  

  
  <meta name="description" content="computer,program,developer,java,linux">
  

  
  <meta name="keywords" content="computer,study,log,tool,fragment,program,developer,java,linux">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="Git"/>

  <meta property="og:site_name" content="Memorykk"/>

  
  <meta property="og:image" content="/images/favicon.ico"/>
  

  <link href="/images/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Memorykk" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <meta name="baidu-site-verification" content="code-DBwLDCJwuQ" />
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Memorykk</a>
    </h1>
    <p class="site-description">never too late to learn</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/about">关于</a></li>
      
        <li><a href="/atom.xml">订阅</a></li>
      
    </ul>
  </nav>
</header>

    <main  class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>Git</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/Git.html" rel="bookmark">
        <time class="entry-date published" datetime="2021-02-15T02:49:13.000Z">
          2021-02-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>Git是目前世界上最先进的分布式版本控制系统（没有之一）。</p>
<span id="more"></span>
<hr>
<p><strong>目录</strong></p>
<ul>
<li><a href="#%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6">版本控制</a></li>
<li><a href="#%E5%AE%89%E8%A3%85git">安装Git</a><ul>
<li><a href="#linux">Linux</a></li>
<li><a href="#linux-1">Linux</a><ul>
<li><a href="#debianubuntu">Debian/Ubuntu</a></li>
<li><a href="#centosredhat">Centos/RedHat</a></li>
</ul>
</li>
<li><a href="#windows">Windows</a></li>
</ul>
</li>
<li><a href="#%E9%85%8D%E7%BD%AEgit">配置Git</a><ul>
<li><a href="#%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8Cemail">配置用户名和Email</a></li>
<li><a href="#%E5%A2%9E%E5%88%A0%E9%85%8D%E7%BD%AE%E9%A1%B9">增删配置项</a><ul>
<li><a href="#%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE%E9%A1%B9">添加配置项</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E9%85%8D%E7%BD%AE%E9%A1%B9">删除配置项</a></li>
</ul>
</li>
<li><a href="#%E6%9B%B4%E5%A4%9A%E9%85%8D%E7%BD%AE%E9%A1%B9">更多配置项</a></li>
</ul>
</li>
<li><a href="#git%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">Git基本概念</a></li>
<li><a href="#git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">Git工作流程</a></li>
<li><a href="#git%E6%93%8D%E4%BD%9C">Git操作</a><ul>
<li><a href="#git%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93">Git创建版本库</a><ul>
<li><a href="#%E5%9C%A8%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%96">在工作目录中初始化</a></li>
<li><a href="#%E4%BB%8E%E7%8E%B0%E6%9C%89%E4%BB%93%E5%BA%93%E5%85%8B%E9%9A%86">从现有仓库克隆</a></li>
</ul>
</li>
<li><a href="#%E6%96%87%E4%BB%B6%E6%9B%B4%E6%96%B0">文件更新</a><ul>
<li><a href="#%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81">文件状态</a></li>
<li><a href="#%E6%A3%80%E6%9F%A5%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81">检查文件状态</a></li>
<li><a href="#%E8%B7%9F%E8%B8%AA%E6%96%87%E4%BB%B6">跟踪文件</a></li>
<li><a href="#%E6%9A%82%E5%AD%98%E5%B7%B2%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6">暂存已修改文件</a></li>
<li><a href="#%E5%BF%BD%E7%95%A5%E6%9F%90%E4%BA%9B%E6%96%87%E4%BB%B6">忽略某些文件</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E6%9C%AA%E6%9A%82%E5%AD%98%E7%9A%84%E6%9B%B4%E6%96%B0">查看未暂存的更新</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%B7%B2%E6%9A%82%E5%AD%98%E7%9A%84%E6%9B%B4%E6%96%B0">查看已暂存的更新</a></li>
<li><a href="#%E6%8F%90%E4%BA%A4%E6%9B%B4%E6%96%B0">提交更新</a></li>
<li><a href="#%E8%B7%B3%E8%BF%87%E4%BD%BF%E7%94%A8%E6%9A%82%E5%AD%98%E5%8C%BA%E5%9F%9F">跳过使用暂存区域</a></li>
<li><a href="#%E7%A7%BB%E9%99%A4%E6%96%87%E4%BB%B6">移除文件</a></li>
<li><a href="#%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6">移动文件</a></li>
</ul>
</li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2">查看提交历史</a><ul>
<li><a href="#%E9%99%90%E5%88%B6%E8%BE%93%E5%87%BA%E9%95%BF%E5%BA%A6">限制输出长度</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%B7%A5%E5%85%B7%E6%9F%A5%E9%98%85%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2">使用图形化工具查阅提交历史</a></li>
</ul>
</li>
<li><a href="#%E6%92%A4%E9%94%80">撤销</a><ul>
<li><a href="#%E4%BF%AE%E6%94%B9%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E6%8F%90%E4%BA%A4">修改最后一次提交</a></li>
<li><a href="#%E5%8F%96%E6%B6%88%E5%B7%B2%E7%BB%8F%E6%9A%82%E5%AD%98%E7%9A%84%E6%96%87%E4%BB%B6">取消已经暂存的文件</a></li>
<li><a href="#%E5%8F%96%E6%B6%88%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%AE%E6%94%B9">取消对文件的修改</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93">文件操作总结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#git%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">Git远程仓库</a><ul>
<li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">查看远程仓库</a></li>
<li><a href="#%E6%B7%BB%E5%8A%A0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">添加远程仓库</a></li>
<li><a href="#%E4%BB%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E6%8A%93%E5%8F%96%E6%95%B0%E6%8D%AE">从远程仓库抓取数据</a></li>
<li><a href="#%E6%8E%A8%E9%80%81%E6%95%B0%E6%8D%AE%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">推送数据到远程仓库</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%BF%A1%E6%81%AF">查看远程仓库信息</a></li>
<li><a href="#%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E5%88%A0%E9%99%A4%E5%92%8C%E9%87%8D%E5%91%BD%E5%90%8D">远程仓库的删除和重命名</a><ul>
<li><a href="#%E9%87%8D%E5%91%BD%E5%90%8D">重命名</a></li>
<li><a href="#%E5%88%A0%E9%99%A4">删除</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%89%88%E6%9C%AC%E6%A0%87%E7%AD%BE">版本标签</a><ul>
<li><a href="#%E6%98%BE%E7%A4%BA%E5%B7%B2%E6%9C%89%E6%A0%87%E7%AD%BE">显示已有标签</a></li>
<li><a href="#%E6%96%B0%E5%BB%BA%E6%A0%87%E7%AD%BE">新建标签</a><ul>
<li><a href="#%E5%90%AB%E9%99%84%E6%B3%A8%E7%9A%84%E6%A0%87%E7%AD%BE">含附注的标签</a></li>
<li><a href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%A0%87%E7%AD%BE">轻量级标签</a></li>
<li><a href="#%E7%AD%BE%E7%BD%B2%E6%A0%87%E7%AD%BE">签署标签</a></li>
<li><a href="#%E9%AA%8C%E8%AF%81%E6%A0%87%E7%AD%BE">验证标签</a></li>
</ul>
</li>
<li><a href="#%E5%90%8E%E6%9C%9F%E5%8A%A0%E6%B3%A8%E6%A0%87%E7%AD%BE">后期加注标签</a></li>
<li><a href="#%E5%88%86%E4%BA%AB%E6%A0%87%E7%AD%BE">分享标签</a></li>
</ul>
</li>
<li><a href="#git%E5%88%86%E6%94%AF">Git分支</a><ul>
<li><a href="#%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B">分支简介</a></li>
<li><a href="#%E6%96%B0%E5%BB%BA%E5%88%86%E6%94%AF">新建分支</a></li>
<li><a href="#head">HEAD</a></li>
<li><a href="#%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF">切换分支</a></li>
<li><a href="#%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF">合并分支</a></li>
<li><a href="#%E9%81%87%E5%88%B0%E5%86%B2%E7%AA%81%E6%97%B6%E7%9A%84%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6">遇到冲突时的分支合并</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF">删除分支</a></li>
<li><a href="#%E6%A1%88%E4%BE%8B">案例</a></li>
<li><a href="#%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86">分支管理</a></li>
<li><a href="#%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">远程分支</a></li>
<li><a href="#%E6%8E%A8%E9%80%81%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF">推送本地分支</a></li>
<li><a href="#%E8%B7%9F%E8%B8%AA%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">跟踪远程分支</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">删除远程分支</a></li>
<li><a href="#%E5%88%86%E6%94%AF%E8%A1%8D%E5%90%88">分支衍合</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li>
</ul>
<hr>
<p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。最初由 Linus Torvalds 为了帮助管理 Linux 内核开发而花了两周时间自己用C写出来的。（理那厮·掏袜子真的太绝了⊙ｏ⊙）</p>
<h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p>版本控制系统分为本地式、集中式和分布式。</p>
<ul>
<li><p>本地式：适合个人使用，用于记录文件更新。代表：RCS</p>
<img src="/images/Git/local.png" class=""></li>
<li><p>集中式：必须联网，断网后可编辑无法commit和回滚。版本库都存在中央服务器上，用户的本地只有自己以前所同步的版本，没有完整的版本库。代表：SVN、CVS、VSS。<br>假设SVN服务器没了，那你丢掉了所有历史信息，因为你的本地只有当前版本以及部分历史信息。</p>
<img src="/images/Git/centralization.png" class=""></li>
<li><p>分布式：只有在push、pull时需要联网，断网后可正常commit。中央服务器只为了修改起来方便，可有可无，每个用户本地都是一个完整的版本库。代表：Git。<br>每个人都同时对同一版本修改，commit操作提交到本地，多人协作时需要push操作和别人同步，但是团队人数多会导致非常麻烦，所以出现所谓的（便于修改的）中央服务器。<br>假设GitHub服务器没了，你不会丢掉任何git历史信息，因为你的本地有完整的版本库信息，你可以把本地的git库重新上传到另外的git服务商。 </p>
<img src="/images/Git/distributed.png" class=""></li>
</ul>
<p><strong>Git的特点</strong></p>
<ul>
<li><p>直接记录快照，而非差异比较<br>Git 只关心文件数据的<strong>整体</strong>是否发生变化，而大多数其他系统则只关心文件内容的具体差异。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。有变化则保存，无则链接。</p>
</li>
<li><p>近乎所有操作都是本地执行</p>
</li>
<li><p>时刻保持数据完整性<br>保存在 Git 数据库中的东西都是用此哈希值来作索引的，而不是靠文件名。</p>
</li>
<li><p>多数操作仅添加数据</p>
</li>
</ul>
<h1 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h1><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。<br><code>yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel</code><br>或<br><code>$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev</code><br>下载源码：<a target="_blank" rel="noopener" href="http://git-scm.com/download">http://git-scm.com/download</a><br>编译安装<br><code>$ tar -zxf git-1.7.2.2.tar.gz</code><br><code>$ cd git-1.7.2.2</code><br><code>$ make prefix=/usr/local all</code><br><code>$ sudo make prefix=/usr/local install</code></p>
<h2 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h2><h3 id="Debian-Ubuntu"><a href="#Debian-Ubuntu" class="headerlink" title="Debian/Ubuntu"></a>Debian/Ubuntu</h3><p><code>$ sudo apt-get install git</code></p>
<h3 id="Centos-RedHat"><a href="#Centos-RedHat" class="headerlink" title="Centos/RedHat"></a>Centos/RedHat</h3><p><code>$ yum install git-core</code></p>
<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p><a target="_blank" rel="noopener" href="https://git-scm.com/downloads">官网下载</a><br><a target="_blank" rel="noopener" href="https://npm.taobao.org/mirrors/git-for-windows/">镜像下载</a><br>默认安装。</p>
<img src="/images/Git/winGit.PNG" class="">
<ul>
<li><kbd>Git Bash</kbd>：Unix与Linux风格的命令行（<strong>推荐</strong>）</li>
<li><kbd>Git CMD</kbd>：DOS风格的命令</li>
<li><kbd>Git GUI</kbd>：图形界面（<strong>新手不推荐</strong>）  </li>
</ul>
<p>打开<kbd>Git Bash</kbd>检查一下：  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git --version</span></span><br><span class="line">git version 2.29.2.windows.2</span><br></pre></td></tr></table></figure>
<h1 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h1><h2 id="配置用户名和Email"><a href="#配置用户名和Email" class="headerlink" title="配置用户名和Email"></a>配置用户名和Email</h2><p>信息将会嵌入你的每次提交中。</p>
<p><strong>配置级别</strong>  </p>
<ul>
<li>系统级<kbd>--system</kbd>：系统中所有用户适用的配置<ul>
<li>Linux：/etc/gitconfig</li>
<li>Windows：Git/mingw64/etc/gitconfig</li>
</ul>
</li>
<li>用户级<kbd>--global</kbd>：当前用户适用的配置<ul>
<li>Linux：~/.gitconfig</li>
<li>Windows：C:/Users/Administrator/.gitconfig</li>
</ul>
</li>
<li>项目级<kbd>--local</kbd>：特定项目适用的配置<ul>
<li>Linux：gitProject/.gitconfig</li>
<li>Windows：gitProject/.gitconfig</li>
</ul>
</li>
</ul>
<p>低级覆盖高级：<strong>local&lt;globall&lt;system</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">&quot;Your Name&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">&quot;Your Email&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>如果用了<kbd>--global</kbd>选项，所有项目都会默认使用这个全局配置，不加则为某个特定的项目信息。</p>
<h2 id="增删配置项"><a href="#增删配置项" class="headerlink" title="增删配置项"></a>增删配置项</h2><h3 id="添加配置项"><a href="#添加配置项" class="headerlink" title="添加配置项"></a>添加配置项</h3><p><code>git config [--local|--global|--system]  section.key value</code></p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">51139@DESKTOP MINGW64 /e/blog</span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global Student.number 2018000001</span></span><br><span class="line">51139@DESKTOP MINGW64 /e/blog</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat C:/Users/51139/.gitconfig</span></span><br><span class="line">[user]</span><br><span class="line">        name = memorykkk</span><br><span class="line">        email = 511390937@qq.com</span><br><span class="line">[Student]</span><br><span class="line">        number = 2018000001</span><br></pre></td></tr></table></figure>

<h3 id="删除配置项"><a href="#删除配置项" class="headerlink" title="删除配置项"></a>删除配置项</h3><p><code>git config [--local|--global|--system] --unset section.key</code></p>
<h2 id="更多配置项"><a href="#更多配置项" class="headerlink" title="更多配置项"></a>更多配置项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config -l, --list     #list all    列出所有</span><br><span class="line">git config -e, --edit     #open an editor    打开一个编辑器</span><br><span class="line">git config --global color.ui true   #打开所有的默认终端着色</span><br><span class="line">git config --global alias.ci commit   #别名 ci 是commit的别名</span><br><span class="line">user.name  #用户名</span><br><span class="line">user.email  #邮箱</span><br><span class="line">core.editor  #文本编辑器  </span><br><span class="line">merge.tool  #差异分析工具  </span><br><span class="line">core.paper &quot;less -N&quot;  #配置显示方式  </span><br><span class="line">color.diff true  #diff颜色配置  </span><br><span class="line">alias.co checkout  #设置别名</span><br><span class="line">git config user.name  #获得用户名</span><br><span class="line">git config core.filemode false  #忽略修改权限的文件 </span><br></pre></td></tr></table></figure>
<p>学习<kbd>config</kbd>命令，运行  <code>$ git help config</code></p>
<p>查看手册 <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-config">git config</a></p>
<h1 id="Git基本概念"><a href="#Git基本概念" class="headerlink" title="Git基本概念"></a>Git基本概念</h1><ol>
<li>Git本地有三个工作区域：<strong>工作区</strong>（Workspace）、<strong>暂存区</strong>（Index/Stage）、<strong>仓库</strong>（Repository），加上<strong>远程仓库</strong>（Remote）共四个工作区域。</li>
</ol>
<p>Git 各个命令可以理解为在各个仓库间转移数据，各个命令对应对每个仓库输入输出。</p>
<ul>
<li>Workspace：工作区，平时能看到的存放项目代码的地方</li>
<li>Index / Stage：暂存区，临时存放改动，保存即将提交到文件列表信息的文件，有时也叫作索引</li>
<li>Repository：仓库区（或本地仓库），安全存放数据的位置，含所有版本的数据，HEAD指向最新版本</li>
<li>Remote：远程仓库，托管代码的服务器，用于远程数据交换</li>
</ul>
<ol start="2">
<li>对于本地三个区域的关系如下：<br><img src="/images/Git/local_relation.png" alt="local_relation"></li>
</ol>
<ul>
<li><p>Directory：使用Git管理的仓库，包含我们的工作空间和Git的管理空间</p>
</li>
<li><p>WorkSpace：需要通过Git进行版本控制的目录和文件组成工作空间</p>
</li>
<li><p>.git：存放Git管理信息的目录，初始化仓库的时候自动创建</p>
</li>
<li><p>Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前存放所有的更新</p>
</li>
<li><p>Local Repo：本地仓库，HEAD会只是当前的开发分支（branch）。</p>
</li>
<li><p>Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。<br>观察命令对各区域的影响：<br><img src="/images/Git/git_theory.jpg" alt="git_theory"></p>
</li>
<li><p>master 是 master 分支所代表的目录树，此时 HEAD 实际是指向 master 分支的一个”游标”，objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。</p>
</li>
<li><p>当对工作区修改（或新增）的文件执行 <kbd>git add</kbd> 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</p>
</li>
<li><p>当执行提交操作 <kbd>git commit</kbd>时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</p>
</li>
<li><p>当执行 <kbd>git reset HEAD</kbd> 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</p>
</li>
<li><p>当执行 <kbd>git rm --cached &lt;file></kbd> 命令时，会直接从暂存区删除文件，工作区则不做出改变。</p>
</li>
<li><p>当执行 <kbd>git checkout .</kbd> 或者 <kbd>git checkout -- &lt;file></kbd> 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</p>
</li>
<li><p>当执行 <kbd>git checkout HEAD .</kbd> 或者 <kbd>git checkout HEAD &lt;file></kbd> 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</p>
</li>
</ul>
<ol start="3">
<li>若对四个区域分级：workspace &lt; index &lt; repository &lt; remote，基本的转移如下表，参数和选项决定数据来源。</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>低等级输入</th>
<th>高等级输入</th>
</tr>
</thead>
<tbody><tr>
<td>workspace</td>
<td>手动</td>
<td>git checkout/git stash</td>
</tr>
<tr>
<td>index/stage</td>
<td>git add</td>
<td>git reset</td>
</tr>
<tr>
<td>repository</td>
<td>git commit</td>
<td>git pull</td>
</tr>
<tr>
<td>remote</td>
<td>git push</td>
<td>-</td>
</tr>
</tbody></table>
<p>四个区域转换关系如下：<br><img src="/images/Git/git_transition.png" alt="git_transition"></p>
<h1 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h1><p>一般工作流程如下：</p>
<ul>
<li>在工作目录中修改某些文件。</li>
<li>对修改后的文件进行快照，然后保存到暂存区域。</li>
<li>提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。</li>
</ul>
<p><img src="/images/Git/git-process-img.png" alt="git-process"></p>
<h1 id="Git操作"><a href="#Git操作" class="headerlink" title="Git操作"></a>Git操作</h1><h2 id="Git创建版本库"><a href="#Git创建版本库" class="headerlink" title="Git创建版本库"></a>Git创建版本库</h2><ul>
<li>在工作目录中初始化新仓库</li>
<li>从现有仓库克隆</li>
</ul>
<h3 id="在工作目录中初始化"><a href="#在工作目录中初始化" class="headerlink" title="在工作目录中初始化"></a>在工作目录中初始化</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure>
<p>在新建空目录或已有目录中，使用命令 <code>git init</code> 初始化一个新仓库。初始化后该目录下自动生成<kbd>.git</kbd>目录，用于生成所有 Git 需要的数据和资源。</p>
<p><strong>文件加入版本库</strong><br>将文件添加到仓库（workspace -&gt; stage）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add &lt;file&gt;</span></span><br></pre></td></tr></table></figure>
<p>执行后没有任何信息则代表执行成功。</p>
<p>将文件提交到仓库（stage -&gt; repository）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m &lt;message&gt;</span></span><br></pre></td></tr></table></figure>

<p>多次<kbd>add</kbd>不同的文件，但只需一次<kbd>commit</kbd>就可以提交。</p>
<h3 id="从现有仓库克隆"><a href="#从现有仓库克隆" class="headerlink" title="从现有仓库克隆"></a>从现有仓库克隆</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> &lt;url&gt; &lt;newName&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Git 收取的是项目历史的完整数据（每一个文件的每一个版本），而不是某个特定版本，服务器上有的数据克隆之后本地也都有了。  </li>
<li><kbd>url</kbd> 支持 git 协议或 SSH 传输协议。通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。  </li>
<li>克隆之后的目录名为 url 中 .git 前的名称，通过 <kbd>&lt;newName></kbd> 可以自定义。目录中包含<kbd>.git</kbd>目录，用于保存下载下来的所有版本记录，然后从中取出最新版本的文件拷贝。</li>
</ul>
<h2 id="文件更新"><a href="#文件更新" class="headerlink" title="文件更新"></a>文件更新</h2><h3 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h3><p>文件状态主要分两种，已跟踪（tracked）即本来就被纳入版本控制管理的文件，其它文件即未跟踪（untracked）。</p>
<ul>
<li>Untracked：未跟踪，此文件没有加入到git库，不参与版本控制。通过 <code>git add</code> 状态变为staged</li>
<li>Unmodify：文件已经入库，未修改，即版本库中的文件快照内容与文件夹中完全一致。这种文件被修改成为Modified，通过<code>git rm</code>移出版本库成为Untracked</li>
<li>Modified：文件已修改。这种文件通过<code>git add</code>可变成staged，通过<code>git checkout</code>则丢弃修改回到unmodify</li>
<li>Staged：暂存状态。通过<code>git commit</code>则将修改同步到库中，这时库中的文件和本地文件又变为一致，变为Unmodify状态。执行<code>git reset HEAD &lt;filename&gt;</code>取消暂存，变为Modified</li>
</ul>
<p>初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改（unmodified）。<br>文件状态变化周期：<br><img src="/images/Git/file-status.png" alt="file-status"></p>
<p>修改后的文件状态是 modified，逐步放在暂存区域，最后一次性提交。</p>
<h3 id="检查文件状态"><a href="#检查文件状态" class="headerlink" title="检查文件状态"></a>检查文件状态</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看指定文件状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status &lt;filename&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看所有文件状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br></pre></td></tr></table></figure>
<p>例如创建README之后：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim README</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Untracked files:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># README</span></span></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure>
<p>表示当前处在<kbd>master</kbd>分支，未跟踪文件里包含 README，即 Git 之前的快照中没有这个文件，未纳入管理。</p>
<h3 id="跟踪文件"><a href="#跟踪文件" class="headerlink" title="跟踪文件"></a>跟踪文件</h3><p>（workspace -&gt; stage；untracked -&gt; staged）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加指定文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add &lt;file1&gt; &lt;file2&gt; ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加指定目录到暂存区，包括子目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add &lt;dir&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加当前目录的所有文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add README</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">    # On branch master</span><br><span class="line">    # Changes to be committed:</span><br><span class="line">    # (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">    #</span><br><span class="line">    # new file: README</span><br><span class="line">    #</span><br></pre></td></tr></table></figure>
<p>“Changes to be committed:” 表示其下的文件处于暂存区</p>
<h3 id="暂存已修改文件"><a href="#暂存已修改文件" class="headerlink" title="暂存已修改文件"></a>暂存已修改文件</h3><p>（untracked -&gt; staged）<br>修改一个已跟踪的文件后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">    # On branch master</span><br><span class="line">    # Changes not staged for commit:</span><br><span class="line">    # (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">    #</span><br><span class="line">    # modified: benchmarks.rb</span><br><span class="line">    #</span><br></pre></td></tr></table></figure>
<p>“Changes not staged for commit:” 表示该文件内容发生变化但还未放到暂存区，需要重新运行 <code>git add</code> 命令。<br>也就是说，文件修改之后必须再次 <code>git add</code>，否则 <code>git commit</code> 提交的是修改前版本。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add benchmarks.rb</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># new file: README</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> modified: benchmarks.rb</span></span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure>

<p><code>git add</code> 根据目标文件的状态产生不同的效果：</p>
<ul>
<li>开始跟踪新文件</li>
<li>把已跟踪的文件放到暂存区</li>
<li>合并时把有冲突的文件标记为已解决状态</li>
</ul>
<h3 id="忽略某些文件"><a href="#忽略某些文件" class="headerlink" title="忽略某些文件"></a>忽略某些文件</h3><p>有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。有以下三种方式：</p>
<ol>
<li><p>创建<kbd>.gitignore</kbd>文件</p>
</li>
<li><p>项目设置中指定排除文件<br>临时指定。需要编辑当前项目中的 .git/info/exclude 文件</p>
</li>
<li><p>定义Git全局的 .gitignore 文件<br>设置全局的.gitignore文件来管理所有Git项目的行为。创建.gitignore文件，存放在任意位置，然后使用命令 <code># git config --global core.excludesfile ~/.gitignore</code> 配置。</p>
</li>
</ol>
<p>格式规范如下：</p>
<ul>
<li>每行一个，空格不匹配任意文件，可作为分隔符，可用反斜杠转义</li>
<li>所有空行或者以注释符号 <kbd>＃</kbd> 开头的行都会被 Git 忽略</li>
<li>可以使用标准的 glob 模式匹配：shell 所使用的简化了的正则表达式</li>
<li>匹配模式最后跟反斜杠<kbd>/</kbd>说明要忽略的是目录下所有文件</li>
<li>使用两个星号”**” 表示匹配任意中间目录</li>
<li><kbd>/</kbd>结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件；<kbd>/</kbd>开始的模式匹配项目根目录</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号<kbd>!</kbd>取反。</li>
<li>关于优先级等更多语法查看<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kevingrace/p/5690241.html">Git忽略提交规则 - .gitignore配置运维总结</a></li>
</ul>
<p>一般来说每个Git项目中都需要一个“.gitignore”文件，告诉Git哪些文件不需要添加到版本管理中，实际项目中很多文件都是不需要版本管理的，例如日志、缩略图、敏感信息等。</p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span></span><br><span class="line">    doc/*.txt</span><br></pre></td></tr></table></figure>


<h3 id="查看未暂存的更新"><a href="#查看未暂存的更新" class="headerlink" title="查看未暂存的更新"></a>查看未暂存的更新</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br></pre></td></tr></table></figure>

<p>查看工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。<br>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br><span class="line">    diff --git a/benchmarks.rb b/benchmarks.rb</span><br><span class="line">    index 3cb747f..da65585 100644</span><br><span class="line">    --- a/benchmarks.rb</span><br><span class="line">    +++ b/benchmarks.rb</span><br><span class="line">    @@ -36,6 +36,10 @@ def main</span><br><span class="line">    @commit.parents[0].parents[0].parents[0]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    + run_code(x, &#x27;commits 1&#x27;) do</span><br><span class="line">    + git.commits.size</span><br><span class="line">    + end</span><br><span class="line">    +</span><br><span class="line">    run_code(x, &#x27;commits 2&#x27;) do</span><br><span class="line">    log = git.commits(&#x27;master&#x27;, 15)</span><br><span class="line">    log.size</span><br></pre></td></tr></table></figure>

<h3 id="查看已暂存的更新"><a href="#查看已暂存的更新" class="headerlink" title="查看已暂存的更新"></a>查看已暂存的更新</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached</span></span><br></pre></td></tr></table></figure>

<p>查看已经暂存起来的文件和上次提交时的快照之间的差异</p>
<h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h3><p>（staged -&gt; commited；stage -&gt; repository）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m &lt;file&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区的指定文件到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit &lt;file1&gt; &lt;file2&gt; ... -m &lt;message&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交工作区自上次commit之后的变化，直接到仓库区，跳过add,对新文件无效</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交时显示所有diff信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -v</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果我们提交后发现有个文件改错了，将修改过的文件通过<span class="string">&quot;git add&quot;</span>后执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m &lt;message&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend &lt;file1&gt; &lt;file2&gt; ...</span> </span><br></pre></td></tr></table></figure>

<p>使用 <code>git status</code> 查看暂存区域状态，准备妥当之后就可以提交了。<br>这样看来暂存区的意义在于<strong>精心准备</strong>每次提交。  </p>
<ul>
<li>直接使用不加 <kbd>-m</kbd> 的 <code>git commit</code> 提交会打开编辑器（通过 <code>$ git config --global core.editor emacs</code> 配置）以便输入本次提交的说明。</li>
<li>使用<kbd>-m</kbd>选项比较方便。</li>
</ul>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;Story 182: Fix benchmarks for speed&quot;</span></span></span><br><span class="line">    [master]: created 463dc4f: &quot;Fix benchmarks for speed&quot;</span><br><span class="line">    2 files changed, 3 insertions(+), 0 deletions(-)</span><br><span class="line">    create mode 100644 README</span><br></pre></td></tr></table></figure>

<p>显示了提交的分支（master）、SHA-1校验和（463dc4f）、修改过的文件数（2）和增（3）删<strong>行数</strong>。  </p>
<p>因为修改后但未暂存的处于已修改态（modified），只能纳入下一次版本。  </p>
<p><strong>每次提交都是对项目的一次快照，以后可以回退</strong></p>
<h3 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -a -m &lt;message&gt;</span></span><br></pre></td></tr></table></figure>

<p>Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤，对新文件无效</p>
<h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><ol>
<li>从 Git 中移除文件</li>
</ol>
<p>未跟踪文件对 Git 来说不存在，手动<code>rm</code>即可，已跟踪文件就必须要从已跟踪文件清单（stage）中移除，然后提交。可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm &lt;file&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果只是简单地从工作目录中手工删除文件，运行 <code>git status</code> 时就会在 “Changes not staged for commit” 部分（未暂存清单）看到。（判断为“修改”操作？）</p>
<ol start="2">
<li>从 Git 中移除，但仍然希望保留在当前工作目录<br>（stage -&gt; workspace；tracked:staged -&gt; untracked）<br>即不小心纳入仓库后，想要移除跟踪但不删除文件。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm --cached &lt;file&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git mv &lt;oldfileName&gt; &lt;newFileName&gt;</span></span><br></pre></td></tr></table></figure>

<p>Git 并不跟踪文件移动操作。如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。要在 Git 中对文件改名，执行<code>git mv</code>实际上相当于</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mv old new</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm old</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add new</span></span><br></pre></td></tr></table></figure>

<h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br></pre></td></tr></table></figure>
<p>默认不用任何参数，<code>git log</code> 会按提交时间列出所有的更新信息。<br>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">    commit ca82a6dff817ec66f44342007202690a93763949   #SHA-1校验和</span><br><span class="line">    Author: Scott Chacon &lt;schacon@gee-mail.com&gt;       #作者&lt;邮箱&gt;</span><br><span class="line">    Date: Mon Mar 17 21:52:11 2008 -0700              #时间</span><br><span class="line"></span><br><span class="line">    changed the version number                        #提交说明</span><br></pre></td></tr></table></figure>

<p><strong>选项</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> &lt;option&gt;</span></span><br><span class="line">  -p    #开显示每次提交的内容差异</span><br><span class="line">  --stat  #仅显示简要的增改行数统计</span><br><span class="line">  --shortstat #只显示 --stat 中最后的行数修改添加移除统计。</span><br><span class="line">  --name-only #仅在提交信息后显示已修改的文件清单。</span><br><span class="line">  --name-status #显示新增、修改、删除的文件清单。</span><br><span class="line">  --abbrev-commit #仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</span><br><span class="line">  --relative-date #使用较短的相对时间显示（比如，“2 weeks ago”）。</span><br><span class="line">  --graph 显示 ASCII #图形表示的分支合并历史。</span><br><span class="line">  --pretty #使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</span><br></pre></td></tr></table></figure>

<h3 id="限制输出长度"><a href="#限制输出长度" class="headerlink" title="限制输出长度"></a>限制输出长度</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> &lt;option&gt;</span></span><br><span class="line">  -(n) #仅显示最近的 n 条提交</span><br><span class="line">  --since, --after #仅显示指定时间之后的提交。</span><br><span class="line">  --until, --before #仅显示指定时间之前的提交。</span><br><span class="line">  --author #仅显示指定作者相关的提交。</span><br><span class="line">  --committer #仅显示指定提交者相关的提交。</span><br></pre></td></tr></table></figure>

<h3 id="使用图形化工具查阅提交历史"><a href="#使用图形化工具查阅提交历史" class="headerlink" title="使用图形化工具查阅提交历史"></a>使用图形化工具查阅提交历史</h3><p>随 Git 一同发布的 gitk 相当于 git log 命令的可视化版本。</p>
<h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><p>任何已经提交到 Git 的都可以被恢复。你可能失去的数据，仅限于没有提交过的，对 Git 来说它们就像从未存在过一样。</p>
<h3 id="修改最后一次提交"><a href="#修改最后一次提交" class="headerlink" title="修改最后一次提交"></a>修改最后一次提交</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果我们提交后发现有个文件改错或没有加，将修改过的文件通过<span class="string">&quot;git add&quot;</span>后执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改上一次commit的提交信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m &lt;message&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend &lt;file1&gt; &lt;file2&gt; ...</span> </span><br></pre></td></tr></table></figure>

<p>也就是说，在执行<code>git commit</code>之后暂存区为空，此时若再次执行<code>git commit --amend</code>判断为修改上次的提交信息；此时若<code>git add</code>新文件到暂存区，执行此命令相当于添加到上次提交。</p>
<h3 id="取消已经暂存的文件"><a href="#取消已经暂存的文件" class="headerlink" title="取消已经暂存的文件"></a>取消已经暂存的文件</h3><p>（staged -&gt; modified）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset HEAD &lt;file&gt;</span></span><br></pre></td></tr></table></figure>
<p>文件从暂存区回到已修改未暂存状态。</p>
<h3 id="取消对文件的修改"><a href="#取消对文件的修改" class="headerlink" title="取消对文件的修改"></a>取消对文件的修改</h3><p>（modified -&gt; unmodified）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- &lt;file&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="文件操作总结"><a href="#文件操作总结" class="headerlink" title="文件操作总结"></a>文件操作总结</h3><p><img src="/images/Git/file-summary.png" alt="file-summary.png"></p>
<h1 id="Git远程仓库"><a href="#Git远程仓库" class="headerlink" title="Git远程仓库"></a>Git远程仓库</h1><p>Git 要求每个远程主机都必须指定一个主机名。</p>
<h2 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote</span></span><br></pre></td></tr></table></figure>
<p>查看每个远程库的简短名字。Git 默认使用“origin”这个名字来标识你所克隆的原始仓库。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br></pre></td></tr></table></figure>

<p>加上<kbd>-v</kbd>选项，显示对应的克隆地址。</p>
<h2 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add &lt;shortname&gt; &lt;url&gt;</span></span><br></pre></td></tr></table></figure>

<p><kbd>&lt;shortname></kbd>即自定义远程主机名<remote-name>，在<code>git remote</code>中显示，</p>
<h2 id="从远程仓库抓取数据"><a href="#从远程仓库抓取数据" class="headerlink" title="从远程仓库抓取数据"></a>从远程仓库抓取数据</h2><p><strong>git fetch</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch add &lt;remote-name&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch add &lt;remote-name&gt; &lt;branch-name&gt;  <span class="comment">#指定分支</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>抓取所有本地仓库没有的数据。但只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支。  </li>
<li>通常用来查看其他人的进程，因为它取回的代码对本地代码没有影响。  </li>
<li>指定分支所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。  </li>
<li>类似的，<code>git fetch origin</code>会抓取上次<code>clone</code>以来的别人提交的更新。  </li>
<li>如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。</li>
</ul>
<p><strong>git pull</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull &lt;remote-name&gt; &lt;remote-branch-name&gt;:&lt;local-branch-name&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>取回远程主机某个分支的更新，再与本地的指定分支合并。  </li>
<li>如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。  </li>
<li>如果是与当前分支合并，则冒号后面的部分可以省略。  </li>
<li>等同于先<code>git fetch</code>再<code>git merge</code>。  </li>
<li>如果远程主机删除了某个分支，默认情况下，<code>git pull</code> 不会在拉取远程分支的时删除对应的本地分支。这是为了防止由于其他人操作了远程主机，导致<code>git pull</code>不知不觉删除了本地分支。除非加上参数 <kbd>-p</kbd> 就会在本地删除远程已经删除的分支。</li>
</ul>
<h2 id="推送数据到远程仓库"><a href="#推送数据到远程仓库" class="headerlink" title="推送数据到远程仓库"></a>推送数据到远程仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;remote-name&gt; &lt;local-branch-name&gt;:&lt;remote-branch-name&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。  </li>
<li>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。<br>将本地仓库中的数据推送到远程仓库，只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。</li>
<li>如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</li>
<li>如果是新建分支第一次<code>git push</code>，会提示：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fatal: The current branch dev1 has no upstream branch.</span><br><span class="line">　　To push the current branch and set the remote as upstream, use</span><br><span class="line">　　git push --set-upstream origin dev1</span><br></pre></td></tr></table></figure>

<p>输入这行命令，然后输入用户名和密码就成功了，以后的push就只需要输入<code>git push origin</code>。</p>
<ul>
<li>如果当前分支只有一个追踪分支，那么主机名都可以省略。</li>
<li>如果当前分支与多个主机存在追踪关系，则可以使用<kbd>-u</kbd>选项指定一个默认主机，这样后面就可以不加任何参数使用<code>git push</code>。</li>
<li>如果不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用<kbd>--all</kbd>选项。</li>
<li>如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做<code>git pull</code>合并差异，然后再推送到远程主机。这时如果你一定要推送，可以使用<kbd>--force</kbd>选项。<br>结果导致远程主机上更新的版本被覆盖。</li>
</ul>
<h2 id="查看远程仓库信息"><a href="#查看远程仓库信息" class="headerlink" title="查看远程仓库信息"></a>查看远程仓库信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote show &lt;remote-name&gt;</span></span><br></pre></td></tr></table></figure>
<p>例如：  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote show origin</span></span><br><span class="line">    * remote origin</span><br><span class="line">    URL: git@github.com:defunkt/github.git</span><br><span class="line">    Remote branch merged with &#x27;git pull&#x27; while on branch issues     # git pull 时将自动合并的分支</span><br><span class="line">    issues</span><br><span class="line">    Remote branch merged with &#x27;git pull&#x27; while on branch master     # git pull 时将自动合并的分支</span><br><span class="line">    master</span><br><span class="line">    New remote branches (next fetch will store in remotes/origin)   # 还没有同步到本地的远端分支</span><br><span class="line">    caching               </span><br><span class="line">    Stale tracking branches (use &#x27;git remote prune&#x27;)    #已同步到本地的远端分支在远端服务器上已被删除</span><br><span class="line">    libwalker</span><br><span class="line">    walker2</span><br><span class="line">    Tracked remote branches</span><br><span class="line">    acl</span><br><span class="line">    apiv2</span><br><span class="line">    dashboard2</span><br><span class="line">    issues</span><br><span class="line">    master</span><br><span class="line">    postgres</span><br><span class="line">    Local branch pushed with &#x27;git push&#x27;     # git push 缺省推送的分支</span><br><span class="line">    master:master         </span><br></pre></td></tr></table></figure>

<h2 id="远程仓库的删除和重命名"><a href="#远程仓库的删除和重命名" class="headerlink" title="远程仓库的删除和重命名"></a>远程仓库的删除和重命名</h2><h3 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote rename pb paul</span></span><br></pre></td></tr></table></figure>
<p>修改的是某个远程仓库在本地的简称，分支名也会发生变化。</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote rm &lt;remote-name&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="版本标签"><a href="#版本标签" class="headerlink" title="版本标签"></a>版本标签</h1><h2 id="显示已有标签"><a href="#显示已有标签" class="headerlink" title="显示已有标签"></a>显示已有标签</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> $ git tag -l <span class="string">&#x27;&lt;tag-name&gt;&#x27;</span>    <span class="comment">#显示指定版本</span></span></span><br></pre></td></tr></table></figure>
<p>按照字母顺序排列。</p>
<h2 id="新建标签"><a href="#新建标签" class="headerlink" title="新建标签"></a>新建标签</h2><p>Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用；而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息。</p>
<p>建议一般使用含附注型的标签，临时性加注标签用轻量级标签。</p>
<h3 id="含附注的标签"><a href="#含附注的标签" class="headerlink" title="含附注的标签"></a>含附注的标签</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -a &lt;tag-name&gt; -m &lt;message&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show <span class="string">&#x27;&lt;tag-name&gt;&#x27;</span>    <span class="comment">#查看相应标签的版本信息</span></span></span><br></pre></td></tr></table></figure>
<p><kbd>-a</kbd>指定标签名，<kbd>-m</kbd>指定对应的标签说明，<code>git show</code>可以显示出。</p>
<h3 id="轻量级标签"><a href="#轻量级标签" class="headerlink" title="轻量级标签"></a>轻量级标签</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag &lt;tag-name&gt;</span></span><br></pre></td></tr></table></figure>
<p>没有选项。</p>
<h3 id="签署标签"><a href="#签署标签" class="headerlink" title="签署标签"></a>签署标签</h3><p>如果你有自己的私钥，还可以用 GPG 来签署标签，只需要把之前的 <kbd>-a</kbd> 改为 <kbd>-s</kbd> 即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -s &lt;tag-name&gt; -m &lt;message&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="验证标签"><a href="#验证标签" class="headerlink" title="验证标签"></a>验证标签</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -v &lt;tag-name&gt;</span></span><br></pre></td></tr></table></figure>
<p>验证已经签署的标签，会调用 GPG 来验证签名，所以需要有签署者的公钥，存放在 keyring 中，才能验证，否则报错<code>gpg: Can&#39;t check signature: public key not found</code>。</p>
<h2 id="后期加注标签"><a href="#后期加注标签" class="headerlink" title="后期加注标签"></a>后期加注标签</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -a &lt;tag-name&gt; &lt;SHA-1&gt;</span></span><br></pre></td></tr></table></figure>
<p>只要在打标签的时候跟上对应提交对象的校验和（或前几位字符）即可。<br>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v1.2 9fceb02</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show v1.2</span></span><br><span class="line">  version 1.2</span><br><span class="line">    commit 9fceb02d0ae598e95dc970b74767f19372d61af8</span><br><span class="line">    Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt;</span><br><span class="line">    Date: Sun Apr 27 20:43:35 2008 -0700</span><br><span class="line"></span><br><span class="line">    updated rakefile</span><br></pre></td></tr></table></figure>

<h2 id="分享标签"><a href="#分享标签" class="headerlink" title="分享标签"></a>分享标签</h2><p>默认情况下，<code>git push</code> 并不会把标签传送到远端服务器上</p>
<ul>
<li>使用<kbd>--tags</kbd>选项一次推送所有本地新增的标签上去</li>
<li>通过显式命令才能分享标签到远端仓库。  </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin --tags</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin [tag-name]</span></span><br></pre></td></tr></table></figure>

<h1 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h1><p>使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。</p>
<h2 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h2><p>在 Git 中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针、作者等附属信息、零个或多个指向该提交对象的父对象指针。首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。</p>
<p>举例：对于三个文件暂存后，Git 嫁给你当前版本的快照（blob类型）连同每个文件的额SHA-1保存至仓库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add README test.rb LICENSE</span></span><br><span class="line">    $ git commit -m &#x27;initial commit of my project&#x27;</span><br></pre></td></tr></table></figure>
<p>现在仓库中有五个对象：</p>
<ul>
<li>三个 blob 对象：表示文件快照内容</li>
<li>tree 对象：记录着目录树内容及其中各个文件对应的 blob 对象索引的</li>
<li>commit 对象：指向 tree 对象（根目录）的索引和其他提交信息元数据。在需要的时候重现此次快照。<br><img src="/images/Git/singleObj.png" alt="singleObj.png"></li>
</ul>
<p>作些修改后再次提交，那么这次的提交对象会包含一个指向上次提交对象的指针（parent 对象）。两次提交后：<br><img src="images/Git/multiObj.png" alt="multiObj.png"></p>
<p>Git 中的分支，其实本质上仅仅是个指向 commit 对象的可变指针。Git 会使用 <kbd>master</kbd> 作为分支的默认名字。在若干次提交后，你其实已经有了一个指向最后一次提交对象的 <kbd>master</kbd> 分支，它在每次提交的时候都会自动向前移动。<br><img src="images/Git/masterHistory.png" alt="masterHistory.png"></p>
<h2 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch &lt;branch-name&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用<code>git branch testing</code>在当前 commit 对象上新建一个分支指针<kbd>testing</kbd>：<br><img src="images/Git/newBranch.png" alt="newBranch.png"></p>
<h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><p>HEAD 是一个指向你正在工作中的本地分支的指针，即当前分支。</p>
<p>运行 <code>git branch</code> 命令，仅仅是建立了一个新的分支，但不会自动切换到这个分支中去，所以依然还在 <kbd>master</kbd> 分支里工作：</p>
<p><img src="images/Git/headMaster.png" alt="headMaster.png"></p>
<h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout &lt;branch-name&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b &lt;branch-name&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用<code>git checkout testing</code>切换分支<kbd>testing</kbd>：<br><img src="images/Git/checkout.png" alt="checkout.png"></p>
<p>或者运行 <code>git checkout</code> 并加上 <kbd>-b</kbd> 参数，新建并切换到该分支。</p>
<p>提交之后：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim test.rb</span></span><br><span class="line">    $ git commit -a -m &#x27;made a change&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="images/Git/headTesting.png" alt="headTesting.png"><br>提交后 HEAD 随<kbd>testing</kbd>分支一起向前移动，，而 <kbd>master</kbd> 分支仍然指向原先 <code>git checkout</code> 时所在的 commit 对象。</p>
<p>如果此时执行<code>git checkout master</code>，切回<kbd>master</kbd>分支：</p>
<p><img src="images/Git/masterHistory.png" alt="masterHistory.png"><br>做了两件事：</p>
<ul>
<li>HEAD 指针移回到 <kbd>master</kbd> 分支</li>
<li>工作目录中的文件换成了 master 分支所指向的快照内容（较旧的进度）<br>它的主要作用是将 testing 分支里作出的修改暂时取消，这样你就可以向另一个方向进行开发。</li>
</ul>
<p>此时如果提交新文件，即：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim test.rb</span></span><br><span class="line">    $ git commit -a -m &#x27;made other changes&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="images/Git/branchHistory.png" alt="branchHistory.png"></p>
<p><strong>Git 中的分支实际上仅是一个包含所指对象校验和（40 个字符长度 SHA-1 字串）的文件，Git 的实现与项目复杂度无关，并且每次提交都记录了 parent 对象，所以 Git 分支操作非常廉价。</strong></p>
<blockquote>
<p>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：<br>你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！<br>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：<br>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：<br>所以Git合并分支也很快！就改改指针，工作区内容也不变！<br>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支。</p>
</blockquote>
<h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge iss53</span></span><br></pre></td></tr></table></figure>

<p>回到 <kbd>master</kbd> 分支，运行 <code>git merge</code> 命令指定要合并进来的分支<kbd>iss53</kbd></p>
<h2 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h2><p>如果在不同的分支中都修改了同一个文件的同一部分，Git 就无法干净地把两者合到一起（逻辑上说，这种问题只能由人来裁决）。结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge iss53</span></span><br><span class="line">    Auto-merging index.html</span><br><span class="line">    CONFLICT (content): Merge conflict in index.html</span><br><span class="line">    Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<p>Git 做了合并但没有提交，等待解决冲突。可以用 <code>git status</code> 查看合并时发生冲突的文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash"> unmerged: index.html</span></span><br></pre></td></tr></table></figure>

<p>任何包含未解决冲突的文件都会以未合并<strong>unmerged</strong>的状态列出。Git 会在有冲突的文件里加入标准的冲突解决标记：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line">    &lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class="line">    =======</span><br><span class="line">    &lt;div id=&quot;footer&quot;&gt;</span><br><span class="line">    please contact us at support@github.com</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></pre></td></tr></table></figure>
<p>可以看到 <kbd>=======</kbd> 隔开的上半部分，是 HEAD（当前分支）中的内容，下半部分是在 <kbd>iss53</kbd> 分支中的内容。</p>
<p>解决办法是删除上面的内容（包括’=’’&lt;’’&gt;’），自行决定怎么写。之后运行<code>git add</code>和<code>git status</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash"> modified: index.html</span></span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p>确认冲突已解决，标记为<strong>modified</strong>，再<code>git commit</code>提交。</p>
<p>也可以使用相关可视化工具解决冲突，运行<code>git mergetool</code>。</p>
<h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d &lt;branch-name&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">强制删除</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -D &lt;branch-name&gt;</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程分支，分支必须完全合并在其上游分支，或者在HEAD上没有设置上游</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete &lt;branch-name&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -dr &lt;remote-name/branch-name&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><strong>工作流程</strong></p>
<ol>
<li>开发某个网站为</li>
<li>实现某个新的需求，创建一个分支。</li>
<li>在这个分支上开展工作。</li>
</ol>
<p>假设此时突然有个很严重的问题需要紧急修补，那么：</p>
<ol>
<li>返回到原先已经发布到生产服务器上的分支。</li>
<li>为这次紧急修补建立一个新分支，并在其中修复问题。</li>
<li>通过测试后，回到生产服务器所在的分支，将修补分支合并进来，然后再推送到生产服务器上。</li>
<li>切换到之前实现新需求的分支，继续工作。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建iss53并切换</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b iss53</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 遇问题切回master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时工作区和之前 master 提交时完全一样</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建紧急修补分支 hotfix</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b <span class="string">&#x27;hotfix&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>Git 的好处：  </p>
<ul>
<li>不需要同时发布这个补丁和 iss53 里作出的修改</li>
<li>不需要在创建和发布该补丁到服务器之前花费大力气来复原这些修改</li>
</ul>
<p>切换分支时需要留心你的暂存区或者工作目录里<strong>还没有提交的修改</strong>，它会产生冲突从而阻止切换，最好保持一个清洁的工作区域（也可以通过 stashing 和 commit amending 绕过这种问题）。</p>
<p><img src="images/Git/hotfixSuccess.png" alt="hotfixSuccess.png.png"></p>
<p>修改、测试之后回到 <kbd>master</kbd> 分支并把 <kbd>hotfix</kbd> 合并：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge hotfix</span></span><br></pre></td></tr></table></figure>
<p>请注意，合并时出现了“Fast forward”的提示。由于当前 <kbd>master</kbd> 分支所在的提交对象是要并入的 <kbd>hotfix</kbd> 分支的直接上游，Git 只需把 <kbd>master</kbd> 分支指针直接右移。换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为<strong>快进</strong>（Fast forward）。</p>
<p><kbd>hotfix</kbd>分支完成历史使命之后可以删掉，回到正常的 iss53 正常工作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d hotfix</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout iss53</span></span><br></pre></td></tr></table></figure>

<p><img src="images/Git/normalWork.png" alt="normalWork.png"></p>
<p>需求#53开发完之后，合并<kbd>master</kbd>和<kbd>iss53</kbd>分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge iss53</span></span><br></pre></td></tr></table></figure>

<p>这次合并操作的底层实现，并不同于之前 <kbd>hotfix</kbd> 的并入方式。因为这次你的开发历史是从更早的地方开始分叉的。由于当前 <kbd>master</kbd> 分支所指向的提交对象（C4）并不是 <kbd>iss53</kbd> 分支的直接祖先，Git 不得不进行一些额外处理。就此例而言，Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算：</p>
<p><img src="images/Git/merge3.png" alt="merge3.png"></p>
<p>这次，Git 没有简单地把分支指针右移，而是对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（C6）（见图 3-17）。这个提交对象比较特殊，它有两个祖先（C4 和 C5）。</p>
<p>值得一提的是 Git 可以自己裁决哪个共同祖先才是最佳合并基础；这和 CVS 或 Subversion（1.5 以后的版本）不同，它们需要开发者手工指定合并基础。所以此特性让 Git 的合并操作比其他系统都要简单不少。</p>
<p><img src="images/Git/mergeAutoCommit.png" alt="mergeAutoCommit.png"></p>
<p>此时<kbd>iss53</kbd>没用了，可以删除。</p>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p><strong>查看所有分支</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">    iss53</span><br><span class="line">    * master</span><br><span class="line">    testing</span><br></pre></td></tr></table></figure>

<p><code>git branch</code> 命令不加参数列出所有分支。 <kbd>master</kbd> 分支前的 <kbd>*</kbd> 字符表示当前所在的分支。也就是说如果现在提交更新，<kbd>master</kbd> 分支将随着开发进度前移。</p>
<p><strong>查看各分支最后一个 commit 对象的信息</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -v</span></span><br></pre></td></tr></table></figure>

<p><strong>查看与HEAD已合并/或未合并分支</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看已并入当前分支的==哪些分支是当前分支的直接上游</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --merged</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看尚未合并的</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --no-merged</span></span><br></pre></td></tr></table></figure>

<p>对于已合并的，可以用<code>git branch -d</code>直接删除，不会有损失。<br>对于已合并的，用<code>git branch -d</code>删除会报错，因为这样做会丢失数据，除非<kbd>-D</kbd>强制删除。</p>
<h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p>用<kbd>remote-name/remote-branch-name</kbd>描述远程分支，区别于本地分支。</p>
<p>在第一次<code>git clone</code>之后，下载的数据命名为<kbd>origin/master</kbd>，无法修改。之后 Git 创建属于本地的 <kbd>master</kbd> 分支，二者都指向远程<kbd>origin</kbd>的<kbd>master</kbd>分支。<br><img src="images/Git/remoteBranch1.png" alt="remoteBranch1.png"></p>
<p>如果在本地 <kbd>master</kbd> 分支做了些改动，在本地的提交历史正朝向不同方向发展，与此同时，其他人向 git.ourcompany.com 推送了他们的更新，服务器上的 <kbd>master</kbd> 分支就会向前推进。不过只要不和服务器通讯，本地的 <kbd>origin/master</kbd> 指针仍然保持原位不会移动。<br><img src="images/Git/remoteBranch2.png" alt="remoteBranch2.png"></p>
<p>可以运行 <code>git fetch origin</code> 来同步远程服务器上的数据到本地。从 origin 上获取尚未拥有的数据，更新你本地的数据库，然后把 <kbd>origin/master</kbd> 的指针移到最新位置。<br><img src="images/Git/remoteBranch3.png" alt="remoteBranch3.png"></p>
<p>假设，还有另一个仅供你的敏捷开发小组使用的内部服务器 git.team1.ourcompany.com。加为当前项目的远程分支之一，并命名为 teamone。</p>
<p>现在可以用 <code>git fetch teamone</code> 来获取小组服务器上你还没有的数据了。由于当前该服务器上的内容是你 <kbd>origin</kbd> 服务器上的子集，Git 不会下载任何数据，而只是简单地创建一个名为 <kbd>teamone/master</kbd> 的远程分支，指向 teamone 服务器上 <kbd>master</kbd> 分支所在的提交对象 <kbd>31b8e</kbd>。<br><img src="images/Git/remoteBranch4.png" alt="remoteBranch4.png"></p>
<p><kbd>master</kbd>并不是多么神秘复杂的东西，分清楚远程的别人的<kbd>origin/master</kbd>、本地的别人的<kbd>origin/master</kbd>、本地的自己的<kbd>master</kbd>就可以了。</p>
<h2 id="推送本地分支"><a href="#推送本地分支" class="headerlink" title="推送本地分支"></a>推送本地分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;remote-name&gt; &lt;branch-name&gt;</span></span><br></pre></td></tr></table></figure>
<p>要想和其他人分享某个本地分支，你需要把它推送到一个你拥有<strong>写权限</strong>的远程仓库。你创建的本地分支不会因为你的写入操作而被自动同步到你引入的远程服务器上，你需要明确地执行推送分支的操作。</p>
<p><code>git push origin serverfix:serverfix</code>意思是“上传我本地的 <kbd>serverfix</kbd> 分支到远程仓库中去，仍旧称它为 <kbd>serverfix</kbd> 分支”。通过此语法，你可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫作 <kbd>awesomebranch</kbd>，可以用 <code>git push origin serverfix:awesomebranch</code> 来推送数据。</p>
<h2 id="跟踪远程分支"><a href="#跟踪远程分支" class="headerlink" title="跟踪远程分支"></a>跟踪远程分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b &lt;branch-name&gt; &lt;remote-name/branch-name&gt;</span></span><br></pre></td></tr></table></figure>
<p>从远程分支 <code>checkout</code> 出来的本地分支，称为<strong>跟踪分支</strong> (tracking branch)。跟踪分支是一种和某个远程分支有直接联系的本地分支。在跟踪分支里输入 <code>git push</code>，Git 会自行推断应该向哪个服务器的哪个分支推送数据。</p>
<h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;remote-name&gt; :&lt;branch-name&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于<code>git push &lt;remote-name&gt; &lt;local-branch-name&gt;:&lt;remote-branch-name&gt;</code> 语法，如果省略 <local-branch-name>，那就等于是在说“在这里提取空白然后把它变成<remote-branch-name>”。</p>
<h2 id="分支衍合"><a href="#分支衍合" class="headerlink" title="分支衍合"></a>分支衍合</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout &lt;rebase-branch-name&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rebase &lt;master-branch-name&gt;</span></span><br></pre></td></tr></table></figure>
<p>把一个分支中的修改整合到另一个分支有两种办法：<code>merge</code> 和 <code>rebase</code>。<br><strong>merge</strong><br><img src="images/Git/merge.png" alt="merge.png"></p>
<p><strong>rebase</strong><br>还有可以把在 C3 里产生的变化补丁在 C4 的基础上重新打一遍，这种操作叫做衍合（rebase）。即把在一个分支里提交的改变移到另一个分支里重放一遍。</p>
<p>原理是回到两个分支最近的共同祖先，根据当前分支（也就是要进行衍合的分支 <kbd>experiment</kbd>）后续的历次提交对象（这里只有一个 C3），生成一系列文件补丁，然后以基底分支（也就是主干分支 <kbd>master</kbd>）最后一个提交对象（C4）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（C3’），从而改写 <kbd>experiment</kbd> 的提交历史，使它成为 <kbd>master</kbd> 分支的直接下游：<br><img src="images/Git/rebase.png" alt="rebase.png"></p>
<p>再进行快进合并：<br><img src="images/Git/speedMerge.png" alt="speedMerge.png"></p>
<p>现在的 C3’ 对应的快照，其实和普通的三方合并，即 C5 对应的快照内容一模一样，结果没有任何区别，只不过提交历史不同。但衍合能产生一个更为整洁的提交历史，仿佛所有修改都是在一根线上先后进行的。</p>
<p>一般我们使用衍合的目的，是想要得到一个能在远程分支上干净应用的补丁。项目志愿开发者通过衍合提交，维护者就不需要做任何整合工作。实际上是把解决分支补丁同最新主干代码之间冲突的责任，化转为由提交补丁的人来解决。</p>
<p>衍合是按照每行的修改次序重演一遍修改，而合并是把最终结果合在一起。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a target="_blank" rel="noopener" href="https://git-scm.com/docs">Git官方参考文档</a></li>
<li><a target="_blank" rel="noopener" href="http://git.oschina.net/progit/">Pro Git（中文版）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/syp172654682/p/7689328.html">深入浅出Git教程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yaozhongxiao/p/3811130.html">Git图解剖析</a></li>
<li><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的官方网站</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/git/">菜鸟教程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kevingrace/p/5690241.html">Git忽略提交规则 - .gitignore配置运维总结</a></li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Tool/">Tool</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Git/">Git</a>
    </span>
    

    </div>

    
  </div>
</article>

  
	<section id="comment" class="comment">
		<div id="gitalk-container"></div>
	</section>
	<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
	<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
	<script>
		var gitalk = new Gitalk({
			clientID: '43df1f730957f2695673',
			clientSecret: '29fa4bdef022da54ce3ebc4ec844d1b5c418d42a',
			repo: 'memorykkk.github.io',
			owner: 'memorykkk',
			admin: ['memorykkk'],
			id: location.pathname,
			distractionFreeMode: false,
			createIssueManually: true,
			proxy: 'https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access_token',
		})

		gitalk.render('gitalk-container')
	</script>







    </main>

    <footer class="site-footer">
  <p class="site-info" style="color='#9e9e9e'">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2020-2021 Memorykk
    
	<a href="http://beian.miit.gov.cn" target="_blank">陕ICP备20005895号-1</a>
  </p>
</footer>
    
    
  </div>
</div>

</body>
</html>