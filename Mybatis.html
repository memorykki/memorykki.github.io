<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Mybatis | Memorykk | never too late to learn</title>

  
  <meta name="author" content="Memorykk">
  

  
  <meta name="description" content="computer,program,developer,java,linux">
  

  
  <meta name="keywords" content="computer,study,log,tool,fragment,program,developer,java,linux">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="Mybatis"/>

  <meta property="og:site_name" content="Memorykk"/>

  
  <meta property="og:image" content="/images/favicon.ico"/>
  

  <link href="/images/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Memorykk" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <meta name="baidu-site-verification" content="code-DBwLDCJwuQ" />
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Memorykk</a>
    </h1>
    <p class="site-description">never too late to learn</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/about">关于</a></li>
      
        <li><a href="/atom.xml">订阅</a></li>
      
    </ul>
  </nav>
</header>

    <main  class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>Mybatis</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/Mybatis.html" rel="bookmark">
        <time class="entry-date published" datetime="2021-08-19T06:23:35.000Z">
          2021-08-19
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>MyBatis 是一个半自动化的<strong>ORM框架</strong> </p>
<span id="more"></span>


<ul>
<li><p><a href="#01-mybatis%E4%B8%8Ehibernate%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C">0.1. <strong>MyBatis与Hibernate有哪些不同？</strong></a></p>
</li>
<li><p><a href="#02-%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2like">0.2. <strong>模糊查询like</strong></a></p>
</li>
<li><p><a href="#03-%E5%BC%95%E5%85%A5%E8%B5%84%E6%BA%90%E6%96%B9%E5%BC%8F">0.3. <strong>引入资源方式</strong></a></p>
</li>
<li><p><a href="#04-namespace">0.4. namespace</a></p>
</li>
<li><p><a href="#05-dao%E6%8E%A5%E5%8F%A3%E5%92%8Cxml%E6%96%87%E4%BB%B6%E9%87%8C%E7%9A%84sql%E6%98%AF%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E5%85%B3%E7%B3%BB%E7%9A%84">0.5. Dao接口和XML文件里的SQL是如何建立关系的？</a></p>
<ul>
<li><a href="#051-%E4%B8%80%E8%A7%A3%E6%9E%90xml">0.5.1. 一、解析XML</a><ul>
<li><a href="#0511-%E5%88%9B%E5%BB%BAsqlsource">0.5.1.1. 、创建SqlSource</a></li>
<li><a href="#0512-%E5%88%9B%E5%BB%BAmappedstatement">0.5.1.2. 、创建MappedStatement</a></li>
</ul>
</li>
<li><a href="#052-%E4%BA%8Cdao%E6%8E%A5%E5%8F%A3%E4%BB%A3%E7%90%86">0.5.2. 二、Dao接口代理</a></li>
<li><a href="#053-%E4%B8%89%E6%89%A7%E8%A1%8C">0.5.3. 三、执行</a></li>
</ul>
</li>
<li><p><a href="#06-%E4%BD%9C%E7%94%A8%E5%9F%9F">0.6. <strong>作用域</strong></a></p>
</li>
<li><p><a href="#07-%E5%B1%9E%E6%80%A7%E5%90%8D%E5%92%8C%E5%AD%97%E6%AE%B5%E5%90%8D%E4%B8%8D%E4%B8%80%E8%87%B4">0.7. 属性名和字段名不一致</a></p>
</li>
<li><p><a href="#08-resultmap">0.8. ResultMap</a></p>
</li>
<li><p><a href="#09-%E5%88%86%E9%A1%B5">0.9. 分页</a></p>
</li>
<li><p><a href="#010-%E5%9C%A8mapper%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0">0.10. <strong>在mapper中如何传递多个参数?</strong></a></p>
</li>
<li><p><a href="#011-mapper-%E7%BC%96%E5%86%99%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F">0.11. Mapper 编写有哪几种方式？</a></p>
</li>
<li><p><a href="#012-%E6%B3%A8%E8%A7%A3">0.12. 注解</a></p>
</li>
<li><p><a href="#013-mybatis%E8%AF%A6%E7%BB%86%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B">0.13. Mybatis详细的执行流程</a></p>
</li>
<li><p><a href="#014-mybatis%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E4%BB%8B%E7%BB%8D">0.14. MyBatis的工作原理以及核心流程介绍</a></p>
<ul>
<li><a href="#0141-mybatis%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3">0.14.1. 、MyBatis的工作原理以及核心流程详解</a></li>
</ul>
</li>
<li><p><a href="#015-param">0.15. @Param</a></p>
</li>
<li><p><a href="#016-%E4%B8%8E%E7%9A%84%E5%8C%BA%E5%88%AB">0.16. #与$的区别</a></p>
</li>
<li><p><a href="#017-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%93%BE%E6%8E%A5%E4%B8%AD%E6%96%AD%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86">0.17. 数据库链接中断如何处理</a></p>
</li>
<li><p><a href="#018-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%92%E5%85%A5%E9%87%8D%E5%A4%8D%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86">0.18. 数据库插入重复如何处理</a></p>
</li>
<li><p><a href="#019-%E4%B8%80%E4%B8%AAconnection%E5%9C%A8mysql%E4%B8%AD%E5%AF%B9%E5%BA%94%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B">0.19. 一个Connection在MySQL中对应一个线程？</a></p>
</li>
<li><p><a href="#020-%E9%A2%84%E7%BC%96%E8%AF%91%E7%9A%84%E8%BF%87%E7%A8%8B">0.20. 预编译的过程</a></p>
<ul>
<li><a href="#0201-jdbc%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E7%94%A8%E6%B3%95">0.20.1. 、JDBC的预编译用法</a></li>
<li><a href="#0202-%E9%A2%84%E7%BC%96%E8%AF%91%E7%9A%84%E5%A5%BD%E5%A4%84">0.20.2. 、预编译的好处</a><ul>
<li><a href="#02021-%E9%A2%84%E7%BC%96%E8%AF%91%E8%83%BD%E9%81%BF%E5%85%8Dsql%E6%B3%A8%E5%85%A5">0.20.2.1. 、预编译能避免SQL注入</a></li>
<li><a href="#02022-%E9%A2%84%E7%BC%96%E8%AF%91%E8%83%BD%E6%8F%90%E9%AB%98sql%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87">0.20.2.2. 、预编译能提高SQL执行效率</a></li>
</ul>
</li>
<li><a href="#0203-%E9%A2%84%E7%BC%96%E8%AF%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B">0.20.3. 、预编译的实现过程</a></li>
</ul>
</li>
<li><p><a href="#021">0.21.</a></p>
</li>
<li><p><a href="#022-%E5%A4%9A%E5%AF%B9%E4%B8%80">0.22. 多对一</a></p>
<ul>
<li><a href="#0221-%E6%8C%89%E6%9F%A5%E8%AF%A2%E5%B5%8C%E5%A5%97%E5%A4%84%E7%90%86">0.22.1. 按查询嵌套处理</a></li>
<li><a href="#0222-%E6%8C%89%E7%BB%93%E6%9E%9C%E5%B5%8C%E5%A5%97%E5%A4%84%E7%90%86">0.22.2. 按结果嵌套处理</a></li>
</ul>
</li>
<li><p><a href="#023-%E4%B8%80%E5%AF%B9%E5%A4%9A">0.23. 一对多</a></p>
<ul>
<li><a href="#0231-%E6%8C%89%E7%BB%93%E6%9E%9C%E5%B5%8C%E5%A5%97%E5%A4%84%E7%90%86">0.23.1. 按结果嵌套处理</a></li>
<li><a href="#0232-%E6%8C%89%E6%9F%A5%E8%AF%A2%E5%B5%8C%E5%A5%97%E5%A4%84%E7%90%86">0.23.2. 按查询嵌套处理</a></li>
</ul>
</li>
<li><p><a href="#024-%E5%8A%A8%E6%80%81-sql">0.24. 动态 SQL</a></p>
</li>
<li><p><a href="#025-dao%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">0.25. Dao接口的工作原理</a></p>
</li>
<li><p><a href="#026-%E7%BC%93%E5%AD%98">0.26. 缓存</a></p>
<ul>
<li><a href="#0261-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98">0.26.1. 一级缓存</a></li>
<li><a href="#0262-%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98">0.26.2. 二级缓存</a></li>
</ul>
</li>
<li><p><a href="#027-%E5%92%8C%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">0.27. 、#{}和${}的区别是什么？</a></p>
</li>
<li><p><a href="#028-xml-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E4%B8%AD%E9%99%A4%E4%BA%86%E5%B8%B8%E8%A7%81%E7%9A%84-selectinsertupdatedelete-%E6%A0%87%E7%AD%BE%E4%B9%8B%E5%A4%96%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A0%87%E7%AD%BE">0.28. 、Xml 映射文件中，除了常见的 select|insert|update|delete 标签之外，还有哪些标签？</a></p>
</li>
<li><p><a href="#029-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%AD%E9%80%9A%E5%B8%B8%E4%B8%80%E4%B8%AA-xml-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E9%83%BD%E4%BC%9A%E5%86%99%E4%B8%80%E4%B8%AA-dao-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E4%B9%8B%E5%AF%B9%E5%BA%94%E8%AF%B7%E9%97%AE%E8%BF%99%E4%B8%AA-dao-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88dao-%E6%8E%A5%E5%8F%A3%E9%87%8C%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%B8%8D%E5%90%8C%E6%97%B6%E6%96%B9%E6%B3%95%E8%83%BD%E9%87%8D%E8%BD%BD%E5%90%97">0.29. 、最佳实践中，通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</a></p>
<ul>
<li><a href="#0291-%E8%A1%A5%E5%85%85">0.29.1. ==补充：==</a></li>
</ul>
</li>
<li><p><a href="#030-mybatis-%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%88%86%E9%A1%B5%E7%9A%84%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88">0.30. 、MyBatis 是如何进行分页的？分页插件的原理是什么？</a></p>
</li>
<li><p><a href="#031-%E7%AE%80%E8%BF%B0-mybatis-%E7%9A%84%E6%8F%92%E4%BB%B6%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%8F%92%E4%BB%B6">0.31. 、简述 MyBatis 的插件运行原理，以及如何编写一个插件。</a></p>
</li>
<li><p><a href="#032-mybatis-%E6%89%A7%E8%A1%8C%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E8%83%BD%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E9%94%AE%E5%88%97%E8%A1%A8%E5%90%97">0.32. 、MyBatis 执行批量插入，能返回数据库主键列表吗？</a></p>
</li>
<li><p><a href="#033-mybatis-%E5%8A%A8%E6%80%81-sql-%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8A%A8%E6%80%81-sql%E8%83%BD%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%8A%A8%E6%80%81-sql-%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E4%B8%8D">0.33. 、MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？</a></p>
</li>
<li><p><a href="#034-mybatis-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B0%86-sql-%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%B0%81%E8%A3%85%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E5%B9%B6%E8%BF%94%E5%9B%9E%E7%9A%84%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%98%A0%E5%B0%84%E5%BD%A2%E5%BC%8F">0.34. 、MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</a></p>
</li>
<li><p><a href="#035-mybatis-%E8%83%BD%E6%89%A7%E8%A1%8C%E4%B8%80%E5%AF%B9%E4%B8%80%E4%B8%80%E5%AF%B9%E5%A4%9A%E7%9A%84%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E5%90%97%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB">0.35. 、MyBatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。</a></p>
</li>
<li><p><a href="#036-mybatis-%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E5%A6%82%E6%9E%9C%E6%94%AF%E6%8C%81%E5%AE%83%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88">0.36. 、MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？</a></p>
</li>
<li><p><a href="#037-mybatis-%E7%9A%84-xml-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E4%B8%AD%E4%B8%8D%E5%90%8C%E7%9A%84-xml-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6id-%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%A4%8D">0.37. 、MyBatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？</a></p>
</li>
<li><p><a href="#038-mybatis-%E4%B8%AD%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E6%89%B9%E5%A4%84%E7%90%86">0.38. 、MyBatis 中如何执行批处理？</a></p>
</li>
<li><p><a href="#039-mybatis-%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B-executor-%E6%89%A7%E8%A1%8C%E5%99%A8%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">0.39. 、MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？</a></p>
</li>
<li><p><a href="#040-mybatis-%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8C%87%E5%AE%9A%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%80%E7%A7%8D-executor-%E6%89%A7%E8%A1%8C%E5%99%A8">0.40. 、MyBatis 中如何指定使用哪一种 Executor 执行器？</a></p>
</li>
<li><p><a href="#041-mybatis-%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%98%A0%E5%B0%84-enum-%E6%9E%9A%E4%B8%BE%E7%B1%BB">0.41. 、MyBatis 是否可以映射 Enum 枚举类？</a></p>
</li>
<li><p><a href="#042-mybatis-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E4%B8%AD%E5%A6%82%E6%9E%9C-a-%E6%A0%87%E7%AD%BE%E9%80%9A%E8%BF%87-include-%E5%BC%95%E7%94%A8%E4%BA%86-b-%E6%A0%87%E7%AD%BE%E7%9A%84%E5%86%85%E5%AE%B9%E8%AF%B7%E9%97%AEb-%E6%A0%87%E7%AD%BE%E8%83%BD%E5%90%A6%E5%AE%9A%E4%B9%89%E5%9C%A8-a-%E6%A0%87%E7%AD%BE%E7%9A%84%E5%90%8E%E9%9D%A2%E8%BF%98%E6%98%AF%E8%AF%B4%E5%BF%85%E9%A1%BB%E5%AE%9A%E4%B9%89%E5%9C%A8-a-%E6%A0%87%E7%AD%BE%E7%9A%84%E5%89%8D%E9%9D%A2">0.42. 、MyBatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？</a></p>
</li>
<li><p><a href="#043-%E7%AE%80%E8%BF%B0-mybatis-%E7%9A%84-xml-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E5%92%8C-mybatis-%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%97%B4%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB">0.43. 、简述 MyBatis 的 Xml 映射文件和 MyBatis 内部数据结构之间的映射关系？</a></p>
</li>
<li><p><a href="#044-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-mybatis-%E6%98%AF%E5%8D%8A%E8%87%AA%E5%8A%A8-orm-%E6%98%A0%E5%B0%84%E5%B7%A5%E5%85%B7%E5%AE%83%E4%B8%8E%E5%85%A8%E8%87%AA%E5%8A%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E5%93%AA%E9%87%8C">0.44. 、为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</a><br>MyBatis 是一个半自动化的<strong>ORM框架</strong> </p>
</li>
<li><p>所有的增删改操作都需要提交事务！</p>
</li>
<li><p>接口所有的普通参数，尽量都写上@Param参数，尤其是多个参数时，必须写上！</p>
</li>
<li><p>有时候根据业务的需求，可以考虑使用map传递参数！</p>
</li>
<li><p>为了规范操作，在SQL的配置文件中，我们尽量将Parameter参数和resultType都写上！</p>
</li>
</ul>
<p><img src="/images/Mybatis/20200606200123233.png" alt="20200606200123233"></p>
<p><img src="/images/Mybatis/image-20210818230659590.png" alt="image-20210818230659590"></p>
<p>Caching缓存</p>
<p>Simple</p>
<p>Batch批量</p>
<p>Reuse复用</p>
<p><a target="_blank" rel="noopener" href="http://www.mybatis.cn/category/interview/">http://www.mybatis.cn/category/interview/</a></p>
<h2 id="maven静态资源过滤问题"><a href="#maven静态资源过滤问题" class="headerlink" title="maven静态资源过滤问题"></a>maven静态资源过滤问题</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="0-1-MyBatis与Hibernate有哪些不同？"><a href="#0-1-MyBatis与Hibernate有哪些不同？" class="headerlink" title="0.1. MyBatis与Hibernate有哪些不同？"></a>0.1. <strong>MyBatis与Hibernate有哪些不同？</strong></h2><p>1、Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。</p>
<p>2、Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。</p>
<p>3、Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用hibernate开发可以节省很多代码，提高效率。</p>
<h2 id="0-2-模糊查询like"><a href="#0-2-模糊查询like" class="headerlink" title="0.2. 模糊查询like"></a>0.2. <strong>模糊查询like</strong></h2><p>第1种：<strong>在Java代码中添加sql通配符。</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">string wildcardname = “%smi%”;</span><br><span class="line">list<span class="tag">&lt;<span class="name">name</span>&gt;</span> names = mapper.selectlike(wildcardname);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">”selectlike”</span>&gt;</span></span><br><span class="line">select * from foo where bar like #&#123;value&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第2种：在sql语句中拼接通配符，会引起sql注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">string wildcardname = “smi”;</span><br><span class="line">list<span class="tag">&lt;<span class="name">name</span>&gt;</span> names = mapper.selectlike(wildcardname);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">”selectlike”</span>&gt;</span></span><br><span class="line">    select * from foo where bar like &quot;%&quot;#&#123;value&#125;&quot;%&quot;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>或是利用sql的contact函数。</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectLike&quot;</span>&gt;</span></span><br><span class="line">    select * from users where name like contact(&quot;%&quot;, #&#123;value&#125;, &quot;%&quot;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="0-3-引入资源方式"><a href="#0-3-引入资源方式" class="headerlink" title="0.3. 引入资源方式"></a>0.3. <strong>引入资源方式</strong></h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用相对于类路径的资源引用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/PostMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用完全限定资源定位符（URL） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///var/mappers/AuthorMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">使用映射器接口实现类的完全限定类名</span></span><br><span class="line"><span class="comment">需要配置文件名称和接口名称一致，并且位于同一目录下</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.AuthorMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">将包内的映射器接口实现全部注册为映射器</span></span><br><span class="line"><span class="comment">但是需要配置文件名称和接口名称一致，并且位于同一目录下</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;org.mybatis.builder&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--优先级由上向下降低--&gt;</span> </span><br></pre></td></tr></table></figure>

<h2 id="0-4-namespace"><a href="#0-4-namespace" class="headerlink" title="0.4. namespace"></a>0.4. namespace</h2><p>namespace中文意思：命名空间，作用如下：</p>
<ul>
<li><ul>
<li>namespace的命名必须跟某个接口同名</li>
<li>接口中的方法与映射文件中sql语句id应该一一对应</li>
</ul>
</li>
<li><ol>
<li>namespace和子元素的id联合保证唯一  , 区别不同的mapper</li>
<li>绑定DAO接口</li>
<li>namespace命名规则 : 包名+类名</li>
</ol>
</li>
</ul>
<h2 id="0-5-Dao接口和XML文件里的SQL是如何建立关系的？"><a href="#0-5-Dao接口和XML文件里的SQL是如何建立关系的？" class="headerlink" title="0.5. Dao接口和XML文件里的SQL是如何建立关系的？"></a>0.5. <a target="_blank" rel="noopener" href="http://www.mybatis.cn/archives/467.html">Dao接口和XML文件里的SQL是如何建立关系的？</a></h2><p><strong>通过Dao接口生成的动态代理调用查询，根据绑定的namespace确定唯一id，在注册中心里找到mappedStatement，通过sqlSource生成SQL语句，jdbc执行返回。</strong></p>
<h3 id="0-5-1-一、解析XML"><a href="#0-5-1-一、解析XML" class="headerlink" title="0.5.1. 一、解析XML"></a>0.5.1. 一、解析XML</h3><p>首先，Mybatis在初始化SqlSessionFactoryBean的时候，找到mapperLocations路径去解析里面所有的XML文件，这里我们重点关注两部分。</p>
<h4 id="0-5-1-1-、创建SqlSource"><a href="#0-5-1-1-、创建SqlSource" class="headerlink" title="0.5.1.1. 、创建SqlSource"></a>0.5.1.1. 、创建SqlSource</h4><p>Mybatis会把每个SQL标签封装成SqlSource对象，然后根据SQL语句的不同，又分为动态SQL和静态SQL。其中，静态SQL包含一段String类型的sql语句；而动态SQL则是由一个个SqlNode组成。</p>
<p><img src="/images/Mybatis/1118429449.jpg" alt="1118429449"></p>
<p><img src="/images/Mybatis/2906669416.jpg" alt="2906669416"></p>
<h4 id="0-5-1-2-、创建MappedStatement"><a href="#0-5-1-2-、创建MappedStatement" class="headerlink" title="0.5.1.2. 、创建MappedStatement"></a>0.5.1.2. 、创建MappedStatement</h4><p>XML文件中的每一个SQL标签就对应一个MappedStatement对象，这里面有两个属性很重要。</p>
<p><strong>id</strong>：全限定类名+方法名组成的ID。</p>
<p><strong>sqlSource</strong>：当前SQL标签对应的SqlSource对象。</p>
<p>创建完MappedStatement对象，将它缓存到Configuration#mappedStatements中。</p>
<p>Configuration对象就是Mybatis中的大管家，基本所有的配置信息都维护在这里。把所有的XML都解析完成之后，Configuration就包含了所有的SQL信息。</p>
<p><img src="/images/Mybatis/3090421271.jpg" alt="3090421271"></p>
<p>到目前为止，XML就解析完成了。当我们执行Mybatis方法的时候，就通过全限定类名+方法名找到MappedStatement对象，然后解析里面的SQL内容，执行即可。</p>
<h3 id="0-5-2-二、Dao接口代理"><a href="#0-5-2-二、Dao接口代理" class="headerlink" title="0.5.2. 二、Dao接口代理"></a>0.5.2. 二、Dao接口代理</h3><p>我们的Dao接口并没有实现类，那么，我们在调用它的时候，它是怎样最终执行到我们的SQL语句的呢？</p>
<p>首先，我们在Spring配置文件中，一般会这样配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.viewscenes.netsupervisor.dao&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者你的项目是基于SpringBoot的，那么肯定也见过这种：</p>
<p>@MapperScan(“com.xxx.dao”)</p>
<p>它们的作用是一样的。将包路径下的所有类注册到Spring Bean中，并且将它们的beanClass设置为MapperFactoryBean。MapperFactoryBean实现了FactoryBean接口，俗称工厂Bean。那么，当我们通过@Autowired注入这个Dao接口的时候，返回的对象就是MapperFactoryBean这个工厂Bean中的getObject()方法对象。</p>
<p>简单来说，它就是<strong>通过JDK动态代理，返回了一个Dao接口的代理对象，这个代理对象的处理器是MapperProxy对象。所有，我们通过@Autowired注入Dao接口的时候，注入的就是这个代理对象，我们调用到Dao接口的方法时，则会调用到MapperProxy对象的invoke方法。</strong></p>
<p>曾经有个朋友问过这样一个问题：</p>
<p>对于有实现的dao接口，mapper还会用代理么？</p>
<p>答案是肯定，只要你配置了MapperScan，它就会去扫描，然后生成代理。但是，如果你的dao接口有实现类，并且这个实现类也是一个Spring Bean，那就要看你在Autowired的时候，去注入哪一个了。</p>
<p>会报错，因为在注入的时候，找到了两个UserDao的实例对象。其实我们通过名字注入就可以了。</p>
<h3 id="0-5-3-三、执行"><a href="#0-5-3-三、执行" class="headerlink" title="0.5.3. 三、执行"></a>0.5.3. 三、执行</h3><p>如上所述，当我们调用Dao接口方法的时候，实际调用到代理对象的invoke方法。 在这里，实际上调用的就是SqlSession里面的东西了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlSession</span> <span class="keyword">implements</span> <span class="title">SqlSession</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">            <span class="keyword">return</span> executor.query(ms, </span><br><span class="line">                wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是通过statement全限定类型+方法名拿到MappedStatement 对象，然后通过执行器Executor去执行具体SQL并返回。</p>
<p><img src="/images/Mybatis/792538947.jpg" alt="792538947"></p>
<h2 id="0-6-作用域"><a href="#0-6-作用域" class="headerlink" title="0.6. 作用域"></a>0.6. <strong>作用域</strong></h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JdnS939HH5TayIhQo5s0aJbReBExSQO1U23XeLAXlhTWUeL87mJZL0lDzPstpY3CSIwvW0dN9ccA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>作用域理解</strong></p>
<ul>
<li>SqlSessionFactoryBuilder 的作用在于创建 SqlSessionFactory，创建成功后，SqlSessionFactoryBuilder 就失去了作用，所以它只能存在于创建 SqlSessionFactory 的方法中，而不要让其长期存在。因此 <strong>SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域</strong>（也就是局部方法变量）。</li>
<li>SqlSessionFactory 可以被认为是一个数据库连接池，它的作用是创建 SqlSession 接口对象。因为 MyBatis 的本质就是 Java 对数据库的操作，所以 SqlSessionFactory 的生命周期存在于整个 MyBatis 的应用之中，所以一旦创建了 SqlSessionFactory，就要长期保存它，直至不再使用 MyBatis 应用，所以可以认为 SqlSessionFactory 的生命周期就等同于 MyBatis 的应用周期。</li>
<li>由于 SqlSessionFactory 是一个对数据库的连接池，所以它占据着数据库的连接资源。如果创建多个 SqlSessionFactory，那么就存在多个数据库连接池，这样不利于对数据库资源的控制，也会导致数据库连接资源被消耗光，出现系统宕机等情况，所以尽量避免发生这样的情况。</li>
<li>因此在一般的应用中我们往往希望 SqlSessionFactory 作为一个单例，让它在应用中被共享。所以说 <strong>SqlSessionFactory 的最佳作用域是应用作用域。</strong></li>
<li>如果说 SqlSessionFactory 相当于数据库连接池，那么 SqlSession 就相当于一个数据库连接（Connection 对象），你可以在一个事务里面执行多条 SQL，然后通过它的 commit、rollback 等方法，提交或者回滚事务。所以它应该存活在一个业务请求中，处理完整个请求后，应该关闭这条连接，让它归还给 SqlSessionFactory，否则数据库资源就很快被耗费精光，系统就会瘫痪，所以用 try…catch…finally… 语句来保证其正确关闭。</li>
<li><strong>所以 SqlSession 的最佳的作用域是请求或方法作用域。</strong></li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JdnS939HH5TayIhQo5s0aJJq1YuJCr3e9PsTBpBgc1tbicoshHB3qLkwgn3Jp2q8qI1dY9vGhIia3w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="0-7-属性名和字段名不一致"><a href="#0-7-属性名和字段名不一致" class="headerlink" title="0.7. 属性名和字段名不一致"></a>0.7. 属性名和字段名不一致</h2><p>方案一：为列名指定别名 , 别名和java实体类的属性名一致 .</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  select id , name , pwd as password from user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>方案二：使用结果集映射-&gt;ResultMap</strong> 【推荐】</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- id为主键 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">  select id , name , pwd from user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="0-8-ResultMap"><a href="#0-8-ResultMap" class="headerlink" title="0.8. ResultMap"></a>0.8. ResultMap</h2><p><strong>自动映射</strong></p>
<p>简单地将所有的列映射到 <code>HashMap</code> 的键上，这由 <code>resultType</code> 属性指定。虽然在大部分情况下都够用，但是 HashMap 不是一个很好的模型。你的程序更可能会使用 JavaBean 或 POJO（Plain Old Java Objects，普通老式 Java 对象）作为模型。</p>
<p><strong>手动映射</strong></p>
<p>返回值类型为resultMap</p>
<h2 id="0-9-分页"><a href="#0-9-分页" class="headerlink" title="0.9. 分页"></a>0.9. 分页</h2><p><strong>limit物理分页</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#语法</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> LIMIT stratIndex，pageSize</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> LIMIT <span class="number">5</span>,<span class="number">10</span>; <span class="operator">/</span><span class="operator">/</span> 检索记录行 <span class="number">6</span><span class="number">-15</span>  </span><br><span class="line"></span><br><span class="line">#为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 <span class="number">-1</span>：   </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> LIMIT <span class="number">95</span>,<span class="number">-1</span>; <span class="operator">/</span><span class="operator">/</span> 检索记录行 <span class="number">96</span><span class="operator">-</span>last.  </span><br><span class="line"></span><br><span class="line">#如果只给定一个参数，它表示返回最大的记录行数目：   </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> LIMIT <span class="number">5</span>; <span class="operator">/</span><span class="operator">/</span>检索前 <span class="number">5</span> 个记录行  </span><br><span class="line"></span><br><span class="line">#换句话说，LIMIT n 等价于 LIMIT <span class="number">0</span>,n。 </span><br></pre></td></tr></table></figure>

<p><strong>RowBounds逻辑分页</strong></p>
<p>除了使用Limit在SQL层面实现分页，也可以使用RowBounds在Java代码层面实现分页</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> currentPage = <span class="number">2</span>;  <span class="comment">//第几页</span></span><br><span class="line">   <span class="keyword">int</span> pageSize = <span class="number">2</span>;  <span class="comment">//每页显示几个</span></span><br><span class="line">   RowBounds rowBounds = <span class="keyword">new</span> RowBounds((currentPage-<span class="number">1</span>)*pageSize,pageSize);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//通过session.**方法进行传递rowBounds，[此种方式现在已经不推荐使用了]</span></span><br><span class="line">   List&lt;User&gt; users = session.selectList(<span class="string">&quot;com.kuang.mapper.UserMapper.getUserByRowBounds&quot;</span>, <span class="keyword">null</span>, rowBounds);</span><br></pre></td></tr></table></figure>

<p><strong>PageHelper</strong></p>
<h2 id="0-10-在mapper中如何传递多个参数"><a href="#0-10-在mapper中如何传递多个参数" class="headerlink" title="0.10. 在mapper中如何传递多个参数?"></a>0.10. <strong>在mapper中如何传递多个参数?</strong></h2><p>1、第一种：</p>
<p>DAO层的函数</p>
<p>2、第二种： 使用 @param 注解:</p>
<p>然后,就可以在xml像下面这样使用(推荐封装为一个map,作为单个参数传递给mapper):</p>
<p>3、第三种：多个参数封装成map</p>
<h2 id="0-11-Mapper-编写有哪几种方式？"><a href="#0-11-Mapper-编写有哪几种方式？" class="headerlink" title="0.11. Mapper 编写有哪几种方式？"></a>0.11. Mapper 编写有哪几种方式？</h2><ul>
<li><p>接口实现类继承 SqlSessionDaoSupport：使用此种方法需要编写mapper 接口，mapper 接口实现类、mapper.xml 文件</p>
<p>1、在 sqlMapConfig.xml 中配置 mapper.xml 的位置</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<pre><code>2、定义 mapper 接口

3、实现类集成 SqlSessionDaoSupport，mapper 方法中可以 this.getSqlSession()进行数据增删改查。

4、spring 配置
</code></pre>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot; &quot;</span> <span class="attr">class</span>=<span class="string">&quot;mapper 接口的实现&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用 org.mybatis.spring.mapper.MapperFactoryBean ：<br>1、在 sqlMapConfig.xml 中配置 mapper.xml 的位置，如果 mapper.xml 和 mappre 接口的名称相同且在同一个目录，这里可以不用配置</li>
</ul>
<figure class="highlight xml"><figcaption><span><mappers></span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<pre><code>    2、定义 mapper 接口：
    2.1、mapper.xml 中的 namespace 为 mapper 接口的地址
    2.2、mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一 致
    3、Spring 中定义
</code></pre>
<ul>
<li><p>使用 mapper 扫描器：</p>
<p>1、mapper.xml 文件编写：<br>mapper.xml 中的 namespace 为 mapper 接口的地址；<br>mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致；<br>如果将 mapper.xml 和 mapper 接口的名称保持一致则不用在 sqlMapConfig.xml 中进行配置</p>
<p>2、定义 mapper 接口：<br>注意 mapper.xml 的文件名和 mapper 的接口名称保持一致，且放在同一个目录</p>
<p>3、配置 mapper 扫描器：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mapper 接口包地址&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4、使用扫描器后从 spring 容器中获取 mapper 的实现对象。</p>
</li>
</ul>
<h2 id="0-12-注解"><a href="#0-12-注解" class="headerlink" title="0.12. 注解"></a>0.12. 注解</h2><p>1、我们在我们的接口中添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询全部用户</span></span><br><span class="line"><span class="meta">@Select(&quot;select id,name,pwd password from user&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getAllUser</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>2、在mybatis的核心配置文件中注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用class绑定接口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.mapper.UserMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="0-13-Mybatis详细的执行流程"><a href="#0-13-Mybatis详细的执行流程" class="headerlink" title="0.13. Mybatis详细的执行流程"></a>0.13. Mybatis详细的执行流程</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LZwwtchlelS8kzAAyVia5uNvhic22X8ahJy5BdOfjy1LlDRfo8Nf3GOAzwALgvriau4SzmXZIhUUd2A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="0-14-MyBatis的工作原理以及核心流程介绍"><a href="#0-14-MyBatis的工作原理以及核心流程介绍" class="headerlink" title="0.14. MyBatis的工作原理以及核心流程介绍"></a>0.14. MyBatis的工作原理以及核心流程介绍</h2><ul>
<li><p>JDBC有四个核心对象：<br>（1）DriverManager，用于注册数据库连接<br>（2）Connection，与数据库连接对象<br>（3）Statement/PrepareStatement，操作数据库SQL语句的对象<br>（4）ResultSet，结果集或一张虚拟表</p>
</li>
<li><p>MyBatis也有四大核心对象：<br>（1）SqlSession对象，该对象中包含了执行SQL语句的所有方法。类似于JDBC里面的Connection<br>（2）Executor接口，它将根据SqlSession传递的参数动态地生成需要执行的SQL语句，同时负责查询缓存的维护。类似于JDBC里面的Statement/PrepareStatement。<br>（3）MappedStatement对象，该对象是对映射SQL的封装，用于存储要映射的SQL语句的id、参数等信息。<br>（4）ResultHandler对象，用于对返回的结果进行处理，最终得到自己想要的数据格式或类型。可以自定义返回类型。</p>
</li>
</ul>
<h3 id="0-14-1-、MyBatis的工作原理以及核心流程详解"><a href="#0-14-1-、MyBatis的工作原理以及核心流程详解" class="headerlink" title="0.14.1. 、MyBatis的工作原理以及核心流程详解"></a>0.14.1. 、MyBatis的工作原理以及核心流程详解</h3><p>MyBatis的工作原理如下图所示：</p>
<p><img src="/images/Mybatis/326517643.png" alt="326517643"></p>
<p>（1）读取MyBatis的配置文件。mybatis-config.xml为MyBatis的全局配置文件，用于配置数据库连接信息。</p>
<p>（2）加载映射文件。映射文件即SQL映射文件，该文件中配置了操作数据库的SQL语句，需要在MyBatis配置文件mybatis-config.xml中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。</p>
<p>（3）构造会话工厂。通过MyBatis的环境配置信息构建会话工厂SqlSessionFactory。</p>
<p>（4）创建会话对象。由会话工厂创建SqlSession对象，该对象中包含了执行SQL语句的所有方法。</p>
<p>（5）Executor执行器。MyBatis底层定义了一个Executor接口来操作数据库，它将根据SqlSession传递的参数动态地生成需要执行的SQL语句，同时负责查询缓存的维护。</p>
<p>（6）MappedStatement对象。在Executor接口的执行方法中有一个MappedStatement类型的参数，该参数是对映射信息的封装，用于存储要映射的SQL语句的id、参数等信息。</p>
<p>（7）输入参数映射。输入参数类型可以是Map、List等集合类型，也可以是基本数据类型和POJO类型。输入参数映射过程类似于JDBC对preparedStatement对象设置参数的过程。</p>
<p>（8）输出结果映射。输出结果类型可以是Map、List等集合类型，也可以是基本数据类型和POJO类型。输出结果映射过程类似于JDBC对结果集的解析过程。</p>
<h2 id="0-15-Param"><a href="#0-15-Param" class="headerlink" title="0.15. @Param"></a>0.15. @Param</h2><p>@Param注解用于给方法参数起一个名字。以下是总结的使用原则：</p>
<ul>
<li><p>在方法只接受一个参数的情况下，可以不使用@Param。</p>
</li>
<li><p>在方法接受多个参数的情况下，建议一定要使用@Param注解给参数命名。</p>
</li>
<li><p>如果参数是 JavaBean ， 则不能使用@Param。</p>
</li>
<li><p>不使用@Param注解时，参数只能有一个，并且是Javabean。</p>
</li>
</ul>
<h2 id="0-16-与-的区别"><a href="#0-16-与-的区别" class="headerlink" title="0.16. #与$的区别"></a>0.16. #与$的区别</h2><p>/#{} 的作用主要是替换预编译语句(PrepareStatement)中的占位符? 【推荐使用】</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">INSERT INTO user (name) VALUES (#&#123;name&#125;);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (name) <span class="keyword">VALUES</span> (?);</span><br></pre></td></tr></table></figure>

<p>${} 的作用是直接进行字符串替换</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (name) <span class="keyword">VALUES</span> (<span class="string">&#x27;$&#123;name&#125;&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (name) <span class="keyword">VALUES</span> (<span class="string">&#x27;kuangshen&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>（3）使用#{}可以有效的防止SQL注入，提高系统安全性。原因在于：预编译机制。<strong>预编译完成之后，SQL的结构已经固定，即便用户输入非法参数，也不会对SQL的结构产生影响，从而避免了潜在的安全风险。</strong></p>
<p>（4）预编译是提前对SQL语句进行预编译，而其后注入的参数将不会再进行SQL编译。我们知道，SQL注入是发生在编译的过程中，因为恶意注入了某些特殊字符，最后被编译成了恶意的执行操作。而预编译机制则可以很好的防止SQL注入。</p>
<h2 id="0-17-数据库链接中断如何处理"><a href="#0-17-数据库链接中断如何处理" class="headerlink" title="0.17. 数据库链接中断如何处理"></a>0.17. 数据库链接中断如何处理</h2><p>数据库的访问底层是通过tcp实现的，如果数据库链接中断，那么应用程序是不知道的，跟时间有关的设置有：max_idle_time，connect_timeout。max_idle_time表明最大的空闲时间，超过这个时间socket就会关闭，timeout。</p>
<h2 id="0-18-数据库插入重复如何处理"><a href="#0-18-数据库插入重复如何处理" class="headerlink" title="0.18. 数据库插入重复如何处理"></a>0.18. 数据库插入重复如何处理</h2><p>插入的过程一般都是分两步的：先判断是否存在记录，没有存在则插入否则不插入。如果存在并发操作，那么同时进行了第一步，然后大家都发现没有记录，最后在第二步的时候都插入了数据从而造成数据的重复。解决插入重复的思路可以是这样的：</p>
<p>下面场景，假设同时有三个线程：线程a、线程b、线程c，进行插入操作。</p>
<p>（1）判断数据库是否有数据，有的话则无所作为。没有数据的话，则进行下面第2步。<br>（2）大家都要去竞争锁，用redis当锁，即：redis set key，其中只有一个操作a会成功，其他并发的线程b和c会失败的。<br>（3）上面set key 成功的线程a，开始执行插入数据操作，无论是否插入数据成功，都在最后del key。【注】插入不成功可以多尝试几次，增加成功的概率。<br>（4）如果拿到锁的线程a没有插入成功，即便是尝试了数次也没有插入成功，此时定是系统出现了bug，应该搞一个短信报警机制，让研发人员及时发现问题。</p>
<h2 id="0-19-一个Connection在MySQL中对应一个线程？"><a href="#0-19-一个Connection在MySQL中对应一个线程？" class="headerlink" title="0.19. 一个Connection在MySQL中对应一个线程？"></a>0.19. 一个Connection在MySQL中对应一个线程？</h2><p>在高性能服务器端端开发底层往往靠io复用来处理，这种模式就是：单线程+事件处理机制。在MySQL里面往往有一个主线程，这是单线程（与Java中处处强调多线程的思想有点不同哦），它不断的循环查看是否有socket是否有读写事件，如果有读写事件，再从线程池里面找个工作线程处理这个socket的读写事件，完事之后工作线程会回到线程池。所以：Java客户端中的一个Connection不是在MySQL中就对应一个线程来处理这个链接，而是由监听socket的主线程+线程池里面固定数目的工作线程来处理的。</p>
<h2 id="0-20-预编译的过程"><a href="#0-20-预编译的过程" class="headerlink" title="0.20. 预编译的过程"></a>0.20. 预编译的过程</h2><h3 id="0-20-1-、JDBC的预编译用法"><a href="#0-20-1-、JDBC的预编译用法" class="headerlink" title="0.20.1. 、JDBC的预编译用法"></a>0.20.1. 、JDBC的预编译用法</h3><p>相信每个人都应该了解JDBC中的PreparedStatement接口，它是用来实现SQL预编译的功能。其用法是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">String url = <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/mybatis&quot;</span>;</span><br><span class="line">String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">String password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="comment">//建立数据库连接</span></span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">&quot;insert into user(username, sex, address) values(?,?,?)&quot;</span>;</span><br><span class="line">PreparedStatement ps = conn.preparedStatement(sql);</span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>);  <span class="comment">//为第一个问号赋值  </span></span><br><span class="line">ps.setInt(<span class="number">2</span>, <span class="number">2</span>);    <span class="comment">//为第二个问号赋值</span></span><br><span class="line">ps.setString(<span class="number">3</span>, <span class="string">&quot;北京&quot;</span>);    <span class="comment">//为第三个问号赋值</span></span><br><span class="line">ps.executeUpdate();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure>

<h3 id="0-20-2-、预编译的好处"><a href="#0-20-2-、预编译的好处" class="headerlink" title="0.20.2. 、预编译的好处"></a>0.20.2. 、预编译的好处</h3><h4 id="0-20-2-1-、预编译能避免SQL注入"><a href="#0-20-2-1-、预编译能避免SQL注入" class="headerlink" title="0.20.2.1. 、预编译能避免SQL注入"></a>0.20.2.1. 、预编译能避免SQL注入</h4><p>预编译功能可以避免SQL注入，因为SQL已经编译完成，其结构已经固定，用户的输入只能当做参数传入进去，不能再破坏SQL的结果，无法造成曲解SQL原本意思的破坏。</p>
<h4 id="0-20-2-2-、预编译能提高SQL执行效率"><a href="#0-20-2-2-、预编译能提高SQL执行效率" class="headerlink" title="0.20.2.2. 、预编译能提高SQL执行效率"></a>0.20.2.2. 、预编译能提高SQL执行效率</h4><p>预编译功能除了避免SQL注入，还能提高SQL执行效率。当客户发送一条SQL语句给服务器后，服务器首先需要校验SQL语句的语法格式是否正确，然后把SQL语句编译成可执行的函数，最后才是执行SQL语句。其中校验语法，和编译所花的时间可能比执行SQL语句花的时间还要多。</p>
<p>如果我们需要执行多次insert语句，但只是每次插入的值不同，MySQL服务器也是需要每次都去校验SQL语句的语法格式以及编译，这就浪费了太多的时间。如果使用预编译功能，那么只对SQL语句进行一次语法校验和编译，所以效率要高。</p>
<h3 id="0-20-3-、预编译的实现过程"><a href="#0-20-3-、预编译的实现过程" class="headerlink" title="0.20.3. 、预编译的实现过程"></a>0.20.3. 、预编译的实现过程</h3><p>预编译功能如此重要，那么数据库是如何实现预编译的呢？这个问题其实可以当做一个面试题，能很好的考察面试者对预编译的理解。下面以MySQL为例说明一下预编译的过程：</p>
<p>MySQL执行预编译分为如三步：</p>
<p>第一步：执行预编译语句，例如：prepare myperson from ‘select * from t_person where name=?’<br>第二步：设置变量，例如：set @name=’Jim’<br>第三步：执行语句，例如：execute myperson using @name</p>
<p>如果需要再次执行myperson，那么就不再需要第一步，即不需要再编译语句了：</p>
<p>设置变量，例如：set @name=’Tom’<br>执行语句，例如：execute myperson using @name</p>
<h2 id="0-21"><a href="#0-21" class="headerlink" title="0.21."></a>0.21.</h2><h2 id="0-22-多对一"><a href="#0-22-多对一" class="headerlink" title="0.22. 多对一"></a>0.22. 多对一</h2><p>多对一的理解：</p>
<ul>
<li>多个学生对应一个老师</li>
<li>如果对于学生这边，就是一个多对一的现象，即从学生这边关联一个老师！</li>
</ul>
<h3 id="0-22-1-按查询嵌套处理"><a href="#0-22-1-按查询嵌套处理" class="headerlink" title="0.22.1. 按查询嵌套处理"></a>0.22.1. 按查询嵌套处理</h3><p>1、给StudentMapper接口增加方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取所有学生及对应老师的信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">getStudents</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>2、编写对应的Mapper文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">       <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">       <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.kuang.mapper.StudentMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">   需求：获取所有学生及对应老师的信息</span></span><br><span class="line"><span class="comment">   思路：</span></span><br><span class="line"><span class="comment">       1. 获取所有学生的信息</span></span><br><span class="line"><span class="comment">       2. 根据获取的学生信息的老师ID-&gt;获取该老师的信息</span></span><br><span class="line"><span class="comment">       3. 思考问题，这样学生的结果集中应该包含老师，该如何处理呢，数据库中我们一般使用关联查询？</span></span><br><span class="line"><span class="comment">           1. 做一个结果集映射：StudentTeacher</span></span><br><span class="line"><span class="comment">           2. StudentTeacher结果集的类型为 Student</span></span><br><span class="line"><span class="comment">           3. 学生中老师的属性为teacher，对应数据库中为tid。</span></span><br><span class="line"><span class="comment">              多个 [1,...）学生关联一个老师=&gt; 一对一，一对多</span></span><br><span class="line"><span class="comment">           4. 查看官网找到：association – 一个复杂类型的关联；使用它来处理关联查询</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudents&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;StudentTeacher&quot;</span>&gt;</span></span><br><span class="line">    select * from student</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentTeacher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span>  <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Teacher&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getTeacher&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">   这里传递过来的id，只有一个属性的时候，下面可以写任何值</span></span><br><span class="line"><span class="comment">   association中column多参数配置：</span></span><br><span class="line"><span class="comment">       column=&quot;&#123;key=value,key=value&#125;&quot;</span></span><br><span class="line"><span class="comment">       其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;teacher&quot;</span>&gt;</span></span><br><span class="line">      select * from teacher where id = #&#123;id&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3、编写完毕去Mybatis配置文件中，注册Mapper！</p>
<p>4、注意点说明：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentTeacher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span>  <span class="attr">column</span>=<span class="string">&quot;&#123;id=tid,name=tid&#125;&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Teacher&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getTeacher&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">这里传递过来的id，只有一个属性的时候，下面可以写任何值</span></span><br><span class="line"><span class="comment">association中column多参数配置：</span></span><br><span class="line"><span class="comment">   column=&quot;&#123;key=value,key=value&#125;&quot;</span></span><br><span class="line"><span class="comment">   其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;teacher&quot;</span>&gt;</span></span><br><span class="line">  select * from teacher where id = #&#123;id&#125; and name = #&#123;name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="0-22-2-按结果嵌套处理"><a href="#0-22-2-按结果嵌套处理" class="headerlink" title="0.22.2. 按结果嵌套处理"></a>0.22.2. 按结果嵌套处理</h3><p>1、接口方法编写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">getStudents2</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>2、编写对应的mapper文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">按查询结果嵌套处理</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">   1. 直接查询出结果，进行结果集的映射</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudents2&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;StudentTeacher2&quot;</span> &gt;</span></span><br><span class="line">  select s.id sid, s.name sname , t.name tname</span><br><span class="line">  from student s,teacher t</span><br><span class="line">  where s.tid = t.id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentTeacher2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span>/&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--关联对象property 关联对象在Student实体类中的属性--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tname&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="0-23-一对多"><a href="#0-23-一对多" class="headerlink" title="0.23. 一对多"></a>0.23. 一对多</h2><p>对多的理解：</p>
<ul>
<li>一个老师拥有多个学生</li>
<li>如果对于老师这边，就是一个一对多的现象，即从一个老师下面拥有一群学生（集合）！</li>
</ul>
<h3 id="0-23-1-按结果嵌套处理"><a href="#0-23-1-按结果嵌套处理" class="headerlink" title="0.23.1. 按结果嵌套处理"></a>0.23.1. 按结果嵌套处理</h3><p>1、TeacherMapper接口编写方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取指定老师，及老师下的所有学生</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Teacher <span class="title">getTeacher</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>

<p>2、编写接口对应的Mapper配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.kuang.mapper.TeacherMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">   思路:</span></span><br><span class="line"><span class="comment">       1. 从学生表和老师表中查出学生id，学生姓名，老师姓名</span></span><br><span class="line"><span class="comment">       2. 对查询出来的操作做结果集映射</span></span><br><span class="line"><span class="comment">           1. 集合的话，使用collection！</span></span><br><span class="line"><span class="comment">               JavaType和ofType都是用来指定对象类型的</span></span><br><span class="line"><span class="comment">               JavaType是用来指定pojo中属性的类型</span></span><br><span class="line"><span class="comment">               ofType指定的是映射到list集合属性中pojo的类型。</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;TeacherStudent&quot;</span>&gt;</span></span><br><span class="line">      select s.id sid, s.name sname , t.name tname, t.id tid</span><br><span class="line">      from student s,teacher t</span><br><span class="line">      where s.tid = t.id and t.id=#&#123;id&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;TeacherStudent&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span>  <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tname&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span> /&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span> /&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;tid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="0-23-2-按查询嵌套处理"><a href="#0-23-2-按查询嵌套处理" class="headerlink" title="0.23.2. 按查询嵌套处理"></a>0.23.2. 按查询嵌套处理</h3><p>1、TeacherMapper接口编写方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Teacher <span class="title">getTeacher2</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>

<p>2、编写接口对应的Mapper配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher2&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;TeacherStudent2&quot;</span>&gt;</span></span><br><span class="line">select * from teacher where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;TeacherStudent2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--column是一对多的外键 , 写的是一的主键的列名--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;ArrayList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Student&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getStudentByTeacherId&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudentByTeacherId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">  select * from student where tid = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>小结</strong></p>
<p>1、关联-association</p>
<p>2、集合-collection</p>
<p>3、所以association是用于一对一和多对一，而collection是用于一对多的关系</p>
<p>4、JavaType和ofType都是用来指定对象类型的</p>
<ul>
<li>JavaType是用来指定pojo中属性的类型</li>
<li>ofType指定的是映射到list集合属性中pojo的类型。</li>
</ul>
<h2 id="0-24-动态-SQL"><a href="#0-24-动态-SQL" class="headerlink" title="0.24. 动态 SQL"></a>0.24. 动态 SQL</h2><p>动态SQL指的是根据不同的查询条件 , 生成不同的Sql语句.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-------------------------------</span><br><span class="line"> - if</span><br><span class="line"> - choose (when, otherwise)</span><br><span class="line"> - trim (where, set)</span><br><span class="line"> - foreach</span><br><span class="line"> -------------------------------</span><br></pre></td></tr></table></figure>

<h2 id="0-25-Dao接口的工作原理"><a href="#0-25-Dao接口的工作原理" class="headerlink" title="0.25. Dao接口的工作原理"></a>0.25. Dao接口的工作原理</h2><p>Dao接口即Mapper接口。接口的全限名，就是映射文件中的namespace的值；接口的方法名，就是映射文件中Mapper的Statement的id值；接口方法内的参数，就是传递给sql的参数。</p>
<p>Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MapperStatement。在Mybatis中，每一个 <select>、<insert>、<update>、<delete>标签，都会被解析为一个MapperStatement对象。</p>
<p>举例来说：cn.mybatis.mappers.StudentDao.findStudentById，可以唯一找到namespace为 com.mybatis.mappers.StudentDao下面 id 为 findStudentById 的 MapperStatement。</p>
<p>Mapper接口里的方法，是不能重载的，因为是使用 全限名+方法名 的保存和寻找策略。Mapper 接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Mapper接口生成代理对象proxy，代理对象会拦截接口方法，转而执行MapperStatement所代表的sql，然后将sql执行结果返回。</p>
<h2 id="0-26-缓存"><a href="#0-26-缓存" class="headerlink" title="0.26. 缓存"></a>0.26. 缓存</h2><p>1、什么是缓存 [ Cache ]？</p>
<ul>
<li>存在内存中的临时数据。</li>
<li>将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。</li>
</ul>
<p>2、为什么使用缓存？</p>
<ul>
<li>减少和数据库的交互次数，减少系统开销，提高系统效率。</li>
</ul>
<p>3、什么样的数据能使用缓存？</p>
<ul>
<li>经常查询并且不经常改变的数据。    </li>
</ul>
<blockquote>
<p>Mybatis的缓存实际上就是一个HashMap，key是真正执行的sql语句，value是缓存的结果。</p>
</blockquote>
<h3 id="0-26-1-一级缓存"><a href="#0-26-1-一级缓存" class="headerlink" title="0.26.1. 一级缓存"></a>0.26.1. 一级缓存</h3><p>一级缓存也叫本地缓存：</p>
<ul>
<li>与数据库同一次会话期间查询到的数据会放在本地缓存中。</li>
<li>以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KickRVspms8t4ZU0jXovPT2qe5QluO0MoibU09bTKiaGG923AzFwOSxICrM7BZFWNJqiaCUOGxDA54Tg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>一级缓存失效的四种情况：</p>
<p>一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；</p>
<p>一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！</p>
<p>1、sqlSession不同。<strong>每个sqlSession中的缓存相互独立</strong></p>
<p>2、sqlSession相同，查询条件不同。<strong>当前缓存中，不存在这个数据</strong></p>
<p>3、sqlSession相同，两次查询之间执行了增删改操作！<strong>因为增删改操作可能会对当前数据产生影响</strong></p>
<p>4、sqlSession相同，手动清除一级缓存。session.clearCache();</p>
<h3 id="0-26-2-二级缓存"><a href="#0-26-2-二级缓存" class="headerlink" title="0.26.2. 二级缓存"></a>0.26.2. 二级缓存</h3><ul>
<li><p>二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存</p>
</li>
<li><p>基于namespace级别的缓存，一个名称空间，对应一个二级缓存；</p>
</li>
<li><p>工作机制</p>
</li>
<li><ul>
<li>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中；</li>
<li>如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中；</li>
<li>新的会话查询信息，就可以从二级缓存中获取内容；</li>
<li>不同的mapper查出的数据会放在自己对应的缓存（map）中；</li>
</ul>
</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据</li>
<li>查出的数据都会被默认先放在一级缓存中</li>
<li>只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中</li>
<li>查询时顺序：二级 -&gt; 一级 -&gt; 数据库</li>
<li>对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KickRVspms8t4ZU0jXovPT2egdNicaJuVnzMYxibyYFvB0COWW4sgDhHPqvFbG9F9KS1vX7ibIMNqefg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="0-27-、-和-的区别是什么？"><a href="#0-27-、-和-的区别是什么？" class="headerlink" title="0.27. 、#{}和${}的区别是什么？"></a>0.27. 、#{}和${}的区别是什么？</h2><p>注：这道题是面试官面试我同事的。</p>
<p>答：</p>
<ul>
<li><code>$&#123;&#125;</code>是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如${driver}会被静态替换为<code>com.mysql.jdbc.Driver</code>。</li>
<li><code>#&#123;&#125;</code>是 sql 的参数占位符，MyBatis 会将 sql 中的<code>#&#123;&#125;</code>替换为?号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的?号占位符设置参数值，比如 ps.setInt(0, parameterValue)，<code>#&#123;item.name&#125;</code> 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 <code>param.getItem().getName()</code>。</li>
</ul>
<h2 id="0-28-、Xml-映射文件中，除了常见的-select-insert-update-delete-标签之外，还有哪些标签？"><a href="#0-28-、Xml-映射文件中，除了常见的-select-insert-update-delete-标签之外，还有哪些标签？" class="headerlink" title="0.28. 、Xml 映射文件中，除了常见的 select|insert|update|delete 标签之外，还有哪些标签？"></a>0.28. 、Xml 映射文件中，除了常见的 select|insert|update|delete 标签之外，还有哪些标签？</h2><p>注：这道题是京东面试官面试我时问的。</p>
<p>答：还有很多其他的标签，<code>&lt;resultMap&gt;</code>、<code>&lt;parameterMap&gt;</code>、<code>&lt;sql&gt;</code>、<code>&lt;include&gt;</code>、<code>&lt;selectKey&gt;</code>，加上动态 sql 的 9 个标签，<code>trim|where|set|foreach|if|choose|when|otherwise|bind</code>等，其中<sql>为 sql 片段标签，通过<code>&lt;include&gt;</code>标签引入 sql 片段，<code>&lt;selectKey&gt;</code>为不支持自增的主键生成策略标签。</p>
<h2 id="0-29-、最佳实践中，通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？"><a href="#0-29-、最佳实践中，通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="0.29. 、最佳实践中，通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？"></a>0.29. 、最佳实践中，通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</h2><p>注：这道题也是京东面试官面试我被问的。</p>
<p>答：Dao 接口，就是人们常说的 <code>Mapper</code>接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中<code>MappedStatement</code>的 id 值，接口方法内的参数，就是传递给 sql 的参数。<code>Mapper</code>接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个<code>MappedStatement</code>，举例：<code>com.mybatis3.mappers.StudentDao.findStudentById</code>，可以唯一找到 namespace 为<code>com.mybatis3.mappers.StudentDao</code>下面<code>id = findStudentById</code>的<code>MappedStatement</code>。在 MyBatis 中，每一个<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code>标签，都会被解析为一个<code>MappedStatement</code>对象。</p>
<p><del>Dao 接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</del></p>
<p>Dao 接口里的方法可以重载，但是Mybatis的XML里面的ID不允许重复。</p>
<p>Mybatis版本3.3.0，亲测如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** * Mapper接口里面方法重载 */</span><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StuMapper</span> </span>&#123;	<span class="function">List&lt;Student&gt; <span class="title">getAllStu</span><span class="params">()</span></span>;    	<span class="function">List&lt;Student&gt; <span class="title">getAllStu</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Integer id)</span></span>;&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 <code>StuMapper.xml</code> 中利用Mybatis的动态sql就可以实现。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;getAllStu&quot; resultType=&quot;com.pojo.Student&quot;&gt; 		select * from student		&lt;where&gt;			&lt;if test=&quot;id != null&quot;&gt;				id = #&#123;id&#125;			&lt;/if&gt;		&lt;/where&gt; 	&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>能正常运行，并能得到相应的结果，这样就实现了在Dao接口中写重载方法。</p>
<p><strong>Mybatis 的 Dao 接口可以有多个重载方法，但是多个接口对应的映射必须只有一个，否则启动会报错。</strong></p>
<p>相关 issue ：<a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/issues/1122">更正：Dao 接口里的方法可以重载，但是Mybatis的XML里面的ID不允许重复！</a>。</p>
<p>Dao 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行<code>MappedStatement</code>所代表的 sql，然后将 sql 执行结果返回。</p>
<h3 id="0-29-1-补充："><a href="#0-29-1-补充：" class="headerlink" title="0.29.1. ==补充：=="></a>0.29.1. ==补充：==</h3><p>Dao接口方法可以重载，但是需要满足以下条件：</p>
<ol>
<li>仅有一个无参方法和一个有参方法</li>
<li>多个有参方法时，参数数量必须一致。且使用相同的 <code>@Param</code> ，或者使用 <code>param1</code> 这种</li>
</ol>
<p>测试如下：</p>
<p><code>PersonDao.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Person <span class="title">queryById</span><span class="params">()</span></span>;<span class="function">Person <span class="title">queryById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span></span>;<span class="function">Person <span class="title">queryById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id, <span class="meta">@Param(&quot;name&quot;)</span> String name)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>PersonMapper.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;PersonMap&quot;</span>&gt;</span>    select      id, name, age, address    from person    <span class="tag">&lt;<span class="name">where</span>&gt;</span>        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != null&quot;</span>&gt;</span>            id = #&#123;id&#125;        <span class="tag">&lt;/<span class="name">if</span>&gt;</span>        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span>            name = #&#123;name&#125;        <span class="tag">&lt;/<span class="name">if</span>&gt;</span>    <span class="tag">&lt;/<span class="name">where</span>&gt;</span>    limit 1<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>org.apache.ibatis.scripting.xmltags.DynamicContext.ContextAccessor#getProperty</code>方法用于获取<code>&lt;if&gt;</code>标签中的条件值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProperty</span><span class="params">(Map context, Object target, Object name)</span> </span>&#123;  Map map = (Map) target;  Object result = map.get(name);  <span class="keyword">if</span> (map.containsKey(name) || result != <span class="keyword">null</span>) &#123;    <span class="keyword">return</span> result;  &#125;  Object parameterObject = map.get(PARAMETER_OBJECT_KEY);  <span class="keyword">if</span> (parameterObject <span class="keyword">instanceof</span> Map) &#123;    <span class="keyword">return</span> ((Map)parameterObject).get(name);  &#125;  <span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br></pre></td></tr></table></figure>

<p><code>parameterObject</code>为map，存放的是Dao接口中参数相关信息。</p>
<p><code>((Map)parameterObject).get(name)</code>方法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;  <span class="keyword">if</span> (!<span class="keyword">super</span>.containsKey(key)) &#123;    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Parameter &#x27;&quot;</span> + key + <span class="string">&quot;&#x27; not found. Available parameters are &quot;</span> + keySet());  &#125;  <span class="keyword">return</span> <span class="keyword">super</span>.get(key);&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>queryById()</code>方法执行时，<code>parameterObject</code>为null，<code>getProperty</code>方法返回null值，<code>&lt;if&gt;</code>标签获取的所有条件值都为null，所有条件不成立，动态sql可以正常执行。</li>
<li><code>queryById(1L)</code>方法执行时，<code>parameterObject</code>为map，包含了<code>id</code>和<code>param1</code>两个key值。当获取<code>&lt;if&gt;</code>标签中<code>name</code>的属性值时，进入<code>((Map)parameterObject).get(name)</code>方法中，map中key不包含<code>name</code>，所以抛出异常。</li>
<li><code>queryById(1L,&quot;1&quot;)</code>方法执行时，<code>parameterObject</code>中包含<code>id</code>,<code>param1</code>,<code>name</code>,<code>param2</code>四个key值，<code>id</code>和<code>name</code>属性都可以获取到，动态sql正常执行。</li>
</ol>
<h2 id="0-30-、MyBatis-是如何进行分页的？分页插件的原理是什么？"><a href="#0-30-、MyBatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="0.30. 、MyBatis 是如何进行分页的？分页插件的原理是什么？"></a>0.30. 、MyBatis 是如何进行分页的？分页插件的原理是什么？</h2><p>注：我出的。</p>
<p>答：**(1)** MyBatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页；**(2)** 可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，**(3)** 也可以使用分页插件来完成物理分页。</p>
<p>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p>
<p>举例：<code>select _ from student</code>，拦截 sql 后重写为：<code>select t._ from （select \* from student）t limit 0，10</code></p>
<h2 id="0-31-、简述-MyBatis-的插件运行原理，以及如何编写一个插件。"><a href="#0-31-、简述-MyBatis-的插件运行原理，以及如何编写一个插件。" class="headerlink" title="0.31. 、简述 MyBatis 的插件运行原理，以及如何编写一个插件。"></a>0.31. 、简述 MyBatis 的插件运行原理，以及如何编写一个插件。</h2><p>注：我出的。</p>
<p>答：MyBatis 仅可以编写针对 <code>ParameterHandler</code>、<code>ResultSetHandler</code>、<code>StatementHandler</code>、<code>Executor</code> 这 4 种接口的插件，MyBatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 <code>InvocationHandler</code> 的 <code>invoke()</code>方法，当然，只会拦截那些你指定需要拦截的方法。</p>
<p>实现 MyBatis 的 Interceptor 接口并复写<code> intercept()</code>方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p>
<h2 id="0-32-、MyBatis-执行批量插入，能返回数据库主键列表吗？"><a href="#0-32-、MyBatis-执行批量插入，能返回数据库主键列表吗？" class="headerlink" title="0.32. 、MyBatis 执行批量插入，能返回数据库主键列表吗？"></a>0.32. 、MyBatis 执行批量插入，能返回数据库主键列表吗？</h2><p>注：我出的。</p>
<p>答：能，JDBC 都能，MyBatis 当然也能。</p>
<h2 id="0-33-、MyBatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？"><a href="#0-33-、MyBatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？" class="headerlink" title="0.33. 、MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？"></a>0.33. 、MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？</h2><p>注：我出的。</p>
<p>答：MyBatis 动态 sql 可以让我们在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能，MyBatis 提供了 9 种动态 sql 标签 <code>trim|where|set|foreach|if|choose|when|otherwise|bind</code>。</p>
<p>其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。</p>
<h2 id="0-34-、MyBatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#0-34-、MyBatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="0.34. 、MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>0.34. 、MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</h2><p>注：我出的。</p>
<p>答：第一种是使用<code>&lt;resultMap&gt;</code>标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，MyBatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，MyBatis 一样可以正常工作。</p>
<p>有了列名与属性名的映射关系后，MyBatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
<h2 id="0-35-、MyBatis-能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。"><a href="#0-35-、MyBatis-能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。" class="headerlink" title="0.35. 、MyBatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。"></a>0.35. 、MyBatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。</h2><p>注：我出的。</p>
<p>答：能，MyBatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把 <code>selectOne()</code>修改为 <code>selectList()</code>即可；多对多查询，其实就是一对多查询，只需要把 <code>selectOne()</code>修改为 <code>selectList()</code>即可。</p>
<p>关联对象查询，有两种实现方式，一种是单独发送一个 sql 去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用 join 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql 查询，就可以把主对象和其关联对象查出来。</p>
<p>那么问题来了，join 查询出来 100 条记录，如何确定主对象是 5 个，而不是 100 个？其去重复的原理是<code>&lt;resultMap&gt;</code>标签内的<code>&lt;id&gt;</code>子标签，指定了唯一确定一条记录的 id 列，MyBatis 根据<id>列值来完成 100 条记录的去重复功能，<code>&lt;id&gt;</code>可以有多个，代表了联合主键的语意。</p>
<p>同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。</p>
<p>举例：下面 join 查询出来 6 条记录，一、二列是 Teacher 对象列，第三列为 Student 对象列，MyBatis 去重复处理后，结果为 1 个老师 6 个学生，而不是 6 个老师 6 个学生。</p>
<table>
<thead>
<tr>
<th>t_id</th>
<th>t_name</th>
<th>s_id</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>teacher</td>
<td>38</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>39</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>40</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>41</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>42</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>43</td>
</tr>
</tbody></table>
<h2 id="0-36-、MyBatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#0-36-、MyBatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="0.36. 、MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>0.36. 、MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h2><p>注：我出的。</p>
<p>答：MyBatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在 MyBatis 配置文件中，可以配置是否启用延迟加载 <code>lazyLoadingEnabled=true|false。</code></p>
<p>它的原理是，使用<code> CGLIB</code> 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 <code>a.getB().getName()</code>，拦截器 <code>invoke()</code>方法发现 <code>a.getB()</code>是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 <code>a.getB().getName()</code>方法的调用。这就是延迟加载的基本原理。</p>
<p>当然了，不光是 MyBatis，几乎所有的包括 Hibernate，支持延迟加载的原理都是一样的。</p>
<h2 id="0-37-、MyBatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？"><a href="#0-37-、MyBatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？" class="headerlink" title="0.37. 、MyBatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？"></a>0.37. 、MyBatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？</h2><p>注：我出的。</p>
<p>答：不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复；毕竟 namespace 不是必须的，只是最佳实践而已。</p>
<p>原因就是 namespace+id 是作为 <code>Map&lt;String, MappedStatement&gt;</code>的 key 使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然也就不同。</p>
<h2 id="0-38-、MyBatis-中如何执行批处理？"><a href="#0-38-、MyBatis-中如何执行批处理？" class="headerlink" title="0.38. 、MyBatis 中如何执行批处理？"></a>0.38. 、MyBatis 中如何执行批处理？</h2><p>注：我出的。</p>
<p>答：使用 BatchExecutor 完成批处理。</p>
<h2 id="0-39-、MyBatis-都有哪些-Executor-执行器？它们之间的区别是什么？"><a href="#0-39-、MyBatis-都有哪些-Executor-执行器？它们之间的区别是什么？" class="headerlink" title="0.39. 、MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？"></a>0.39. 、MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h2><p>注：我出的</p>
<p>答：MyBatis 有三种基本的 Executor 执行器，**<code>SimpleExecutor</code>、<code>ReuseExecutor</code>、<code>BatchExecutor</code>。**</p>
<p><strong><code>SimpleExecutor</code>：</strong>每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。</p>
<p><strong><code>ReuseExecutor</code>：</strong>执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用 Statement 对象。</p>
<p><strong><code>BatchExecutor</code>：</strong>执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。</p>
<p>作用范围：Executor 的这些特点，都严格限制在 SqlSession 生命周期范围内。</p>
<h2 id="0-40-、MyBatis-中如何指定使用哪一种-Executor-执行器？"><a href="#0-40-、MyBatis-中如何指定使用哪一种-Executor-执行器？" class="headerlink" title="0.40. 、MyBatis 中如何指定使用哪一种 Executor 执行器？"></a>0.40. 、MyBatis 中如何指定使用哪一种 Executor 执行器？</h2><p>注：我出的</p>
<p>答：在 MyBatis 配置文件中，可以指定默认的 ExecutorType 执行器类型，也可以手动给 <code>DefaultSqlSessionFactory</code> 的创建 SqlSession 的方法传递 ExecutorType 类型参数。</p>
<h2 id="0-41-、MyBatis-是否可以映射-Enum-枚举类？"><a href="#0-41-、MyBatis-是否可以映射-Enum-枚举类？" class="headerlink" title="0.41. 、MyBatis 是否可以映射 Enum 枚举类？"></a>0.41. 、MyBatis 是否可以映射 Enum 枚举类？</h2><p>注：我出的</p>
<p>答：MyBatis 可以映射枚举类，不单可以映射枚举类，MyBatis 可以映射任何对象到表的一列上。映射方式为自定义一个 <code>TypeHandler</code>，实现 <code>TypeHandler</code> 的 <code>setParameter()</code>和 <code>getResult()</code>接口方法。<code>TypeHandler</code> 有两个作用，一是完成从 javaType 至 jdbcType 的转换，二是完成 jdbcType 至 javaType 的转换，体现为 <code>setParameter()</code>和 <code>getResult()</code>两个方法，分别代表设置 sql 问号占位符参数和获取列查询结果。</p>
<h2 id="0-42-、MyBatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？"><a href="#0-42-、MyBatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？" class="headerlink" title="0.42. 、MyBatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？"></a>0.42. 、MyBatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？</h2><p>注：我出的</p>
<p>答：虽然 MyBatis 解析 Xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可以定义在任何地方，MyBatis 都可以正确识别。</p>
<p>原理是，MyBatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，MyBatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，MyBatis 会重新解析那些被标记为未解析的标签，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</p>
<h2 id="0-43-、简述-MyBatis-的-Xml-映射文件和-MyBatis-内部数据结构之间的映射关系？"><a href="#0-43-、简述-MyBatis-的-Xml-映射文件和-MyBatis-内部数据结构之间的映射关系？" class="headerlink" title="0.43. 、简述 MyBatis 的 Xml 映射文件和 MyBatis 内部数据结构之间的映射关系？"></a>0.43. 、简述 MyBatis 的 Xml 映射文件和 MyBatis 内部数据结构之间的映射关系？</h2><p>注：我出的</p>
<p>答：MyBatis 将所有 Xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部。在 Xml 映射文件中，<code>&lt;parameterMap&gt;</code>标签会被解析为 <code>ParameterMap</code> 对象，其每个子元素会被解析为 ParameterMapping 对象。<code>&lt;resultMap&gt;</code>标签会被解析为 <code>ResultMap</code> 对象，其每个子元素会被解析为 <code>ResultMapping</code> 对象。每一个<code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code>标签均会被解析为 <code>MappedStatement</code> 对象，标签内的 sql 会被解析为 BoundSql 对象。</p>
<h2 id="0-44-、为什么说-MyBatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？"><a href="#0-44-、为什么说-MyBatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？" class="headerlink" title="0.44. 、为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？"></a>0.44. 、为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</h2><p>注：我出的</p>
<p>答：Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 MyBatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。</p>
<p>面试题看似都很简单，但是想要能正确回答上来，必定是研究过源码且深入的人，而不是仅会使用的人或者用的很熟的人，以上所有面试题及其答案所涉及的内容，在我的 MyBatis 系列博客中都有详细讲解和原理分析。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Study/">Study</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Mybatis/">Mybatis</a>
    </span>
    

    </div>

    
  </div>
</article>

  
	<section id="comment" class="comment">
		<div id="gitalk-container"></div>
	</section>
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css">
	<script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script>
	<script>
		var gitalk = new Gitalk({
			clientID: '43df1f730957f2695673',
			clientSecret: '29fa4bdef022da54ce3ebc4ec844d1b5c418d42a',
			repo: 'memorykkk.github.io',
			owner: 'memorykkk',
			admin: ['memorykkk'],
			id: location.pathname,
			distractionFreeMode: false,
			createIssueManually: true,
			proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token',
		})

		gitalk.render('gitalk-container')
	</script>







    </main>

    <footer class="site-footer">
  <p class="site-info" style="color='#9e9e9e'">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2020-2021 Memorykk
    
	<a href="http://beian.miit.gov.cn" target="_blank">陕ICP备20005895号-1</a>
  </p>
</footer>
    
    
  </div>
</div>

</body>
</html>